
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }

    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
    // at the end of hydration without touching the remaining nodes.
    let is_hydrating = false;
    const nodes_to_detach = new Set();
    function start_hydrating() {
        is_hydrating = true;
    }
    function end_hydrating() {
        is_hydrating = false;
        for (const node of nodes_to_detach) {
            node.parentNode.removeChild(node);
        }
        nodes_to_detach.clear();
    }
    function append(target, node) {
        if (is_hydrating) {
            nodes_to_detach.delete(node);
        }
        if (node.parentNode !== target) {
            target.appendChild(node);
        }
    }
    function insert(target, node, anchor) {
        if (is_hydrating) {
            nodes_to_detach.delete(node);
        }
        if (node.parentNode !== target || (anchor && node.nextSibling !== anchor)) {
            target.insertBefore(node, anchor || null);
        }
    }
    function detach(node) {
        if (is_hydrating) {
            nodes_to_detach.add(node);
        }
        else if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                start_hydrating();
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            end_hydrating();
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var t=function(n,e){return (t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,n){t.__proto__=n;}||function(t,n){for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e]);})(n,e)};function n$1(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=n;}t(n,e),n.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r);}var e=function(){return (e=Object.assign||function(t){for(var n,e=1,r=arguments.length;e<r;e++)for(var o in n=arguments[e])Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o]);return t}).apply(this,arguments)};function r$2(t,n,e,r){return new(e||(e=Promise))((function(o,a){function i(t){try{u(r.next(t));}catch(t){a(t);}}function c(t){try{u(r.throw(t));}catch(t){a(t);}}function u(t){var n;t.done?o(t.value):(n=t.value,n instanceof e?n:new e((function(t){t(n);}))).then(i,c);}u((r=r.apply(t,n||[])).next());}))}function o$1(t,n){var e,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:c(0),throw:c(1),return:c(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function c(a){return function(c){return function(a){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=i.trys,(o=o.length>0&&o[o.length-1])||6!==a[0]&&2!==a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=n.call(t,i);}catch(t){a=[6,t],r=0;}finally{e=o=0;}if(5&a[0])throw a[1];return {value:a[0]?a[1]:void 0,done:!0}}([a,c])}}}function a$1(t,n){void 0===n&&(n=!1);var e=function(){var t=new Int8Array(1);window.crypto.getRandomValues(t);var n=new Uint8Array(Math.max(16,Math.abs(t[0])));return window.crypto.getRandomValues(n),n.join("")}();return Object.defineProperty(window,e,{value:function(r){return n&&Reflect.deleteProperty(window,e),null==t?void 0:t(r)},writable:!1,configurable:!0}),e}function i$1(t,n){return void 0===n&&(n={}),r$2(this,void 0,void 0,(function(){return o$1(this,(function(r){return [2,new Promise((function(r,o){var i=a$1((function(t){r(t),Reflect.deleteProperty(window,c);}),!0),c=a$1((function(t){o(t),Reflect.deleteProperty(window,i);}),!0);window.rpc.notify(t,e({__invokeKey:__TAURI_INVOKE_KEY__,callback:i,error:c},n));}))]}))}))}function c$3(t){return navigator.userAgent.includes("Windows")?"https://asset.localhost/"+t:"asset://"+t}Object.freeze({__proto__:null,transformCallback:a$1,invoke:i$1,convertFileSrc:c$3});

    function n(n){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(i){return [2,i$1("tauri",n)]}))}))}

    function r$1(i,r,u){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){switch(t.label){case 0:return [4,n({__tauriModule:"Event",message:{cmd:"emit",event:i,windowLabel:r,payload:u}})];case 1:return t.sent(),[2]}}))}))}function u$1(i){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Event",message:{cmd:"unlisten",eventId:i}})]}))}))}function o(r,o){return r$2(this,void 0,void 0,(function(){var s=this;return o$1(this,(function(c){return [2,n({__tauriModule:"Event",message:{cmd:"listen",event:r,handler:a$1(o)}}).then((function(i){return function(){return r$2(s,void 0,void 0,(function(){return o$1(this,(function(t){return [2,u$1(i)]}))}))}}))]}))}))}function s$2(i,e){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,o(i,(function(t){e(t),u$1(t.id).catch((function(){}));}))]}))}))}function c$2(i,e){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,r$1(i,void 0,e)]}))}))}Object.freeze({__proto__:null,listen:o,once:s$2,emit:c$2});

    /*
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     */

    const isUndefined = value => typeof value === "undefined";

    const isFunction = value => typeof value === "function";

    const isNumber = value => typeof value === "number";

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
    	return (
    		!event.defaultPrevented &&
    		event.button === 0 &&
    		!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    	);
    }

    function createCounter() {
    	let i = 0;
    	/**
    	 * Returns an id and increments the internal state
    	 * @returns {number}
    	 */
    	return () => i++;
    }

    /**
     * Create a globally unique id
     *
     * @returns {string} An id
     */
    function createGlobalId() {
    	return Math.random().toString(36).substring(2);
    }

    const isSSR = typeof window === "undefined";

    function addListener(target, type, handler) {
    	target.addEventListener(type, handler);
    	return () => target.removeEventListener(type, handler);
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    /*
     * Adapted from https://github.com/EmilTholin/svelte-routing
     *
     * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE
     */

    const createKey = ctxName => `@@svnav-ctx__${ctxName}`;

    // Use strings instead of objects, so different versions of
    // svelte-navigator can potentially still work together
    const LOCATION = createKey("LOCATION");
    const ROUTER = createKey("ROUTER");
    const ROUTE = createKey("ROUTE");
    const ROUTE_PARAMS = createKey("ROUTE_PARAMS");
    const FOCUS_ELEM = createKey("FOCUS_ELEM");

    const paramRegex = /^:(.+)/;

    /**
     * Check if `string` starts with `search`
     * @param {string} string
     * @param {string} search
     * @return {boolean}
     */
    const startsWith$1 = (string, search) =>
    	string.substr(0, search.length) === search;

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    const isRootSegment = segment => segment === "";

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    const isDynamic = segment => paramRegex.test(segment);

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    const isSplat = segment => segment[0] === "*";

    /**
     * Strip potention splat and splatname of the end of a path
     * @param {string} str
     * @return {string}
     */
    const stripSplat = str => str.replace(/\*.*$/, "");

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    const stripSlashes = str => str.replace(/(^\/+|\/+$)/g, "");

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri, filterFalsy = false) {
    	const segments = stripSlashes(uri).split("/");
    	return filterFalsy ? segments.filter(Boolean) : segments;
    }

    /**
     * Add the query to the pathname if a query is given
     * @param {string} pathname
     * @param {string} [query]
     * @return {string}
     */
    const addQuery = (pathname, query) =>
    	pathname + (query ? `?${query}` : "");

    /**
     * Normalizes a basepath
     *
     * @param {string} path
     * @returns {string}
     *
     * @example
     * normalizePath("base/path/") // -> "/base/path"
     */
    const normalizePath = path => `/${stripSlashes(path)}`;

    /**
     * Joins and normalizes multiple path fragments
     *
     * @param {...string} pathFragments
     * @returns {string}
     */
    function join(...pathFragments) {
    	const joinFragment = fragment => segmentize(fragment, true).join("/");
    	const joinedSegments = pathFragments.map(joinFragment).join("/");
    	return normalizePath(joinedSegments);
    }

    // We start from 1 here, so we can check if an origin id has been passed
    // by using `originId || <fallback>`
    const LINK_ID = 1;
    const ROUTE_ID = 2;
    const ROUTER_ID = 3;
    const USE_FOCUS_ID = 4;
    const USE_LOCATION_ID = 5;
    const USE_MATCH_ID = 6;
    const USE_NAVIGATE_ID = 7;
    const USE_PARAMS_ID = 8;
    const USE_RESOLVABLE_ID = 9;
    const USE_RESOLVE_ID = 10;
    const NAVIGATE_ID = 11;

    const labels = {
    	[LINK_ID]: "Link",
    	[ROUTE_ID]: "Route",
    	[ROUTER_ID]: "Router",
    	[USE_FOCUS_ID]: "useFocus",
    	[USE_LOCATION_ID]: "useLocation",
    	[USE_MATCH_ID]: "useMatch",
    	[USE_NAVIGATE_ID]: "useNavigate",
    	[USE_PARAMS_ID]: "useParams",
    	[USE_RESOLVABLE_ID]: "useResolvable",
    	[USE_RESOLVE_ID]: "useResolve",
    	[NAVIGATE_ID]: "navigate",
    };

    const createLabel = labelId => labels[labelId];

    function createIdentifier(labelId, props) {
    	let attr;
    	if (labelId === ROUTE_ID) {
    		attr = props.path ? `path="${props.path}"` : "default";
    	} else if (labelId === LINK_ID) {
    		attr = `to="${props.to}"`;
    	} else if (labelId === ROUTER_ID) {
    		attr = `basepath="${props.basepath || ""}"`;
    	}
    	return `<${createLabel(labelId)} ${attr || ""} />`;
    }

    function createMessage(labelId, message, props, originId) {
    	const origin = props && createIdentifier(originId || labelId, props);
    	const originMsg = origin ? `\n\nOccurred in: ${origin}` : "";
    	const label = createLabel(labelId);
    	const msg = isFunction(message) ? message(label) : message;
    	return `<${label}> ${msg}${originMsg}`;
    }

    const createMessageHandler = handler => (...args) =>
    	handler(createMessage(...args));

    const fail = createMessageHandler(message => {
    	throw new Error(message);
    });

    // eslint-disable-next-line no-console
    const warn = createMessageHandler(console.warn);

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
    	const score = route.default
    		? 0
    		: segmentize(route.fullPath).reduce((acc, segment) => {
    				let nextScore = acc;
    				nextScore += SEGMENT_POINTS;

    				if (isRootSegment(segment)) {
    					nextScore += ROOT_POINTS;
    				} else if (isDynamic(segment)) {
    					nextScore += DYNAMIC_POINTS;
    				} else if (isSplat(segment)) {
    					nextScore -= SEGMENT_POINTS + SPLAT_PENALTY;
    				} else {
    					nextScore += STATIC_POINTS;
    				}

    				return nextScore;
    		  }, 0);

    	return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
    	return (
    		routes
    			.map(rankRoute)
    			// If two routes have the exact same score, we go by index instead
    			.sort((a, b) => {
    				if (a.score < b.score) {
    					return 1;
    				}
    				if (a.score > b.score) {
    					return -1;
    				}
    				return a.index - b.index;
    			})
    	);
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { fullPath, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick(routes, uri) {
    	let bestMatch;
    	let defaultMatch;

    	const [uriPathname] = uri.split("?");
    	const uriSegments = segmentize(uriPathname);
    	const isRootUri = uriSegments[0] === "";
    	const ranked = rankRoutes(routes);

    	for (let i = 0, l = ranked.length; i < l; i++) {
    		const { route } = ranked[i];
    		let missed = false;
    		const params = {};

    		// eslint-disable-next-line no-shadow
    		const createMatch = uri => ({ ...route, params, uri });

    		if (route.default) {
    			defaultMatch = createMatch(uri);
    			continue;
    		}

    		const routeSegments = segmentize(route.fullPath);
    		const max = Math.max(uriSegments.length, routeSegments.length);
    		let index = 0;

    		for (; index < max; index++) {
    			const routeSegment = routeSegments[index];
    			const uriSegment = uriSegments[index];

    			if (!isUndefined(routeSegment) && isSplat(routeSegment)) {
    				// Hit a splat, just grab the rest, and return a match
    				// uri:   /files/documents/work
    				// route: /files/* or /files/*splatname
    				const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

    				params[splatName] = uriSegments
    					.slice(index)
    					.map(decodeURIComponent)
    					.join("/");
    				break;
    			}

    			if (isUndefined(uriSegment)) {
    				// URI is shorter than the route, no match
    				// uri:   /users
    				// route: /users/:userId
    				missed = true;
    				break;
    			}

    			const dynamicMatch = paramRegex.exec(routeSegment);

    			if (dynamicMatch && !isRootUri) {
    				const value = decodeURIComponent(uriSegment);
    				params[dynamicMatch[1]] = value;
    			} else if (routeSegment !== uriSegment) {
    				// Current segments don't match, not dynamic, not splat, so no match
    				// uri:   /users/123/settings
    				// route: /users/:id/profile
    				missed = true;
    				break;
    			}
    		}

    		if (!missed) {
    			bestMatch = createMatch(join(...uriSegments.slice(0, index)));
    			break;
    		}
    	}

    	return bestMatch || defaultMatch || null;
    }

    /**
     * Check if the `route.fullPath` matches the `uri`.
     * @param {Object} route
     * @param {string} uri
     * @return {?object}
     */
    function match(route, uri) {
    	return pick([route], uri);
    }

    /**
     * Resolve URIs as though every path is a directory, no files. Relative URIs
     * in the browser can feel awkward because not only can you be "in a directory",
     * you can be "at a file", too. For example:
     *
     *  browserSpecResolve('foo', '/bar/') => /bar/foo
     *  browserSpecResolve('foo', '/bar') => /foo
     *
     * But on the command line of a file system, it's not as complicated. You can't
     * `cd` from a file, only directories. This way, links have to know less about
     * their current path. To go deeper you can do this:
     *
     *  <Link to="deeper"/>
     *  // instead of
     *  <Link to=`{${props.uri}/deeper}`/>
     *
     * Just like `cd`, if you want to go deeper from the command line, you do this:
     *
     *  cd deeper
     *  # not
     *  cd $(pwd)/deeper
     *
     * By treating every path as a directory, linking to relative paths should
     * require less contextual information and (fingers crossed) be more intuitive.
     * @param {string} to
     * @param {string} base
     * @return {string}
     */
    function resolve(to, base) {
    	// /foo/bar, /baz/qux => /foo/bar
    	if (startsWith$1(to, "/")) {
    		return to;
    	}

    	const [toPathname, toQuery] = to.split("?");
    	const [basePathname] = base.split("?");
    	const toSegments = segmentize(toPathname);
    	const baseSegments = segmentize(basePathname);

    	// ?a=b, /users?b=c => /users?a=b
    	if (toSegments[0] === "") {
    		return addQuery(basePathname, toQuery);
    	}

    	// profile, /users/789 => /users/789/profile
    	if (!startsWith$1(toSegments[0], ".")) {
    		const pathname = baseSegments.concat(toSegments).join("/");
    		return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
    	}

    	// ./       , /users/123 => /users/123
    	// ../      , /users/123 => /users
    	// ../..    , /users/123 => /
    	// ../../one, /a/b/c/d   => /a/b/one
    	// .././one , /a/b/c/d   => /a/b/c/one
    	const allSegments = baseSegments.concat(toSegments);
    	const segments = [];

    	allSegments.forEach(segment => {
    		if (segment === "..") {
    			segments.pop();
    		} else if (segment !== ".") {
    			segments.push(segment);
    		}
    	});

    	return addQuery(`/${segments.join("/")}`, toQuery);
    }

    /**
     * Normalizes a location for consumption by `Route` children and the `Router`.
     * It removes the apps basepath from the pathname
     * and sets default values for `search` and `hash` properties.
     *
     * @param {Object} location The current global location supplied by the history component
     * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)
     *
     * @returns The normalized location
     */
    function normalizeLocation(location, basepath) {
    	const { pathname, hash = "", search = "", state } = location;
    	const baseSegments = segmentize(basepath, true);
    	const pathSegments = segmentize(pathname, true);
    	while (baseSegments.length) {
    		if (baseSegments[0] !== pathSegments[0]) {
    			fail(
    				ROUTER_ID,
    				`Invalid state: All locations must begin with the basepath "${basepath}", found "${pathname}"`,
    			);
    		}
    		baseSegments.shift();
    		pathSegments.shift();
    	}
    	return {
    		pathname: join(...pathSegments),
    		hash,
    		search,
    		state,
    	};
    }

    const normalizeUrlFragment = frag => (frag.length === 1 ? "" : frag);

    /**
     * Creates a location object from an url.
     * It is used to create a location from the url prop used in SSR
     *
     * @param {string} url The url string (e.g. "/path/to/somewhere")
     *
     * @returns {{ pathname: string; search: string; hash: string }} The location
     */
    function createLocation$1(url) {
    	const searchIndex = url.indexOf("?");
    	const hashIndex = url.indexOf("#");
    	const hasSearchIndex = searchIndex !== -1;
    	const hasHashIndex = hashIndex !== -1;
    	const hash = hasHashIndex ? normalizeUrlFragment(url.substr(hashIndex)) : "";
    	const pathnameAndSearch = hasHashIndex ? url.substr(0, hashIndex) : url;
    	const search = hasSearchIndex
    		? normalizeUrlFragment(pathnameAndSearch.substr(searchIndex))
    		: "";
    	const pathname = hasSearchIndex
    		? pathnameAndSearch.substr(0, searchIndex)
    		: pathnameAndSearch;
    	return { pathname, search, hash };
    }

    /**
     * Resolves a link relative to the parent Route and the Routers basepath.
     *
     * @param {string} path The given path, that will be resolved
     * @param {string} routeBase The current Routes base path
     * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory
     * @returns {string} The resolved path
     *
     * @example
     * resolveLink("relative", "/routeBase", "/") // -> "/routeBase/relative"
     * resolveLink("/absolute", "/routeBase", "/") // -> "/absolute"
     * resolveLink("relative", "/routeBase", "/base") // -> "/base/routeBase/relative"
     * resolveLink("/absolute", "/routeBase", "/base") // -> "/base/absolute"
     */
    function resolveLink(path, routeBase, appBase) {
    	return join(appBase, resolve(path, routeBase));
    }

    /**
     * Get the uri for a Route, by matching it against the current location.
     *
     * @param {string} routePath The Routes resolved path
     * @param {string} pathname The current locations pathname
     */
    function extractBaseUri(routePath, pathname) {
    	const fullPath = normalizePath(stripSplat(routePath));
    	const baseSegments = segmentize(fullPath, true);
    	const pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);
    	const routeMatch = match({ fullPath }, join(...pathSegments));
    	return routeMatch && routeMatch.uri;
    }

    /*
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     */

    const POP = "POP";
    const PUSH = "PUSH";
    const REPLACE = "REPLACE";

    function getLocation(source) {
    	return {
    		...source.location,
    		pathname: encodeURI(decodeURI(source.location.pathname)),
    		state: source.history.state,
    		_key: (source.history.state && source.history.state._key) || "initial",
    	};
    }

    function createHistory(source) {
    	let listeners = [];
    	let location = getLocation(source);
    	let action = POP;

    	const notifyListeners = (listenerFns = listeners) =>
    		listenerFns.forEach(listener => listener({ location, action }));

    	return {
    		get location() {
    			return location;
    		},
    		listen(listener) {
    			listeners.push(listener);

    			const popstateListener = () => {
    				location = getLocation(source);
    				action = POP;
    				notifyListeners([listener]);
    			};

    			// Call listener when it is registered
    			notifyListeners([listener]);

    			const unlisten = addListener(source, "popstate", popstateListener);
    			return () => {
    				unlisten();
    				listeners = listeners.filter(fn => fn !== listener);
    			};
    		},
    		/**
    		 * Navigate to a new absolute route.
    		 *
    		 * @param {string|number} to The path to navigate to.
    		 *
    		 * If `to` is a number we will navigate to the stack entry index + `to`
    		 * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
    		 * @param {Object} options
    		 * @param {*} [options.state] The state will be accessible through `location.state`
    		 * @param {boolean} [options.replace=false] Replace the current entry in the history
    		 * stack, instead of pushing on a new one
    		 */
    		navigate(to, options) {
    			const { state = {}, replace = false } = options || {};
    			action = replace ? REPLACE : PUSH;
    			if (isNumber(to)) {
    				if (options) {
    					warn(
    						NAVIGATE_ID,
    						"Navigation options (state or replace) are not supported, " +
    							"when passing a number as the first argument to navigate. " +
    							"They are ignored.",
    					);
    				}
    				action = POP;
    				source.history.go(to);
    			} else {
    				const keyedState = { ...state, _key: createGlobalId() };
    				// try...catch iOS Safari limits to 100 pushState calls
    				try {
    					source.history[replace ? "replaceState" : "pushState"](
    						keyedState,
    						"",
    						to,
    					);
    				} catch (e) {
    					source.location[replace ? "replace" : "assign"](to);
    				}
    			}

    			location = getLocation(source);
    			notifyListeners();
    		},
    	};
    }

    function createStackFrame(state, uri) {
    	return { ...createLocation$1(uri), state };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
    	let index = 0;
    	let stack = [createStackFrame(null, initialPathname)];

    	return {
    		// This is just for testing...
    		get entries() {
    			return stack;
    		},
    		get location() {
    			return stack[index];
    		},
    		addEventListener() {},
    		removeEventListener() {},
    		history: {
    			get state() {
    				return stack[index].state;
    			},
    			pushState(state, title, uri) {
    				index++;
    				// Throw away anything in the stack with an index greater than the current index.
    				// This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.
    				// If we call `go(+n)` the stack entries with an index greater than the current index can
    				// be reused.
    				// However, if we navigate to a path, instead of a number, we want to create a new branch
    				// of navigation.
    				stack = stack.slice(0, index);
    				stack.push(createStackFrame(state, uri));
    			},
    			replaceState(state, title, uri) {
    				stack[index] = createStackFrame(state, uri);
    			},
    			go(to) {
    				const newIndex = index + to;
    				if (newIndex < 0 || newIndex > stack.length - 1) {
    					return;
    				}
    				index = newIndex;
    			},
    		},
    	};
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = !!(
    	!isSSR &&
    	window.document &&
    	window.document.createElement
    );
    // Use memory history in iframes (for example in Svelte REPL)
    const isEmbeddedPage = !isSSR && window.location.origin === "null";
    const globalHistory = createHistory(
    	canUseDOM && !isEmbeddedPage ? window : createMemorySource(),
    );
    const { navigate } = globalHistory;

    // We need to keep the focus candidate in a separate file, so svelte does
    // not update, when we mutate it.
    // Also, we need a single global reference, because taking focus needs to
    // work globally, even if we have multiple top level routers
    // eslint-disable-next-line import/no-mutable-exports
    let focusCandidate = null;

    // eslint-disable-next-line import/no-mutable-exports
    let initialNavigation = true;

    /**
     * Check if RouterA is above RouterB in the document
     * @param {number} routerIdA The first Routers id
     * @param {number} routerIdB The second Routers id
     */
    function isAbove(routerIdA, routerIdB) {
    	const routerMarkers = document.querySelectorAll("[data-svnav-router]");
    	for (let i = 0; i < routerMarkers.length; i++) {
    		const node = routerMarkers[i];
    		const currentId = Number(node.dataset.svnavRouter);
    		if (currentId === routerIdA) return true;
    		if (currentId === routerIdB) return false;
    	}
    	return false;
    }

    /**
     * Check if a Route candidate is the best choice to move focus to,
     * and store the best match.
     * @param {{
         level: number;
         routerId: number;
         route: {
           id: number;
           focusElement: import("svelte/store").Readable<Promise<Element>|null>;
         }
       }} item A Route candidate, that updated and is visible after a navigation
     */
    function pushFocusCandidate(item) {
    	if (
    		// Best candidate if it's the only candidate...
    		!focusCandidate ||
    		// Route is nested deeper, than previous candidate
    		// -> Route change was triggered in the deepest affected
    		// Route, so that's were focus should move to
    		item.level > focusCandidate.level ||
    		// If the level is identical, we want to focus the first Route in the document,
    		// so we pick the first Router lookin from page top to page bottom.
    		(item.level === focusCandidate.level &&
    			isAbove(item.routerId, focusCandidate.routerId))
    	) {
    		focusCandidate = item;
    	}
    }

    /**
     * Reset the focus candidate.
     */
    function clearFocusCandidate() {
    	focusCandidate = null;
    }

    function initialNavigationOccurred() {
    	initialNavigation = false;
    }

    /*
     * `focus` Adapted from https://github.com/oaf-project/oaf-side-effects/blob/master/src/index.ts
     *
     * https://github.com/oaf-project/oaf-side-effects/blob/master/LICENSE
     */
    function focus(elem) {
    	if (!elem) return false;
    	const TABINDEX = "tabindex";
    	try {
    		if (!elem.hasAttribute(TABINDEX)) {
    			elem.setAttribute(TABINDEX, "-1");
    			let unlisten;
    			// We remove tabindex after blur to avoid weird browser behavior
    			// where a mouse click can activate elements with tabindex="-1".
    			const blurListener = () => {
    				elem.removeAttribute(TABINDEX);
    				unlisten();
    			};
    			unlisten = addListener(elem, "blur", blurListener);
    		}
    		elem.focus();
    		return document.activeElement === elem;
    	} catch (e) {
    		// Apparently trying to focus a disabled element in IE can throw.
    		// See https://stackoverflow.com/a/1600194/2476884
    		return false;
    	}
    }

    function isEndMarker(elem, id) {
    	return Number(elem.dataset.svnavRouteEnd) === id;
    }

    function isHeading(elem) {
    	return /^H[1-6]$/i.test(elem.tagName);
    }

    function query(selector, parent = document) {
    	return parent.querySelector(selector);
    }

    function queryHeading(id) {
    	const marker = query(`[data-svnav-route-start="${id}"]`);
    	let current = marker.nextElementSibling;
    	while (!isEndMarker(current, id)) {
    		if (isHeading(current)) {
    			return current;
    		}
    		const heading = query("h1,h2,h3,h4,h5,h6", current);
    		if (heading) {
    			return heading;
    		}
    		current = current.nextElementSibling;
    	}
    	return null;
    }

    function handleFocus(route) {
    	Promise.resolve(get_store_value(route.focusElement)).then(elem => {
    		const focusElement = elem || queryHeading(route.id);
    		if (!focusElement) {
    			warn(
    				ROUTER_ID,
    				"Could not find an element to focus. " +
    					"You should always render a header for accessibility reasons, " +
    					'or set a custom focus element via the "useFocus" hook. ' +
    					"If you don't want this Route or Router to manage focus, " +
    					'pass "primary={false}" to it.',
    				route,
    				ROUTE_ID,
    			);
    		}
    		const headingFocused = focus(focusElement);
    		if (headingFocused) return;
    		focus(document.documentElement);
    	});
    }

    const createTriggerFocus = (a11yConfig, announcementText, location) => (
    	manageFocus,
    	announceNavigation,
    ) =>
    	// Wait until the dom is updated, so we can look for headings
    	tick().then(() => {
    		if (!focusCandidate || initialNavigation) {
    			initialNavigationOccurred();
    			return;
    		}
    		if (manageFocus) {
    			handleFocus(focusCandidate.route);
    		}
    		if (a11yConfig.announcements && announceNavigation) {
    			const { path, fullPath, meta, params, uri } = focusCandidate.route;
    			const announcementMessage = a11yConfig.createAnnouncement(
    				{ path, fullPath, meta, params, uri },
    				get_store_value(location),
    			);
    			Promise.resolve(announcementMessage).then(message => {
    				announcementText.set(message);
    			});
    		}
    		clearFocusCandidate();
    	});

    const visuallyHiddenStyle =
    	"position:fixed;" +
    	"top:-1px;" +
    	"left:0;" +
    	"width:1px;" +
    	"height:1px;" +
    	"padding:0;" +
    	"overflow:hidden;" +
    	"clip:rect(0,0,0,0);" +
    	"white-space:nowrap;" +
    	"border:0;";

    /* node_modules/svelte-navigator/src/Router.svelte generated by Svelte v3.38.1 */

    const file$10 = "node_modules/svelte-navigator/src/Router.svelte";

    // (195:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}
    function create_if_block$x(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*$announcementText*/ ctx[0]);
    			attr_dev(div, "role", "status");
    			attr_dev(div, "aria-atomic", "true");
    			attr_dev(div, "aria-live", "polite");
    			attr_dev(div, "style", visuallyHiddenStyle);
    			add_location(div, file$10, 195, 1, 5906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$announcementText*/ 1) set_data_dev(t, /*$announcementText*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(195:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	let if_block = /*isTopLevelRouter*/ ctx[2] && /*manageFocus*/ ctx[4] && /*a11yConfig*/ ctx[1].announcements && create_if_block$x(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			set_style(div, "display", "none");
    			attr_dev(div, "aria-hidden", "true");
    			attr_dev(div, "data-svnav-router", /*routerId*/ ctx[3]);
    			add_location(div, file$10, 190, 0, 5750);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 524288)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
    				}
    			}

    			if (/*isTopLevelRouter*/ ctx[2] && /*manageFocus*/ ctx[4] && /*a11yConfig*/ ctx[1].announcements) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const createId$1 = createCounter();
    const defaultBasepath = "/";

    function instance$11($$self, $$props, $$invalidate) {
    	let $location;
    	let $routes;
    	let $prevLocation;
    	let $activeRoute;
    	let $announcementText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, ['default']);
    	let { basepath = defaultBasepath } = $$props;
    	let { url = null } = $$props;
    	let { history = globalHistory } = $$props;
    	let { primary = true } = $$props;
    	let { a11y = {} } = $$props;

    	const a11yConfig = {
    		createAnnouncement: route => `Navigated to ${route.uri}`,
    		announcements: true,
    		...a11y
    	};

    	// Remember the initial `basepath`, so we can fire a warning
    	// when the user changes it later
    	const initialBasepath = basepath;

    	const normalizedBasepath = normalizePath(basepath);
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const isTopLevelRouter = !locationContext;
    	const routerId = createId$1();
    	const manageFocus = primary && !(routerContext && !routerContext.manageFocus);
    	const announcementText = writable("");
    	validate_store(announcementText, "announcementText");
    	component_subscribe($$self, announcementText, value => $$invalidate(0, $announcementText = value));
    	const routes = writable([]);
    	validate_store(routes, "routes");
    	component_subscribe($$self, routes, value => $$invalidate(16, $routes = value));
    	const activeRoute = writable(null);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(18, $activeRoute = value));

    	// Used in SSR to synchronously set that a Route is active.
    	let hasActiveRoute = false;

    	// Nesting level of router.
    	// We will need this to identify sibling routers, when moving
    	// focus on navigation, so we can focus the first possible router
    	const level = isTopLevelRouter ? 0 : routerContext.level + 1;

    	// If we're running an SSR we force the location to the `url` prop
    	const getInitialLocation = () => normalizeLocation(isSSR ? createLocation$1(url) : history.location, normalizedBasepath);

    	const location = isTopLevelRouter
    	? writable(getInitialLocation())
    	: locationContext;

    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(15, $location = value));
    	const prevLocation = writable($location);
    	validate_store(prevLocation, "prevLocation");
    	component_subscribe($$self, prevLocation, value => $$invalidate(17, $prevLocation = value));
    	const triggerFocus = createTriggerFocus(a11yConfig, announcementText, location);
    	const createRouteFilter = routeId => routeList => routeList.filter(routeItem => routeItem.id !== routeId);

    	function registerRoute(route) {
    		if (isSSR) {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match(route, $location.pathname);

    			if (matchingRoute) {
    				hasActiveRoute = true;

    				// Return the match in SSR mode, so the matched Route can use it immediatly.
    				// Waiting for activeRoute to update does not work, because it updates
    				// after the Route is initialized
    				return matchingRoute; // eslint-disable-line consistent-return
    			}
    		} else {
    			routes.update(prevRoutes => {
    				// Remove an old version of the updated route,
    				// before pushing the new version
    				const nextRoutes = createRouteFilter(route.id)(prevRoutes);

    				nextRoutes.push(route);
    				return nextRoutes;
    			});
    		}
    	}

    	function unregisterRoute(routeId) {
    		routes.update(createRouteFilter(routeId));
    	}

    	if (!isTopLevelRouter && basepath !== defaultBasepath) {
    		warn(ROUTER_ID, "Only top-level Routers can have a \"basepath\" prop. It is ignored.", { basepath });
    	}

    	if (isTopLevelRouter) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = history.listen(changedHistory => {
    				const normalizedLocation = normalizeLocation(changedHistory.location, normalizedBasepath);
    				prevLocation.set($location);
    				location.set(normalizedLocation);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		registerRoute,
    		unregisterRoute,
    		manageFocus,
    		level,
    		id: routerId,
    		history: isTopLevelRouter ? history : routerContext.history,
    		basepath: isTopLevelRouter
    		? normalizedBasepath
    		: routerContext.basepath
    	});

    	const writable_props = ["basepath", "url", "history", "primary", "a11y"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("basepath" in $$props) $$invalidate(10, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(11, url = $$props.url);
    		if ("history" in $$props) $$invalidate(12, history = $$props.history);
    		if ("primary" in $$props) $$invalidate(13, primary = $$props.primary);
    		if ("a11y" in $$props) $$invalidate(14, a11y = $$props.a11y);
    		if ("$$scope" in $$props) $$invalidate(19, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createCounter,
    		createId: createId$1,
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		normalizePath,
    		pick,
    		match,
    		normalizeLocation,
    		createLocation: createLocation$1,
    		isSSR,
    		warn,
    		ROUTER_ID,
    		pushFocusCandidate,
    		visuallyHiddenStyle,
    		createTriggerFocus,
    		defaultBasepath,
    		basepath,
    		url,
    		history,
    		primary,
    		a11y,
    		a11yConfig,
    		initialBasepath,
    		normalizedBasepath,
    		locationContext,
    		routerContext,
    		isTopLevelRouter,
    		routerId,
    		manageFocus,
    		announcementText,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		level,
    		getInitialLocation,
    		location,
    		prevLocation,
    		triggerFocus,
    		createRouteFilter,
    		registerRoute,
    		unregisterRoute,
    		$location,
    		$routes,
    		$prevLocation,
    		$activeRoute,
    		$announcementText
    	});

    	$$self.$inject_state = $$props => {
    		if ("basepath" in $$props) $$invalidate(10, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(11, url = $$props.url);
    		if ("history" in $$props) $$invalidate(12, history = $$props.history);
    		if ("primary" in $$props) $$invalidate(13, primary = $$props.primary);
    		if ("a11y" in $$props) $$invalidate(14, a11y = $$props.a11y);
    		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*basepath*/ 1024) {
    			if (basepath !== initialBasepath) {
    				warn(ROUTER_ID, "You cannot change the \"basepath\" prop. It is ignored.");
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$routes, $location*/ 98304) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			{
    				const bestMatch = pick($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$location, $prevLocation*/ 163840) {
    			// Manage focus and announce navigation to screen reader users
    			{
    				if (isTopLevelRouter) {
    					const hasHash = !!$location.hash;

    					// When a hash is present in the url, we skip focus management, because
    					// focusing a different element will prevent in-page jumps (See #3)
    					const shouldManageFocus = !hasHash && manageFocus;

    					// We don't want to make an announcement, when the hash changes,
    					// but the active route stays the same
    					const announceNavigation = !hasHash || $location.pathname !== $prevLocation.pathname;

    					triggerFocus(shouldManageFocus, announceNavigation);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$activeRoute*/ 262144) {
    			// Queue matched Route, so top level Router can decide which Route to focus.
    			// Non primary Routers should just be ignored
    			if (manageFocus && $activeRoute && $activeRoute.primary) {
    				pushFocusCandidate({ level, routerId, route: $activeRoute });
    			}
    		}
    	};

    	return [
    		$announcementText,
    		a11yConfig,
    		isTopLevelRouter,
    		routerId,
    		manageFocus,
    		announcementText,
    		routes,
    		activeRoute,
    		location,
    		prevLocation,
    		basepath,
    		url,
    		history,
    		primary,
    		a11y,
    		$location,
    		$routes,
    		$prevLocation,
    		$activeRoute,
    		$$scope,
    		slots
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$11,
    			create_fragment$11,
    			safe_not_equal,
    			{
    				basepath: 10,
    				url: 11,
    				history: 12,
    				primary: 13,
    				a11y: 14
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get history() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set history(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primary() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primary(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get a11y() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set a11y(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Check if a component or hook have been created outside of a
     * context providing component
     * @param {number} componentId
     * @param {*} props
     * @param {string?} ctxKey
     * @param {number?} ctxProviderId
     */
    function usePreflightCheck(
    	componentId,
    	props,
    	ctxKey = ROUTER,
    	ctxProviderId = ROUTER_ID,
    ) {
    	const ctx = getContext(ctxKey);
    	if (!ctx) {
    		fail(
    			componentId,
    			label =>
    				`You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`,
    			props,
    		);
    	}
    }

    const toReadonly = ctx => {
    	const { subscribe } = getContext(ctx);
    	return { subscribe };
    };

    /**
     * Access the current location via a readable store.
     * @returns {import("svelte/store").Readable<{
        pathname: string;
        search: string;
        hash: string;
        state: {};
      }>}
     *
     * @example
      ```html
      <script>
        import { useLocation } from "svelte-navigator";

        const location = useLocation();

        $: console.log($location);
        // {
        //   pathname: "/blog",
        //   search: "?id=123",
        //   hash: "#comments",
        //   state: {}
        // }
      </script>
      ```
     */
    function useLocation() {
    	usePreflightCheck(USE_LOCATION_ID);
    	return toReadonly(LOCATION);
    }

    /**
     * @typedef {{
        path: string;
        fullPath: string;
        uri: string;
        params: {};
      }} RouteMatch
     */

    /**
     * @typedef {import("svelte/store").Readable<RouteMatch|null>} RouteMatchStore
     */

    /**
     * Access the history of top level Router.
     */
    function useHistory() {
    	const { history } = getContext(ROUTER);
    	return history;
    }

    /**
     * Access the base of the parent Route.
     */
    function useRouteBase() {
    	const route = getContext(ROUTE);
    	return route ? derived(route, _route => _route.base) : writable("/");
    }

    /**
     * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.
     * It is used under the hood in `Link` and `useNavigate`.
     * You can use it to manually resolve links, when using the `link` or `links` actions.
     *
     * @returns {(path: string) => string}
     *
     * @example
      ```html
      <script>
        import { link, useResolve } from "svelte-navigator";

        const resolve = useResolve();
        // `resolvedLink` will be resolved relative to its parent Route
        // and the Routers `basepath`
        const resolvedLink = resolve("relativePath");
      </script>

      <a href={resolvedLink} use:link>Relative link</a>
      ```
     */
    function useResolve() {
    	usePreflightCheck(USE_RESOLVE_ID);
    	const routeBase = useRouteBase();
    	const { basepath: appBase } = getContext(ROUTER);
    	/**
    	 * Resolves the path relative to the current route and basepath.
    	 *
    	 * @param {string} path The path to resolve
    	 * @returns {string} The resolved path
    	 */
    	const resolve = path => resolveLink(path, get_store_value(routeBase), appBase);
    	return resolve;
    }

    /**
     * A hook, that returns a context-aware version of `navigate`.
     * It will automatically resolve the given link relative to the current Route.
     * It will also resolve a link against the `basepath` of the Router.
     *
     * @example
      ```html
      <!-- App.svelte -->
      <script>
        import { link, Route } from "svelte-navigator";
        import RouteComponent from "./RouteComponent.svelte";
      </script>

      <Router>
        <Route path="route1">
          <RouteComponent />
        </Route>
        <!-- ... -->
      </Router>

      <!-- RouteComponent.svelte -->
      <script>
        import { useNavigate } from "svelte-navigator";

        const navigate = useNavigate();
      </script>

      <button on:click="{() => navigate('relativePath')}">
        go to /route1/relativePath
      </button>
      <button on:click="{() => navigate('/absolutePath')}">
        go to /absolutePath
      </button>
      ```
      *
      * @example
      ```html
      <!-- App.svelte -->
      <script>
        import { link, Route } from "svelte-navigator";
        import RouteComponent from "./RouteComponent.svelte";
      </script>

      <Router basepath="/base">
        <Route path="route1">
          <RouteComponent />
        </Route>
        <!-- ... -->
      </Router>

      <!-- RouteComponent.svelte -->
      <script>
        import { useNavigate } from "svelte-navigator";

        const navigate = useNavigate();
      </script>

      <button on:click="{() => navigate('relativePath')}">
        go to /base/route1/relativePath
      </button>
      <button on:click="{() => navigate('/absolutePath')}">
        go to /base/absolutePath
      </button>
      ```
     */
    function useNavigate() {
    	usePreflightCheck(USE_NAVIGATE_ID);
    	const resolve = useResolve();
    	const { navigate } = useHistory();
    	/**
    	 * Navigate to a new route.
    	 * Resolves the link relative to the current route and basepath.
    	 *
    	 * @param {string|number} to The path to navigate to.
    	 *
    	 * If `to` is a number we will navigate to the stack entry index + `to`
    	 * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
    	 * @param {Object} options
    	 * @param {*} [options.state]
    	 * @param {boolean} [options.replace=false]
    	 */
    	const navigateRelative = (to, options) => {
    		// If to is a number, we navigate to the target stack entry via `history.go`.
    		// Otherwise resolve the link
    		const target = isNumber(to) ? to : resolve(to);
    		return navigate(target, options);
    	};
    	return navigateRelative;
    }

    /* node_modules/svelte-navigator/src/Route.svelte generated by Svelte v3.38.1 */
    const file$$ = "node_modules/svelte-navigator/src/Route.svelte";

    const get_default_slot_changes = dirty => ({
    	params: dirty & /*$params*/ 16,
    	location: dirty & /*$location*/ 4
    });

    const get_default_slot_context = ctx => ({
    	params: isSSR ? get_store_value(/*params*/ ctx[9]) : /*$params*/ ctx[4],
    	location: /*$location*/ ctx[2],
    	navigate: /*navigate*/ ctx[10]
    });

    // (97:0) {#if isActive}
    function create_if_block$w(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				primary: /*primary*/ ctx[1],
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const router_changes = {};
    			if (dirty & /*primary*/ 2) router_changes.primary = /*primary*/ ctx[1];

    			if (dirty & /*$$scope, component, $location, $params, $$restProps*/ 264213) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(97:0) {#if isActive}",
    		ctx
    	});

    	return block;
    }

    // (113:2) {:else}
    function create_else_block$h(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, $params, $location*/ 262164)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(113:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (105:2) {#if component !== null}
    function create_if_block_1$g(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[2] },
    		{ navigate: /*navigate*/ ctx[10] },
    		isSSR ? get_store_value(/*params*/ ctx[9]) : /*$params*/ ctx[4],
    		/*$$restProps*/ ctx[11]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, navigate, isSSR, get, params, $params, $$restProps*/ 3604)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 4 && { location: /*$location*/ ctx[2] },
    					dirty & /*navigate*/ 1024 && { navigate: /*navigate*/ ctx[10] },
    					dirty & /*isSSR, get, params, $params*/ 528 && get_spread_object(isSSR ? get_store_value(/*params*/ ctx[9]) : /*$params*/ ctx[4]),
    					dirty & /*$$restProps*/ 2048 && get_spread_object(/*$$restProps*/ ctx[11])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(105:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    // (98:1) <Router {primary}>
    function create_default_slot$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$g, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(98:1) <Router {primary}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	let if_block = /*isActive*/ ctx[3] && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			set_style(div0, "display", "none");
    			attr_dev(div0, "aria-hidden", "true");
    			attr_dev(div0, "data-svnav-route-start", /*id*/ ctx[5]);
    			add_location(div0, file$$, 95, 0, 2622);
    			set_style(div1, "display", "none");
    			attr_dev(div1, "aria-hidden", "true");
    			attr_dev(div1, "data-svnav-route-end", /*id*/ ctx[5]);
    			add_location(div1, file$$, 121, 0, 3295);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isActive*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isActive*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$w(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const createId = createCounter();

    function instance$10($$self, $$props, $$invalidate) {
    	let isActive;
    	const omit_props_names = ["path","component","meta","primary"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $parentBase;
    	let $location;
    	let $activeRoute;
    	let $params;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Route", slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	let { meta = {} } = $$props;
    	let { primary = true } = $$props;
    	usePreflightCheck(ROUTE_ID, $$props);
    	const id = createId();
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(16, $activeRoute = value));
    	const parentBase = useRouteBase();
    	validate_store(parentBase, "parentBase");
    	component_subscribe($$self, parentBase, value => $$invalidate(15, $parentBase = value));
    	const location = useLocation();
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(2, $location = value));
    	const focusElement = writable(null);

    	// In SSR we cannot wait for $activeRoute to update,
    	// so we use the match returned from `registerRoute` instead
    	let ssrMatch;

    	const route = writable();
    	const params = writable({});
    	validate_store(params, "params");
    	component_subscribe($$self, params, value => $$invalidate(4, $params = value));
    	setContext(ROUTE, route);
    	setContext(ROUTE_PARAMS, params);
    	setContext(FOCUS_ELEM, focusElement);

    	// We need to call useNavigate after the route is set,
    	// so we can use the routes path for link resolution
    	const navigate = useNavigate();

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway
    	if (!isSSR) {
    		onDestroy(() => unregisterRoute(id));
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("path" in $$new_props) $$invalidate(12, path = $$new_props.path);
    		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ("meta" in $$new_props) $$invalidate(13, meta = $$new_props.meta);
    		if ("primary" in $$new_props) $$invalidate(1, primary = $$new_props.primary);
    		if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createCounter,
    		createId,
    		getContext,
    		onDestroy,
    		setContext,
    		writable,
    		get: get_store_value,
    		Router,
    		ROUTER,
    		ROUTE,
    		ROUTE_PARAMS,
    		FOCUS_ELEM,
    		useLocation,
    		useNavigate,
    		useRouteBase,
    		usePreflightCheck,
    		isSSR,
    		extractBaseUri,
    		join,
    		ROUTE_ID,
    		path,
    		component,
    		meta,
    		primary,
    		id,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		parentBase,
    		location,
    		focusElement,
    		ssrMatch,
    		route,
    		params,
    		navigate,
    		$parentBase,
    		$location,
    		isActive,
    		$activeRoute,
    		$params
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    		if ("path" in $$props) $$invalidate(12, path = $$new_props.path);
    		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
    		if ("meta" in $$props) $$invalidate(13, meta = $$new_props.meta);
    		if ("primary" in $$props) $$invalidate(1, primary = $$new_props.primary);
    		if ("ssrMatch" in $$props) $$invalidate(14, ssrMatch = $$new_props.ssrMatch);
    		if ("isActive" in $$props) $$invalidate(3, isActive = $$new_props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*path, $parentBase, meta, $location, primary*/ 45062) {
    			{
    				// The route store will be re-computed whenever props, location or parentBase change
    				const isDefault = path === "";

    				const rawBase = join($parentBase, path);

    				const updatedRoute = {
    					id,
    					path,
    					meta,
    					// If no path prop is given, this Route will act as the default Route
    					// that is rendered if no other Route in the Router is a match
    					default: isDefault,
    					fullPath: isDefault ? "" : rawBase,
    					base: isDefault
    					? $parentBase
    					: extractBaseUri(rawBase, $location.pathname),
    					primary,
    					focusElement
    				};

    				route.set(updatedRoute);

    				// If we're in SSR mode and the Route matches,
    				// `registerRoute` will return the match
    				$$invalidate(14, ssrMatch = registerRoute(updatedRoute));
    			}
    		}

    		if ($$self.$$.dirty & /*ssrMatch, $activeRoute*/ 81920) {
    			$$invalidate(3, isActive = !!(ssrMatch || $activeRoute && $activeRoute.id === id));
    		}

    		if ($$self.$$.dirty & /*isActive, ssrMatch, $activeRoute*/ 81928) {
    			if (isActive) {
    				const { params: activeParams } = ssrMatch || $activeRoute;
    				params.set(activeParams);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		primary,
    		$location,
    		isActive,
    		$params,
    		id,
    		activeRoute,
    		parentBase,
    		location,
    		params,
    		navigate,
    		$$restProps,
    		path,
    		meta,
    		ssrMatch,
    		$parentBase,
    		$activeRoute,
    		slots,
    		$$scope
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
    			path: 12,
    			component: 0,
    			meta: 13,
    			primary: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get meta() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set meta(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primary() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primary(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-navigator/src/Link.svelte generated by Svelte v3.38.1 */
    const file$_ = "node_modules/svelte-navigator/src/Link.svelte";

    function create_fragment$$(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	let a_levels = [{ href: /*href*/ ctx[0] }, /*ariaCurrent*/ ctx[1], /*props*/ ctx[2]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$_, 63, 0, 1735);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				dirty & /*ariaCurrent*/ 2 && /*ariaCurrent*/ ctx[1],
    				dirty & /*props*/ 4 && /*props*/ ctx[2]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let href;
    	let isPartiallyCurrent;
    	let isCurrent;
    	let ariaCurrent;
    	let props;
    	const omit_props_names = ["to","replace","state","getProps"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Link", slots, ['default']);
    	let { to } = $$props;
    	let { replace = false } = $$props;
    	let { state = {} } = $$props;
    	let { getProps = null } = $$props;
    	usePreflightCheck(LINK_ID, $$props);
    	const location = useLocation();
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(9, $location = value));
    	const dispatch = createEventDispatcher();
    	const resolve = useResolve();
    	const { navigate } = useHistory();

    	function onClick(event) {
    		dispatch("click", event);

    		if (shouldNavigate(event)) {
    			event.preventDefault();

    			// Don't push another entry to the history stack when the user
    			// clicks on a Link to the page they are currently on.
    			const shouldReplace = isCurrent || replace;

    			navigate(href, { state, replace: shouldReplace });
    		}
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("to" in $$new_props) $$invalidate(5, to = $$new_props.to);
    		if ("replace" in $$new_props) $$invalidate(6, replace = $$new_props.replace);
    		if ("state" in $$new_props) $$invalidate(7, state = $$new_props.state);
    		if ("getProps" in $$new_props) $$invalidate(8, getProps = $$new_props.getProps);
    		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		useLocation,
    		useResolve,
    		useHistory,
    		usePreflightCheck,
    		shouldNavigate,
    		isFunction,
    		startsWith: startsWith$1,
    		LINK_ID,
    		to,
    		replace,
    		state,
    		getProps,
    		location,
    		dispatch,
    		resolve,
    		navigate,
    		onClick,
    		href,
    		$location,
    		isPartiallyCurrent,
    		isCurrent,
    		ariaCurrent,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    		if ("to" in $$props) $$invalidate(5, to = $$new_props.to);
    		if ("replace" in $$props) $$invalidate(6, replace = $$new_props.replace);
    		if ("state" in $$props) $$invalidate(7, state = $$new_props.state);
    		if ("getProps" in $$props) $$invalidate(8, getProps = $$new_props.getProps);
    		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    		if ("isPartiallyCurrent" in $$props) $$invalidate(10, isPartiallyCurrent = $$new_props.isPartiallyCurrent);
    		if ("isCurrent" in $$props) $$invalidate(11, isCurrent = $$new_props.isCurrent);
    		if ("ariaCurrent" in $$props) $$invalidate(1, ariaCurrent = $$new_props.ariaCurrent);
    		if ("props" in $$props) $$invalidate(2, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*to, $location*/ 544) {
    			// We need to pass location here to force re-resolution of the link,
    			// when the pathname changes. Otherwise we could end up with stale path params,
    			// when for example an :id changes in the parent Routes path
    			$$invalidate(0, href = resolve(to, $location));
    		}

    		if ($$self.$$.dirty & /*$location, href*/ 513) {
    			$$invalidate(10, isPartiallyCurrent = startsWith$1($location.pathname, href));
    		}

    		if ($$self.$$.dirty & /*href, $location*/ 513) {
    			$$invalidate(11, isCurrent = href === $location.pathname);
    		}

    		if ($$self.$$.dirty & /*isCurrent*/ 2048) {
    			$$invalidate(1, ariaCurrent = isCurrent ? { "aria-current": "page" } : {});
    		}

    		$$invalidate(2, props = (() => {
    			if (isFunction(getProps)) {
    				const dynamicProps = getProps({
    					location: $location,
    					href,
    					isPartiallyCurrent,
    					isCurrent
    				});

    				return { ...$$restProps, ...dynamicProps };
    			}

    			return $$restProps;
    		})());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		href,
    		ariaCurrent,
    		props,
    		location,
    		onClick,
    		to,
    		replace,
    		state,
    		getProps,
    		$location,
    		isPartiallyCurrent,
    		isCurrent,
    		$$scope,
    		slots
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, { to: 5, replace: 6, state: 7, getProps: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$$.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*to*/ ctx[5] === undefined && !("to" in props)) {
    			console.warn("<Link> was created without expected prop 'to'");
    		}
    	}

    	get to() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const new_account = function (account, authkey, nickname) {
        return {
            account: account,
            authkey: authkey,
            nickname: nickname,
            on_chain: null,
            balance: null,
        };
    };
    const signingAccount = writable(new_account("", "", ""));
    const mnem = writable("");
    const isInit = writable(false);
    const isRefreshingAccounts = writable(false);
    const all_accounts = writable([]);
    const isAccountsLoaded = writable(false);
    const accountEvents = writable({}); // TODO define interface AccountEvent
    const makeWhole = writable({});

    // one of the Errors mapped in carpeError.ts
    // display these errors
    // the state get switched to false whenever a new backlog submission happens.
    // todo: each error needs have its own rules for clearing
    const EmptyError = {};
    const displayInsufficientBalance = writable(EmptyError);
    const displayWrongDifficulty = writable(EmptyError);
    const displayTooManyProofs = writable(EmptyError);
    const displayDiscontinuity = writable(EmptyError);
    const displayInvalidProof = writable(EmptyError);
    const clearDisplayErrors = () => {
        displayWrongDifficulty.set(EmptyError);
        displayTooManyProofs.set(EmptyError);
        displayDiscontinuity.set(EmptyError);
        displayInvalidProof.set(EmptyError);
        displayInsufficientBalance.set(EmptyError);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*! UIkit 3.8.1 | https://www.getuikit.com | (c) 2014 - 2021 YOOtheme | MIT License */

    var uikit = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        var objPrototype = Object.prototype;
        var hasOwnProperty = objPrototype.hasOwnProperty;

        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }

        var hyphenateRe = /\B([A-Z])/g;

        var hyphenate = memoize(function (str) { return str
            .replace(hyphenateRe, '-$1')
            .toLowerCase(); }
        );

        var camelizeRe = /-(\w)/g;

        var camelize = memoize(function (str) { return str.replace(camelizeRe, toUpper); }
        );

        var ucfirst = memoize(function (str) { return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : ''; }
        );

        function toUpper(_, c) {
            return c ? c.toUpperCase() : '';
        }

        var strPrototype = String.prototype;
        var startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };

        function startsWith(str, search) {
            return startsWithFn.call(str, search);
        }

        var endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };

        function endsWith(str, search) {
            return endsWithFn.call(str, search);
        }

        var arrPrototype = Array.prototype;

        var includesFn = function (search, i) { return !!~this.indexOf(search, i); };
        var includesStr = strPrototype.includes || includesFn;
        var includesArray = arrPrototype.includes || includesFn;

        function includes(obj, search) {
            return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);
        }

        var findIndexFn = arrPrototype.findIndex || function (predicate) {
            var arguments$1 = arguments;

            for (var i = 0; i < this.length; i++) {
                if (predicate.call(arguments$1[1], this[i], i, this)) {
                    return i;
                }
            }
            return -1;
        };

        function findIndex(array, predicate) {
            return findIndexFn.call(array, predicate);
        }

        var isArray = Array.isArray;

        function isFunction(obj) {
            return typeof obj === 'function';
        }

        function isObject(obj) {
            return obj !== null && typeof obj === 'object';
        }

        var toString = objPrototype.toString;
        function isPlainObject(obj) {
            return toString.call(obj) === '[object Object]';
        }

        function isWindow(obj) {
            return isObject(obj) && obj === obj.window;
        }

        function isDocument(obj) {
            return nodeType(obj) === 9;
        }

        function isNode(obj) {
            return nodeType(obj) >= 1;
        }

        function isElement(obj) {
            return nodeType(obj) === 1;
        }

        function nodeType(obj) {
            return !isWindow(obj) && isObject(obj) && obj.nodeType;
        }

        function isBoolean(value) {
            return typeof value === 'boolean';
        }

        function isString(value) {
            return typeof value === 'string';
        }

        function isNumber(value) {
            return typeof value === 'number';
        }

        function isNumeric(value) {
            return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
        }

        function isEmpty(obj) {
            return !(isArray(obj)
                ? obj.length
                : isObject(obj)
                    ? Object.keys(obj).length
                    : false
            );
        }

        function isUndefined(value) {
            return value === void 0;
        }

        function toBoolean(value) {
            return isBoolean(value)
                ? value
                : value === 'true' || value === '1' || value === ''
                    ? true
                    : value === 'false' || value === '0'
                        ? false
                        : value;
        }

        function toNumber(value) {
            var number = Number(value);
            return !isNaN(number) ? number : false;
        }

        function toFloat(value) {
            return parseFloat(value) || 0;
        }

        var toArray = Array.from || (function (value) { return arrPrototype.slice.call(value); });

        function toNode(element) {
            return toNodes(element)[0];
        }

        function toNodes(element) {
            return element && (isNode(element) ? [element] : toArray(element).filter(isNode)) || [];
        }

        function toWindow(element) {
            if (isWindow(element)) {
                return element;
            }

            element = toNode(element);

            return element
                ? (isDocument(element)
                    ? element
                    : element.ownerDocument
                ).defaultView
                : window;
        }

        function toMs(time) {
            return !time
                ? 0
                : endsWith(time, 'ms')
                    ? toFloat(time)
                    : toFloat(time) * 1000;
        }

        function isEqual(value, other) {
            return value === other
                || isObject(value)
                && isObject(other)
                && Object.keys(value).length === Object.keys(other).length
                && each(value, function (val, key) { return val === other[key]; });
        }

        function swap(value, a, b) {
            return value.replace(
                new RegExp((a + "|" + b), 'g'),
                function (match) { return match === a ? b : a; }
            );
        }

        var assign = Object.assign || function (target) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            target = Object(target);
            for (var i = 0; i < args.length; i++) {
                var source = args[i];
                if (source !== null) {
                    for (var key in source) {
                        if (hasOwn(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
            }
            return target;
        };

        function last(array) {
            return array[array.length - 1];
        }

        function each(obj, cb) {
            for (var key in obj) {
                if (false === cb(obj[key], key)) {
                    return false;
                }
            }
            return true;
        }

        function sortBy$1(array, prop) {
            return array.slice().sort(function (ref, ref$1) {
                    var propA = ref[prop]; if ( propA === void 0 ) propA = 0;
                    var propB = ref$1[prop]; if ( propB === void 0 ) propB = 0;

                    return propA > propB
                    ? 1
                    : propB > propA
                        ? -1
                        : 0;
            }
            );
        }

        function uniqueBy(array, prop) {
            var seen = new Set();
            return array.filter(function (ref) {
                var check = ref[prop];

                return seen.has(check)
                ? false
                : seen.add(check) || true;
            } // IE 11 does not return the Set object
            );
        }

        function clamp(number, min, max) {
            if ( min === void 0 ) min = 0;
            if ( max === void 0 ) max = 1;

            return Math.min(Math.max(toNumber(number) || 0, min), max);
        }

        function noop() {}

        function intersectRect() {
            var rects = [], len = arguments.length;
            while ( len-- ) rects[ len ] = arguments[ len ];

            return [['bottom', 'top'], ['right', 'left']].every(function (ref) {
                    var minProp = ref[0];
                    var maxProp = ref[1];

                    return Math.min.apply(Math, rects.map(function (ref) {
                    var min = ref[minProp];

                    return min;
                    })) - Math.max.apply(Math, rects.map(function (ref) {
                    var max = ref[maxProp];

                    return max;
                    })) > 0;
            }
            );
        }

        function pointInRect(point, rect) {
            return point.x <= rect.right &&
                point.x >= rect.left &&
                point.y <= rect.bottom &&
                point.y >= rect.top;
        }

        var Dimensions = {

            ratio: function(dimensions, prop, value) {
                var obj;


                var aProp = prop === 'width' ? 'height' : 'width';

                return ( obj = {}, obj[aProp] = dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp], obj[prop] = value, obj );
            },

            contain: function(dimensions, maxDimensions) {
                var this$1$1 = this;

                dimensions = assign({}, dimensions);

                each(dimensions, function (_, prop) { return dimensions = dimensions[prop] > maxDimensions[prop]
                    ? this$1$1.ratio(dimensions, prop, maxDimensions[prop])
                    : dimensions; }
                );

                return dimensions;
            },

            cover: function(dimensions, maxDimensions) {
                var this$1$1 = this;

                dimensions = this.contain(dimensions, maxDimensions);

                each(dimensions, function (_, prop) { return dimensions = dimensions[prop] < maxDimensions[prop]
                    ? this$1$1.ratio(dimensions, prop, maxDimensions[prop])
                    : dimensions; }
                );

                return dimensions;
            }

        };

        function getIndex(i, elements, current, finite) {
            if ( current === void 0 ) current = 0;
            if ( finite === void 0 ) finite = false;


            elements = toNodes(elements);

            var length = elements.length;

            i = isNumeric(i)
                ? toNumber(i)
                : i === 'next'
                    ? current + 1
                    : i === 'previous'
                        ? current - 1
                        : elements.indexOf(toNode(i));

            if (finite) {
                return clamp(i, 0, length - 1);
            }

            i %= length;

            return i < 0 ? i + length : i;
        }

        function memoize(fn) {
            var cache = Object.create(null);
            return function (key) { return cache[key] || (cache[key] = fn(key)); };
        }

        function attr(element, name, value) {

            if (isObject(name)) {
                for (var key in name) {
                    attr(element, key, name[key]);
                }
                return;
            }

            if (isUndefined(value)) {
                element = toNode(element);
                return element && element.getAttribute(name);
            } else {
                toNodes(element).forEach(function (element) {

                    if (isFunction(value)) {
                        value = value.call(element, attr(element, name));
                    }

                    if (value === null) {
                        removeAttr(element, name);
                    } else {
                        element.setAttribute(name, value);
                    }
                });
            }

        }

        function hasAttr(element, name) {
            return toNodes(element).some(function (element) { return element.hasAttribute(name); });
        }

        function removeAttr(element, name) {
            element = toNodes(element);
            name.split(' ').forEach(function (name) { return element.forEach(function (element) { return element.hasAttribute(name) && element.removeAttribute(name); }
                ); }
            );
        }

        function data(element, attribute) {
            for (var i = 0, attrs = [attribute, ("data-" + attribute)]; i < attrs.length; i++) {
                if (hasAttr(element, attrs[i])) {
                    return attr(element, attrs[i]);
                }
            }
        }

        /* global DocumentTouch */

        var inBrowser = typeof window !== 'undefined';
        var isIE = inBrowser && /msie|trident/i.test(window.navigator.userAgent);
        var isRtl = inBrowser && attr(document.documentElement, 'dir') === 'rtl';

        var hasTouchEvents = inBrowser && 'ontouchstart' in window;
        var hasPointerEvents = inBrowser && window.PointerEvent;
        var hasTouch = inBrowser && (hasTouchEvents
            || window.DocumentTouch && document instanceof DocumentTouch
            || navigator.maxTouchPoints); // IE >=11

        var pointerDown = hasPointerEvents ? 'pointerdown' : hasTouchEvents ? 'touchstart' : 'mousedown';
        var pointerMove = hasPointerEvents ? 'pointermove' : hasTouchEvents ? 'touchmove' : 'mousemove';
        var pointerUp = hasPointerEvents ? 'pointerup' : hasTouchEvents ? 'touchend' : 'mouseup';
        var pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouchEvents ? '' : 'mouseenter';
        var pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouchEvents ? '' : 'mouseleave';
        var pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';

        var voidElements = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            menuitem: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        function isVoidElement(element) {
            return toNodes(element).some(function (element) { return voidElements[element.tagName.toLowerCase()]; });
        }

        function isVisible(element) {
            return toNodes(element).some(function (element) { return element.offsetWidth || element.offsetHeight || element.getClientRects().length; });
        }

        var selInput = 'input,select,textarea,button';
        function isInput(element) {
            return toNodes(element).some(function (element) { return matches(element, selInput); });
        }

        var selFocusable = selInput + ",a[href],[tabindex]";
        function isFocusable(element) {
            return matches(element, selFocusable);
        }

        function parent(element) {
            element = toNode(element);
            return element && isElement(element.parentNode) && element.parentNode;
        }

        function filter$1(element, selector) {
            return toNodes(element).filter(function (element) { return matches(element, selector); });
        }

        var elProto = inBrowser ? Element.prototype : {};
        var matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector || noop;

        function matches(element, selector) {
            return toNodes(element).some(function (element) { return matchesFn.call(element, selector); });
        }

        var closestFn = elProto.closest || function (selector) {
            var ancestor = this;

            do {

                if (matches(ancestor, selector)) {
                    return ancestor;
                }

            } while ((ancestor = parent(ancestor)));
        };

        function closest(element, selector) {

            if (startsWith(selector, '>')) {
                selector = selector.slice(1);
            }

            return isElement(element)
                ? closestFn.call(element, selector)
                : toNodes(element).map(function (element) { return closest(element, selector); }).filter(Boolean);
        }

        function within(element, selector) {
            return !isString(selector)
                ? element === selector || (isDocument(selector)
                    ? selector.documentElement
                    : toNode(selector)).contains(toNode(element)) // IE 11 document does not implement contains
                : matches(element, selector) || !!closest(element, selector);
        }

        function parents(element, selector) {
            var elements = [];

            while ((element = parent(element))) {
                if (!selector || matches(element, selector)) {
                    elements.push(element);
                }
            }

            return elements;
        }

        function children(element, selector) {
            element = toNode(element);
            var children = element ? toNodes(element.children) : [];
            return selector ? filter$1(children, selector) : children;
        }

        function index(element, ref) {
            return ref
                ? toNodes(element).indexOf(toNode(ref))
                : children(parent(element)).indexOf(element);
        }

        function query(selector, context) {
            return find(selector, getContext(selector, context));
        }

        function queryAll(selector, context) {
            return findAll(selector, getContext(selector, context));
        }

        function getContext(selector, context) {
            if ( context === void 0 ) context = document;

            return isString(selector) && isContextSelector(selector) || isDocument(context)
                ? context
                : context.ownerDocument;
        }

        function find(selector, context) {
            return toNode(_query(selector, context, 'querySelector'));
        }

        function findAll(selector, context) {
            return toNodes(_query(selector, context, 'querySelectorAll'));
        }

        function _query(selector, context, queryFn) {
            if ( context === void 0 ) context = document;


            if (!selector || !isString(selector)) {
                return selector;
            }

            selector = selector.replace(contextSanitizeRe, '$1 *');

            if (isContextSelector(selector)) {

                selector = splitSelector(selector).map(function (selector) {

                    var ctx = context;

                    if (selector[0] === '!') {

                        var selectors = selector.substr(1).trim().split(' ');
                        ctx = closest(parent(context), selectors[0]);
                        selector = selectors.slice(1).join(' ').trim();

                    }

                    if (selector[0] === '-') {

                        var selectors$1 = selector.substr(1).trim().split(' ');
                        var prev = (ctx || context).previousElementSibling;
                        ctx = matches(prev, selector.substr(1)) ? prev : null;
                        selector = selectors$1.slice(1).join(' ');

                    }

                    if (!ctx) {
                        return null;
                    }

                    return ((domPath(ctx)) + " " + selector);

                }).filter(Boolean).join(',');

                context = document;

            }

            try {

                return context[queryFn](selector);

            } catch (e) {

                return null;

            }

        }

        var contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
        var contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;

        var isContextSelector = memoize(function (selector) { return selector.match(contextSelectorRe); });

        var selectorRe = /.*?[^\\](?:,|$)/g;

        var splitSelector = memoize(function (selector) { return selector.match(selectorRe).map(function (selector) { return selector.replace(/,$/, '').trim(); }
            ); }
        );

        function domPath(element) {
            var names = [];
            while (element.parentNode) {
                if (element.id) {
                    names.unshift(("#" + (escape(element.id))));
                    break;
                } else {
                    var tagName = element.tagName;
                    if (tagName !== 'HTML') {
                        tagName += ":nth-child(" + (index(element) + 1) + ")";
                    }
                    names.unshift(tagName);
                    element = element.parentNode;
                }
            }
            return names.join(' > ');
        }

        var escapeFn = inBrowser && window.CSS && CSS.escape || function (css) { return css.replace(/([^\x7f-\uFFFF\w-])/g, function (match) { return ("\\" + match); }); };
        function escape(css) {
            return isString(css) ? escapeFn.call(null, css) : '';
        }

        function on() {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];


            var ref = getArgs(args);
            var targets = ref[0];
            var type = ref[1];
            var selector = ref[2];
            var listener = ref[3];
            var useCapture = ref[4];

            targets = toEventTargets(targets);

            if (listener.length > 1) {
                listener = detail(listener);
            }

            if (useCapture && useCapture.self) {
                listener = selfFilter(listener);
            }

            if (selector) {
                listener = delegate(selector, listener);
            }

            useCapture = useCaptureFilter(useCapture);

            type.split(' ').forEach(function (type) { return targets.forEach(function (target) { return target.addEventListener(type, listener, useCapture); }
                ); }
            );
            return function () { return off(targets, type, listener, useCapture); };
        }

        function off(targets, type, listener, useCapture) {
            if ( useCapture === void 0 ) useCapture = false;

            useCapture = useCaptureFilter(useCapture);
            targets = toEventTargets(targets);
            type.split(' ').forEach(function (type) { return targets.forEach(function (target) { return target.removeEventListener(type, listener, useCapture); }
                ); }
            );
        }

        function once() {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];


            var ref = getArgs(args);
            var element = ref[0];
            var type = ref[1];
            var selector = ref[2];
            var listener = ref[3];
            var useCapture = ref[4];
            var condition = ref[5];
            var off = on(element, type, selector, function (e) {
                var result = !condition || condition(e);
                if (result) {
                    off();
                    listener(e, result);
                }
            }, useCapture);

            return off;
        }

        function trigger(targets, event, detail) {
            return toEventTargets(targets).reduce(function (notCanceled, target) { return notCanceled && target.dispatchEvent(createEvent(event, true, true, detail)); }
                , true);
        }

        function createEvent(e, bubbles, cancelable, detail) {
            if ( bubbles === void 0 ) bubbles = true;
            if ( cancelable === void 0 ) cancelable = false;

            if (isString(e)) {
                var event = document.createEvent('CustomEvent'); // IE 11
                event.initCustomEvent(e, bubbles, cancelable, detail);
                e = event;
            }

            return e;
        }

        function getArgs(args) {
            if (isFunction(args[2])) {
                args.splice(2, 0, false);
            }
            return args;
        }

        function delegate(selector, listener) {
            var this$1$1 = this;

            return function (e) {

                var current = selector[0] === '>'
                    ? findAll(selector, e.currentTarget).reverse().filter(function (element) { return within(e.target, element); })[0]
                    : closest(e.target, selector);

                if (current) {
                    e.current = current;
                    listener.call(this$1$1, e);
                }

            };
        }

        function detail(listener) {
            return function (e) { return isArray(e.detail) ? listener.apply(void 0, [ e ].concat( e.detail )) : listener(e); };
        }

        function selfFilter(listener) {
            return function (e) {
                if (e.target === e.currentTarget || e.target === e.current) {
                    return listener.call(null, e);
                }
            };
        }

        function useCaptureFilter(options) {
            return options && isIE && !isBoolean(options)
                ? !!options.capture
                : options;
        }

        function isEventTarget(target) {
            return target && 'addEventListener' in target;
        }

        function toEventTarget(target) {
            return isEventTarget(target) ? target : toNode(target);
        }

        function toEventTargets(target) {
            return isArray(target)
                    ? target.map(toEventTarget).filter(Boolean)
                    : isString(target)
                        ? findAll(target)
                        : isEventTarget(target)
                            ? [target]
                            : toNodes(target);
        }

        function isTouch(e) {
            return e.pointerType === 'touch' || !!e.touches;
        }

        function getEventPos(e) {
            var touches = e.touches;
            var changedTouches = e.changedTouches;
            var ref = touches && touches[0] || changedTouches && changedTouches[0] || e;
            var x = ref.clientX;
            var y = ref.clientY;

            return {x: x, y: y};
        }

        /* global setImmediate */

        var Promise$1 = inBrowser && window.Promise || PromiseFn;

        var Deferred = function() {
            var this$1$1 = this;

            this.promise = new Promise$1(function (resolve, reject) {
                this$1$1.reject = reject;
                this$1$1.resolve = resolve;
            });
        };

        /**
         * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
         */

        var RESOLVED = 0;
        var REJECTED = 1;
        var PENDING = 2;

        var async = inBrowser && window.setImmediate || setTimeout;

        function PromiseFn(executor) {

            this.state = PENDING;
            this.value = undefined;
            this.deferred = [];

            var promise = this;

            try {
                executor(
                    function (x) {
                        promise.resolve(x);
                    },
                    function (r) {
                        promise.reject(r);
                    }
                );
            } catch (e) {
                promise.reject(e);
            }
        }

        PromiseFn.reject = function (r) {
            return new PromiseFn(function (resolve, reject) {
                reject(r);
            });
        };

        PromiseFn.resolve = function (x) {
            return new PromiseFn(function (resolve, reject) {
                resolve(x);
            });
        };

        PromiseFn.all = function all(iterable) {
            return new PromiseFn(function (resolve, reject) {
                var result = [];
                var count = 0;

                if (iterable.length === 0) {
                    resolve(result);
                }

                function resolver(i) {
                    return function (x) {
                        result[i] = x;
                        count += 1;

                        if (count === iterable.length) {
                            resolve(result);
                        }
                    };
                }

                for (var i = 0; i < iterable.length; i += 1) {
                    PromiseFn.resolve(iterable[i]).then(resolver(i), reject);
                }
            });
        };

        PromiseFn.race = function race(iterable) {
            return new PromiseFn(function (resolve, reject) {
                for (var i = 0; i < iterable.length; i += 1) {
                    PromiseFn.resolve(iterable[i]).then(resolve, reject);
                }
            });
        };

        var p = PromiseFn.prototype;

        p.resolve = function resolve(x) {
            var promise = this;

            if (promise.state === PENDING) {
                if (x === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                var called = false;

                try {
                    var then = x && x.then;

                    if (x !== null && isObject(x) && isFunction(then)) {
                        then.call(
                            x,
                            function (x) {
                                if (!called) {
                                    promise.resolve(x);
                                }
                                called = true;
                            },
                            function (r) {
                                if (!called) {
                                    promise.reject(r);
                                }
                                called = true;
                            }
                        );
                        return;
                    }
                } catch (e) {
                    if (!called) {
                        promise.reject(e);
                    }
                    return;
                }

                promise.state = RESOLVED;
                promise.value = x;
                promise.notify();
            }
        };

        p.reject = function reject(reason) {
            var promise = this;

            if (promise.state === PENDING) {
                if (reason === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                promise.state = REJECTED;
                promise.value = reason;
                promise.notify();
            }
        };

        p.notify = function notify() {
            var this$1$1 = this;

            async(function () {
                if (this$1$1.state !== PENDING) {
                    while (this$1$1.deferred.length) {
                        var ref = this$1$1.deferred.shift();
                        var onResolved = ref[0];
                        var onRejected = ref[1];
                        var resolve = ref[2];
                        var reject = ref[3];

                        try {
                            if (this$1$1.state === RESOLVED) {
                                if (isFunction(onResolved)) {
                                    resolve(onResolved.call(undefined, this$1$1.value));
                                } else {
                                    resolve(this$1$1.value);
                                }
                            } else if (this$1$1.state === REJECTED) {
                                if (isFunction(onRejected)) {
                                    resolve(onRejected.call(undefined, this$1$1.value));
                                } else {
                                    reject(this$1$1.value);
                                }
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }
                }
            });
        };

        p.then = function then(onResolved, onRejected) {
            var this$1$1 = this;

            return new PromiseFn(function (resolve, reject) {
                this$1$1.deferred.push([onResolved, onRejected, resolve, reject]);
                this$1$1.notify();
            });
        };

        p.catch = function (onRejected) {
            return this.then(undefined, onRejected);
        };

        function ajax(url, options) {

            var env = assign({
                data: null,
                method: 'GET',
                headers: {},
                xhr: new XMLHttpRequest(),
                beforeSend: noop,
                responseType: ''
            }, options);

            return Promise$1.resolve()
                .then(function () { return env.beforeSend(env); })
                .then(function () { return send(url, env); });
        }

        function send(url, env) {
            return new Promise$1(function (resolve, reject) {
                var xhr = env.xhr;

                for (var prop in env) {
                    if (prop in xhr) {
                        try {

                            xhr[prop] = env[prop];

                        } catch (e) {}
                    }
                }

                xhr.open(env.method.toUpperCase(), url);

                for (var header in env.headers) {
                    xhr.setRequestHeader(header, env.headers[header]);
                }

                on(xhr, 'load', function () {

                    if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {

                        // IE 11 does not support responseType 'json'
                        if (env.responseType === 'json' && isString(xhr.response)) {
                            xhr = assign(copyXhr(xhr), {response: JSON.parse(xhr.response)});
                        }

                        resolve(xhr);

                    } else {
                        reject(assign(Error(xhr.statusText), {
                            xhr: xhr,
                            status: xhr.status
                        }));
                    }

                });

                on(xhr, 'error', function () { return reject(assign(Error('Network Error'), {xhr: xhr})); });
                on(xhr, 'timeout', function () { return reject(assign(Error('Network Timeout'), {xhr: xhr})); });

                xhr.send(env.data);
            });
        }

        function getImage(src, srcset, sizes) {

            return new Promise$1(function (resolve, reject) {
                var img = new Image();

                img.onerror = function (e) { return reject(e); };
                img.onload = function () { return resolve(img); };

                sizes && (img.sizes = sizes);
                srcset && (img.srcset = srcset);
                img.src = src;
            });

        }

        function copyXhr(source) {
            var target = {};
            for (var key in source) {
                target[key] = source[key];
            }
            return target;
        }

        function ready(fn) {

            if (document.readyState !== 'loading') {
                fn();
                return;
            }

            var unbind = on(document, 'DOMContentLoaded', function () {
                unbind();
                fn();
            });
        }

        function empty(element) {
            element = $(element);
            element.innerHTML = '';
            return element;
        }

        function html(parent, html) {
            parent = $(parent);
            return isUndefined(html)
                ? parent.innerHTML
                : append(parent.hasChildNodes() ? empty(parent) : parent, html);
        }

        function prepend(parent, element) {

            parent = $(parent);

            if (!parent.hasChildNodes()) {
                return append(parent, element);
            } else {
                return insertNodes(element, function (element) { return parent.insertBefore(element, parent.firstChild); });
            }
        }

        function append(parent, element) {
            parent = $(parent);
            return insertNodes(element, function (element) { return parent.appendChild(element); });
        }

        function before(ref, element) {
            ref = $(ref);
            return insertNodes(element, function (element) { return ref.parentNode.insertBefore(element, ref); });
        }

        function after(ref, element) {
            ref = $(ref);
            return insertNodes(element, function (element) { return ref.nextSibling
                ? before(ref.nextSibling, element)
                : append(ref.parentNode, element); }
            );
        }

        function insertNodes(element, fn) {
            element = isString(element) ? fragment(element) : element;
            return element
                ? 'length' in element
                    ? toNodes(element).map(fn)
                    : fn(element)
                : null;
        }

        function remove$1(element) {
            toNodes(element).forEach(function (element) { return element.parentNode && element.parentNode.removeChild(element); });
        }

        function wrapAll(element, structure) {

            structure = toNode(before(element, structure));

            while (structure.firstChild) {
                structure = structure.firstChild;
            }

            append(structure, element);

            return structure;
        }

        function wrapInner(element, structure) {
            return toNodes(toNodes(element).map(function (element) { return element.hasChildNodes ? wrapAll(toNodes(element.childNodes), structure) : append(element, structure); }
            ));
        }

        function unwrap(element) {
            toNodes(element)
                .map(parent)
                .filter(function (value, index, self) { return self.indexOf(value) === index; })
                .forEach(function (parent) {
                    before(parent, parent.childNodes);
                    remove$1(parent);
                });
        }

        var fragmentRe = /^\s*<(\w+|!)[^>]*>/;
        var singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;

        function fragment(html) {

            var matches = singleTagRe.exec(html);
            if (matches) {
                return document.createElement(matches[1]);
            }

            var container = document.createElement('div');
            if (fragmentRe.test(html)) {
                container.insertAdjacentHTML('beforeend', html.trim());
            } else {
                container.textContent = html;
            }

            return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild;

        }

        function apply$1(node, fn) {

            if (!isElement(node)) {
                return;
            }

            fn(node);
            node = node.firstElementChild;
            while (node) {
                var next = node.nextElementSibling;
                apply$1(node, fn);
                node = next;
            }
        }

        function $(selector, context) {
            return isHtml(selector)
                ? toNode(fragment(selector))
                : find(selector, context);
        }

        function $$(selector, context) {
            return isHtml(selector)
                ? toNodes(fragment(selector))
                : findAll(selector, context);
        }

        function isHtml(str) {
            return isString(str) && (str[0] === '<' || str.match(/^\s*</));
        }

        function addClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            apply(element, args, 'add');
        }

        function removeClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            apply(element, args, 'remove');
        }

        function removeClasses(element, cls) {
            attr(element, 'class', function (value) { return (value || '').replace(new RegExp(("\\b" + cls + "\\b"), 'g'), ''); });
        }

        function replaceClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            args[0] && removeClass(element, args[0]);
            args[1] && addClass(element, args[1]);
        }

        function hasClass(element, cls) {
            var assign;

            (assign = getClasses(cls), cls = assign[0]);
            var nodes = toNodes(element);
            for (var n = 0; n < nodes.length; n++) {
                if (cls && nodes[n].classList.contains(cls)) {
                    return true;
                }
            }
            return false;
        }

        function toggleClass(element, cls, force) {

            cls = getClasses(cls);

            var nodes = toNodes(element);
            for (var n = 0; n < nodes.length; n++) {
                var list = nodes[n].classList;
                for (var i = 0; i < cls.length; i++) {
                    if (isUndefined(force)) {
                        list.toggle(cls[i]);
                    } else if (supports.Force) {
                        list.toggle(cls[i], !!force);
                    } else {
                        list[force ? 'add' : 'remove'](cls[i]);
                    }
                }
            }
        }

        function apply(element, args, fn) {
            var ref;


            args = args.reduce(function (args, arg) { return args.concat(getClasses(arg)); }, []);

            var nodes = toNodes(element);
            var loop = function ( n ) {
                if (supports.Multiple) {
                    (ref = nodes[n].classList)[fn].apply(ref, args);
                } else {
                    args.forEach(function (cls) { return nodes[n].classList[fn](cls); });
                }
            };

            for (var n = 0; n < nodes.length; n++) loop( n );
        }

        function getClasses(str) {
            return String(str).split(/\s|,/).filter(Boolean);
        }

        // IE 11
        var supports = {

            get Multiple() {
                return this.get('Multiple');
            },

            get Force() {
                return this.get('Force');
            },

            get: function(key) {

                var ref = document.createElement('_');
                var classList = ref.classList;
                classList.add('a', 'b');
                classList.toggle('c', false);
                supports = {
                    Multiple: classList.contains('b'),
                    Force: !classList.contains('c')
                };

                return supports[key];
            }

        };

        var cssNumber = {
            'animation-iteration-count': true,
            'column-count': true,
            'fill-opacity': true,
            'flex-grow': true,
            'flex-shrink': true,
            'font-weight': true,
            'line-height': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'stroke-dasharray': true,
            'stroke-dashoffset': true,
            'widows': true,
            'z-index': true,
            'zoom': true
        };

        function css(element, property, value, priority) {
            if ( priority === void 0 ) priority = '';


            return toNodes(element).map(function (element) {

                if (isString(property)) {

                    property = propName(property);

                    if (isUndefined(value)) {
                        return getStyle(element, property);
                    } else if (!value && !isNumber(value)) {
                        element.style.removeProperty(property);
                    } else {
                        element.style.setProperty(property, isNumeric(value) && !cssNumber[property] ? (value + "px") : value, priority);
                    }

                } else if (isArray(property)) {

                    var styles = getStyles(element);

                    return property.reduce(function (props, property) {
                        props[property] = styles[propName(property)];
                        return props;
                    }, {});

                } else if (isObject(property)) {
                    priority = value;
                    each(property, function (value, property) { return css(element, property, value, priority); });
                }

                return element;

            })[0];

        }

        function getStyles(element, pseudoElt) {
            return toWindow(element).getComputedStyle(element, pseudoElt);
        }

        function getStyle(element, property, pseudoElt) {
            return getStyles(element, pseudoElt)[property];
        }

        var parseCssVar = memoize(function (name) {
            /* usage in css: .uk-name:before { content:"xyz" } */

            var element = append(document.documentElement, document.createElement('div'));

            addClass(element, ("uk-" + name));

            name = getStyle(element, 'content', ':before').replace(/^["'](.*)["']$/, '$1');

            remove$1(element);

            return name;
        });

        function getCssVar(name) {
            return !isIE
                ? getStyles(document.documentElement).getPropertyValue(("--uk-" + name))
                : parseCssVar(name);
        }

        // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty
        var propName = memoize(function (name) { return vendorPropName(name); });

        var cssPrefixes = ['webkit', 'moz', 'ms'];

        function vendorPropName(name) {

            name = hyphenate(name);

            var ref = document.documentElement;
            var style = ref.style;

            if (name in style) {
                return name;
            }

            var i = cssPrefixes.length, prefixedName;

            while (i--) {
                prefixedName = "-" + (cssPrefixes[i]) + "-" + name;
                if (prefixedName in style) {
                    return prefixedName;
                }
            }
        }

        function transition(element, props, duration, timing) {
            if ( duration === void 0 ) duration = 400;
            if ( timing === void 0 ) timing = 'linear';


            return Promise$1.all(toNodes(element).map(function (element) { return new Promise$1(function (resolve, reject) {

                    for (var name in props) {
                        var value = css(element, name);
                        if (value === '') {
                            css(element, name, value);
                        }
                    }

                    var timer = setTimeout(function () { return trigger(element, 'transitionend'); }, duration);

                    once(element, 'transitionend transitioncanceled', function (ref) {
                        var type = ref.type;

                        clearTimeout(timer);
                        removeClass(element, 'uk-transition');
                        css(element, {
                            transitionProperty: '',
                            transitionDuration: '',
                            transitionTimingFunction: ''
                        });
                        type === 'transitioncanceled' ? reject() : resolve(element);
                    }, {self: true});

                    addClass(element, 'uk-transition');
                    css(element, assign({
                        transitionProperty: Object.keys(props).map(propName).join(','),
                        transitionDuration: (duration + "ms"),
                        transitionTimingFunction: timing
                    }, props));

                }); }
            ));

        }

        var Transition = {

            start: transition,

            stop: function(element) {
                trigger(element, 'transitionend');
                return Promise$1.resolve();
            },

            cancel: function(element) {
                trigger(element, 'transitioncanceled');
            },

            inProgress: function(element) {
                return hasClass(element, 'uk-transition');
            }

        };

        var animationPrefix = 'uk-animation-';

        function animate$1(element, animation, duration, origin, out) {
            if ( duration === void 0 ) duration = 200;


            return Promise$1.all(toNodes(element).map(function (element) { return new Promise$1(function (resolve, reject) {

                    trigger(element, 'animationcanceled');
                    var timer = setTimeout(function () { return trigger(element, 'animationend'); }, duration);

                    once(element, 'animationend animationcanceled', function (ref) {
                        var type = ref.type;


                        clearTimeout(timer);

                        type === 'animationcanceled' ? reject() : resolve(element);

                        css(element, 'animationDuration', '');
                        removeClasses(element, (animationPrefix + "\\S*"));

                    }, {self: true});

                    css(element, 'animationDuration', (duration + "ms"));
                    addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));

                    if (startsWith(animation, animationPrefix)) {
                        origin && addClass(element, ("uk-transform-origin-" + origin));
                        out && addClass(element, (animationPrefix + "reverse"));
                    }

                }); }
            ));

        }

        var inProgress = new RegExp((animationPrefix + "(enter|leave)"));
        var Animation = {

            in: animate$1,

            out: function(element, animation, duration, origin) {
                return animate$1(element, animation, duration, origin, true);
            },

            inProgress: function(element) {
                return inProgress.test(attr(element, 'class'));
            },

            cancel: function(element) {
                trigger(element, 'animationcanceled');
            }

        };

        var dirs$1 = {
            width: ['left', 'right'],
            height: ['top', 'bottom']
        };

        function dimensions(element) {

            var rect = isElement(element)
                ? toNode(element).getBoundingClientRect()
                : {height: height(element), width: width(element), top: 0, left: 0};

            return {
                height: rect.height,
                width: rect.width,
                top: rect.top,
                left: rect.left,
                bottom: rect.top + rect.height,
                right: rect.left + rect.width
            };
        }

        function offset(element, coordinates) {

            var currentOffset = dimensions(element);
            var ref = toWindow(element);
            var pageYOffset = ref.pageYOffset;
            var pageXOffset = ref.pageXOffset;
            var offsetBy = {height: pageYOffset, width: pageXOffset};

            for (var dir in dirs$1) {
                for (var i in dirs$1[dir]) {
                    currentOffset[dirs$1[dir][i]] += offsetBy[dir];
                }
            }

            if (!coordinates) {
                return currentOffset;
            }

            var pos = css(element, 'position');

            each(css(element, ['left', 'top']), function (value, prop) { return css(element, prop, coordinates[prop]
                    - currentOffset[prop]
                    + toFloat(pos === 'absolute' && value === 'auto'
                        ? position(element)[prop]
                        : value)
                ); }
            );
        }

        function position(element) {

            var ref = offset(element);
            var top = ref.top;
            var left = ref.left;

            var ref$1 = toNode(element);
            var ref$1_ownerDocument = ref$1.ownerDocument;
            var body = ref$1_ownerDocument.body;
            var documentElement = ref$1_ownerDocument.documentElement;
            var offsetParent = ref$1.offsetParent;
            var parent = offsetParent || documentElement;

            while (parent && (parent === body || parent === documentElement) && css(parent, 'position') === 'static') {
                parent = parent.parentNode;
            }

            if (isElement(parent)) {
                var parentOffset = offset(parent);
                top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));
                left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));
            }

            return {
                top: top - toFloat(css(element, 'marginTop')),
                left: left - toFloat(css(element, 'marginLeft'))
            };
        }

        function offsetPosition(element) {
            var offset = [0, 0];

            element = toNode(element);

            do {

                offset[0] += element.offsetTop;
                offset[1] += element.offsetLeft;

                if (css(element, 'position') === 'fixed') {
                    var win = toWindow(element);
                    offset[0] += win.pageYOffset;
                    offset[1] += win.pageXOffset;
                    return offset;
                }

            } while ((element = element.offsetParent));

            return offset;
        }

        var height = dimension('height');
        var width = dimension('width');

        function dimension(prop) {
            var propName = ucfirst(prop);
            return function (element, value) {

                if (isUndefined(value)) {

                    if (isWindow(element)) {
                        return element[("inner" + propName)];
                    }

                    if (isDocument(element)) {
                        var doc = element.documentElement;
                        return Math.max(doc[("offset" + propName)], doc[("scroll" + propName)]);
                    }

                    element = toNode(element);

                    value = css(element, prop);
                    value = value === 'auto' ? element[("offset" + propName)] : toFloat(value) || 0;

                    return value - boxModelAdjust(element, prop);

                } else {

                    return css(element, prop, !value && value !== 0
                        ? ''
                        : +value + boxModelAdjust(element, prop) + 'px'
                    );

                }

            };
        }

        function boxModelAdjust(element, prop, sizing) {
            if ( sizing === void 0 ) sizing = 'border-box';

            return css(element, 'boxSizing') === sizing
                ? dirs$1[prop].map(ucfirst).reduce(function (value, prop) { return value
                    + toFloat(css(element, ("padding" + prop)))
                    + toFloat(css(element, ("border" + prop + "Width"))); }
                    , 0)
                : 0;
        }

        function flipPosition(pos) {
            for (var dir in dirs$1) {
                for (var i in dirs$1[dir]) {
                    if (dirs$1[dir][i] === pos) {
                        return dirs$1[dir][1 - i];
                    }
                }
            }
            return pos;
        }

        function toPx(value, property, element) {
            if ( property === void 0 ) property = 'width';
            if ( element === void 0 ) element = window;

            return isNumeric(value)
                ? +value
                : endsWith(value, 'vh')
                    ? percent(height(toWindow(element)), value)
                    : endsWith(value, 'vw')
                        ? percent(width(toWindow(element)), value)
                        : endsWith(value, '%')
                            ? percent(dimensions(element)[property], value)
                            : toFloat(value);
        }

        function percent(base, value) {
            return base * toFloat(value) / 100;
        }

        /*
            Based on:
            Copyright (c) 2016 Wilson Page wilsonpage@me.com
            https://github.com/wilsonpage/fastdom
        */

        var fastdom = {

            reads: [],
            writes: [],

            read: function(task) {
                this.reads.push(task);
                scheduleFlush();
                return task;
            },

            write: function(task) {
                this.writes.push(task);
                scheduleFlush();
                return task;
            },

            clear: function(task) {
                remove(this.reads, task);
                remove(this.writes, task);
            },

            flush: flush

        };

        function flush(recursion) {
            if ( recursion === void 0 ) recursion = 1;

            runTasks(fastdom.reads);
            runTasks(fastdom.writes.splice(0));

            fastdom.scheduled = false;

            if (fastdom.reads.length || fastdom.writes.length) {
                scheduleFlush(recursion + 1);
            }
        }

        var RECURSION_LIMIT = 4;
        function scheduleFlush(recursion) {

            if (fastdom.scheduled) {
                return;
            }

            fastdom.scheduled = true;
            if (recursion && recursion < RECURSION_LIMIT) {
                Promise$1.resolve().then(function () { return flush(recursion); });
            } else {
                requestAnimationFrame(function () { return flush(); });
            }

        }

        function runTasks(tasks) {
            var task;
            while ((task = tasks.shift())) {
                try {
                    task();
                } catch (e) {
                    console.error(e);
                }
            }
        }

        function remove(array, item) {
            var index = array.indexOf(item);
            return ~index && array.splice(index, 1);
        }

        function MouseTracker() {}

        MouseTracker.prototype = {

            positions: [],

            init: function() {
                var this$1$1 = this;


                this.positions = [];

                var position;
                this.unbind = on(document, 'mousemove', function (e) { return position = getEventPos(e); });
                this.interval = setInterval(function () {

                    if (!position) {
                        return;
                    }

                    this$1$1.positions.push(position);

                    if (this$1$1.positions.length > 5) {
                        this$1$1.positions.shift();
                    }
                }, 50);

            },

            cancel: function() {
                this.unbind && this.unbind();
                this.interval && clearInterval(this.interval);
            },

            movesTo: function(target) {

                if (this.positions.length < 2) {
                    return false;
                }

                var p = target.getBoundingClientRect();
                var left = p.left;
                var right = p.right;
                var top = p.top;
                var bottom = p.bottom;

                var ref = this.positions;
                var prevPosition = ref[0];
                var position = last(this.positions);
                var path = [prevPosition, position];

                if (pointInRect(position, p)) {
                    return false;
                }

                var diagonals = [[{x: left, y: top}, {x: right, y: bottom}], [{x: left, y: bottom}, {x: right, y: top}]];

                return diagonals.some(function (diagonal) {
                    var intersection = intersect(path, diagonal);
                    return intersection && pointInRect(intersection, p);
                });
            }

        };

        // Inspired by http://paulbourke.net/geometry/pointlineplane/
        function intersect(ref, ref$1) {
            var ref_0 = ref[0];
            var x1 = ref_0.x;
            var y1 = ref_0.y;
            var ref_1 = ref[1];
            var x2 = ref_1.x;
            var y2 = ref_1.y;
            var ref$1_0 = ref$1[0];
            var x3 = ref$1_0.x;
            var y3 = ref$1_0.y;
            var ref$1_1 = ref$1[1];
            var x4 = ref$1_1.x;
            var y4 = ref$1_1.y;


            var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

            // Lines are parallel
            if (denominator === 0) {
                return false;
            }

            var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;

            if (ua < 0) {
                return false;
            }

            // Return an object with the x and y coordinates of the intersection
            return {x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1)};
        }

        var strats = {};

        strats.events =
        strats.created =
        strats.beforeConnect =
        strats.connected =
        strats.beforeDisconnect =
        strats.disconnected =
        strats.destroy = concatStrat;

        // args strategy
        strats.args = function (parentVal, childVal) {
            return childVal !== false && concatStrat(childVal || parentVal);
        };

        // update strategy
        strats.update = function (parentVal, childVal) {
            return sortBy$1(concatStrat(parentVal, isFunction(childVal) ? {read: childVal} : childVal), 'order');
        };

        // property strategy
        strats.props = function (parentVal, childVal) {

            if (isArray(childVal)) {
                childVal = childVal.reduce(function (value, key) {
                    value[key] = String;
                    return value;
                }, {});
            }

            return strats.methods(parentVal, childVal);
        };

        // extend strategy
        strats.computed =
        strats.methods = function (parentVal, childVal) {
            return childVal
                ? parentVal
                    ? assign({}, parentVal, childVal)
                    : childVal
                : parentVal;
        };

        // data strategy
        strats.data = function (parentVal, childVal, vm) {

            if (!vm) {

                if (!childVal) {
                    return parentVal;
                }

                if (!parentVal) {
                    return childVal;
                }

                return function (vm) {
                    return mergeFnData(parentVal, childVal, vm);
                };

            }

            return mergeFnData(parentVal, childVal, vm);
        };

        function mergeFnData(parentVal, childVal, vm) {
            return strats.computed(
                isFunction(parentVal)
                    ? parentVal.call(vm, vm)
                    : parentVal,
                isFunction(childVal)
                    ? childVal.call(vm, vm)
                    : childVal
            );
        }

        // concat strategy
        function concatStrat(parentVal, childVal) {

            parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;

            return childVal
                ? parentVal
                    ? parentVal.concat(childVal)
                    : isArray(childVal)
                        ? childVal
                        : [childVal]
                : parentVal;
        }

        // default strategy
        function defaultStrat(parentVal, childVal) {
            return isUndefined(childVal) ? parentVal : childVal;
        }

        function mergeOptions(parent, child, vm) {

            var options = {};

            if (isFunction(child)) {
                child = child.options;
            }

            if (child.extends) {
                parent = mergeOptions(parent, child.extends, vm);
            }

            if (child.mixins) {
                for (var i = 0, l = child.mixins.length; i < l; i++) {
                    parent = mergeOptions(parent, child.mixins[i], vm);
                }
            }

            for (var key in parent) {
                mergeKey(key);
            }

            for (var key$1 in child) {
                if (!hasOwn(parent, key$1)) {
                    mergeKey(key$1);
                }
            }

            function mergeKey(key) {
                options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
            }

            return options;
        }

        function parseOptions(options, args) {
            var obj;

            if ( args === void 0 ) args = [];

            try {

                return !options
                    ? {}
                    : startsWith(options, '{')
                        ? JSON.parse(options)
                        : args.length && !includes(options, ':')
                            ? (( obj = {}, obj[args[0]] = options, obj ))
                            : options.split(';').reduce(function (options, option) {
                                var ref = option.split(/:(.*)/);
                                var key = ref[0];
                                var value = ref[1];
                                if (key && !isUndefined(value)) {
                                    options[key.trim()] = value.trim();
                                }
                                return options;
                            }, {});

            } catch (e) {
                return {};
            }

        }

        function play(el) {

            if (isIFrame(el)) {
                call(el, {func: 'playVideo', method: 'play'});
            }

            if (isHTML5(el)) {
                try {
                    el.play().catch(noop);
                } catch (e) {}
            }

        }

        function pause(el) {

            if (isIFrame(el)) {
                call(el, {func: 'pauseVideo', method: 'pause'});
            }

            if (isHTML5(el)) {
                el.pause();
            }

        }

        function mute(el) {

            if (isIFrame(el)) {
                call(el, {func: 'mute', method: 'setVolume', value: 0});
            }

            if (isHTML5(el)) {
                el.muted = true;
            }

        }

        function isVideo(el) {
            return isHTML5(el) || isIFrame(el);
        }

        function isHTML5(el) {
            return el && el.tagName === 'VIDEO';
        }

        function isIFrame(el) {
            return el && el.tagName === 'IFRAME' && (isYoutube(el) || isVimeo(el));
        }

        function isYoutube(el) {
            return !!el.src.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/);
        }

        function isVimeo(el) {
            return !!el.src.match(/vimeo\.com\/video\/.*/);
        }

        function call(el, cmd) {
            enableApi(el).then(function () { return post(el, cmd); });
        }

        function post(el, cmd) {
            try {
                el.contentWindow.postMessage(JSON.stringify(assign({event: 'command'}, cmd)), '*');
            } catch (e) {}
        }

        var stateKey$1 = '_ukPlayer';
        var counter = 0;
        function enableApi(el) {

            if (el[stateKey$1]) {
                return el[stateKey$1];
            }

            var youtube = isYoutube(el);
            var vimeo = isVimeo(el);

            var id = ++counter;
            var poller;

            return el[stateKey$1] = new Promise$1(function (resolve) {

                youtube && once(el, 'load', function () {
                    var listener = function () { return post(el, {event: 'listening', id: id}); };
                    poller = setInterval(listener, 100);
                    listener();
                });

                once(window, 'message', resolve, false, function (ref) {
                    var data = ref.data;


                    try {
                        data = JSON.parse(data);
                        return data && (youtube && data.id === id && data.event === 'onReady' || vimeo && Number(data.player_id) === id);
                    } catch (e) {}

                });

                el.src = "" + (el.src) + (includes(el.src, '?') ? '&' : '?') + (youtube ? 'enablejsapi=1' : ("api=1&player_id=" + id));

            }).then(function () { return clearInterval(poller); });
        }

        function isInView(element, offsetTop, offsetLeft) {
            if ( offsetTop === void 0 ) offsetTop = 0;
            if ( offsetLeft === void 0 ) offsetLeft = 0;


            if (!isVisible(element)) {
                return false;
            }

            return intersectRect.apply(void 0, scrollParents(element).map(function (parent) {

                var ref = offset(getViewport$1(parent));
                var top = ref.top;
                var left = ref.left;
                var bottom = ref.bottom;
                var right = ref.right;

                return {
                    top: top - offsetTop,
                    left: left - offsetLeft,
                    bottom: bottom + offsetTop,
                    right: right + offsetLeft
                };
            }).concat(offset(element)));
        }

        function scrollTop(element, top) {

            if (isWindow(element) || isDocument(element)) {
                element = getScrollingElement(element);
            } else {
                element = toNode(element);
            }

            element.scrollTop = top;
        }

        function scrollIntoView(element, ref) {
            if ( ref === void 0 ) ref = {};
            var offsetBy = ref.offset; if ( offsetBy === void 0 ) offsetBy = 0;


            var parents = isVisible(element) ? scrollParents(element) : [];
            return parents.reduce(function (fn, scrollElement, i) {

                var scrollTop = scrollElement.scrollTop;
                var scrollHeight = scrollElement.scrollHeight;
                var offsetHeight = scrollElement.offsetHeight;
                var maxScroll = scrollHeight - getViewportClientHeight(scrollElement);
                var ref = offset(parents[i - 1] || element);
                var elHeight = ref.height;
                var elTop = ref.top;

                var top = Math.ceil(
                    elTop
                    - offset(getViewport$1(scrollElement)).top
                    - offsetBy
                    + scrollTop
                );

                if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {
                    top += offsetBy;
                } else {
                    offsetBy = 0;
                }

                if (top > maxScroll) {
                    offsetBy -= top - maxScroll;
                    top = maxScroll;
                } else if (top < 0) {
                    offsetBy -= top;
                    top = 0;
                }

                return function () { return scrollTo(scrollElement, top - scrollTop).then(fn); };

            }, function () { return Promise$1.resolve(); })();

            function scrollTo(element, top) {
                return new Promise$1(function (resolve) {

                    var scroll = element.scrollTop;
                    var duration = getDuration(Math.abs(top));
                    var start = Date.now();

                    (function step() {

                        var percent = ease(clamp((Date.now() - start) / duration));

                        scrollTop(element, scroll + top * percent);

                        // scroll more if we have not reached our destination
                        if (percent !== 1) {
                            requestAnimationFrame(step);
                        } else {
                            resolve();
                        }

                    })();
                });
            }

            function getDuration(dist) {
                return 40 * Math.pow(dist, .375);
            }

            function ease(k) {
                return 0.5 * (1 - Math.cos(Math.PI * k));
            }

        }

        function scrolledOver(element, heightOffset) {
            if ( heightOffset === void 0 ) heightOffset = 0;


            if (!isVisible(element)) {
                return 0;
            }

            var ref = scrollParents(element, /auto|scroll/, true);
            var scrollElement = ref[0];
            var scrollHeight = scrollElement.scrollHeight;
            var scrollTop = scrollElement.scrollTop;
            var clientHeight = getViewportClientHeight(scrollElement);
            var viewportTop = offsetPosition(element)[0] - scrollTop - offsetPosition(scrollElement)[0];
            var viewportDist = Math.min(clientHeight, viewportTop + scrollTop);

            var top = viewportTop - viewportDist;
            var dist = Math.min(
                element.offsetHeight + heightOffset + viewportDist,
                scrollHeight - (viewportTop + scrollTop),
                scrollHeight - clientHeight
            );

            return clamp(-1 * top / dist);
        }

        function scrollParents(element, overflowRe, scrollable) {
            if ( overflowRe === void 0 ) overflowRe = /auto|scroll|hidden/;
            if ( scrollable === void 0 ) scrollable = false;

            var scrollEl = getScrollingElement(element);

            var ancestors = parents(element).reverse();
            ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);

            var fixedIndex = findIndex(ancestors, function (el) { return css(el, 'position') === 'fixed'; });
            if (~fixedIndex) {
                ancestors = ancestors.slice(fixedIndex);
            }

            return [scrollEl].concat(ancestors.filter(function (parent) { return overflowRe.test(css(parent, 'overflow')) && (!scrollable || parent.scrollHeight > getViewportClientHeight(parent)); })
            ).reverse();
        }

        function getViewport$1(scrollElement) {
            return scrollElement === getScrollingElement(scrollElement) ? window : scrollElement;
        }

        // iOS 12 returns <body> as scrollingElement
        function getViewportClientHeight(scrollElement) {
            return (scrollElement === getScrollingElement(scrollElement) ? document.documentElement : scrollElement).clientHeight;
        }

        function getScrollingElement(element) {
            var ref = toWindow(element);
            var document = ref.document;
            return document.scrollingElement || document.documentElement;
        }

        var dirs = {
            width: ['x', 'left', 'right'],
            height: ['y', 'top', 'bottom']
        };

        function positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {

            elAttach = getPos(elAttach);
            targetAttach = getPos(targetAttach);

            var flipped = {element: elAttach, target: targetAttach};

            if (!element || !target) {
                return flipped;
            }

            var dim = offset(element);
            var targetDim = offset(target);
            var position = targetDim;

            moveTo(position, elAttach, dim, -1);
            moveTo(position, targetAttach, targetDim, 1);

            elOffset = getOffsets(elOffset, dim.width, dim.height);
            targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);

            elOffset['x'] += targetOffset['x'];
            elOffset['y'] += targetOffset['y'];

            position.left += elOffset['x'];
            position.top += elOffset['y'];

            if (flip) {

                var boundaries = scrollParents(element).map(getViewport$1);

                if (boundary && !includes(boundaries, boundary)) {
                    boundaries.unshift(boundary);
                }

                boundaries = boundaries.map(function (el) { return offset(el); });

                each(dirs, function (ref, prop) {
                    var dir = ref[0];
                    var align = ref[1];
                    var alignFlip = ref[2];


                    if (!(flip === true || includes(flip, dir))) {
                        return;
                    }

                    boundaries.some(function (boundary) {

                        var elemOffset = elAttach[dir] === align
                            ? -dim[prop]
                            : elAttach[dir] === alignFlip
                                ? dim[prop]
                                : 0;

                        var targetOffset = targetAttach[dir] === align
                            ? targetDim[prop]
                            : targetAttach[dir] === alignFlip
                                ? -targetDim[prop]
                                : 0;

                        if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {

                            var centerOffset = dim[prop] / 2;
                            var centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;

                            return elAttach[dir] === 'center' && (
                                apply(centerOffset, centerTargetOffset)
                                || apply(-centerOffset, -centerTargetOffset)
                            ) || apply(elemOffset, targetOffset);

                        }

                        function apply(elemOffset, targetOffset) {

                            var newVal = toFloat((position[align] + elemOffset + targetOffset - elOffset[dir] * 2).toFixed(4));

                            if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {
                                position[align] = newVal;

                                ['element', 'target'].forEach(function (el) {
                                    flipped[el][dir] = !elemOffset
                                        ? flipped[el][dir]
                                        : flipped[el][dir] === dirs[prop][1]
                                            ? dirs[prop][2]
                                            : dirs[prop][1];
                                });

                                return true;
                            }

                        }

                    });

                });
            }

            offset(element, position);

            return flipped;
        }

        function moveTo(position, attach, dim, factor) {
            each(dirs, function (ref, prop) {
                var dir = ref[0];
                var align = ref[1];
                var alignFlip = ref[2];

                if (attach[dir] === alignFlip) {
                    position[align] += dim[prop] * factor;
                } else if (attach[dir] === 'center') {
                    position[align] += dim[prop] * factor / 2;
                }
            });
        }

        function getPos(pos) {

            var x = /left|center|right/;
            var y = /top|center|bottom/;

            pos = (pos || '').split(' ');

            if (pos.length === 1) {
                pos = x.test(pos[0])
                    ? pos.concat('center')
                    : y.test(pos[0])
                        ? ['center'].concat(pos)
                        : ['center', 'center'];
            }

            return {
                x: x.test(pos[0]) ? pos[0] : 'center',
                y: y.test(pos[1]) ? pos[1] : 'center'
            };
        }

        function getOffsets(offsets, width, height) {

            var ref = (offsets || '').split(' ');
            var x = ref[0];
            var y = ref[1];

            return {
                x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,
                y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0
            };
        }

        var util = /*#__PURE__*/Object.freeze({
            __proto__: null,
            ajax: ajax,
            getImage: getImage,
            transition: transition,
            Transition: Transition,
            animate: animate$1,
            Animation: Animation,
            attr: attr,
            hasAttr: hasAttr,
            removeAttr: removeAttr,
            data: data,
            addClass: addClass,
            removeClass: removeClass,
            removeClasses: removeClasses,
            replaceClass: replaceClass,
            hasClass: hasClass,
            toggleClass: toggleClass,
            dimensions: dimensions,
            offset: offset,
            position: position,
            offsetPosition: offsetPosition,
            height: height,
            width: width,
            boxModelAdjust: boxModelAdjust,
            flipPosition: flipPosition,
            toPx: toPx,
            ready: ready,
            empty: empty,
            html: html,
            prepend: prepend,
            append: append,
            before: before,
            after: after,
            remove: remove$1,
            wrapAll: wrapAll,
            wrapInner: wrapInner,
            unwrap: unwrap,
            fragment: fragment,
            apply: apply$1,
            $: $,
            $$: $$,
            inBrowser: inBrowser,
            isIE: isIE,
            isRtl: isRtl,
            hasTouch: hasTouch,
            pointerDown: pointerDown,
            pointerMove: pointerMove,
            pointerUp: pointerUp,
            pointerEnter: pointerEnter,
            pointerLeave: pointerLeave,
            pointerCancel: pointerCancel,
            on: on,
            off: off,
            once: once,
            trigger: trigger,
            createEvent: createEvent,
            toEventTargets: toEventTargets,
            isTouch: isTouch,
            getEventPos: getEventPos,
            fastdom: fastdom,
            isVoidElement: isVoidElement,
            isVisible: isVisible,
            selInput: selInput,
            isInput: isInput,
            selFocusable: selFocusable,
            isFocusable: isFocusable,
            parent: parent,
            filter: filter$1,
            matches: matches,
            closest: closest,
            within: within,
            parents: parents,
            children: children,
            index: index,
            hasOwn: hasOwn,
            hyphenate: hyphenate,
            camelize: camelize,
            ucfirst: ucfirst,
            startsWith: startsWith,
            endsWith: endsWith,
            includes: includes,
            findIndex: findIndex,
            isArray: isArray,
            isFunction: isFunction,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isWindow: isWindow,
            isDocument: isDocument,
            isNode: isNode,
            isElement: isElement,
            isBoolean: isBoolean,
            isString: isString,
            isNumber: isNumber,
            isNumeric: isNumeric,
            isEmpty: isEmpty,
            isUndefined: isUndefined,
            toBoolean: toBoolean,
            toNumber: toNumber,
            toFloat: toFloat,
            toArray: toArray,
            toNode: toNode,
            toNodes: toNodes,
            toWindow: toWindow,
            toMs: toMs,
            isEqual: isEqual,
            swap: swap,
            assign: assign,
            last: last,
            each: each,
            sortBy: sortBy$1,
            uniqueBy: uniqueBy,
            clamp: clamp,
            noop: noop,
            intersectRect: intersectRect,
            pointInRect: pointInRect,
            Dimensions: Dimensions,
            getIndex: getIndex,
            memoize: memoize,
            MouseTracker: MouseTracker,
            mergeOptions: mergeOptions,
            parseOptions: parseOptions,
            play: play,
            pause: pause,
            mute: mute,
            isVideo: isVideo,
            positionAt: positionAt,
            Promise: Promise$1,
            Deferred: Deferred,
            query: query,
            queryAll: queryAll,
            find: find,
            findAll: findAll,
            escape: escape,
            css: css,
            getCssVar: getCssVar,
            propName: propName,
            isInView: isInView,
            scrollTop: scrollTop,
            scrollIntoView: scrollIntoView,
            scrolledOver: scrolledOver,
            scrollParents: scrollParents,
            getViewport: getViewport$1,
            getViewportClientHeight: getViewportClientHeight
        });

        function globalAPI (UIkit) {

            var DATA = UIkit.data;

            UIkit.use = function (plugin) {

                if (plugin.installed) {
                    return;
                }

                plugin.call(null, this);
                plugin.installed = true;

                return this;
            };

            UIkit.mixin = function (mixin, component) {
                component = (isString(component) ? UIkit.component(component) : component) || this;
                component.options = mergeOptions(component.options, mixin);
            };

            UIkit.extend = function (options) {

                options = options || {};

                var Super = this;
                var Sub = function UIkitComponent(options) {
                    this._init(options);
                };

                Sub.prototype = Object.create(Super.prototype);
                Sub.prototype.constructor = Sub;
                Sub.options = mergeOptions(Super.options, options);

                Sub.super = Super;
                Sub.extend = Super.extend;

                return Sub;
            };

            UIkit.update = function (element, e) {

                element = element ? toNode(element) : document.body;

                parents(element).reverse().forEach(function (element) { return update(element[DATA], e); });
                apply$1(element, function (element) { return update(element[DATA], e); });

            };

            var container;
            Object.defineProperty(UIkit, 'container', {

                get: function() {
                    return container || document.body;
                },

                set: function(element) {
                    container = $(element);
                }

            });

            function update(data, e) {

                if (!data) {
                    return;
                }

                for (var name in data) {
                    if (data[name]._connected) {
                        data[name]._callUpdate(e);
                    }
                }

            }
        }

        function hooksAPI (UIkit) {

            UIkit.prototype._callHook = function (hook) {
                var this$1$1 = this;


                var handlers = this.$options[hook];

                if (handlers) {
                    handlers.forEach(function (handler) { return handler.call(this$1$1); });
                }
            };

            UIkit.prototype._callConnected = function () {

                if (this._connected) {
                    return;
                }

                this._data = {};
                this._computeds = {};

                this._initProps();

                this._callHook('beforeConnect');
                this._connected = true;

                this._initEvents();
                this._initObservers();

                this._callHook('connected');
                this._callUpdate();
            };

            UIkit.prototype._callDisconnected = function () {

                if (!this._connected) {
                    return;
                }

                this._callHook('beforeDisconnect');
                this._disconnectObservers();
                this._unbindEvents();
                this._callHook('disconnected');

                this._connected = false;
                delete this._watch;

            };

            UIkit.prototype._callUpdate = function (e) {
                var this$1$1 = this;
                if ( e === void 0 ) e = 'update';


                if (!this._connected) {
                    return;
                }

                if (e === 'update' || e === 'resize') {
                    this._callWatches();
                }

                if (!this.$options.update) {
                    return;
                }

                if (!this._updates) {
                    this._updates = new Set();
                    fastdom.read(function () {
                        if (this$1$1._connected) {
                            runUpdates.call(this$1$1, this$1$1._updates);
                        }
                        delete this$1$1._updates;
                    });
                }

                this._updates.add(e.type || e);
            };

            UIkit.prototype._callWatches = function () {
                var this$1$1 = this;


                if (this._watch) {
                    return;
                }

                var initial = !hasOwn(this, '_watch');

                this._watch = fastdom.read(function () {
                    if (this$1$1._connected) {
                        runWatches.call(this$1$1, initial);
                    }
                    this$1$1._watch = null;

                });

            };

            function runUpdates(types) {
                var this$1$1 = this;


                var updates = this.$options.update;

                var loop = function ( i ) {
                    var ref = updates[i];
                    var read = ref.read;
                    var write = ref.write;
                    var events = ref.events;

                    if (!types.has('update') && (!events || !events.some(function (type) { return types.has(type); }))) {
                        return;
                    }

                    var result = (void 0);
                    if (read) {

                        result = read.call(this$1$1, this$1$1._data, types);

                        if (result && isPlainObject(result)) {
                            assign(this$1$1._data, result);
                        }
                    }

                    if (write && result !== false) {
                        fastdom.write(function () { return write.call(this$1$1, this$1$1._data, types); });
                    }

                };

                for (var i = 0; i < updates.length; i++) loop( i );
            }

            function runWatches(initial) {

                var ref = this;
                var computed = ref.$options.computed;
                var _computeds = ref._computeds;

                for (var key in computed) {

                    var hasPrev = hasOwn(_computeds, key);
                    var prev = _computeds[key];

                    delete _computeds[key];

                    var ref$1 = computed[key];
                    var watch = ref$1.watch;
                    var immediate = ref$1.immediate;
                    if (watch && (
                        initial && immediate
                        || hasPrev && !isEqual(prev, this[key])
                    )) {
                        watch.call(this, this[key], prev);
                    }

                }
            }
        }

        function stateAPI (UIkit) {

            var uid = 0;

            UIkit.prototype._init = function (options) {

                options = options || {};
                options.data = normalizeData(options, this.constructor.options);

                this.$options = mergeOptions(this.constructor.options, options, this);
                this.$el = null;
                this.$props = {};

                this._uid = uid++;
                this._initData();
                this._initMethods();
                this._initComputeds();
                this._callHook('created');

                if (options.el) {
                    this.$mount(options.el);
                }
            };

            UIkit.prototype._initData = function () {

                var ref = this.$options;
                var data = ref.data; if ( data === void 0 ) data = {};

                for (var key in data) {
                    this.$props[key] = this[key] = data[key];
                }
            };

            UIkit.prototype._initMethods = function () {

                var ref = this.$options;
                var methods = ref.methods;

                if (methods) {
                    for (var key in methods) {
                        this[key] = methods[key].bind(this);
                    }
                }
            };

            UIkit.prototype._initComputeds = function () {

                var ref = this.$options;
                var computed = ref.computed;

                this._computeds = {};

                if (computed) {
                    for (var key in computed) {
                        registerComputed(this, key, computed[key]);
                    }
                }
            };

            UIkit.prototype._initProps = function (props) {

                var key;

                props = props || getProps(this.$options, this.$name);

                for (key in props) {
                    if (!isUndefined(props[key])) {
                        this.$props[key] = props[key];
                    }
                }

                var exclude = [this.$options.computed, this.$options.methods];
                for (key in this.$props) {
                    if (key in props && notIn(exclude, key)) {
                        this[key] = this.$props[key];
                    }
                }
            };

            UIkit.prototype._initEvents = function () {
                var this$1$1 = this;


                this._events = [];

                var ref = this.$options;
                var events = ref.events;

                if (events) {

                    events.forEach(function (event) {

                        if (!hasOwn(event, 'handler')) {
                            for (var key in event) {
                                registerEvent(this$1$1, event[key], key);
                            }
                        } else {
                            registerEvent(this$1$1, event);
                        }

                    });
                }
            };

            UIkit.prototype._unbindEvents = function () {
                this._events.forEach(function (unbind) { return unbind(); });
                delete this._events;
            };

            UIkit.prototype._initObservers = function () {
                this._observers = [
                    initChildListObserver(this),
                    initPropsObserver(this)
                ];
            };

            UIkit.prototype._disconnectObservers = function () {
                this._observers.forEach(function (observer) { return observer && observer.disconnect(); }
                );
            };

            function getProps(opts, name) {

                var data$1 = {};
                var args = opts.args; if ( args === void 0 ) args = [];
                var props = opts.props; if ( props === void 0 ) props = {};
                var el = opts.el;

                if (!props) {
                    return data$1;
                }

                for (var key in props) {
                    var prop = hyphenate(key);
                    var value = data(el, prop);

                    if (isUndefined(value)) {
                        continue;
                    }

                    value = props[key] === Boolean && value === ''
                        ? true
                        : coerce(props[key], value);

                    if (prop === 'target' && (!value || startsWith(value, '_'))) {
                        continue;
                    }

                    data$1[key] = value;
                }

                var options = parseOptions(data(el, name), args);

                for (var key$1 in options) {
                    var prop$1 = camelize(key$1);
                    if (props[prop$1] !== undefined) {
                        data$1[prop$1] = coerce(props[prop$1], options[key$1]);
                    }
                }

                return data$1;
            }

            function registerComputed(component, key, cb) {
                Object.defineProperty(component, key, {

                    enumerable: true,

                    get: function() {

                        var _computeds = component._computeds;
                        var $props = component.$props;
                        var $el = component.$el;

                        if (!hasOwn(_computeds, key)) {
                            _computeds[key] = (cb.get || cb).call(component, $props, $el);
                        }

                        return _computeds[key];
                    },

                    set: function(value) {

                        var _computeds = component._computeds;

                        _computeds[key] = cb.set ? cb.set.call(component, value) : value;

                        if (isUndefined(_computeds[key])) {
                            delete _computeds[key];
                        }
                    }

                });
            }

            function registerEvent(component, event, key) {

                if (!isPlainObject(event)) {
                    event = ({name: key, handler: event});
                }

                var name = event.name;
                var el = event.el;
                var handler = event.handler;
                var capture = event.capture;
                var passive = event.passive;
                var delegate = event.delegate;
                var filter = event.filter;
                var self = event.self;
                el = isFunction(el)
                    ? el.call(component)
                    : el || component.$el;

                if (isArray(el)) {
                    el.forEach(function (el) { return registerEvent(component, assign({}, event, {el: el}), key); });
                    return;
                }

                if (!el || filter && !filter.call(component)) {
                    return;
                }

                component._events.push(
                    on(
                        el,
                        name,
                        !delegate
                            ? null
                            : isString(delegate)
                                ? delegate
                                : delegate.call(component),
                        isString(handler) ? component[handler] : handler.bind(component),
                        {passive: passive, capture: capture, self: self}
                    )
                );

            }

            function notIn(options, key) {
                return options.every(function (arr) { return !arr || !hasOwn(arr, key); });
            }

            function coerce(type, value) {

                if (type === Boolean) {
                    return toBoolean(value);
                } else if (type === Number) {
                    return toNumber(value);
                } else if (type === 'list') {
                    return toList(value);
                }

                return type ? type(value) : value;
            }

            function toList(value) {
                return isArray(value)
                    ? value
                    : isString(value)
                        ? value.split(/,(?![^(]*\))/).map(function (value) { return isNumeric(value)
                            ? toNumber(value)
                            : toBoolean(value.trim()); })
                        : [value];
            }

            function normalizeData(ref, ref$1) {
                var data = ref.data;
                var args = ref$1.args;
                var props = ref$1.props; if ( props === void 0 ) props = {};

                data = isArray(data)
                    ? !isEmpty(args)
                        ? data.slice(0, args.length).reduce(function (data, value, index) {
                            if (isPlainObject(value)) {
                                assign(data, value);
                            } else {
                                data[args[index]] = value;
                            }
                            return data;
                        }, {})
                        : undefined
                    : data;

                if (data) {
                    for (var key in data) {
                        if (isUndefined(data[key])) {
                            delete data[key];
                        } else {
                            data[key] = props[key] ? coerce(props[key], data[key]) : data[key];
                        }
                    }
                }

                return data;
            }

            function initChildListObserver(component) {
                var ref = component.$options;
                var el = ref.el;

                var observer = new MutationObserver(function () { return component.$emit(); });
                observer.observe(el, {
                    childList: true,
                    subtree: true
                });

                return observer;
            }

            function initPropsObserver(component) {

                var $name = component.$name;
                var $options = component.$options;
                var $props = component.$props;
                var attrs = $options.attrs;
                var props = $options.props;
                var el = $options.el;

                if (!props || attrs === false) {
                    return;
                }

                var attributes = isArray(attrs) ? attrs : Object.keys(props);
                var filter = attributes.map(function (key) { return hyphenate(key); }).concat($name);

                var observer = new MutationObserver(function (records) {
                    var data = getProps($options, $name);
                    if (records.some(function (ref) {
                        var attributeName = ref.attributeName;

                        var prop = attributeName.replace('data-', '');
                        return (prop === $name ? attributes : [camelize(prop), camelize(attributeName)]).some(function (prop) { return !isUndefined(data[prop]) && data[prop] !== $props[prop]; }
                        );
                    })) {
                        component.$reset();
                    }
                });

                observer.observe(el, {
                    attributes: true,
                    attributeFilter: filter.concat(filter.map(function (key) { return ("data-" + key); }))
                });

                return observer;
            }
        }

        function instanceAPI (UIkit) {

            var DATA = UIkit.data;

            UIkit.prototype.$create = function (component, element, data) {
                return UIkit[component](element, data);
            };

            UIkit.prototype.$mount = function (el) {

                var ref = this.$options;
                var name = ref.name;

                if (!el[DATA]) {
                    el[DATA] = {};
                }

                if (el[DATA][name]) {
                    return;
                }

                el[DATA][name] = this;

                this.$el = this.$options.el = this.$options.el || el;

                if (within(el, document)) {
                    this._callConnected();
                }
            };

            UIkit.prototype.$reset = function () {
                this._callDisconnected();
                this._callConnected();
            };

            UIkit.prototype.$destroy = function (removeEl) {
                if ( removeEl === void 0 ) removeEl = false;


                var ref = this.$options;
                var el = ref.el;
                var name = ref.name;

                if (el) {
                    this._callDisconnected();
                }

                this._callHook('destroy');

                if (!el || !el[DATA]) {
                    return;
                }

                delete el[DATA][name];

                if (!isEmpty(el[DATA])) {
                    delete el[DATA];
                }

                if (removeEl) {
                    remove$1(this.$el);
                }
            };

            UIkit.prototype.$emit = function (e) {
                this._callUpdate(e);
            };

            UIkit.prototype.$update = function (element, e) {
                if ( element === void 0 ) element = this.$el;

                UIkit.update(element, e);
            };

            UIkit.prototype.$getComponent = UIkit.getComponent;

            var componentName = memoize(function (name) { return UIkit.prefix + hyphenate(name); });
            Object.defineProperties(UIkit.prototype, {

                $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),

                $name: {

                    get: function() {
                        return componentName(this.$options.name);
                    }

                }

            });

        }

        function componentAPI (UIkit) {

            var DATA = UIkit.data;

            var components = {};

            UIkit.component = function (name, options) {

                var id = hyphenate(name);

                name = camelize(id);

                if (!options) {

                    if (isPlainObject(components[name])) {
                        components[name] = UIkit.extend(components[name]);
                    }

                    return components[name];

                }

                UIkit[name] = function (element, data) {
                    var i = arguments.length, argsArray = Array(i);
                    while ( i-- ) argsArray[i] = arguments[i];


                    var component = UIkit.component(name);

                    return component.options.functional
                        ? new component({data: isPlainObject(element) ? element : [].concat( argsArray )})
                        : !element ? init(element) : $$(element).map(init)[0];

                    function init(element) {

                        var instance = UIkit.getComponent(element, name);

                        if (instance) {
                            if (!data) {
                                return instance;
                            } else {
                                instance.$destroy();
                            }
                        }

                        return new component({el: element, data: data});

                    }

                };

                var opt = isPlainObject(options) ? assign({}, options) : options.options;

                opt.name = name;

                if (opt.install) {
                    opt.install(UIkit, opt, name);
                }

                if (UIkit._initialized && !opt.functional) {
                    fastdom.read(function () { return UIkit[name](("[uk-" + id + "],[data-uk-" + id + "]")); });
                }

                return components[name] = isPlainObject(options) ? opt : options;
            };

            UIkit.getComponents = function (element) { return element && element[DATA] || {}; };
            UIkit.getComponent = function (element, name) { return UIkit.getComponents(element)[name]; };

            UIkit.connect = function (node) {

                if (node[DATA]) {
                    for (var name in node[DATA]) {
                        node[DATA][name]._callConnected();
                    }
                }

                for (var i = 0; i < node.attributes.length; i++) {

                    var name$1 = getComponentName(node.attributes[i].name);

                    if (name$1 && name$1 in components) {
                        UIkit[name$1](node);
                    }

                }

            };

            UIkit.disconnect = function (node) {
                for (var name in node[DATA]) {
                    node[DATA][name]._callDisconnected();
                }
            };

        }

        var getComponentName = memoize(function (attribute) {
            return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-')
                ? camelize(attribute.replace('data-uk-', '').replace('uk-', ''))
                : false;
        });

        var UIkit = function (options) {
            this._init(options);
        };

        UIkit.util = util;
        UIkit.data = '__uikit__';
        UIkit.prefix = 'uk-';
        UIkit.options = {};
        UIkit.version = '3.8.1';

        globalAPI(UIkit);
        hooksAPI(UIkit);
        stateAPI(UIkit);
        componentAPI(UIkit);
        instanceAPI(UIkit);

        function Core (UIkit) {

            if (!inBrowser) {
                return;
            }

            // throttle 'resize'
            var pendingResize;
            var handleResize = function () {
                if (pendingResize) {
                    return;
                }
                pendingResize = true;
                fastdom.write(function () { return pendingResize = false; });
                UIkit.update(null, 'resize');
            };

            on(window, 'load resize', handleResize);
            on(document, 'loadedmetadata load', handleResize, true);

            if ('ResizeObserver' in window) {
                (new ResizeObserver(handleResize)).observe(document.documentElement);
            }

            // throttle `scroll` event (Safari triggers multiple `scroll` events per frame)
            var pending;
            on(window, 'scroll', function (e) {

                if (pending) {
                    return;
                }
                pending = true;
                fastdom.write(function () { return pending = false; });

                UIkit.update(null, e.type);

            }, {passive: true, capture: true});

            var started = 0;
            on(document, 'animationstart', function (ref) {
                var target = ref.target;

                if ((css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {

                    started++;
                    css(document.documentElement, 'overflowX', 'hidden');
                    setTimeout(function () {
                        if (!--started) {
                            css(document.documentElement, 'overflowX', '');
                        }
                    }, toMs(css(target, 'animationDuration')) + 100);
                }
            }, true);

            on(document, pointerDown, function (e) {

                if (!isTouch(e)) {
                    return;
                }

                // Handle Swipe Gesture
                var pos = getEventPos(e);
                var target = 'tagName' in e.target ? e.target : parent(e.target);
                once(document, (pointerUp + " " + pointerCancel + " scroll"), function (e) {

                    var ref = getEventPos(e);
                    var x = ref.x;
                    var y = ref.y;

                    // swipe
                    if (e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {

                        setTimeout(function () {
                            trigger(target, 'swipe');
                            trigger(target, ("swipe" + (swipeDirection(pos.x, pos.y, x, y))));
                        });

                    }

                });

            }, {passive: true});

        }

        function swipeDirection(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) >= Math.abs(y1 - y2)
                ? x1 - x2 > 0
                    ? 'Left'
                    : 'Right'
                : y1 - y2 > 0
                    ? 'Up'
                    : 'Down';
        }

        function boot (UIkit) {

            var connect = UIkit.connect;
            var disconnect = UIkit.disconnect;

            if (!inBrowser || !window.MutationObserver) {
                return;
            }

            fastdom.read(function () {

                if (document.body) {
                    apply$1(document.body, connect);
                }

                new MutationObserver(function (records) { return records.forEach(applyChildListMutation); }
                ).observe(document, {
                    childList: true,
                    subtree: true
                });

                new MutationObserver(function (records) { return records.forEach(applyAttributeMutation); }
                ).observe(document, {
                    attributes: true,
                    subtree: true
                });

                UIkit._initialized = true;
            });

            function applyChildListMutation(ref) {
                var addedNodes = ref.addedNodes;
                var removedNodes = ref.removedNodes;

                for (var i = 0; i < addedNodes.length; i++) {
                    apply$1(addedNodes[i], connect);
                }

                for (var i$1 = 0; i$1 < removedNodes.length; i$1++) {
                    apply$1(removedNodes[i$1], disconnect);
                }
            }

            function applyAttributeMutation(ref) {
                var target = ref.target;
                var attributeName = ref.attributeName;


                var name = getComponentName(attributeName);

                if (!name || !(name in UIkit)) {
                    return;
                }

                if (hasAttr(target, attributeName)) {
                    UIkit[name](target);
                    return;
                }

                var component = UIkit.getComponent(target, name);

                if (component) {
                    component.$destroy();
                }

            }

        }

        var Class = {

            connected: function() {
                !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);
            }

        };

        var Togglable = {

            props: {
                cls: Boolean,
                animation: 'list',
                duration: Number,
                origin: String,
                transition: String
            },

            data: {
                cls: false,
                animation: [false],
                duration: 200,
                origin: false,
                transition: 'linear',
                clsEnter: 'uk-togglabe-enter',
                clsLeave: 'uk-togglabe-leave',

                initProps: {
                    overflow: '',
                    height: '',
                    paddingTop: '',
                    paddingBottom: '',
                    marginTop: '',
                    marginBottom: ''
                },

                hideProps: {
                    overflow: 'hidden',
                    height: 0,
                    paddingTop: 0,
                    paddingBottom: 0,
                    marginTop: 0,
                    marginBottom: 0
                }

            },

            computed: {

                hasAnimation: function(ref) {
                    var animation = ref.animation;

                    return !!animation[0];
                },

                hasTransition: function(ref) {
                    var animation = ref.animation;

                    return this.hasAnimation && animation[0] === true;
                }

            },

            methods: {

                toggleElement: function(targets, toggle, animate) {
                    var this$1$1 = this;

                    return new Promise$1(function (resolve) { return Promise$1.all(toNodes(targets).map(function (el) {

                            var show = isBoolean(toggle) ? toggle : !this$1$1.isToggled(el);

                            if (!trigger(el, ("before" + (show ? 'show' : 'hide')), [this$1$1])) {
                                return Promise$1.reject();
                            }

                            var promise = (
                                isFunction(animate)
                                    ? animate
                                    : animate === false || !this$1$1.hasAnimation
                                    ? this$1$1._toggle
                                    : this$1$1.hasTransition
                                        ? toggleHeight(this$1$1)
                                        : toggleAnimation(this$1$1)
                            )(el, show);

                            var cls = show ? this$1$1.clsEnter : this$1$1.clsLeave;

                            addClass(el, cls);

                            trigger(el, show ? 'show' : 'hide', [this$1$1]);

                            var done = function () {
                                removeClass(el, cls);
                                trigger(el, show ? 'shown' : 'hidden', [this$1$1]);
                                this$1$1.$update(el);
                            };

                            return promise ? promise.then(done, function () {
                                removeClass(el, cls);
                                return Promise$1.reject();
                            }) : done();

                        })).then(resolve, noop); }
                    );
                },

                isToggled: function(el) {
                    var assign;

                    if ( el === void 0 ) el = this.$el;
                    (assign = toNodes(el), el = assign[0]);
                    return hasClass(el, this.clsEnter)
                        ? true
                        : hasClass(el, this.clsLeave)
                            ? false
                            : this.cls
                                ? hasClass(el, this.cls.split(' ')[0])
                                : isVisible(el);
                },

                _toggle: function(el, toggled) {

                    if (!el) {
                        return;
                    }

                    toggled = Boolean(toggled);

                    var changed;
                    if (this.cls) {
                        changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);
                        changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
                    } else {
                        changed = toggled === el.hidden;
                        changed && (el.hidden = !toggled);
                    }

                    $$('[autofocus]', el).some(function (el) { return isVisible(el) ? el.focus() || true : el.blur(); });

                    if (changed) {
                        trigger(el, 'toggled', [toggled, this]);
                        this.$update(el);
                    }
                }

            }

        };

        function toggleHeight(ref) {
            var isToggled = ref.isToggled;
            var duration = ref.duration;
            var initProps = ref.initProps;
            var hideProps = ref.hideProps;
            var transition = ref.transition;
            var _toggle = ref._toggle;

            return function (el, show) {

                var inProgress = Transition.inProgress(el);
                var inner = el.hasChildNodes ? toFloat(css(el.firstElementChild, 'marginTop')) + toFloat(css(el.lastElementChild, 'marginBottom')) : 0;
                var currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;

                Transition.cancel(el);

                if (!isToggled(el)) {
                    _toggle(el, true);
                }

                height(el, '');

                // Update child components first
                fastdom.flush();

                var endHeight = height(el) + (inProgress ? 0 : inner);
                height(el, currentHeight);

                return (show
                    ? Transition.start(el, assign({}, initProps, {overflow: 'hidden', height: endHeight}), Math.round(duration * (1 - currentHeight / endHeight)), transition)
                    : Transition.start(el, hideProps, Math.round(duration * (currentHeight / endHeight)), transition).then(function () { return _toggle(el, false); })
                ).then(function () { return css(el, initProps); });

            };
        }

        function toggleAnimation(cmp) {
            return function (el, show) {

                Animation.cancel(el);

                var animation = cmp.animation;
                var duration = cmp.duration;
                var _toggle = cmp._toggle;

                if (show) {
                    _toggle(el, true);
                    return Animation.in(el, animation[0], duration, cmp.origin);
                }

                return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(function () { return _toggle(el, false); });
            };
        }

        var Accordion = {

            mixins: [Class, Togglable],

            props: {
                targets: String,
                active: null,
                collapsible: Boolean,
                multiple: Boolean,
                toggle: String,
                content: String,
                transition: String,
                offset: Number
            },

            data: {
                targets: '> *',
                active: false,
                animation: [true],
                collapsible: true,
                multiple: false,
                clsOpen: 'uk-open',
                toggle: '> .uk-accordion-title',
                content: '> .uk-accordion-content',
                transition: 'ease',
                offset: 0
            },

            computed: {

                items: {

                    get: function(ref, $el) {
                        var targets = ref.targets;

                        return $$(targets, $el);
                    },

                    watch: function(items, prev) {
                        var this$1$1 = this;


                        items.forEach(function (el) { return hide($(this$1$1.content, el), !hasClass(el, this$1$1.clsOpen)); });

                        if (prev || hasClass(items, this.clsOpen)) {
                            return;
                        }

                        var active = this.active !== false && items[Number(this.active)]
                            || !this.collapsible && items[0];

                        if (active) {
                            this.toggle(active, false);
                        }

                    },

                    immediate: true

                },

                toggles: function(ref) {
                    var toggle = ref.toggle;

                    return this.items.map(function (item) { return $(toggle, item); });
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.targets) + " " + (this.$props.toggle));
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.toggle(index(this.toggles, e.current));
                    }

                }

            ],

            methods: {

                toggle: function(item, animate) {
                    var this$1$1 = this;


                    var items = [this.items[getIndex(item, this.items)]];
                    var activeItems = filter$1(this.items, ("." + (this.clsOpen)));

                    if (!this.multiple && !includes(activeItems, items[0])) {
                        items = items.concat(activeItems);
                    }

                    if (!this.collapsible && activeItems.length < 2 && !filter$1(items, (":not(." + (this.clsOpen) + ")")).length) {
                        return;
                    }

                    items.forEach(function (el) { return this$1$1.toggleElement(el, !hasClass(el, this$1$1.clsOpen), function (el, show) {

                        toggleClass(el, this$1$1.clsOpen, show);
                        attr($(this$1$1.$props.toggle, el), 'aria-expanded', show);

                        var content = $(("" + (el._wrapper ? '> * ' : '') + (this$1$1.content)), el);

                        if (animate === false || !this$1$1.hasTransition) {
                            hide(content, !show);
                            return;
                        }

                        if (!el._wrapper) {
                            el._wrapper = wrapAll(content, ("<div" + (show ? ' hidden' : '') + ">"));
                        }

                        hide(content, false);
                        return toggleHeight(this$1$1)(el._wrapper, show).then(function () {
                            hide(content, !show);
                            delete el._wrapper;
                            unwrap(content);

                            if (show) {
                                var toggle = $(this$1$1.$props.toggle, el);
                                if (!isInView(toggle)) {
                                    scrollIntoView(toggle, {offset: this$1$1.offset});
                                }
                            }
                        });
                    }); });
                }

            }

        };

        function hide(el, hide) {
            el && (el.hidden = hide);
        }

        var alert = {

            mixins: [Class, Togglable],

            args: 'animation',

            props: {
                close: String
            },

            data: {
                animation: [true],
                selClose: '.uk-alert-close',
                duration: 150,
                hideProps: assign({opacity: 0}, Togglable.data.hideProps)
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selClose;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.close();
                    }

                }

            ],

            methods: {

                close: function() {
                    var this$1$1 = this;

                    this.toggleElement(this.$el).then(function () { return this$1$1.$destroy(true); });
                }

            }

        };

        var Video = {

            args: 'autoplay',

            props: {
                automute: Boolean,
                autoplay: Boolean
            },

            data: {
                automute: false,
                autoplay: true
            },

            computed: {

                inView: function(ref) {
                    var autoplay = ref.autoplay;

                    return autoplay === 'inview';
                }

            },

            connected: function() {

                if (this.inView && !hasAttr(this.$el, 'preload')) {
                    this.$el.preload = 'none';
                }

                if (this.automute) {
                    mute(this.$el);
                }

            },

            update: {

                read: function() {

                    if (!isVideo(this.$el)) {
                        return false;
                    }

                    return {
                        visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',
                        inView: this.inView && isInView(this.$el)
                    };
                },

                write: function(ref) {
                    var visible = ref.visible;
                    var inView = ref.inView;


                    if (!visible || this.inView && !inView) {
                        pause(this.$el);
                    } else if (this.autoplay === true || this.inView && inView) {
                        play(this.$el);
                    }

                },

                events: ['resize', 'scroll']

            }

        };

        var cover = {

            mixins: [Class, Video],

            props: {
                width: Number,
                height: Number
            },

            data: {
                automute: true
            },

            update: {

                read: function() {

                    var el = this.$el;
                    var ref = getPositionedParent(el) || parent(el);
                    var height = ref.offsetHeight;
                    var width = ref.offsetWidth;
                    var dim = Dimensions.cover(
                        {
                            width: this.width || el.naturalWidth || el.videoWidth || el.clientWidth,
                            height: this.height || el.naturalHeight || el.videoHeight || el.clientHeight
                        },
                        {
                            width: width + (width % 2 ? 1 : 0),
                            height: height + (height % 2 ? 1 : 0)
                        }
                    );

                    if (!dim.width || !dim.height) {
                        return false;
                    }

                    return dim;
                },

                write: function(ref) {
                    var height = ref.height;
                    var width = ref.width;

                    css(this.$el, {height: height, width: width});
                },

                events: ['resize']

            }

        };

        function getPositionedParent(el) {
            while ((el = parent(el))) {
                if (css(el, 'position') !== 'static') {
                    return el;
                }
            }
        }

        var Container = {

            props: {
                container: Boolean
            },

            data: {
                container: true
            },

            computed: {

                container: function(ref) {
                    var container = ref.container;

                    return container === true && this.$container || container && $(container);
                }

            }

        };

        var Position = {

            props: {
                pos: String,
                offset: null,
                flip: Boolean,
                clsPos: String
            },

            data: {
                pos: ("bottom-" + (!isRtl ? 'left' : 'right')),
                flip: true,
                offset: false,
                clsPos: ''
            },

            computed: {

                pos: function(ref) {
                    var pos = ref.pos;

                    return (pos + (!includes(pos, '-') ? '-center' : '')).split('-');
                },

                dir: function() {
                    return this.pos[0];
                },

                align: function() {
                    return this.pos[1];
                }

            },

            methods: {

                positionAt: function(element, target, boundary) {

                    removeClasses(element, ((this.clsPos) + "-(top|bottom|left|right)(-[a-z]+)?"));

                    var ref = this;
                    var offset$1 = ref.offset;
                    var axis = this.getAxis();

                    if (!isNumeric(offset$1)) {
                        var node = $(offset$1);
                        offset$1 = node
                            ? offset(node)[axis === 'x' ? 'left' : 'top'] - offset(target)[axis === 'x' ? 'right' : 'bottom']
                            : 0;
                    }

                    var ref$1 = positionAt(
                        element,
                        target,
                        axis === 'x' ? ((flipPosition(this.dir)) + " " + (this.align)) : ((this.align) + " " + (flipPosition(this.dir))),
                        axis === 'x' ? ((this.dir) + " " + (this.align)) : ((this.align) + " " + (this.dir)),
                        axis === 'x' ? ("" + (this.dir === 'left' ? -offset$1 : offset$1)) : (" " + (this.dir === 'top' ? -offset$1 : offset$1)),
                        null,
                        this.flip,
                        boundary
                    ).target;
                    var x = ref$1.x;
                    var y = ref$1.y;

                    this.dir = axis === 'x' ? x : y;
                    this.align = axis === 'x' ? y : x;

                    toggleClass(element, ((this.clsPos) + "-" + (this.dir) + "-" + (this.align)), this.offset === false);

                },

                getAxis: function() {
                    return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';
                }

            }

        };

        var active$1;

        var drop = {

            mixins: [Container, Position, Togglable],

            args: 'pos',

            props: {
                mode: 'list',
                toggle: Boolean,
                boundary: Boolean,
                boundaryAlign: Boolean,
                delayShow: Number,
                delayHide: Number,
                clsDrop: String
            },

            data: {
                mode: ['click', 'hover'],
                toggle: '- *',
                boundary: true,
                boundaryAlign: false,
                delayShow: 0,
                delayHide: 800,
                clsDrop: false,
                animation: ['uk-animation-fade'],
                cls: 'uk-open',
                container: false
            },

            computed: {

                boundary: function(ref, $el) {
                    var boundary = ref.boundary;

                    return boundary === true ? window : query(boundary, $el);
                },

                clsDrop: function(ref) {
                    var clsDrop = ref.clsDrop;

                    return clsDrop || ("uk-" + (this.$options.name));
                },

                clsPos: function() {
                    return this.clsDrop;
                }

            },

            created: function() {
                this.tracker = new MouseTracker();
            },

            connected: function() {

                addClass(this.$el, this.clsDrop);

                if (this.toggle && !this.target) {
                    this.target = this.$create('toggle', query(this.toggle, this.$el), {
                        target: this.$el,
                        mode: this.mode
                    });
                }

            },

            disconnected: function() {
                if (this.isActive()) {
                    active$1 = null;
                }
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ("." + (this.clsDrop) + "-close");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.hide(false);
                    }

                },

                {

                    name: 'click',

                    delegate: function() {
                        return 'a[href^="#"]';
                    },

                    handler: function(ref) {
                        var defaultPrevented = ref.defaultPrevented;
                        var hash = ref.current.hash;

                        if (!defaultPrevented && hash && !within(hash, this.$el)) {
                            this.hide(false);
                        }
                    }

                },

                {

                    name: 'beforescroll',

                    handler: function() {
                        this.hide(false);
                    }

                },

                {

                    name: 'toggle',

                    self: true,

                    handler: function(e, toggle) {

                        e.preventDefault();

                        if (this.isToggled()) {
                            this.hide(false);
                        } else {
                            this.show(toggle.$el, false);
                        }
                    }

                },

                {

                    name: 'toggleshow',

                    self: true,

                    handler: function(e, toggle) {
                        e.preventDefault();
                        this.show(toggle.$el);
                    }

                },

                {

                    name: 'togglehide',

                    self: true,

                    handler: function(e) {
                        e.preventDefault();
                        if (!matches(this.$el, ':focus,:hover')) {
                            this.hide();
                        }
                    }

                },

                {

                    name: (pointerEnter + " focusin"),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (!isTouch(e)) {
                            this.clearTimers();
                        }
                    }

                },

                {

                    name: (pointerLeave + " focusout"),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (!isTouch(e) && e.relatedTarget) {
                            this.hide();
                        }
                    }

                },

                {

                    name: 'toggled',

                    self: true,

                    handler: function(e, toggled) {

                        if (!toggled) {
                            return;
                        }

                        this.clearTimers();
                        this.position();
                    }

                },

                {

                    name: 'show',

                    self: true,

                    handler: function() {
                        var this$1$1 = this;


                        active$1 = this;

                        this.tracker.init();

                        once(this.$el, 'hide', on(document, pointerDown, function (ref) {
                                var target = ref.target;

                                return !within(target, this$1$1.$el) && once(document, (pointerUp + " " + pointerCancel + " scroll"), function (ref) {
                                var defaultPrevented = ref.defaultPrevented;
                                var type = ref.type;
                                var newTarget = ref.target;

                                if (!defaultPrevented && type === pointerUp && target === newTarget && !(this$1$1.target && within(target, this$1$1.target))) {
                                    this$1$1.hide(false);
                                }
                            }, true);
                        }
                        ), {self: true});

                        once(this.$el, 'hide', on(document, 'keydown', function (e) {
                            if (e.keyCode === 27) {
                                this$1$1.hide(false);
                            }
                        }), {self: true});

                    }

                },

                {

                    name: 'beforehide',

                    self: true,

                    handler: function() {
                        this.clearTimers();
                    }

                },

                {

                    name: 'hide',

                    handler: function(ref) {
                        var target = ref.target;


                        if (this.$el !== target) {
                            active$1 = active$1 === null && within(target, this.$el) && this.isToggled() ? this : active$1;
                            return;
                        }

                        active$1 = this.isActive() ? null : active$1;
                        this.tracker.cancel();
                    }

                }

            ],

            update: {

                write: function() {

                    if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {
                        this.position();
                    }

                },

                events: ['resize']

            },

            methods: {

                show: function(target, delay) {
                    var this$1$1 = this;
                    if ( target === void 0 ) target = this.target;
                    if ( delay === void 0 ) delay = true;


                    if (this.isToggled() && target && this.target && target !== this.target) {
                        this.hide(false);
                    }

                    this.target = target;

                    this.clearTimers();

                    if (this.isActive()) {
                        return;
                    }

                    if (active$1) {

                        if (delay && active$1.isDelaying) {
                            this.showTimer = setTimeout(this.show, 10);
                            return;
                        }

                        var prev;
                        while (active$1 && prev !== active$1 && !within(this.$el, active$1.$el)) {
                            prev = active$1;
                            active$1.hide(false);
                        }

                    }

                    if (this.container && parent(this.$el) !== this.container) {
                        append(this.container, this.$el);
                    }

                    this.showTimer = setTimeout(function () { return this$1$1.toggleElement(this$1$1.$el, true); }, delay && this.delayShow || 0);

                },

                hide: function(delay) {
                    var this$1$1 = this;
                    if ( delay === void 0 ) delay = true;


                    var hide = function () { return this$1$1.toggleElement(this$1$1.$el, false, false); };

                    this.clearTimers();

                    this.isDelaying = getPositionedElements(this.$el).some(function (el) { return this$1$1.tracker.movesTo(el); });

                    if (delay && this.isDelaying) {
                        this.hideTimer = setTimeout(this.hide, 50);
                    } else if (delay && this.delayHide) {
                        this.hideTimer = setTimeout(hide, this.delayHide);
                    } else {
                        hide();
                    }
                },

                clearTimers: function() {
                    clearTimeout(this.showTimer);
                    clearTimeout(this.hideTimer);
                    this.showTimer = null;
                    this.hideTimer = null;
                    this.isDelaying = false;
                },

                isActive: function() {
                    return active$1 === this;
                },

                position: function() {

                    removeClass(this.$el, ((this.clsDrop) + "-stack"));
                    toggleClass(this.$el, ((this.clsDrop) + "-boundary"), this.boundaryAlign);

                    var boundary = offset(this.boundary);
                    var alignTo = this.boundaryAlign ? boundary : offset(this.target);

                    if (this.align === 'justify') {
                        var prop = this.getAxis() === 'y' ? 'width' : 'height';
                        css(this.$el, prop, alignTo[prop]);
                    } else if (this.boundary && this.$el.offsetWidth > Math.max(boundary.right - alignTo.left, alignTo.right - boundary.left)) {
                        addClass(this.$el, ((this.clsDrop) + "-stack"));
                    }

                    this.positionAt(this.$el, this.boundaryAlign ? this.boundary : this.target, this.boundary);

                }

            }

        };

        function getPositionedElements(el) {
            var result = [];
            apply$1(el, function (el) { return css(el, 'position') !== 'static' && result.push(el); });
            return result;
        }

        var formCustom = {

            mixins: [Class],

            args: 'target',

            props: {
                target: Boolean
            },

            data: {
                target: false
            },

            computed: {

                input: function(_, $el) {
                    return $(selInput, $el);
                },

                state: function() {
                    return this.input.nextElementSibling;
                },

                target: function(ref, $el) {
                    var target = ref.target;

                    return target && (target === true
                        && parent(this.input) === $el
                        && this.input.nextElementSibling
                        || query(target, $el));
                }

            },

            update: function() {

                var ref = this;
                var target = ref.target;
                var input = ref.input;

                if (!target) {
                    return;
                }

                var option;
                var prop = isInput(target) ? 'value' : 'textContent';
                var prev = target[prop];
                var value = input.files && input.files[0]
                    ? input.files[0].name
                    : matches(input, 'select') && (option = $$('option', input).filter(function (el) { return el.selected; })[0]) // eslint-disable-line prefer-destructuring
                        ? option.textContent
                        : input.value;

                if (prev !== value) {
                    target[prop] = value;
                }

            },

            events: [

                {
                    name: 'change',

                    handler: function() {
                        this.$update();
                    }
                },

                {
                    name: 'reset',

                    el: function() {
                        return closest(this.$el, 'form');
                    },

                    handler: function() {
                        this.$update();
                    }
                }

            ]

        };

        // Deprecated
        var gif = {

            update: {

                read: function(data) {

                    var inview = isInView(this.$el);

                    if (!inview || data.isInView === inview) {
                        return false;
                    }

                    data.isInView = inview;
                },

                write: function() {
                    this.$el.src = '' + this.$el.src; // force self-assign
                },

                events: ['scroll', 'resize']
            }

        };

        var Margin = {

            props: {
                margin: String,
                firstColumn: Boolean
            },

            data: {
                margin: 'uk-margin-small-top',
                firstColumn: 'uk-first-column'
            },

            update: {

                read: function() {

                    var rows = getRows(this.$el.children);

                    return {
                        rows: rows,
                        columns: getColumns(rows)
                    };
                },

                write: function(ref) {
                    var columns = ref.columns;
                    var rows = ref.rows;

                    for (var i = 0; i < rows.length; i++) {
                        for (var j = 0; j < rows[i].length; j++) {
                            toggleClass(rows[i][j], this.margin, i !== 0);
                            toggleClass(rows[i][j], this.firstColumn, !!~columns[0].indexOf(rows[i][j]));
                        }
                    }
                },

                events: ['resize']

            }

        };

        function getRows(items) {
            return sortBy(items, 'top', 'bottom');
        }

        function getColumns(rows) {

            var columns = [];

            for (var i = 0; i < rows.length; i++) {
                var sorted = sortBy(rows[i], 'left', 'right');
                for (var j = 0; j < sorted.length; j++) {
                    columns[j] = !columns[j] ? sorted[j] : columns[j].concat(sorted[j]);
                }
            }

            return isRtl
                ? columns.reverse()
                : columns;
        }

        function sortBy(items, startProp, endProp) {

            var sorted = [[]];

            for (var i = 0; i < items.length; i++) {

                var el = items[i];

                if (!isVisible(el)) {
                    continue;
                }

                var dim = getOffset(el);

                for (var j = sorted.length - 1; j >= 0; j--) {

                    var current = sorted[j];

                    if (!current[0]) {
                        current.push(el);
                        break;
                    }

                    var startDim = (void 0);
                    if (current[0].offsetParent === el.offsetParent) {
                        startDim = getOffset(current[0]);
                    } else {
                        dim = getOffset(el, true);
                        startDim = getOffset(current[0], true);
                    }

                    if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {
                        sorted.push([el]);
                        break;
                    }

                    if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {
                        current.push(el);
                        break;
                    }

                    if (j === 0) {
                        sorted.unshift([el]);
                        break;
                    }

                }

            }

            return sorted;
        }

        function getOffset(element, offset) {
            var assign;

            if ( offset === void 0 ) offset = false;

            var offsetTop = element.offsetTop;
            var offsetLeft = element.offsetLeft;
            var offsetHeight = element.offsetHeight;
            var offsetWidth = element.offsetWidth;

            if (offset) {
                (assign = offsetPosition(element), offsetTop = assign[0], offsetLeft = assign[1]);
            }

            return {
                top: offsetTop,
                left: offsetLeft,
                bottom: offsetTop + offsetHeight,
                right: offsetLeft + offsetWidth
            };
        }

        var grid = {

            extends: Margin,

            mixins: [Class],

            name: 'grid',

            props: {
                masonry: Boolean,
                parallax: Number
            },

            data: {
                margin: 'uk-grid-margin',
                clsStack: 'uk-grid-stack',
                masonry: false,
                parallax: 0
            },

            connected: function() {
                this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');
            },

            update: [

                {

                    write: function(ref) {
                        var columns = ref.columns;

                        toggleClass(this.$el, this.clsStack, columns.length < 2);
                    },

                    events: ['resize']

                },

                {

                    read: function(data) {

                        var columns = data.columns;
                        var rows = data.rows;

                        // Filter component makes elements positioned absolute
                        if (!columns.length || !this.masonry && !this.parallax || positionedAbsolute(this.$el)) {
                            data.translates = false;
                            return false;
                        }

                        var translates = false;

                        var nodes = children(this.$el);
                        var columnHeights = getColumnHeights(columns);
                        var margin = getMarginTop(nodes, this.margin) * (rows.length - 1);
                        var elHeight = Math.max.apply(Math, columnHeights) + margin;

                        if (this.masonry) {
                            columns = columns.map(function (column) { return sortBy$1(column, 'offsetTop'); });
                            translates = getTranslates(rows, columns);
                        }

                        var padding = Math.abs(this.parallax);
                        if (padding) {
                            padding = columnHeights.reduce(function (newPadding, hgt, i) { return Math.max(newPadding, hgt + margin + (i % 2 ? padding : padding / 8) - elHeight); }
                                , 0);
                        }

                        return {padding: padding, columns: columns, translates: translates, height: translates ? elHeight : ''};

                    },

                    write: function(ref) {
                        var height = ref.height;
                        var padding = ref.padding;


                        css(this.$el, 'paddingBottom', padding || '');
                        height !== false && css(this.$el, 'height', height);

                    },

                    events: ['resize']

                },

                {

                    read: function(ref) {
                        var height$1 = ref.height;


                        if (positionedAbsolute(this.$el)) {
                            return false;
                        }

                        return {
                            scrolled: this.parallax
                                ? scrolledOver(this.$el, height$1 ? height$1 - height(this.$el) : 0) * Math.abs(this.parallax)
                                : false
                        };
                    },

                    write: function(ref) {
                        var columns = ref.columns;
                        var scrolled = ref.scrolled;
                        var translates = ref.translates;


                        if (scrolled === false && !translates) {
                            return;
                        }

                        columns.forEach(function (column, i) { return column.forEach(function (el, j) { return css(el, 'transform', !scrolled && !translates ? '' : ("translateY(" + ((translates && -translates[i][j]) + (scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)) + "px)")); }
                            ); }
                        );

                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        function positionedAbsolute(el) {
            return children(el).some(function (el) { return css(el, 'position') === 'absolute'; });
        }

        function getTranslates(rows, columns) {

            var rowHeights = rows.map(function (row) { return Math.max.apply(Math, row.map(function (el) { return el.offsetHeight; })); }
            );

            return columns.map(function (elements) {
                var prev = 0;
                return elements.map(function (element, row) { return prev += row
                        ? rowHeights[row - 1] - elements[row - 1].offsetHeight
                        : 0; }
                );
            });
        }

        function getMarginTop(nodes, cls) {

            var ref = nodes.filter(function (el) { return hasClass(el, cls); });
            var node = ref[0];

            return toFloat(node
                ? css(node, 'marginTop')
                : css(nodes[0], 'paddingLeft'));
        }

        function getColumnHeights(columns) {
            return columns.map(function (column) { return column.reduce(function (sum, el) { return sum + el.offsetHeight; }, 0); }
            );
        }

        // IE 11 fix (min-height on a flex container won't apply to its flex items)
        var FlexBug = isIE ? {

            props: {
                selMinHeight: String
            },

            data: {
                selMinHeight: false,
                forceHeight: false
            },

            computed: {

                elements: function(ref, $el) {
                    var selMinHeight = ref.selMinHeight;

                    return selMinHeight ? $$(selMinHeight, $el) : [$el];
                }

            },

            update: [

                {

                    read: function() {
                        css(this.elements, 'height', '');
                    },

                    order: -5,

                    events: ['resize']

                },

                {

                    write: function() {
                        var this$1$1 = this;

                        this.elements.forEach(function (el) {
                            var height = toFloat(css(el, 'minHeight'));
                            if (height && (this$1$1.forceHeight || Math.round(height + boxModelAdjust(el, 'height', 'content-box')) >= el.offsetHeight)) {
                                css(el, 'height', height);
                            }
                        });
                    },

                    order: 5,

                    events: ['resize']

                }

            ]

        } : {};

        var heightMatch = {

            mixins: [FlexBug],

            args: 'target',

            props: {
                target: String,
                row: Boolean
            },

            data: {
                target: '> *',
                row: true,
                forceHeight: true
            },

            computed: {

                elements: function(ref, $el) {
                    var target = ref.target;

                    return $$(target, $el);
                }

            },

            update: {

                read: function() {
                    return {
                        rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1)
                    };
                },

                write: function(ref) {
                    var rows = ref.rows;

                    rows.forEach(function (ref) {
                            var heights = ref.heights;
                            var elements = ref.elements;

                            return elements.forEach(function (el, i) { return css(el, 'minHeight', heights[i]); }
                        );
                    }
                    );
                },

                events: ['resize']

            }

        };

        function match$1(elements) {

            if (elements.length < 2) {
                return {heights: [''], elements: elements};
            }

            var heights = elements.map(getHeight);
            var max = Math.max.apply(Math, heights);
            var hasMinHeight = elements.some(function (el) { return el.style.minHeight; });
            var hasShrunk = elements.some(function (el, i) { return !el.style.minHeight && heights[i] < max; });

            if (hasMinHeight && hasShrunk) {
                css(elements, 'minHeight', '');
                heights = elements.map(getHeight);
                max = Math.max.apply(Math, heights);
            }

            heights = elements.map(function (el, i) { return heights[i] === max && toFloat(el.style.minHeight).toFixed(2) !== max.toFixed(2) ? '' : max; }
            );

            return {heights: heights, elements: elements};
        }

        function getHeight(element) {

            var style = false;
            if (!isVisible(element)) {
                style = element.style.display;
                css(element, 'display', 'block', 'important');
            }

            var height = dimensions(element).height - boxModelAdjust(element, 'height', 'content-box');

            if (style !== false) {
                css(element, 'display', style);
            }

            return height;
        }

        var heightViewport = {

            mixins: [FlexBug],

            props: {
                expand: Boolean,
                offsetTop: Boolean,
                offsetBottom: Boolean,
                minHeight: Number
            },

            data: {
                expand: false,
                offsetTop: false,
                offsetBottom: false,
                minHeight: 0
            },

            update: {

                read: function(ref) {
                    var prev = ref.minHeight;


                    if (!isVisible(this.$el)) {
                        return false;
                    }

                    var minHeight = '';
                    var box = boxModelAdjust(this.$el, 'height', 'content-box');

                    if (this.expand) {

                        minHeight = height(window) - (dimensions(document.documentElement).height - dimensions(this.$el).height) - box || '';

                    } else {

                        // on mobile devices (iOS and Android) window.innerHeight !== 100vh
                        minHeight = 'calc(100vh';

                        if (this.offsetTop) {

                            var ref$1 = offset(this.$el);
                            var top = ref$1.top;
                            minHeight += top > 0 && top < height(window) / 2 ? (" - " + top + "px") : '';

                        }

                        if (this.offsetBottom === true) {

                            minHeight += " - " + (dimensions(this.$el.nextElementSibling).height) + "px";

                        } else if (isNumeric(this.offsetBottom)) {

                            minHeight += " - " + (this.offsetBottom) + "vh";

                        } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {

                            minHeight += " - " + (toFloat(this.offsetBottom)) + "px";

                        } else if (isString(this.offsetBottom)) {

                            minHeight += " - " + (dimensions(query(this.offsetBottom, this.$el)).height) + "px";

                        }

                        minHeight += (box ? (" - " + box + "px") : '') + ")";

                    }

                    return {minHeight: minHeight, prev: prev};
                },

                write: function(ref) {
                    var minHeight = ref.minHeight;
                    var prev = ref.prev;


                    css(this.$el, {minHeight: minHeight});

                    if (minHeight !== prev) {
                        this.$update(this.$el, 'resize');
                    }

                    if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {
                        css(this.$el, 'minHeight', this.minHeight);
                    }

                },

                events: ['resize']

            }

        };

        var SVG = {

            args: 'src',

            props: {
                id: Boolean,
                icon: String,
                src: String,
                style: String,
                width: Number,
                height: Number,
                ratio: Number,
                class: String,
                strokeAnimation: Boolean,
                focusable: Boolean, // IE 11
                attributes: 'list'
            },

            data: {
                ratio: 1,
                include: ['style', 'class', 'focusable'],
                class: '',
                strokeAnimation: false
            },

            beforeConnect: function() {
                this.class += ' uk-svg';
            },

            connected: function() {
                var this$1$1 = this;
                var assign;


                if (!this.icon && includes(this.src, '#')) {
                    (assign = this.src.split('#'), this.src = assign[0], this.icon = assign[1]);
                }

                this.svg = this.getSvg().then(function (el) {

                    if (this$1$1._connected) {

                        var svg = insertSVG(el, this$1$1.$el);

                        if (this$1$1.svgEl && svg !== this$1$1.svgEl) {
                            remove$1(this$1$1.svgEl);
                        }

                        this$1$1.applyAttributes(svg, el);
                        this$1$1.$emit();
                        return this$1$1.svgEl = svg;
                    }

                }, noop);

            },

            disconnected: function() {
                var this$1$1 = this;


                this.svg.then(function (svg) {
                    if (!this$1$1._connected) {

                        if (isVoidElement(this$1$1.$el)) {
                            this$1$1.$el.hidden = false;
                        }

                        remove$1(svg);
                        this$1$1.svgEl = null;
                    }
                });

                this.svg = null;

            },

            update: {

                read: function() {
                    return !!(this.strokeAnimation && this.svgEl && isVisible(this.svgEl));
                },

                write: function() {
                    applyAnimation(this.svgEl);
                },

                type: ['resize']

            },

            methods: {

                getSvg: function() {
                    var this$1$1 = this;

                    return loadSVG(this.src).then(function (svg) { return parseSVG(svg, this$1$1.icon) || Promise$1.reject('SVG not found.'); }
                    );
                },

                applyAttributes: function(el, ref) {
                    var this$1$1 = this;


                    for (var prop in this.$options.props) {
                        if (includes(this.include, prop) && (prop in this)) {
                            attr(el, prop, this[prop]);
                        }
                    }

                    for (var attribute in this.attributes) {
                        var ref$1 = this.attributes[attribute].split(':', 2);
                        var prop$1 = ref$1[0];
                        var value = ref$1[1];
                        attr(el, prop$1, value);
                    }

                    if (!this.id) {
                        removeAttr(el, 'id');
                    }

                    var props = ['width', 'height'];
                    var dimensions = props.map(function (prop) { return this$1$1[prop]; });

                    if (!dimensions.some(function (val) { return val; })) {
                        dimensions = props.map(function (prop) { return attr(ref, prop); });
                    }

                    var viewBox = attr(ref, 'viewBox');
                    if (viewBox && !dimensions.some(function (val) { return val; })) {
                        dimensions = viewBox.split(' ').slice(2);
                    }

                    dimensions.forEach(function (val, i) { return attr(el, props[i], toFloat(val) * this$1$1.ratio || null); }
                    );

                }

            }

        };

        var loadSVG = memoize(function (src) { return new Promise$1(function (resolve, reject) {

                if (!src) {
                    reject();
                    return;
                }

                if (startsWith(src, 'data:')) {
                    resolve(decodeURIComponent(src.split(',')[1]));
                } else {

                    ajax(src).then(
                        function (xhr) { return resolve(xhr.response); },
                        function () { return reject('SVG not found.'); }
                    );

                }
            }); }
        );

        function parseSVG(svg, icon) {

            if (icon && includes(svg, '<symbol')) {
                svg = parseSymbols(svg, icon) || svg;
            }

            svg = $(svg.substr(svg.indexOf('<svg')));
            return svg && svg.hasChildNodes() && svg;
        }

        var symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
        var symbols = {};

        function parseSymbols(svg, icon) {

            if (!symbols[svg]) {

                symbols[svg] = {};

                symbolRe.lastIndex = 0;

                var match;
                while ((match = symbolRe.exec(svg))) {
                    symbols[svg][match[3]] = "<svg xmlns=\"http://www.w3.org/2000/svg\"" + (match[1]) + "svg>";
                }

            }

            return symbols[svg][icon];
        }

        function applyAnimation(el) {

            var length = getMaxPathLength(el);

            if (length) {
                el.style.setProperty('--uk-animation-stroke', length);
            }

        }

        function getMaxPathLength(el) {
            return Math.ceil(Math.max.apply(Math, [ 0 ].concat( $$('[stroke]', el).map(function (stroke) {
                try {
                    return stroke.getTotalLength();
                } catch (e) {
                    return 0;
                }
            }) )));
        }

        function insertSVG(el, root) {

            if (isVoidElement(root) || root.tagName === 'CANVAS') {

                root.hidden = true;

                var next = root.nextElementSibling;
                return equals(el, next)
                    ? next
                    : after(root, el);

            }

            var last = root.lastElementChild;
            return equals(el, last)
                ? last
                : append(root, el);
        }

        function equals(el, other) {
            return isSVG(el) && isSVG(other) && innerHTML(el) === innerHTML(other);
        }

        function isSVG(el) {
            return el && el.tagName === 'svg';
        }

        function innerHTML(el) {
            return (el.innerHTML || (new XMLSerializer()).serializeToString(el).replace(/<svg.*?>(.*?)<\/svg>/g, '$1')).replace(/\s/g, '');
        }

        var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

        var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

        var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";

        var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"9\" width=\"20\" height=\"2\"/><rect y=\"3\" width=\"20\" height=\"2\"/><rect y=\"15\" width=\"20\" height=\"2\"/></svg>";

        var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";

        var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

        var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

        var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

        var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

        var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

        var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1 \"/></svg>";

        var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5 \"/></svg>";

        var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23 \"/></svg>";

        var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547 \"/></svg>";

        var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

        var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9 \"/></svg>";

        var icons = {
            spinner: spinner,
            totop: totop,
            marker: marker,
            'close-icon': closeIcon,
            'close-large': closeLarge,
            'navbar-toggle-icon': navbarToggleIcon,
            'overlay-icon': overlayIcon,
            'pagination-next': paginationNext,
            'pagination-previous': paginationPrevious,
            'search-icon': searchIcon,
            'search-large': searchLarge,
            'search-navbar': searchNavbar,
            'slidenav-next': slidenavNext,
            'slidenav-next-large': slidenavNextLarge,
            'slidenav-previous': slidenavPrevious,
            'slidenav-previous-large': slidenavPreviousLarge
        };

        var Icon = {

            install: install$3,

            extends: SVG,

            args: 'icon',

            props: ['icon'],

            data: {
                include: ['focusable']
            },

            isIcon: true,

            beforeConnect: function() {
                addClass(this.$el, 'uk-icon');
            },

            methods: {

                getSvg: function() {

                    var icon = getIcon(this.icon);

                    if (!icon) {
                        return Promise$1.reject('Icon not found.');
                    }

                    return Promise$1.resolve(icon);
                }

            }

        };

        var IconComponent = {

            args: false,

            extends: Icon,

            data: function (vm) { return ({
                icon: hyphenate(vm.constructor.options.name)
            }); },

            beforeConnect: function() {
                addClass(this.$el, this.$name);
            }

        };

        var Slidenav = {

            extends: IconComponent,

            beforeConnect: function() {
                addClass(this.$el, 'uk-slidenav');
            },

            computed: {

                icon: function(ref, $el) {
                    var icon = ref.icon;

                    return hasClass($el, 'uk-slidenav-large')
                        ? (icon + "-large")
                        : icon;
                }

            }

        };

        var Search = {

            extends: IconComponent,

            computed: {

                icon: function(ref, $el) {
                    var icon = ref.icon;

                    return hasClass($el, 'uk-search-icon') && parents($el, '.uk-search-large').length
                        ? 'search-large'
                        : parents($el, '.uk-search-navbar').length
                            ? 'search-navbar'
                            : icon;
                }

            }

        };

        var Close = {

            extends: IconComponent,

            computed: {

                icon: function() {
                    return ("close-" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon'));
                }

            }

        };

        var Spinner = {

            extends: IconComponent,

            connected: function() {
                var this$1$1 = this;

                this.svg.then(function (svg) { return svg && this$1$1.ratio !== 1 && css($('circle', svg), 'strokeWidth', 1 / this$1$1.ratio); });
            }

        };

        var parsed = {};
        function install$3(UIkit) {
            UIkit.icon.add = function (name, svg) {
                var obj;


                var added = isString(name) ? (( obj = {}, obj[name] = svg, obj )) : name;
                each(added, function (svg, name) {
                    icons[name] = svg;
                    delete parsed[name];
                });

                if (UIkit._initialized) {
                    apply$1(document.body, function (el) { return each(UIkit.getComponents(el), function (cmp) {
                            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
                        }); }
                    );
                }
            };
        }

        function getIcon(icon) {

            if (!icons[icon]) {
                return null;
            }

            if (!parsed[icon]) {
                parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());
            }

            return parsed[icon].cloneNode(true);
        }

        function applyRtl(icon) {
            return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;
        }

        var img = {

            args: 'dataSrc',

            props: {
                dataSrc: String,
                dataSrcset: Boolean,
                sizes: String,
                width: Number,
                height: Number,
                offsetTop: String,
                offsetLeft: String,
                target: String
            },

            data: {
                dataSrc: '',
                dataSrcset: false,
                sizes: false,
                width: false,
                height: false,
                offsetTop: '50vh',
                offsetLeft: '50vw',
                target: false
            },

            computed: {

                cacheKey: function(ref) {
                    var dataSrc = ref.dataSrc;

                    return ((this.$name) + "." + dataSrc);
                },

                width: function(ref) {
                    var width = ref.width;
                    var dataWidth = ref.dataWidth;

                    return width || dataWidth;
                },

                height: function(ref) {
                    var height = ref.height;
                    var dataHeight = ref.dataHeight;

                    return height || dataHeight;
                },

                sizes: function(ref) {
                    var sizes = ref.sizes;
                    var dataSizes = ref.dataSizes;

                    return sizes || dataSizes;
                },

                isImg: function(_, $el) {
                    return isImg($el);
                },

                target: {

                    get: function(ref) {
                        var target = ref.target;

                        return [this.$el ].concat( queryAll(target, this.$el));
                    },

                    watch: function() {
                        this.observe();
                    }

                },

                offsetTop: function(ref) {
                    var offsetTop = ref.offsetTop;

                    return toPx(offsetTop, 'height');
                },

                offsetLeft: function(ref) {
                    var offsetLeft = ref.offsetLeft;

                    return toPx(offsetLeft, 'width');
                }

            },

            connected: function() {

                if (!window.IntersectionObserver) {
                    setSrcAttrs(this.$el, this.dataSrc, this.dataSrcset, this.sizes);
                    return;
                }

                if (storage[this.cacheKey]) {
                    setSrcAttrs(this.$el, storage[this.cacheKey], this.dataSrcset, this.sizes);
                } else if (this.isImg && this.width && this.height) {
                    setSrcAttrs(this.$el, getPlaceholderImage(this.width, this.height, this.sizes));
                }

                this.observer = new IntersectionObserver(this.load, {
                    rootMargin: ((this.offsetTop) + "px " + (this.offsetLeft) + "px")
                });

                requestAnimationFrame(this.observe);

            },

            disconnected: function() {
                this.observer && this.observer.disconnect();
            },

            update: {

                read: function(ref) {
                    var this$1$1 = this;
                    var image = ref.image;


                    if (!this.observer) {
                        return false;
                    }

                    if (!image && document.readyState === 'complete') {
                        this.load(this.observer.takeRecords());
                    }

                    if (this.isImg) {
                        return false;
                    }

                    image && image.then(function (img) { return img && img.currentSrc !== '' && setSrcAttrs(this$1$1.$el, currentSrc(img)); });

                },

                write: function(data) {

                    if (this.dataSrcset && window.devicePixelRatio !== 1) {

                        var bgSize = css(this.$el, 'backgroundSize');
                        if (bgSize.match(/^(auto\s?)+$/) || toFloat(bgSize) === data.bgSize) {
                            data.bgSize = getSourceSize(this.dataSrcset, this.sizes);
                            css(this.$el, 'backgroundSize', ((data.bgSize) + "px"));
                        }

                    }

                },

                events: ['resize']

            },

            methods: {

                load: function(entries) {
                    var this$1$1 = this;


                    // Old chromium based browsers (UC Browser) did not implement `isIntersecting`
                    if (!entries.some(function (entry) { return isUndefined(entry.isIntersecting) || entry.isIntersecting; })) {
                        return;
                    }

                    this._data.image = getImage(this.dataSrc, this.dataSrcset, this.sizes).then(function (img) {

                        setSrcAttrs(this$1$1.$el, currentSrc(img), img.srcset, img.sizes);
                        storage[this$1$1.cacheKey] = currentSrc(img);
                        return img;

                    }, function (e) { return trigger(this$1$1.$el, new e.constructor(e.type, e)); });

                    this.observer.disconnect();
                },

                observe: function() {
                    var this$1$1 = this;

                    if (this._connected && !this._data.image) {
                        this.target.forEach(function (el) { return this$1$1.observer.observe(el); });
                    }
                }

            }

        };

        function setSrcAttrs(el, src, srcset, sizes) {

            if (isImg(el)) {
                var set = function (prop, val) { return val && val !== el[prop] && (el[prop] = val); };
                set('sizes', sizes);
                set('srcset', srcset);
                set('src', src);
            } else if (src) {

                var change = !includes(el.style.backgroundImage, src);
                if (change) {
                    css(el, 'backgroundImage', ("url(" + (escape(src)) + ")"));
                    trigger(el, createEvent('load', false));
                }

            }

        }

        function getPlaceholderImage(width, height, sizes) {
            var assign;


            if (sizes) {
                ((assign = Dimensions.ratio({width: width, height: height}, 'width', toPx(sizesToPixel(sizes))), width = assign.width, height = assign.height));
            }

            return ("data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + width + "\" height=\"" + height + "\"></svg>");
        }

        var sizesRe = /\s*(.*?)\s*(\w+|calc\(.*?\))\s*(?:,|$)/g;
        function sizesToPixel(sizes) {
            var matches;

            sizesRe.lastIndex = 0;

            while ((matches = sizesRe.exec(sizes))) {
                if (!matches[1] || window.matchMedia(matches[1]).matches) {
                    matches = evaluateSize(matches[2]);
                    break;
                }
            }

            return matches || '100vw';
        }

        var sizeRe = /\d+(?:\w+|%)/g;
        var additionRe = /[+-]?(\d+)/g;
        function evaluateSize(size) {
            return startsWith(size, 'calc')
                ? size
                    .slice(5, -1)
                    .replace(sizeRe, function (size) { return toPx(size); })
                    .replace(/ /g, '')
                    .match(additionRe)
                    .reduce(function (a, b) { return a + +b; }, 0)
                : size;
        }

        var srcSetRe = /\s+\d+w\s*(?:,|$)/g;
        function getSourceSize(srcset, sizes) {
            var srcSize = toPx(sizesToPixel(sizes));
            var descriptors = (srcset.match(srcSetRe) || []).map(toFloat).sort(function (a, b) { return a - b; });

            return descriptors.filter(function (size) { return size >= srcSize; })[0] || descriptors.pop() || '';
        }

        function isImg(el) {
            return el.tagName === 'IMG';
        }

        function currentSrc(el) {
            return el.currentSrc || el.src;
        }

        var key = '__test__';
        var storage;

        // workaround for Safari's private browsing mode and accessing sessionStorage in Blink
        try {
            storage = window.sessionStorage || {};
            storage[key] = 1;
            delete storage[key];
        } catch (e) {
            storage = {};
        }

        var Media = {

            props: {
                media: Boolean
            },

            data: {
                media: false
            },

            computed: {

                matchMedia: function() {
                    var media = toMedia(this.media);
                    return !media || window.matchMedia(media).matches;
                }

            }

        };

        function toMedia(value) {

            if (isString(value)) {
                if (value[0] === '@') {
                    var name = "breakpoint-" + (value.substr(1));
                    value = toFloat(getCssVar(name));
                } else if (isNaN(value)) {
                    return value;
                }
            }

            return value && !isNaN(value) ? ("(min-width: " + value + "px)") : false;
        }

        var leader = {

            mixins: [Class, Media],

            props: {
                fill: String
            },

            data: {
                fill: '',
                clsWrapper: 'uk-leader-fill',
                clsHide: 'uk-leader-hide',
                attrFill: 'data-fill'
            },

            computed: {

                fill: function(ref) {
                    var fill = ref.fill;

                    return fill || getCssVar('leader-fill-content');
                }

            },

            connected: function() {
                var assign;

                (assign = wrapInner(this.$el, ("<span class=\"" + (this.clsWrapper) + "\">")), this.wrapper = assign[0]);
            },

            disconnected: function() {
                unwrap(this.wrapper.childNodes);
            },

            update: {

                read: function(ref) {
                    var changed = ref.changed;
                    var width = ref.width;


                    var prev = width;

                    width = Math.floor(this.$el.offsetWidth / 2);

                    return {
                        width: width,
                        fill: this.fill,
                        changed: changed || prev !== width,
                        hide: !this.matchMedia
                    };
                },

                write: function(data) {

                    toggleClass(this.wrapper, this.clsHide, data.hide);

                    if (data.changed) {
                        data.changed = false;
                        attr(this.wrapper, this.attrFill, new Array(data.width).join(data.fill));
                    }

                },

                events: ['resize']

            }

        };

        var active = [];

        var Modal = {

            mixins: [Class, Container, Togglable],

            props: {
                selPanel: String,
                selClose: String,
                escClose: Boolean,
                bgClose: Boolean,
                stack: Boolean
            },

            data: {
                cls: 'uk-open',
                escClose: true,
                bgClose: true,
                overlay: true,
                stack: false
            },

            computed: {

                panel: function(ref, $el) {
                    var selPanel = ref.selPanel;

                    return $(selPanel, $el);
                },

                transitionElement: function() {
                    return this.panel;
                },

                bgClose: function(ref) {
                    var bgClose = ref.bgClose;

                    return bgClose && this.panel;
                }

            },

            beforeDisconnect: function() {
                if (includes(active, this)) {
                    this.toggleElement(this.$el, false, false);
                }
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selClose;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.hide();
                    }

                },

                {

                    name: 'toggle',

                    self: true,

                    handler: function(e, toggle) {

                        if (e.defaultPrevented) {
                            return;
                        }

                        e.preventDefault();

                        if (this.isToggled() === includes(active, this)) {
                            this.toggle();
                        }
                    }

                },

                {
                    name: 'beforeshow',

                    self: true,

                    handler: function(e) {

                        if (includes(active, this)) {
                            return false;
                        }

                        if (!this.stack && active.length) {
                            Promise$1.all(active.map(function (modal) { return modal.hide(); })).then(this.show);
                            e.preventDefault();
                        } else {
                            active.push(this);
                        }
                    }

                },

                {

                    name: 'show',

                    self: true,

                    handler: function() {
                        var this$1$1 = this;


                        var docEl = document.documentElement;

                        if (width(window) > docEl.clientWidth && this.overlay) {
                            css(document.body, 'overflowY', 'scroll');
                        }

                        if (this.stack) {
                            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active.length);
                        }

                        addClass(docEl, this.clsPage);

                        if (this.bgClose) {
                            once(this.$el, 'hide', on(document, pointerDown, function (ref) {
                                var target = ref.target;


                                if (last(active) !== this$1$1 || this$1$1.overlay && !within(target, this$1$1.$el) || within(target, this$1$1.panel)) {
                                    return;
                                }

                                once(document, (pointerUp + " " + pointerCancel + " scroll"), function (ref) {
                                    var defaultPrevented = ref.defaultPrevented;
                                    var type = ref.type;
                                    var newTarget = ref.target;

                                    if (!defaultPrevented && type === pointerUp && target === newTarget) {
                                        this$1$1.hide();
                                    }
                                }, true);

                            }), {self: true});
                        }

                        if (this.escClose) {
                            once(this.$el, 'hide', on(document, 'keydown', function (e) {
                                if (e.keyCode === 27 && last(active) === this$1$1) {
                                    this$1$1.hide();
                                }
                            }), {self: true});
                        }
                    }

                },

                {
                    name: 'shown',

                    self: true,

                    handler: function() {
                        if (!isFocusable(this.$el)) {
                            attr(this.$el, 'tabindex', '-1');
                        }

                        if (!$(':focus', this.$el)) {
                            this.$el.focus();
                        }
                    }
                },

                {

                    name: 'hidden',

                    self: true,

                    handler: function() {
                        var this$1$1 = this;


                        if (includes(active, this)) {
                            active.splice(active.indexOf(this), 1);
                        }

                        if (!active.length) {
                            css(document.body, 'overflowY', '');
                        }

                        css(this.$el, 'zIndex', '');

                        if (!active.some(function (modal) { return modal.clsPage === this$1$1.clsPage; })) {
                            removeClass(document.documentElement, this.clsPage);
                        }

                    }

                }

            ],

            methods: {

                toggle: function() {
                    return this.isToggled() ? this.hide() : this.show();
                },

                show: function() {
                    var this$1$1 = this;

                    if (this.container && parent(this.$el) !== this.container) {
                        append(this.container, this.$el);
                        return new Promise$1(function (resolve) { return requestAnimationFrame(function () { return this$1$1.show().then(resolve); }
                            ); }
                        );
                    }

                    return this.toggleElement(this.$el, true, animate(this));
                },

                hide: function() {
                    return this.toggleElement(this.$el, false, animate(this));
                }

            }

        };

        function animate(ref) {
            var transitionElement = ref.transitionElement;
            var _toggle = ref._toggle;

            return function (el, show) { return new Promise$1(function (resolve, reject) { return once(el, 'show hide', function () {
                        el._reject && el._reject();
                        el._reject = reject;

                        _toggle(el, show);

                        var off = once(transitionElement, 'transitionstart', function () {
                            once(transitionElement, 'transitionend transitioncancel', resolve, {self: true});
                            clearTimeout(timer);
                        }, {self: true});

                        var timer = setTimeout(function () {
                            off();
                            resolve();
                        }, toMs(css(transitionElement, 'transitionDuration')));

                    }); }
                ).then(function () { return delete el._reject; }); };
        }

        var modal = {

            install: install$2,

            mixins: [Modal],

            data: {
                clsPage: 'uk-modal-page',
                selPanel: '.uk-modal-dialog',
                selClose: '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full'
            },

            events: [

                {
                    name: 'show',

                    self: true,

                    handler: function() {

                        if (hasClass(this.panel, 'uk-margin-auto-vertical')) {
                            addClass(this.$el, 'uk-flex');
                        } else {
                            css(this.$el, 'display', 'block');
                        }

                        height(this.$el); // force reflow
                    }
                },

                {
                    name: 'hidden',

                    self: true,

                    handler: function() {

                        css(this.$el, 'display', '');
                        removeClass(this.$el, 'uk-flex');

                    }
                }

            ]

        };

        function install$2(ref) {
            var modal = ref.modal;


            modal.dialog = function (content, options) {

                var dialog = modal(
                    ("<div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">" + content + "</div> </div>"),
                    options
                );

                dialog.show();

                on(dialog.$el, 'hidden', function () { return Promise$1.resolve().then(function () { return dialog.$destroy(true); }
                    ); }, {self: true}
                );

                return dialog;
            };

            modal.alert = function (message, options) {
                return openDialog(
                    function (ref) {
                        var labels = ref.labels;

                        return ("<div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>" + (labels.ok) + "</button> </div>");
                },
                    options,
                    function (deferred) { return deferred.resolve(); }
                );
            };

            modal.confirm = function (message, options) {
                return openDialog(
                    function (ref) {
                        var labels = ref.labels;

                        return ("<form> <div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + (labels.cancel) + "</button> <button class=\"uk-button uk-button-primary\" autofocus>" + (labels.ok) + "</button> </div> </form>");
                },
                    options,
                    function (deferred) { return deferred.reject(); }
                );
            };

            modal.prompt = function (message, value, options) {
                return openDialog(
                    function (ref) {
                        var labels = ref.labels;

                        return ("<form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>" + (isString(message) ? message : html(message)) + "</label> <input class=\"uk-input\" value=\"" + (value || '') + "\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + (labels.cancel) + "</button> <button class=\"uk-button uk-button-primary\">" + (labels.ok) + "</button> </div> </form>");
                },
                    options,
                    function (deferred) { return deferred.resolve(null); },
                    function (dialog) { return $('input', dialog.$el).value; }
                );
            };

            modal.labels = {
                ok: 'Ok',
                cancel: 'Cancel'
            };

            function openDialog(tmpl, options, hideFn, submitFn) {

                options = assign({bgClose: false, escClose: true, labels: modal.labels}, options);

                var dialog = modal.dialog(tmpl(options), options);
                var deferred = new Deferred();

                var resolved = false;

                on(dialog.$el, 'submit', 'form', function (e) {
                    e.preventDefault();
                    deferred.resolve(submitFn && submitFn(dialog));
                    resolved = true;
                    dialog.hide();
                });

                on(dialog.$el, 'hide', function () { return !resolved && hideFn(deferred); });

                deferred.promise.dialog = dialog;

                return deferred.promise;
            }

        }

        var nav = {

            extends: Accordion,

            data: {
                targets: '> .uk-parent',
                toggle: '> a',
                content: '> ul'
            }

        };

        var navItem = '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle';

        var navbar = {

            mixins: [Class, Container, FlexBug],

            props: {
                dropdown: String,
                mode: 'list',
                align: String,
                offset: Number,
                boundary: Boolean,
                boundaryAlign: Boolean,
                clsDrop: String,
                delayShow: Number,
                delayHide: Number,
                dropbar: Boolean,
                dropbarMode: String,
                dropbarAnchor: Boolean,
                duration: Number
            },

            data: {
                dropdown: navItem,
                align: !isRtl ? 'left' : 'right',
                clsDrop: 'uk-navbar-dropdown',
                mode: undefined,
                offset: undefined,
                delayShow: undefined,
                delayHide: undefined,
                boundaryAlign: undefined,
                flip: 'x',
                boundary: true,
                dropbar: false,
                dropbarMode: 'slide',
                dropbarAnchor: false,
                duration: 200,
                forceHeight: true,
                selMinHeight: navItem,
                container: false
            },

            computed: {

                boundary: function(ref, $el) {
                    var boundary = ref.boundary;
                    var boundaryAlign = ref.boundaryAlign;

                    return boundary === true || boundaryAlign ? $el : boundary;
                },

                dropbarAnchor: function(ref, $el) {
                    var dropbarAnchor = ref.dropbarAnchor;

                    return query(dropbarAnchor, $el);
                },

                pos: function(ref) {
                    var align = ref.align;

                    return ("bottom-" + align);
                },

                dropbar: {

                    get: function(ref) {
                        var dropbar = ref.dropbar;


                        if (!dropbar) {
                            return null;
                        }

                        dropbar = this._dropbar || query(dropbar, this.$el) || $('+ .uk-navbar-dropbar', this.$el);

                        return dropbar ? dropbar : (this._dropbar = $('<div></div>'));

                    },

                    watch: function(dropbar) {
                        addClass(dropbar, 'uk-navbar-dropbar');
                    },

                    immediate: true

                },

                dropContainer: function(_, $el) {
                    return this.container || $el;
                },

                dropdowns: {

                    get: function(ref, $el) {
                        var this$1$1 = this;
                        var clsDrop = ref.clsDrop;

                        var dropdowns = $$(("." + clsDrop), $el);

                        if (this.dropContainer !== $el) {
                            $$(("." + clsDrop), this.dropContainer).forEach(function (el) {
                                var dropdown = this$1$1.getDropdown(el);
                                if (!includes(dropdowns, el) && dropdown && dropdown.target && within(dropdown.target, this$1$1.$el)) {
                                    dropdowns.push(el);
                                }
                            });
                        }

                        return dropdowns;
                    },

                    watch: function(dropdowns) {
                        var this$1$1 = this;

                        this.$create(
                            'drop',
                            dropdowns.filter(function (el) { return !this$1$1.getDropdown(el); }),
                            assign({}, this.$props, {boundary: this.boundary, pos: this.pos, offset: this.dropbar || this.offset})
                        );
                    },

                    immediate: true

                },

                toggles: function(ref, $el) {
                    var dropdown = ref.dropdown;

                    return $$(dropdown, $el);
                }

            },

            disconnected: function() {
                this.dropbar && remove$1(this.dropbar);
                delete this._dropbar;
            },

            events: [

                {
                    name: 'mouseover focusin',

                    delegate: function() {
                        return this.dropdown;
                    },

                    handler: function(ref) {
                        var current = ref.current;

                        var active = this.getActive();
                        if (active && includes(active.mode, 'hover') && active.target && !within(active.target, current) && !active.tracker.movesTo(active.$el)) {
                            active.hide(false);
                        }
                    }

                },

                {
                    name: 'keydown',

                    delegate: function() {
                        return this.dropdown;
                    },

                    handler: function(e) {

                        var current = e.current;
                        var keyCode = e.keyCode;
                        var active = this.getActive();

                        if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {

                            e.preventDefault();

                            if (!active || active.target !== current) {
                                current.click();
                                once(this.dropContainer, 'show', function (ref) {
                                    var target = ref.target;

                                    return focusFirstFocusableElement(target);
                                });
                            } else {
                                focusFirstFocusableElement(active.$el);
                            }

                        }

                        handleNavItemNavigation(e, this.toggles, active);
                    }
                },

                {
                    name: 'keydown',

                    el: function() {
                        return this.dropContainer;
                    },

                    delegate: function() {
                        return ("." + (this.clsDrop));
                    },

                    handler: function(e) {

                        var current = e.current;
                        var keyCode = e.keyCode;

                        if (!includes(this.dropdowns, current)) {
                            return;
                        }

                        var active = this.getActive();
                        var elements = $$(selFocusable, current);
                        var i = findIndex(elements, function (el) { return matches(el, ':focus'); });

                        if (keyCode === keyMap.UP) {
                            e.preventDefault();
                            if (i > 0) {
                                elements[i - 1].focus();
                            }
                        }

                        if (keyCode === keyMap.DOWN) {
                            e.preventDefault();
                            if (i < elements.length - 1) {
                                elements[i + 1].focus();
                            }
                        }

                        if (keyCode === keyMap.ESC) {
                            active && active.target && active.target.focus();
                        }

                        handleNavItemNavigation(e, this.toggles, active);
                    }
                },

                {
                    name: 'mouseleave',

                    el: function() {
                        return this.dropbar;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function() {
                        var active = this.getActive();

                        if (active && includes(active.mode, 'hover') && !this.dropdowns.some(function (el) { return matches(el, ':hover'); })) {
                            active.hide();
                        }
                    }
                },

                {
                    name: 'beforeshow',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function() {

                        if (!parent(this.dropbar)) {
                            after(this.dropbarAnchor || this.$el, this.dropbar);
                        }

                    }
                },

                {
                    name: 'show',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(_, ref) {
                        var $el = ref.$el;
                        var dir = ref.dir;

                        if (!hasClass($el, this.clsDrop)) {
                            return;
                        }

                        if (this.dropbarMode === 'slide') {
                            addClass(this.dropbar, 'uk-navbar-dropbar-slide');
                        }

                        this.clsDrop && addClass($el, ((this.clsDrop) + "-dropbar"));

                        if (dir === 'bottom') {
                            this.transitionTo($el.offsetHeight + toFloat(css($el, 'marginTop')) + toFloat(css($el, 'marginBottom')), $el);
                        }
                    }
                },

                {
                    name: 'beforehide',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(e, ref) {
                        var $el = ref.$el;


                        var active = this.getActive();

                        if (matches(this.dropbar, ':hover') && active && active.$el === $el) {
                            e.preventDefault();
                        }
                    }
                },

                {
                    name: 'hide',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(_, ref) {
                        var $el = ref.$el;

                        if (!hasClass($el, this.clsDrop)) {
                            return;
                        }

                        var active = this.getActive();

                        if (!active || active && active.$el === $el) {
                            this.transitionTo(0);
                        }
                    }
                }

            ],

            methods: {

                getActive: function() {
                    return active$1 && within(active$1.target, this.$el) && active$1;
                },

                transitionTo: function(newHeight, el) {
                    var this$1$1 = this;


                    var ref = this;
                    var dropbar = ref.dropbar;
                    var oldHeight = isVisible(dropbar) ? height(dropbar) : 0;

                    el = oldHeight < newHeight && el;

                    css(el, 'clip', ("rect(0," + (el.offsetWidth) + "px," + oldHeight + "px,0)"));

                    height(dropbar, oldHeight);

                    Transition.cancel([el, dropbar]);
                    return Promise$1.all([
                        Transition.start(dropbar, {height: newHeight}, this.duration),
                        Transition.start(el, {clip: ("rect(0," + (el.offsetWidth) + "px," + newHeight + "px,0)")}, this.duration)
                    ])
                        .catch(noop)
                        .then(function () {
                            css(el, {clip: ''});
                            this$1$1.$update(dropbar);
                        });
                },

                getDropdown: function(el) {
                    return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');
                }

            }

        };

        function handleNavItemNavigation(e, toggles, active) {

            var current = e.current;
            var keyCode = e.keyCode;
            var target = active && active.target || current;
            var i = toggles.indexOf(target);

            // Left
            if (keyCode === keyMap.LEFT && i > 0) {
                active && active.hide(false);
                toggles[i - 1].focus();
            }

            // Right
            if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {
                active && active.hide(false);
                toggles[i + 1].focus();
            }

            if (keyCode === keyMap.TAB) {
                target.focus();
                active && active.hide(false);
            }
        }

        function focusFirstFocusableElement(el) {
            if (!$(':focus', el)) {
                var focusEl = $(selFocusable, el);
                if (focusEl) {
                    focusEl.focus();
                }
            }
        }

        var keyMap = {
            TAB: 9,
            ESC: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        };

        var offcanvas = {

            mixins: [Modal],

            args: 'mode',

            props: {
                mode: String,
                flip: Boolean,
                overlay: Boolean
            },

            data: {
                mode: 'slide',
                flip: false,
                overlay: false,
                clsPage: 'uk-offcanvas-page',
                clsContainer: 'uk-offcanvas-container',
                selPanel: '.uk-offcanvas-bar',
                clsFlip: 'uk-offcanvas-flip',
                clsContainerAnimation: 'uk-offcanvas-container-animation',
                clsSidebarAnimation: 'uk-offcanvas-bar-animation',
                clsMode: 'uk-offcanvas',
                clsOverlay: 'uk-offcanvas-overlay',
                selClose: '.uk-offcanvas-close',
                container: false
            },

            computed: {

                clsFlip: function(ref) {
                    var flip = ref.flip;
                    var clsFlip = ref.clsFlip;

                    return flip ? clsFlip : '';
                },

                clsOverlay: function(ref) {
                    var overlay = ref.overlay;
                    var clsOverlay = ref.clsOverlay;

                    return overlay ? clsOverlay : '';
                },

                clsMode: function(ref) {
                    var mode = ref.mode;
                    var clsMode = ref.clsMode;

                    return (clsMode + "-" + mode);
                },

                clsSidebarAnimation: function(ref) {
                    var mode = ref.mode;
                    var clsSidebarAnimation = ref.clsSidebarAnimation;

                    return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;
                },

                clsContainerAnimation: function(ref) {
                    var mode = ref.mode;
                    var clsContainerAnimation = ref.clsContainerAnimation;

                    return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;
                },

                transitionElement: function(ref) {
                    var mode = ref.mode;

                    return mode === 'reveal' ? parent(this.panel) : this.panel;
                }

            },

            update: {

                read: function() {
                    if (this.isToggled() && !isVisible(this.$el)) {
                        this.hide();
                    }
                },

                events: ['resize']

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return 'a[href^="#"]';
                    },

                    handler: function(ref) {
                        var hash = ref.current.hash;
                        var defaultPrevented = ref.defaultPrevented;

                        if (!defaultPrevented && hash && $(hash, document.body)) {
                            this.hide();
                        }
                    }

                },

                {
                    name: 'touchstart',

                    passive: true,

                    el: function() {
                        return this.panel;
                    },

                    handler: function(ref) {
                        var targetTouches = ref.targetTouches;


                        if (targetTouches.length === 1) {
                            this.clientY = targetTouches[0].clientY;
                        }

                    }

                },

                {
                    name: 'touchmove',

                    self: true,
                    passive: false,

                    filter: function() {
                        return this.overlay;
                    },

                    handler: function(e) {
                        e.cancelable && e.preventDefault();
                    }

                },

                {
                    name: 'touchmove',

                    passive: false,

                    el: function() {
                        return this.panel;
                    },

                    handler: function(e) {

                        if (e.targetTouches.length !== 1) {
                            return;
                        }

                        var clientY = e.targetTouches[0].clientY - this.clientY;
                        var ref = this.panel;
                        var scrollTop = ref.scrollTop;
                        var scrollHeight = ref.scrollHeight;
                        var clientHeight = ref.clientHeight;

                        if (clientHeight >= scrollHeight
                            || scrollTop === 0 && clientY > 0
                            || scrollHeight - scrollTop <= clientHeight && clientY < 0
                        ) {
                            e.cancelable && e.preventDefault();
                        }

                    }

                },

                {
                    name: 'show',

                    self: true,

                    handler: function() {

                        if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {
                            wrapAll(this.panel, '<div>');
                            addClass(parent(this.panel), this.clsMode);
                        }

                        css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');
                        addClass(document.body, this.clsContainer, this.clsFlip);
                        css(document.body, 'touch-action', 'pan-y pinch-zoom');
                        css(this.$el, 'display', 'block');
                        addClass(this.$el, this.clsOverlay);
                        addClass(this.panel, this.clsSidebarAnimation, this.mode !== 'reveal' ? this.clsMode : '');

                        height(document.body); // force reflow
                        addClass(document.body, this.clsContainerAnimation);

                        this.clsContainerAnimation && suppressUserScale();


                    }
                },

                {
                    name: 'hide',

                    self: true,

                    handler: function() {
                        removeClass(document.body, this.clsContainerAnimation);
                        css(document.body, 'touch-action', '');
                    }
                },

                {
                    name: 'hidden',

                    self: true,

                    handler: function() {

                        this.clsContainerAnimation && resumeUserScale();

                        if (this.mode === 'reveal') {
                            unwrap(this.panel);
                        }

                        removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
                        removeClass(this.$el, this.clsOverlay);
                        css(this.$el, 'display', '');
                        removeClass(document.body, this.clsContainer, this.clsFlip);

                        css(document.documentElement, 'overflowY', '');

                    }
                },

                {
                    name: 'swipeLeft swipeRight',

                    handler: function(e) {

                        if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {
                            this.hide();
                        }

                    }
                }

            ]

        };

        // Chrome in responsive mode zooms page upon opening offcanvas
        function suppressUserScale() {
            getViewport().content += ',user-scalable=0';
        }

        function resumeUserScale() {
            var viewport = getViewport();
            viewport.content = viewport.content.replace(/,user-scalable=0$/, '');
        }

        function getViewport() {
            return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">');
        }

        var overflowAuto = {

            mixins: [Class],

            props: {
                selContainer: String,
                selContent: String,
                minHeight: Number
            },

            data: {
                selContainer: '.uk-modal',
                selContent: '.uk-modal-dialog',
                minHeight: 150
            },

            computed: {

                container: function(ref, $el) {
                    var selContainer = ref.selContainer;

                    return closest($el, selContainer);
                },

                content: function(ref, $el) {
                    var selContent = ref.selContent;

                    return closest($el, selContent);
                }

            },

            connected: function() {
                css(this.$el, 'minHeight', this.minHeight);
            },

            update: {

                read: function() {

                    if (!this.content || !this.container || !isVisible(this.$el)) {
                        return false;
                    }

                    return {
                        current: toFloat(css(this.$el, 'maxHeight')),
                        max: Math.max(this.minHeight, height(this.container) - (dimensions(this.content).height - height(this.$el)))
                    };
                },

                write: function(ref) {
                    var current = ref.current;
                    var max = ref.max;

                    css(this.$el, 'maxHeight', max);
                    if (Math.round(current) !== Math.round(max)) {
                        trigger(this.$el, 'resize');
                    }
                },

                events: ['resize']

            }

        };

        var responsive = {

            props: ['width', 'height'],

            connected: function() {
                addClass(this.$el, 'uk-responsive-width');
            },

            update: {

                read: function() {
                    return isVisible(this.$el) && this.width && this.height
                        ? {width: width(parent(this.$el)), height: this.height}
                        : false;
                },

                write: function(dim) {
                    height(this.$el, Dimensions.contain({
                        height: this.height,
                        width: this.width
                    }, dim).height);
                },

                events: ['resize']

            }

        };

        var scroll = {

            props: {
                offset: Number
            },

            data: {
                offset: 0
            },

            methods: {

                scrollTo: function(el) {
                    var this$1$1 = this;


                    el = el && $(el) || document.body;

                    if (trigger(this.$el, 'beforescroll', [this, el])) {
                        scrollIntoView(el, {offset: this.offset}).then(function () { return trigger(this$1$1.$el, 'scrolled', [this$1$1, el]); }
                        );
                    }

                }

            },

            events: {

                click: function(e) {

                    if (e.defaultPrevented) {
                        return;
                    }

                    e.preventDefault();
                    this.scrollTo(("#" + (escape(decodeURIComponent((this.$el.hash || '').substr(1))))));
                }

            }

        };

        var stateKey = '_ukScrollspy';
        var scrollspy = {

            args: 'cls',

            props: {
                cls: String,
                target: String,
                hidden: Boolean,
                offsetTop: Number,
                offsetLeft: Number,
                repeat: Boolean,
                delay: Number
            },

            data: function () { return ({
                cls: false,
                target: false,
                hidden: true,
                offsetTop: 0,
                offsetLeft: 0,
                repeat: false,
                delay: 0,
                inViewClass: 'uk-scrollspy-inview'
            }); },

            computed: {

                elements: {

                    get: function(ref, $el) {
                        var target = ref.target;

                        return target ? $$(target, $el) : [$el];
                    },

                    watch: function(elements) {
                        if (this.hidden) {
                            css(filter$1(elements, (":not(." + (this.inViewClass) + ")")), 'visibility', 'hidden');
                        }
                    },

                    immediate: true

                }

            },

            disconnected: function() {
                var this$1$1 = this;

                this.elements.forEach(function (el) {
                    removeClass(el, this$1$1.inViewClass, el[stateKey] ? el[stateKey].cls : '');
                    delete el[stateKey];
                });
            },

            update: [

                {

                    read: function(data$1) {
                        var this$1$1 = this;


                        // Let child components be applied at least once first
                        if (!data$1.update) {
                            Promise$1.resolve().then(function () {
                                this$1$1.$emit();
                                data$1.update = true;
                            });
                            return false;
                        }

                        this.elements.forEach(function (el) {

                            if (!el[stateKey]) {
                                el[stateKey] = {cls: data(el, 'uk-scrollspy-class') || this$1$1.cls};
                            }

                            el[stateKey].show = isInView(el, this$1$1.offsetTop, this$1$1.offsetLeft);

                        });

                    },

                    write: function(data) {
                        var this$1$1 = this;


                        this.elements.forEach(function (el) {

                            var state = el[stateKey];

                            if (state.show && !state.inview && !state.queued) {

                                state.queued = true;

                                data.promise = (data.promise || Promise$1.resolve()).then(function () { return new Promise$1(function (resolve) { return setTimeout(resolve, this$1$1.delay); }
                                    ); }
                                ).then(function () {
                                    this$1$1.toggle(el, true);
                                    setTimeout(function () {
                                        state.queued = false;
                                        this$1$1.$emit();
                                    }, 300);
                                });

                            } else if (!state.show && state.inview && !state.queued && this$1$1.repeat) {

                                this$1$1.toggle(el, false);

                            }

                        });

                    },

                    events: ['scroll', 'resize']

                }

            ],

            methods: {

                toggle: function(el, inview) {

                    var state = el[stateKey];

                    state.off && state.off();

                    css(el, 'visibility', !inview && this.hidden ? 'hidden' : '');

                    toggleClass(el, this.inViewClass, inview);
                    toggleClass(el, state.cls);

                    if (/\buk-animation-/.test(state.cls)) {
                        state.off = once(el, 'animationcancel animationend', function () { return removeClasses(el, 'uk-animation-[\\w-]+'); }
                        );
                    }

                    trigger(el, inview ? 'inview' : 'outview');

                    state.inview = inview;

                    this.$update(el);
                }

            }

        };

        var scrollspyNav = {

            props: {
                cls: String,
                closest: String,
                scroll: Boolean,
                overflow: Boolean,
                offset: Number
            },

            data: {
                cls: 'uk-active',
                closest: false,
                scroll: false,
                overflow: true,
                offset: 0
            },

            computed: {

                links: {

                    get: function(_, $el) {
                        return $$('a[href^="#"]', $el).filter(function (el) { return el.hash; });
                    },

                    watch: function(links) {
                        if (this.scroll) {
                            this.$create('scroll', links, {offset: this.offset || 0});
                        }
                    },

                    immediate: true

                },

                targets: function() {
                    return $$(this.links.map(function (el) { return escape(el.hash).substr(1); }).join(','));
                },

                elements: function(ref) {
                    var selector = ref.closest;

                    return closest(this.links, selector || '*');
                }

            },

            update: [

                {

                    read: function() {
                        var this$1$1 = this;


                        var ref = this.targets;
                        var length = ref.length;

                        if (!length || !isVisible(this.$el)) {
                            return false;
                        }

                        var ref$1 = scrollParents(this.targets, /auto|scroll/, true);
                        var scrollElement = ref$1[0];
                        var scrollTop = scrollElement.scrollTop;
                        var scrollHeight = scrollElement.scrollHeight;
                        var max = scrollHeight - getViewportClientHeight(scrollElement);
                        var active = false;

                        if (scrollTop === max) {
                            active = length - 1;
                        } else {

                            this.targets.every(function (el, i) {
                                if (offset(el).top - offset(getViewport$1(scrollElement)).top - this$1$1.offset <= 0) {
                                    active = i;
                                    return true;
                                }
                            });

                            if (active === false && this.overflow) {
                                active = 0;
                            }
                        }

                        return {active: active};
                    },

                    write: function(ref) {
                        var active = ref.active;


                        var changed = active !== false && !hasClass(this.elements[active], this.cls);

                        this.links.forEach(function (el) { return el.blur(); });
                        removeClass(this.elements, this.cls);
                        addClass(this.elements[active], this.cls);

                        if (changed) {
                            trigger(this.$el, 'active', [active, this.elements[active]]);
                        }
                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        var sticky = {

            mixins: [Class, Media],

            props: {
                top: null,
                bottom: Boolean,
                offset: String,
                animation: String,
                clsActive: String,
                clsInactive: String,
                clsFixed: String,
                clsBelow: String,
                selTarget: String,
                widthElement: Boolean,
                showOnUp: Boolean,
                targetOffset: Number
            },

            data: {
                top: 0,
                bottom: false,
                offset: 0,
                animation: '',
                clsActive: 'uk-active',
                clsInactive: '',
                clsFixed: 'uk-sticky-fixed',
                clsBelow: 'uk-sticky-below',
                selTarget: '',
                widthElement: false,
                showOnUp: false,
                targetOffset: false
            },

            computed: {

                offset: function(ref) {
                    var offset = ref.offset;

                    return toPx(offset);
                },

                selTarget: function(ref, $el) {
                    var selTarget = ref.selTarget;

                    return selTarget && $(selTarget, $el) || $el;
                },

                widthElement: function(ref, $el) {
                    var widthElement = ref.widthElement;

                    return query(widthElement, $el) || this.placeholder;
                },

                isActive: {

                    get: function() {
                        return hasClass(this.selTarget, this.clsActive);
                    },

                    set: function(value) {
                        if (value && !this.isActive) {
                            replaceClass(this.selTarget, this.clsInactive, this.clsActive);
                            trigger(this.$el, 'active');
                        } else if (!value && !hasClass(this.selTarget, this.clsInactive)) {
                            replaceClass(this.selTarget, this.clsActive, this.clsInactive);
                            trigger(this.$el, 'inactive');
                        }
                    }

                }

            },

            connected: function() {
                this.placeholder = $('+ .uk-sticky-placeholder', this.$el) || $('<div class="uk-sticky-placeholder"></div>');
                this.isFixed = false;
                this.isActive = false;
            },

            disconnected: function() {

                if (this.isFixed) {
                    this.hide();
                    removeClass(this.selTarget, this.clsInactive);
                }

                remove$1(this.placeholder);
                this.placeholder = null;
                this.widthElement = null;
            },

            events: [

                {

                    name: 'load hashchange popstate',

                    el: function() {
                        return window;
                    },

                    handler: function() {
                        var this$1$1 = this;


                        if (!(this.targetOffset !== false && location.hash && window.pageYOffset > 0)) {
                            return;
                        }

                        var target = $(location.hash);

                        if (target) {
                            fastdom.read(function () {

                                var ref = offset(target);
                                var top = ref.top;
                                var elTop = offset(this$1$1.$el).top;
                                var elHeight = this$1$1.$el.offsetHeight;

                                if (this$1$1.isFixed && elTop + elHeight >= top && elTop <= top + target.offsetHeight) {
                                    scrollTop(window, top - elHeight - (isNumeric(this$1$1.targetOffset) ? this$1$1.targetOffset : 0) - this$1$1.offset);
                                }

                            });
                        }

                    }

                }

            ],

            update: [

                {

                    read: function(ref, types) {
                        var height = ref.height;


                        this.inactive = !this.matchMedia || !isVisible(this.$el);

                        if (this.inactive) {
                            return false;
                        }

                        if (this.isActive && types.has('resize')) {
                            this.hide();
                            height = this.$el.offsetHeight;
                            this.show();
                        }

                        height = !this.isActive ? this.$el.offsetHeight : height;

                        this.topOffset = offset(this.isFixed ? this.placeholder : this.$el).top;
                        this.bottomOffset = this.topOffset + height;
                        this.offsetParentTop = offset(this.$el.offsetParent).top;

                        var bottom = parseProp('bottom', this);

                        this.top = Math.max(toFloat(parseProp('top', this)), this.topOffset) - this.offset;
                        this.bottom = bottom && bottom - this.$el.offsetHeight;
                        this.width = dimensions(isVisible(this.widthElement) ? this.widthElement : this.$el).width;

                        return {
                            height: height,
                            top: offsetPosition(this.placeholder)[0],
                            margins: css(this.$el, ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'])
                        };
                    },

                    write: function(ref) {
                        var height = ref.height;
                        var margins = ref.margins;


                        var ref$1 = this;
                        var placeholder = ref$1.placeholder;

                        css(placeholder, assign({height: height}, margins));

                        if (!within(placeholder, document)) {
                            after(this.$el, placeholder);
                            placeholder.hidden = true;
                        }

                        this.isActive = !!this.isActive; // force self-assign

                    },

                    events: ['resize']

                },

                {

                    read: function(ref) {
                        var scroll = ref.scroll; if ( scroll === void 0 ) scroll = 0;


                        this.scroll = window.pageYOffset;

                        return {
                            dir: scroll <= this.scroll ? 'down' : 'up',
                            scroll: this.scroll
                        };
                    },

                    write: function(data, types) {
                        var this$1$1 = this;


                        var now = Date.now();
                        var isScrollUpdate = types.has('scroll');
                        var initTimestamp = data.initTimestamp; if ( initTimestamp === void 0 ) initTimestamp = 0;
                        var dir = data.dir;
                        var lastDir = data.lastDir;
                        var lastScroll = data.lastScroll;
                        var scroll = data.scroll;
                        var top = data.top;

                        data.lastScroll = scroll;

                        if (scroll < 0 || scroll === lastScroll && isScrollUpdate || this.showOnUp && !isScrollUpdate && !this.isFixed) {
                            return;
                        }

                        if (now - initTimestamp > 300 || dir !== lastDir) {
                            data.initScroll = scroll;
                            data.initTimestamp = now;
                        }

                        data.lastDir = dir;

                        if (this.showOnUp && !this.isFixed && Math.abs(data.initScroll - scroll) <= 30 && Math.abs(lastScroll - scroll) <= 10) {
                            return;
                        }

                        if (this.inactive
                            || scroll < this.top
                            || this.showOnUp && (scroll <= this.top || dir === 'down' && isScrollUpdate || dir === 'up' && !this.isFixed && scroll <= this.bottomOffset)
                        ) {

                            if (!this.isFixed) {

                                if (Animation.inProgress(this.$el) && top > scroll) {
                                    Animation.cancel(this.$el);
                                    this.hide();
                                }

                                return;
                            }

                            this.isFixed = false;

                            if (this.animation && scroll > this.topOffset) {
                                Animation.cancel(this.$el);
                                Animation.out(this.$el, this.animation).then(function () { return this$1$1.hide(); }, noop);
                            } else {
                                this.hide();
                            }

                        } else if (this.isFixed) {

                            this.update();

                        } else if (this.animation) {

                            Animation.cancel(this.$el);
                            this.show();
                            Animation.in(this.$el, this.animation).catch(noop);

                        } else {
                            this.show();
                        }

                    },

                    events: ['resize', 'scroll']

                }

            ],

            methods: {

                show: function() {

                    this.isFixed = true;
                    this.update();
                    this.placeholder.hidden = false;

                },

                hide: function() {

                    this.isActive = false;
                    removeClass(this.$el, this.clsFixed, this.clsBelow);
                    css(this.$el, {position: '', top: '', width: ''});
                    this.placeholder.hidden = true;

                },

                update: function() {

                    var active = this.top !== 0 || this.scroll > this.top;
                    var top = Math.max(0, this.offset);
                    var position = 'fixed';

                    if (isNumeric(this.bottom) && this.scroll > this.bottom - this.offset) {
                        top = this.bottom - this.offsetParentTop;
                        position = 'absolute';
                    }

                    css(this.$el, {
                        position: position,
                        top: (top + "px"),
                        width: this.width
                    });

                    this.isActive = active;
                    toggleClass(this.$el, this.clsBelow, this.scroll > this.bottomOffset);
                    addClass(this.$el, this.clsFixed);

                }

            }

        };

        function parseProp(prop, ref) {
            var $props = ref.$props;
            var $el = ref.$el;
            var propOffset = ref[(prop + "Offset")];


            var value = $props[prop];

            if (!value) {
                return;
            }

            if (isString(value) && value.match(/^-?\d/)) {

                return propOffset + toPx(value);

            } else {

                return offset(value === true ? parent($el) : query(value, $el)).bottom;

            }
        }

        var Switcher = {

            mixins: [Togglable],

            args: 'connect',

            props: {
                connect: String,
                toggle: String,
                itemNav: String,
                active: Number,
                swiping: Boolean
            },

            data: {
                connect: '~.uk-switcher',
                toggle: '> * > :first-child',
                itemNav: false,
                active: 0,
                swiping: true,
                cls: 'uk-active',
                attrItem: 'uk-switcher-item'
            },

            computed: {

                connects: {

                    get: function(ref, $el) {
                        var connect = ref.connect;

                        return queryAll(connect, $el);
                    },

                    watch: function(connects) {
                        var this$1$1 = this;


                        if (this.swiping) {
                            css(connects, 'touch-action', 'pan-y pinch-zoom');
                        }

                        var index = this.index();
                        this.connects.forEach(function (el) { return children(el).forEach(function (child, i) { return toggleClass(child, this$1$1.cls, i === index); }
                            ); }
                        );

                    },

                    immediate: true

                },

                toggles: {

                    get: function(ref, $el) {
                        var toggle = ref.toggle;

                        return $$(toggle, $el).filter(function (el) { return !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'); });
                    },

                    watch: function(toggles) {
                        var active = this.index();
                        this.show(~active ? active : toggles[this.active] || toggles[0]);
                    },

                    immediate: true

                },

                children: function() {
                    var this$1$1 = this;

                    return children(this.$el).filter(function (child) { return this$1$1.toggles.some(function (toggle) { return within(toggle, child); }); });
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.toggle;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(e.current);
                    }

                },

                {
                    name: 'click',

                    el: function() {
                        return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);
                    },

                    delegate: function() {
                        return ("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(data(e.current, this.attrItem));
                    }
                },

                {
                    name: 'swipeRight swipeLeft',

                    filter: function() {
                        return this.swiping;
                    },

                    el: function() {
                        return this.connects;
                    },

                    handler: function(ref) {
                        var type = ref.type;

                        this.show(endsWith(type, 'Left') ? 'next' : 'previous');
                    }
                }

            ],

            methods: {

                index: function() {
                    var this$1$1 = this;

                    return findIndex(this.children, function (el) { return hasClass(el, this$1$1.cls); });
                },

                show: function(item) {
                    var this$1$1 = this;


                    var prev = this.index();
                    var next = getIndex(
                        this.children[getIndex(item, this.toggles, prev)],
                        children(this.$el)
                    );

                    if (prev === next) {
                        return;
                    }

                    this.children.forEach(function (child, i) {
                        toggleClass(child, this$1$1.cls, next === i);
                        attr(this$1$1.toggles[i], 'aria-expanded', next === i);
                    });

                    this.connects.forEach(function (ref) {
                            var children = ref.children;

                            return this$1$1.toggleElement(toNodes(children).filter(function (child) { return hasClass(child, this$1$1.cls); }
                        ), false, prev >= 0).then(function () { return this$1$1.toggleElement(children[next], true, prev >= 0); }
                        );
                    }
                    );
                }

            }

        };

        var tab = {

            mixins: [Class],

            extends: Switcher,

            props: {
                media: Boolean
            },

            data: {
                media: 960,
                attrItem: 'uk-tab-item'
            },

            connected: function() {

                var cls = hasClass(this.$el, 'uk-tab-left')
                    ? 'uk-tab-left'
                    : hasClass(this.$el, 'uk-tab-right')
                        ? 'uk-tab-right'
                        : false;

                if (cls) {
                    this.$create('toggle', this.$el, {cls: cls, mode: 'media', media: this.media});
                }
            }

        };

        var toggle = {

            mixins: [Media, Togglable],

            args: 'target',

            props: {
                href: String,
                target: null,
                mode: 'list',
                queued: Boolean
            },

            data: {
                href: false,
                target: false,
                mode: 'click',
                queued: true
            },

            connected: function() {
                if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {
                    attr(this.$el, 'tabindex', '0');
                }
            },

            computed: {

                target: {

                    get: function(ref, $el) {
                        var href = ref.href;
                        var target = ref.target;

                        target = queryAll(target || href, $el);
                        return target.length && target || [$el];
                    },

                    watch: function() {
                        this.updateAria();
                    },

                    immediate: true

                }

            },

            events: [

                {
                    name: pointerDown,

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        var this$1$1 = this;


                        if (!isTouch(e) || this._showState) {
                            return;
                        }

                        // Clicking a button does not give it focus on all browsers and platforms
                        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
                        trigger(this.$el, 'focus');
                        once(document, pointerDown, function () { return trigger(this$1$1.$el, 'blur'); }, true, function (e) { return !within(e.target, this$1$1.$el); });

                        // Prevent initial click to prevent double toggle through focus + click
                        if (includes(this.mode, 'click')) {
                            this._preventClick = true;
                        }
                    }
                },

                {

                    name: (pointerEnter + " " + pointerLeave + " focus blur"),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (isTouch(e)) {
                            return;
                        }

                        var show = includes([pointerEnter, 'focus'], e.type);
                        var expanded = attr(this.$el, 'aria-expanded');

                        // Skip hide if still hovered or focused
                        if (!show && (
                            e.type === pointerLeave && matches(this.$el, ':focus')
                            || e.type === 'blur' && matches(this.$el, ':hover')
                        )) {
                            return;
                        }

                        // Skip if state does not change e.g. hover + focus received
                        if (this._showState && show === (expanded !== this._showState)) {

                            // Ensure reset if state has changed through click
                            if (!show) {
                                this._showState = null;
                            }
                            return;
                        }

                        this._showState = show ? expanded : null;

                        this.toggle(("toggle" + (show ? 'show' : 'hide')));
                    }

                },

                {
                    name: 'keydown',

                    filter: function() {
                        return includes(this.mode, 'click');
                    },

                    handler: function(e) {
                        // Space
                        if (e.keyCode === 32) {
                            e.preventDefault();
                            this.$el.click();
                        }
                    }
                },

                {

                    name: 'click',

                    filter: function() {
                        return includes(this.mode, 'click');
                    },

                    handler: function(e) {

                        if (this._preventClick) {
                            return this._preventClick = null;
                        }

                        var link;
                        if (closest(e.target, 'a[href="#"], a[href=""]')
                            || (link = closest(e.target, 'a[href]')) && (
                                attr(this.$el, 'aria-expanded') !== 'true'
                                || link.hash && matches(this.target, link.hash)
                            )
                        ) {
                            e.preventDefault();
                        }

                        this.toggle();
                    }

                },

                {

                    name: 'toggled',

                    self: true,

                    el: function() {
                        return this.target;
                    },

                    handler: function(e, toggled) {
                        if (e.target === this.target[0]) {
                            this.updateAria(toggled);
                        }
                    }
                }

            ],

            update: {

                read: function() {
                    return includes(this.mode, 'media') && this.media
                        ? {match: this.matchMedia}
                        : false;
                },

                write: function(ref) {
                    var match = ref.match;


                    var toggled = this.isToggled(this.target);
                    if (match ? !toggled : toggled) {
                        this.toggle();
                    }

                },

                events: ['resize']

            },

            methods: {

                toggle: function(type) {
                    var this$1$1 = this;


                    if (!trigger(this.target, type || 'toggle', [this])) {
                        return;
                    }

                    if (!this.queued) {
                        return this.toggleElement(this.target);
                    }

                    var leaving = this.target.filter(function (el) { return hasClass(el, this$1$1.clsLeave); });

                    if (leaving.length) {
                        this.target.forEach(function (el) {
                            var isLeaving = includes(leaving, el);
                            this$1$1.toggleElement(el, isLeaving, isLeaving);
                        });
                        return;
                    }

                    var toggled = this.target.filter(this.isToggled);
                    this.toggleElement(toggled, false).then(function () { return this$1$1.toggleElement(this$1$1.target.filter(function (el) { return !includes(toggled, el); }
                        ), true); }
                    );

                },

                updateAria: function(toggled) {
                    if (includes(this.mode, 'media')) {
                        return;
                    }

                    attr(this.$el, 'aria-expanded', isBoolean(toggled)
                        ? toggled
                        : this.isToggled(this.target)
                    );
                }

            }

        };

        var components$1 = /*#__PURE__*/Object.freeze({
            __proto__: null,
            Accordion: Accordion,
            Alert: alert,
            Cover: cover,
            Drop: drop,
            Dropdown: drop,
            FormCustom: formCustom,
            Gif: gif,
            Grid: grid,
            HeightMatch: heightMatch,
            HeightViewport: heightViewport,
            Icon: Icon,
            Img: img,
            Leader: leader,
            Margin: Margin,
            Modal: modal,
            Nav: nav,
            Navbar: navbar,
            Offcanvas: offcanvas,
            OverflowAuto: overflowAuto,
            Responsive: responsive,
            Scroll: scroll,
            Scrollspy: scrollspy,
            ScrollspyNav: scrollspyNav,
            Sticky: sticky,
            Svg: SVG,
            Switcher: Switcher,
            Tab: tab,
            Toggle: toggle,
            Video: Video,
            Close: Close,
            Spinner: Spinner,
            SlidenavNext: Slidenav,
            SlidenavPrevious: Slidenav,
            SearchIcon: Search,
            Marker: IconComponent,
            NavbarToggleIcon: IconComponent,
            OverlayIcon: IconComponent,
            PaginationNext: IconComponent,
            PaginationPrevious: IconComponent,
            Totop: IconComponent
        });

        // register components
        each(components$1, function (component, name) { return UIkit.component(name, component); }
        );

        // core functionality
        UIkit.use(Core);

        boot(UIkit);

        var countdown = {

            mixins: [Class],

            props: {
                date: String,
                clsWrapper: String
            },

            data: {
                date: '',
                clsWrapper: '.uk-countdown-%unit%'
            },

            computed: {

                date: function(ref) {
                    var date = ref.date;

                    return Date.parse(date);
                },

                days: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'days'), $el);
                },

                hours: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'hours'), $el);
                },

                minutes: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'minutes'), $el);
                },

                seconds: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'seconds'), $el);
                },

                units: function() {
                    var this$1$1 = this;

                    return ['days', 'hours', 'minutes', 'seconds'].filter(function (unit) { return this$1$1[unit]; });
                }

            },

            connected: function() {
                this.start();
            },

            disconnected: function() {
                var this$1$1 = this;

                this.stop();
                this.units.forEach(function (unit) { return empty(this$1$1[unit]); });
            },

            events: [

                {

                    name: 'visibilitychange',

                    el: function() {
                        return document;
                    },

                    handler: function() {
                        if (document.hidden) {
                            this.stop();
                        } else {
                            this.start();
                        }
                    }

                }

            ],

            update: {

                write: function() {
                    var this$1$1 = this;


                    var timespan = getTimeSpan(this.date);

                    if (timespan.total <= 0) {

                        this.stop();

                        timespan.days
                            = timespan.hours
                            = timespan.minutes
                            = timespan.seconds
                            = 0;
                    }

                    this.units.forEach(function (unit) {

                        var digits = String(Math.floor(timespan[unit]));

                        digits = digits.length < 2 ? ("0" + digits) : digits;

                        var el = this$1$1[unit];
                        if (el.textContent !== digits) {
                            digits = digits.split('');

                            if (digits.length !== el.children.length) {
                                html(el, digits.map(function () { return '<span></span>'; }).join(''));
                            }

                            digits.forEach(function (digit, i) { return el.children[i].textContent = digit; });
                        }

                    });

                }

            },

            methods: {

                start: function() {

                    this.stop();

                    if (this.date && this.units.length) {
                        this.$update();
                        this.timer = setInterval(this.$update, 1000);
                    }

                },

                stop: function() {

                    if (this.timer) {
                        clearInterval(this.timer);
                        this.timer = null;
                    }

                }

            }

        };

        function getTimeSpan(date) {

            var total = date - Date.now();

            return {
                total: total,
                seconds: total / 1000 % 60,
                minutes: total / 1000 / 60 % 60,
                hours: total / 1000 / 60 / 60 % 24,
                days: total / 1000 / 60 / 60 / 24
            };
        }

        var clsLeave = 'uk-transition-leave';
        var clsEnter = 'uk-transition-enter';

        function fade(action, target, duration, stagger) {
            if ( stagger === void 0 ) stagger = 0;


            var index = transitionIndex(target, true);
            var propsIn = {opacity: 1};
            var propsOut = {opacity: 0};

            var wrapIndexFn = function (fn) { return function () { return index === transitionIndex(target) ? fn() : Promise$1.reject(); }; };

            var leaveFn = wrapIndexFn(function () {

                addClass(target, clsLeave);

                return Promise$1.all(getTransitionNodes(target).map(function (child, i) { return new Promise$1(function (resolve) { return setTimeout(function () { return Transition.start(child, propsOut, duration / 2, 'ease').then(resolve); }, i * stagger); }
                    ); }
                )).then(function () { return removeClass(target, clsLeave); });

            });

            var enterFn = wrapIndexFn(function () {

                var oldHeight = height(target);

                addClass(target, clsEnter);
                action();

                css(children(target), {opacity: 0});

                // Ensure UIkit updates have propagated
                return new Promise$1(function (resolve) { return requestAnimationFrame(function () {

                        var nodes = children(target);
                        var newHeight = height(target);

                        // Ensure Grid cells do not stretch when height is applied
                        css(target, 'alignContent', 'flex-start');
                        height(target, oldHeight);

                        var transitionNodes = getTransitionNodes(target);
                        css(nodes, propsOut);

                        var transitions = transitionNodes.map(function (child, i) { return new Promise$1(function (resolve) { return setTimeout(function () { return Transition.start(child, propsIn, duration / 2, 'ease').then(resolve); }, i * stagger); }
                            ); }
                        );

                        if (oldHeight !== newHeight) {
                            transitions.push(Transition.start(target, {height: newHeight}, duration / 2 + transitionNodes.length * stagger, 'ease'));
                        }

                        Promise$1.all(transitions).then(function () {
                            removeClass(target, clsEnter);
                            if (index === transitionIndex(target)) {
                                css(target, {height: '', alignContent: ''});
                                css(nodes, {opacity: ''});
                                delete target.dataset.transition;
                            }
                            resolve();
                        });
                    }); }
                );
            });

            return hasClass(target, clsLeave)
                ? waitTransitionend(target).then(enterFn)
                : hasClass(target, clsEnter)
                    ? waitTransitionend(target).then(leaveFn).then(enterFn)
                    : leaveFn().then(enterFn);
        }

        function transitionIndex(target, next) {
            if (next) {
                target.dataset.transition = 1 + transitionIndex(target);
            }

            return toNumber(target.dataset.transition) || 0;
        }

        function waitTransitionend(target) {
            return Promise$1.all(children(target).filter(Transition.inProgress).map(function (el) { return new Promise$1(function (resolve) { return once(el, 'transitionend transitioncanceled', resolve); }); }
            ));
        }

        function getTransitionNodes(target) {
            return getRows(children(target)).reduce(function (nodes, row) { return nodes.concat(sortBy$1(row.filter(function (el) { return isInView(el); }), 'offsetLeft')); }, []);
        }

        function slide (action, target, duration) {

            return new Promise$1(function (resolve) { return requestAnimationFrame(function () {

                    var nodes = children(target);

                    // Get current state
                    var currentProps = nodes.map(function (el) { return getProps(el, true); });
                    var targetProps = css(target, ['height', 'padding']);

                    // Cancel previous animations
                    Transition.cancel(target);
                    nodes.forEach(Transition.cancel);
                    reset(target);

                    // Adding, sorting, removing nodes
                    action();

                    // Find new nodes
                    nodes = nodes.concat(children(target).filter(function (el) { return !includes(nodes, el); }));

                    // Wait for update to propagate
                    Promise$1.resolve().then(function () {

                        // Force update
                        fastdom.flush();

                        // Get new state
                        var targetPropsTo = css(target, ['height', 'padding']);
                        var ref = getTransitionProps(target, nodes, currentProps);
                        var propsTo = ref[0];
                        var propsFrom = ref[1];

                        // Reset to previous state
                        nodes.forEach(function (el, i) { return propsFrom[i] && css(el, propsFrom[i]); });
                        css(target, assign({display: 'block'}, targetProps));

                        // Start transitions on next frame
                        requestAnimationFrame(function () {

                            var transitions = nodes.map(function (el, i) { return parent(el) === target && Transition.start(el, propsTo[i], duration, 'ease'); }
                                ).concat(Transition.start(target, targetPropsTo, duration, 'ease'));

                            Promise$1.all(transitions).then(function () {
                                nodes.forEach(function (el, i) { return parent(el) === target && css(el, 'display', propsTo[i].opacity === 0 ? 'none' : ''); });
                                reset(target);
                            }, noop).then(resolve);

                        });
                    });
                }); });
        }

        function getProps(el, opacity) {

            var zIndex = css(el, 'zIndex');

            return isVisible(el)
                ? assign({
                    display: '',
                    opacity: opacity ? css(el, 'opacity') : '0',
                    pointerEvents: 'none',
                    position: 'absolute',
                    zIndex: zIndex === 'auto' ? index(el) : zIndex
                }, getPositionWithMargin(el))
                : false;
        }

        function getTransitionProps(target, nodes, currentProps) {

            var propsTo = nodes.map(function (el, i) { return parent(el) && i in currentProps
                    ? currentProps[i]
                    ? isVisible(el)
                        ? getPositionWithMargin(el)
                        : {opacity: 0}
                    : {opacity: isVisible(el) ? 1 : 0}
                    : false; });

            var propsFrom = propsTo.map(function (props, i) {

                var from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));

                if (!from) {
                    return false;
                }

                if (!props) {
                    delete from.opacity;
                } else if (!('opacity' in props)) {
                    var opacity = from.opacity;

                    if (opacity % 1) {
                        props.opacity = 1;
                    } else {
                        delete from.opacity;
                    }
                }

                return from;
            });

            return [propsTo, propsFrom];
        }

        function reset(el) {
            css(el.children, {
                height: '',
                left: '',
                opacity: '',
                pointerEvents: '',
                position: '',
                top: '',
                marginTop: '',
                marginLeft: '',
                transform: '',
                width: '',
                zIndex: ''
            });
            css(el, {height: '', display: '', padding: ''});
        }

        function getPositionWithMargin(el) {
            var ref = offset(el);
            var height = ref.height;
            var width = ref.width;
            var ref$1 = position(el);
            var top = ref$1.top;
            var left = ref$1.left;
            var ref$2 = css(el, ['marginTop', 'marginLeft']);
            var marginLeft = ref$2.marginLeft;
            var marginTop = ref$2.marginTop;

            return {top: top, left: left, height: height, width: width, marginLeft: marginLeft, marginTop: marginTop, transform: ''};
        }

        var Animate = {

            props: {
                duration: Number,
                animation: Boolean
            },

            data: {
                duration: 150,
                animation: 'slide'
            },

            methods: {

                animate: function(action, target) {
                    var this$1$1 = this;
                    if ( target === void 0 ) target = this.$el;


                    var name = this.animation;
                    var animationFn = name === 'fade'
                        ? fade
                        : name === 'delayed-fade'
                            ? function () {
                                var args = [], len = arguments.length;
                                while ( len-- ) args[ len ] = arguments[ len ];

                                return fade.apply(void 0, args.concat( [40] ));
                    }
                            : !name
                                ? function () {
                                    action();
                                    return Promise$1.resolve();
                                }
                                : slide;

                    return animationFn(action, target, this.duration)
                        .then(function () { return this$1$1.$update(target, 'resize'); }, noop);
                }

            }
        };

        var filter = {

            mixins: [Animate],

            args: 'target',

            props: {
                target: Boolean,
                selActive: Boolean
            },

            data: {
                target: null,
                selActive: false,
                attrItem: 'uk-filter-control',
                cls: 'uk-active',
                duration: 250
            },

            computed: {

                toggles: {

                    get: function(ref, $el) {
                        var attrItem = ref.attrItem;

                        return $$(("[" + attrItem + "],[data-" + attrItem + "]"), $el);
                    },

                    watch: function() {
                        var this$1$1 = this;


                        this.updateState();

                        if (this.selActive !== false) {
                            var actives = $$(this.selActive, this.$el);
                            this.toggles.forEach(function (el) { return toggleClass(el, this$1$1.cls, includes(actives, el)); });
                        }

                    },

                    immediate: true

                },

                children: {

                    get: function(ref, $el) {
                        var target = ref.target;

                        return $$((target + " > *"), $el);
                    },

                    watch: function(list, old) {
                        if (old && !isEqualList(list, old)) {
                            this.updateState();
                        }
                    },

                    immediate: true

                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]");
                    },

                    handler: function(e) {

                        e.preventDefault();
                        this.apply(e.current);

                    }

                }

            ],

            methods: {

                apply: function(el) {
                    var prevState = this.getState();
                    var newState = mergeState(el, this.attrItem, this.getState());

                    if (!isEqualState(prevState, newState)) {
                        this.setState(newState);
                    }
                },

                getState: function() {
                    var this$1$1 = this;

                    return this.toggles
                        .filter(function (item) { return hasClass(item, this$1$1.cls); })
                        .reduce(function (state, el) { return mergeState(el, this$1$1.attrItem, state); }, {filter: {'': ''}, sort: []});
                },

                setState: function(state, animate) {
                    var this$1$1 = this;
                    if ( animate === void 0 ) animate = true;


                    state = assign({filter: {'': ''}, sort: []}, state);

                    trigger(this.$el, 'beforeFilter', [this, state]);

                    this.toggles.forEach(function (el) { return toggleClass(el, this$1$1.cls, !!matchFilter(el, this$1$1.attrItem, state)); });

                    Promise$1.all($$(this.target, this.$el).map(function (target) {
                        var filterFn = function () {
                            applyState(state, target, children(target));
                            this$1$1.$update(this$1$1.$el);
                        };
                        return animate ? this$1$1.animate(filterFn, target) : filterFn();
                    })).then(function () { return trigger(this$1$1.$el, 'afterFilter', [this$1$1]); });

                },

                updateState: function() {
                    var this$1$1 = this;

                    fastdom.write(function () { return this$1$1.setState(this$1$1.getState(), false); });
                }

            }

        };

        function getFilter(el, attr) {
            return parseOptions(data(el, attr), ['filter']);
        }

        function isEqualState(stateA, stateB) {
            return ['filter', 'sort'].every(function (prop) { return isEqual(stateA[prop], stateB[prop]); });
        }

        function applyState(state, target, children) {
            var selector = getSelector(state);

            children.forEach(function (el) { return css(el, 'display', selector && !matches(el, selector) ? 'none' : ''); });

            var ref = state.sort;
            var sort = ref[0];
            var order = ref[1];

            if (sort) {
                var sorted = sortItems(children, sort, order);
                if (!isEqual(sorted, children)) {
                    append(target, sorted);
                }
            }
        }

        function mergeState(el, attr, state) {

            var filterBy = getFilter(el, attr);
            var filter = filterBy.filter;
            var group = filterBy.group;
            var sort = filterBy.sort;
            var order = filterBy.order; if ( order === void 0 ) order = 'asc';

            if (filter || isUndefined(sort)) {

                if (group) {

                    if (filter) {
                        delete state.filter[''];
                        state.filter[group] = filter;
                    } else {
                        delete state.filter[group];

                        if (isEmpty(state.filter) || '' in state.filter) {
                            state.filter = {'': filter || ''};
                        }

                    }

                } else {
                    state.filter = {'': filter || ''};
                }

            }

            if (!isUndefined(sort)) {
                state.sort = [sort, order];
            }

            return state;
        }

        function matchFilter(el, attr, ref) {
            var stateFilter = ref.filter; if ( stateFilter === void 0 ) stateFilter = {'': ''};
            var ref_sort = ref.sort;
            var stateSort = ref_sort[0];
            var stateOrder = ref_sort[1];


            var ref$1 = getFilter(el, attr);
            var filter = ref$1.filter; if ( filter === void 0 ) filter = '';
            var group = ref$1.group; if ( group === void 0 ) group = '';
            var sort = ref$1.sort;
            var order = ref$1.order; if ( order === void 0 ) order = 'asc';

            return isUndefined(sort)
                ? group in stateFilter && filter === stateFilter[group]
                    || !filter && group && !(group in stateFilter) && !stateFilter['']
                : stateSort === sort && stateOrder === order;
        }

        function isEqualList(listA, listB) {
            return listA.length === listB.length
                && listA.every(function (el) { return ~listB.indexOf(el); });
        }

        function getSelector(ref) {
            var filter = ref.filter;

            var selector = '';
            each(filter, function (value) { return selector += value || ''; });
            return selector;
        }

        function sortItems(nodes, sort, order) {
            return assign([], nodes).sort(function (a, b) { return data(a, sort).localeCompare(data(b, sort), undefined, {numeric: true}) * (order === 'asc' || -1); });
        }

        var Animations$2 = {

            slide: {

                show: function(dir) {
                    return [
                        {transform: translate(dir * -100)},
                        {transform: translate()}
                    ];
                },

                percent: function(current) {
                    return translated(current);
                },

                translate: function(percent, dir) {
                    return [
                        {transform: translate(dir * -100 * percent)},
                        {transform: translate(dir * 100 * (1 - percent))}
                    ];
                }

            }

        };

        function translated(el) {
            return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;
        }

        function translate(value, unit) {
            if ( value === void 0 ) value = 0;
            if ( unit === void 0 ) unit = '%';

            value += value ? unit : '';
            return isIE ? ("translateX(" + value + ")") : ("translate3d(" + value + ", 0, 0)"); // currently not translate3d in IE, translate3d within translate3d does not work while transitioning
        }

        function scale3d(value) {
            return ("scale3d(" + value + ", " + value + ", 1)");
        }

        var Animations$1 = assign({}, Animations$2, {

            fade: {

                show: function() {
                    return [
                        {opacity: 0},
                        {opacity: 1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent},
                        {opacity: percent}
                    ];
                }

            },

            scale: {

                show: function() {
                    return [
                        {opacity: 0, transform: scale3d(1 - .2)},
                        {opacity: 1, transform: scale3d(1)}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, transform: scale3d(1 - .2 * percent)},
                        {opacity: percent, transform: scale3d(1 - .2 + .2 * percent)}
                    ];
                }

            }

        });

        function Transitioner$1(prev, next, dir, ref) {
            var animation = ref.animation;
            var easing = ref.easing;


            var percent = animation.percent;
            var translate = animation.translate;
            var show = animation.show; if ( show === void 0 ) show = noop;
            var props = show(dir);
            var deferred = new Deferred();

            return {

                dir: dir,

                show: function(duration, percent, linear) {
                    var this$1$1 = this;
                    if ( percent === void 0 ) percent = 0;


                    var timing = linear ? 'linear' : easing;
                    duration -= Math.round(duration * clamp(percent, -1, 1));

                    this.translate(percent);

                    triggerUpdate$1(next, 'itemin', {percent: percent, duration: duration, timing: timing, dir: dir});
                    triggerUpdate$1(prev, 'itemout', {percent: 1 - percent, duration: duration, timing: timing, dir: dir});

                    Promise$1.all([
                        Transition.start(next, props[1], duration, timing),
                        Transition.start(prev, props[0], duration, timing)
                    ]).then(function () {
                        this$1$1.reset();
                        deferred.resolve();
                    }, noop);

                    return deferred.promise;
                },

                cancel: function() {
                    Transition.cancel([next, prev]);
                },

                reset: function() {
                    for (var prop in props[0]) {
                        css([next, prev], prop, '');
                    }
                },

                forward: function(duration, percent) {
                    if ( percent === void 0 ) percent = this.percent();

                    Transition.cancel([next, prev]);
                    return this.show(duration, percent, true);
                },

                translate: function(percent) {

                    this.reset();

                    var props = translate(percent, dir);
                    css(next, props[1]);
                    css(prev, props[0]);
                    triggerUpdate$1(next, 'itemtranslatein', {percent: percent, dir: dir});
                    triggerUpdate$1(prev, 'itemtranslateout', {percent: 1 - percent, dir: dir});

                },

                percent: function() {
                    return percent(prev || next, next, dir);
                },

                getDistance: function() {
                    return prev && prev.offsetWidth;
                }

            };

        }

        function triggerUpdate$1(el, type, data) {
            trigger(el, createEvent(type, false, false, data));
        }

        var SliderAutoplay = {

            props: {
                autoplay: Boolean,
                autoplayInterval: Number,
                pauseOnHover: Boolean
            },

            data: {
                autoplay: false,
                autoplayInterval: 7000,
                pauseOnHover: true
            },

            connected: function() {
                this.autoplay && this.startAutoplay();
            },

            disconnected: function() {
                this.stopAutoplay();
            },

            update: function() {
                attr(this.slides, 'tabindex', '-1');
            },

            events: [

                {

                    name: 'visibilitychange',

                    el: function() {
                        return document;
                    },

                    filter: function() {
                        return this.autoplay;
                    },

                    handler: function() {
                        if (document.hidden) {
                            this.stopAutoplay();
                        } else {
                            this.startAutoplay();
                        }
                    }

                }

            ],

            methods: {

                startAutoplay: function() {
                    var this$1$1 = this;


                    this.stopAutoplay();

                    this.interval = setInterval(
                        function () { return (!this$1$1.draggable || !$(':focus', this$1$1.$el))
                            && (!this$1$1.pauseOnHover || !matches(this$1$1.$el, ':hover'))
                            && !this$1$1.stack.length
                            && this$1$1.show('next'); },
                        this.autoplayInterval
                    );

                },

                stopAutoplay: function() {
                    this.interval && clearInterval(this.interval);
                }

            }

        };

        var SliderDrag = {

            props: {
                draggable: Boolean
            },

            data: {
                draggable: true,
                threshold: 10
            },

            created: function() {
                var this$1$1 = this;


                ['start', 'move', 'end'].forEach(function (key) {

                    var fn = this$1$1[key];
                    this$1$1[key] = function (e) {

                        var pos = getEventPos(e).x * (isRtl ? -1 : 1);

                        this$1$1.prevPos = pos !== this$1$1.pos ? this$1$1.pos : this$1$1.prevPos;
                        this$1$1.pos = pos;

                        fn(e);
                    };

                });

            },

            events: [

                {

                    name: pointerDown,

                    delegate: function() {
                        return this.selSlides;
                    },

                    handler: function(e) {

                        if (!this.draggable
                            || !isTouch(e) && hasTextNodesOnly(e.target)
                            || closest(e.target, selInput)
                            || e.button > 0
                            || this.length < 2
                        ) {
                            return;
                        }

                        this.start(e);
                    }

                },

                {
                    name: 'dragstart',

                    handler: function(e) {
                        e.preventDefault();
                    }
                }

            ],

            methods: {

                start: function() {

                    this.drag = this.pos;

                    if (this._transitioner) {

                        this.percent = this._transitioner.percent();
                        this.drag += this._transitioner.getDistance() * this.percent * this.dir;

                        this._transitioner.cancel();
                        this._transitioner.translate(this.percent);

                        this.dragging = true;

                        this.stack = [];

                    } else {
                        this.prevIndex = this.index;
                    }

                    on(document, pointerMove, this.move, {passive: false});

                    // 'input' event is triggered by video controls
                    on(document, (pointerUp + " " + pointerCancel + " input"), this.end, true);

                    css(this.list, 'userSelect', 'none');

                },

                move: function(e) {
                    var this$1$1 = this;


                    var distance = this.pos - this.drag;

                    if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {
                        return;
                    }

                    // prevent click event
                    css(this.list, 'pointerEvents', 'none');

                    e.cancelable && e.preventDefault();

                    this.dragging = true;
                    this.dir = (distance < 0 ? 1 : -1);

                    var ref = this;
                    var slides = ref.slides;
                    var ref$1 = this;
                    var prevIndex = ref$1.prevIndex;
                    var dis = Math.abs(distance);
                    var nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
                    var width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

                    while (nextIndex !== prevIndex && dis > width) {

                        this.drag -= width * this.dir;

                        prevIndex = nextIndex;
                        dis -= width;
                        nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
                        width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

                    }

                    this.percent = dis / width;

                    var prev = slides[prevIndex];
                    var next = slides[nextIndex];
                    var changed = this.index !== nextIndex;
                    var edge = prevIndex === nextIndex;

                    var itemShown;

                    [this.index, this.prevIndex].filter(function (i) { return !includes([nextIndex, prevIndex], i); }).forEach(function (i) {
                        trigger(slides[i], 'itemhidden', [this$1$1]);

                        if (edge) {
                            itemShown = true;
                            this$1$1.prevIndex = prevIndex;
                        }

                    });

                    if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
                        trigger(slides[this.index], 'itemshown', [this]);
                    }

                    if (changed) {
                        this.prevIndex = prevIndex;
                        this.index = nextIndex;

                        !edge && trigger(prev, 'beforeitemhide', [this]);
                        trigger(next, 'beforeitemshow', [this]);
                    }

                    this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);

                    if (changed) {
                        !edge && trigger(prev, 'itemhide', [this]);
                        trigger(next, 'itemshow', [this]);
                    }

                },

                end: function() {

                    off(document, pointerMove, this.move, {passive: false});
                    off(document, (pointerUp + " " + pointerCancel + " input"), this.end, true);

                    if (this.dragging) {

                        this.dragging = null;

                        if (this.index === this.prevIndex) {
                            this.percent = 1 - this.percent;
                            this.dir *= -1;
                            this._show(false, this.index, true);
                            this._transitioner = null;
                        } else {

                            var dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;
                            this.index = dirChange ? this.index : this.prevIndex;

                            if (dirChange) {
                                this.percent = 1 - this.percent;
                            }

                            this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);
                        }

                    }

                    css(this.list, {userSelect: '', pointerEvents: ''});

                    this.drag
                        = this.percent
                        = null;

                }

            }

        };

        function hasTextNodesOnly(el) {
            return !el.children.length && el.childNodes.length;
        }

        var SliderNav = {

            data: {
                selNav: false
            },

            computed: {

                nav: function(ref, $el) {
                    var selNav = ref.selNav;

                    return $(selNav, $el);
                },

                selNavItem: function(ref) {
                    var attrItem = ref.attrItem;

                    return ("[" + attrItem + "],[data-" + attrItem + "]");
                },

                navItems: function(_, $el) {
                    return $$(this.selNavItem, $el);
                }

            },

            update: {

                write: function() {
                    var this$1$1 = this;


                    if (this.nav && this.length !== this.nav.children.length) {
                        html(this.nav, this.slides.map(function (_, i) { return ("<li " + (this$1$1.attrItem) + "=\"" + i + "\"><a href></a></li>"); }).join(''));
                    }

                    this.navItems.concat(this.nav).forEach(function (el) { return el && (el.hidden = !this$1$1.maxIndex); });

                    this.updateNav();

                },

                events: ['resize']

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selNavItem;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(data(e.current, this.attrItem));
                    }

                },

                {

                    name: 'itemshow',
                    handler: 'updateNav'

                }

            ],

            methods: {

                updateNav: function() {
                    var this$1$1 = this;


                    var i = this.getValidIndex();
                    this.navItems.forEach(function (el) {

                        var cmd = data(el, this$1$1.attrItem);

                        toggleClass(el, this$1$1.clsActive, toNumber(cmd) === i);
                        toggleClass(el, 'uk-invisible', this$1$1.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this$1$1.maxIndex));
                    });

                }

            }

        };

        var Slider = {

            mixins: [SliderAutoplay, SliderDrag, SliderNav],

            props: {
                clsActivated: Boolean,
                easing: String,
                index: Number,
                finite: Boolean,
                velocity: Number,
                selSlides: String
            },

            data: function () { return ({
                easing: 'ease',
                finite: false,
                velocity: 1,
                index: 0,
                prevIndex: -1,
                stack: [],
                percent: 0,
                clsActive: 'uk-active',
                clsActivated: false,
                Transitioner: false,
                transitionOptions: {}
            }); },

            connected: function() {
                this.prevIndex = -1;
                this.index = this.getValidIndex(this.$props.index);
                this.stack = [];
            },

            disconnected: function() {
                removeClass(this.slides, this.clsActive);
            },

            computed: {

                duration: function(ref, $el) {
                    var velocity = ref.velocity;

                    return speedUp($el.offsetWidth / velocity);
                },

                list: function(ref, $el) {
                    var selList = ref.selList;

                    return $(selList, $el);
                },

                maxIndex: function() {
                    return this.length - 1;
                },

                selSlides: function(ref) {
                    var selList = ref.selList;
                    var selSlides = ref.selSlides;

                    return (selList + " " + (selSlides || '> *'));
                },

                slides: {

                    get: function() {
                        return $$(this.selSlides, this.$el);
                    },

                    watch: function() {
                        this.$reset();
                    }

                },

                length: function() {
                    return this.slides.length;
                }

            },

            events: {

                itemshown: function() {
                    this.$update(this.list);
                }

            },

            methods: {

                show: function(index, force) {
                    var this$1$1 = this;
                    if ( force === void 0 ) force = false;


                    if (this.dragging || !this.length) {
                        return;
                    }

                    var ref = this;
                    var stack = ref.stack;
                    var queueIndex = force ? 0 : stack.length;
                    var reset = function () {
                        stack.splice(queueIndex, 1);

                        if (stack.length) {
                            this$1$1.show(stack.shift(), true);
                        }
                    };

                    stack[force ? 'unshift' : 'push'](index);

                    if (!force && stack.length > 1) {

                        if (stack.length === 2) {
                            this._transitioner.forward(Math.min(this.duration, 200));
                        }

                        return;
                    }

                    var prevIndex = this.getIndex(this.index);
                    var prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
                    var nextIndex = this.getIndex(index, this.index);
                    var next = this.slides[nextIndex];

                    if (prev === next) {
                        reset();
                        return;
                    }

                    this.dir = getDirection(index, prevIndex);
                    this.prevIndex = prevIndex;
                    this.index = nextIndex;

                    if (prev && !trigger(prev, 'beforeitemhide', [this])
                        || !trigger(next, 'beforeitemshow', [this, prev])
                    ) {
                        this.index = this.prevIndex;
                        reset();
                        return;
                    }

                    var promise = this._show(prev, next, force).then(function () {

                        prev && trigger(prev, 'itemhidden', [this$1$1]);
                        trigger(next, 'itemshown', [this$1$1]);

                        return new Promise$1(function (resolve) {
                            fastdom.write(function () {
                                stack.shift();
                                if (stack.length) {
                                    this$1$1.show(stack.shift(), true);
                                } else {
                                    this$1$1._transitioner = null;
                                }
                                resolve();
                            });
                        });

                    });

                    prev && trigger(prev, 'itemhide', [this]);
                    trigger(next, 'itemshow', [this]);

                    return promise;

                },

                getIndex: function(index, prev) {
                    if ( index === void 0 ) index = this.index;
                    if ( prev === void 0 ) prev = this.index;

                    return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);
                },

                getValidIndex: function(index, prevIndex) {
                    if ( index === void 0 ) index = this.index;
                    if ( prevIndex === void 0 ) prevIndex = this.prevIndex;

                    return this.getIndex(index, prevIndex);
                },

                _show: function(prev, next, force) {

                    this._transitioner = this._getTransitioner(
                        prev,
                        next,
                        this.dir,
                        assign({
                            easing: force
                                ? next.offsetWidth < 600
                                    ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */
                                    : 'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */
                                : this.easing
                        }, this.transitionOptions)
                    );

                    if (!force && !prev) {
                        this._translate(1);
                        return Promise$1.resolve();
                    }

                    var ref = this.stack;
                    var length = ref.length;
                    return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);

                },

                _getDistance: function(prev, next) {
                    return this._getTransitioner(prev, prev !== next && next).getDistance();
                },

                _translate: function(percent, prev, next) {
                    if ( prev === void 0 ) prev = this.prevIndex;
                    if ( next === void 0 ) next = this.index;

                    var transitioner = this._getTransitioner(prev !== next ? prev : false, next);
                    transitioner.translate(percent);
                    return transitioner;
                },

                _getTransitioner: function(prev, next, dir, options) {
                    if ( prev === void 0 ) prev = this.prevIndex;
                    if ( next === void 0 ) next = this.index;
                    if ( dir === void 0 ) dir = this.dir || 1;
                    if ( options === void 0 ) options = this.transitionOptions;

                    return new this.Transitioner(
                        isNumber(prev) ? this.slides[prev] : prev,
                        isNumber(next) ? this.slides[next] : next,
                        dir * (isRtl ? -1 : 1),
                        options
                    );
                }

            }

        };

        function getDirection(index, prevIndex) {
            return index === 'next'
                ? 1
                : index === 'previous'
                    ? -1
                    : index < prevIndex
                        ? -1
                        : 1;
        }

        function speedUp(x) {
            return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)
        }

        var Slideshow = {

            mixins: [Slider],

            props: {
                animation: String
            },

            data: {
                animation: 'slide',
                clsActivated: 'uk-transition-active',
                Animations: Animations$2,
                Transitioner: Transitioner$1
            },

            computed: {

                animation: function(ref) {
                    var animation = ref.animation;
                    var Animations = ref.Animations;

                    return assign(Animations[animation] || Animations.slide, {name: animation});
                },

                transitionOptions: function() {
                    return {animation: this.animation};
                }

            },

            events: {

                'itemshow itemhide itemshown itemhidden': function(ref) {
                    var target = ref.target;

                    this.$update(target);
                },

                beforeitemshow: function(ref) {
                    var target = ref.target;

                    addClass(target, this.clsActive);
                },

                itemshown: function(ref) {
                    var target = ref.target;

                    addClass(target, this.clsActivated);
                },

                itemhidden: function(ref) {
                    var target = ref.target;

                    removeClass(target, this.clsActive, this.clsActivated);
                }

            }

        };

        var LightboxPanel = {

            mixins: [Container, Modal, Togglable, Slideshow],

            functional: true,

            props: {
                delayControls: Number,
                preload: Number,
                videoAutoplay: Boolean,
                template: String
            },

            data: function () { return ({
                preload: 1,
                videoAutoplay: false,
                delayControls: 3000,
                items: [],
                cls: 'uk-open',
                clsPage: 'uk-lightbox-page',
                selList: '.uk-lightbox-items',
                attrItem: 'uk-lightbox-item',
                selClose: '.uk-close-large',
                selCaption: '.uk-lightbox-caption',
                pauseOnHover: false,
                velocity: 2,
                Animations: Animations$1,
                template: "<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>"
            }); },

            created: function() {

                var $el = $(this.template);
                var list = $(this.selList, $el);
                this.items.forEach(function () { return append(list, '<li>'); });

                this.$mount(append(this.container, $el));

            },

            computed: {

                caption: function(ref, $el) {
                    var selCaption = ref.selCaption;

                    return $(selCaption, $el);
                }

            },

            events: [

                {

                    name: (pointerMove + " " + pointerDown + " keydown"),

                    handler: 'showControls'

                },

                {

                    name: 'click',

                    self: true,

                    delegate: function() {
                        return this.selSlides;
                    },

                    handler: function(e) {

                        if (e.defaultPrevented) {
                            return;
                        }

                        this.hide();
                    }

                },

                {

                    name: 'shown',

                    self: true,

                    handler: function() {
                        this.showControls();
                    }

                },

                {

                    name: 'hide',

                    self: true,

                    handler: function() {

                        this.hideControls();

                        removeClass(this.slides, this.clsActive);
                        Transition.stop(this.slides);

                    }
                },

                {

                    name: 'hidden',

                    self: true,

                    handler: function() {
                        this.$destroy(true);
                    }

                },

                {

                    name: 'keyup',

                    el: function() {
                        return document;
                    },

                    handler: function(e) {

                        if (!this.isToggled(this.$el) || !this.draggable) {
                            return;
                        }

                        switch (e.keyCode) {
                            case 37:
                                this.show('previous');
                                break;
                            case 39:
                                this.show('next');
                                break;
                        }
                    }
                },

                {

                    name: 'beforeitemshow',

                    handler: function(e) {

                        if (this.isToggled()) {
                            return;
                        }

                        this.draggable = false;

                        e.preventDefault();

                        this.toggleElement(this.$el, true, false);

                        this.animation = Animations$1['scale'];
                        removeClass(e.target, this.clsActive);
                        this.stack.splice(1, 0, this.index);

                    }

                },

                {

                    name: 'itemshow',

                    handler: function() {

                        html(this.caption, this.getItem().caption || '');

                        for (var j = -this.preload; j <= this.preload; j++) {
                            this.loadItem(this.index + j);
                        }

                    }

                },

                {

                    name: 'itemshown',

                    handler: function() {
                        this.draggable = this.$props.draggable;
                    }

                },

                {

                    name: 'itemload',

                    handler: function(_, item) {
                        var this$1$1 = this;


                        var src = item.source;
                        var type = item.type;
                        var alt = item.alt; if ( alt === void 0 ) alt = '';
                        var poster = item.poster;
                        var attrs = item.attrs; if ( attrs === void 0 ) attrs = {};

                        this.setItem(item, '<span uk-spinner></span>');

                        if (!src) {
                            return;
                        }

                        var matches;
                        var iframeAttrs = {
                            frameborder: '0',
                            allow: 'autoplay',
                            allowfullscreen: '',
                            style: 'max-width: 100%; box-sizing: border-box;',
                            'uk-responsive': '',
                            'uk-video': ("" + (this.videoAutoplay))
                        };

                        // Image
                        if (type === 'image' || src.match(/\.(avif|jpe?g|a?png|gif|svg|webp)($|\?)/i)) {

                            getImage(src, attrs.srcset, attrs.size).then(
                                function (ref) {
                                    var width = ref.width;
                                    var height = ref.height;

                                    return this$1$1.setItem(item, createEl('img', assign({src: src, width: width, height: height, alt: alt}, attrs)));
                            },
                                function () { return this$1$1.setError(item); }
                            );

                        // Video
                        } else if (type === 'video' || src.match(/\.(mp4|webm|ogv)($|\?)/i)) {

                            var video = createEl('video', assign({
                                src: src,
                                poster: poster,
                                controls: '',
                                playsinline: '',
                                'uk-video': ("" + (this.videoAutoplay))
                            }, attrs));

                            on(video, 'loadedmetadata', function () {
                                attr(video, {width: video.videoWidth, height: video.videoHeight});
                                this$1$1.setItem(item, video);
                            });
                            on(video, 'error', function () { return this$1$1.setError(item); });

                        // Iframe
                        } else if (type === 'iframe' || src.match(/\.(html|php)($|\?)/i)) {

                            this.setItem(item, createEl('iframe', assign({
                                src: src,
                                frameborder: '0',
                                allowfullscreen: '',
                                class: 'uk-lightbox-iframe'
                            }, attrs)));

                        // YouTube
                        } else if ((matches = src.match(/\/\/(?:.*?youtube(-nocookie)?\..*?[?&]v=|youtu\.be\/)([\w-]{11})[&?]?(.*)?/))) {

                            this.setItem(item, createEl('iframe', assign({
                                src: ("https://www.youtube" + (matches[1] || '') + ".com/embed/" + (matches[2]) + (matches[3] ? ("?" + (matches[3])) : '')),
                                width: 1920,
                                height: 1080
                            }, iframeAttrs, attrs)));

                        // Vimeo
                        } else if ((matches = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/))) {

                            ajax(("https://vimeo.com/api/oembed.json?maxwidth=1920&url=" + (encodeURI(src))), {
                                responseType: 'json',
                                withCredentials: false
                            }).then(
                                function (ref) {
                                    var ref_response = ref.response;
                                    var height = ref_response.height;
                                    var width = ref_response.width;

                                    return this$1$1.setItem(item, createEl('iframe', assign({
                                    src: ("https://player.vimeo.com/video/" + (matches[1]) + (matches[2] ? ("?" + (matches[2])) : '')),
                                    width: width,
                                    height: height
                                }, iframeAttrs, attrs)));
                            },
                                function () { return this$1$1.setError(item); }
                            );

                        }

                    }

                }

            ],

            methods: {

                loadItem: function(index) {
                    if ( index === void 0 ) index = this.index;


                    var item = this.getItem(index);

                    if (!this.getSlide(item).childElementCount) {
                        trigger(this.$el, 'itemload', [item]);
                    }
                },

                getItem: function(index) {
                    if ( index === void 0 ) index = this.index;

                    return this.items[getIndex(index, this.slides)];
                },

                setItem: function(item, content) {
                    trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content) ]);
                },

                getSlide: function(item) {
                    return this.slides[this.items.indexOf(item)];
                },

                setError: function(item) {
                    this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
                },

                showControls: function() {

                    clearTimeout(this.controlsTimer);
                    this.controlsTimer = setTimeout(this.hideControls, this.delayControls);

                    addClass(this.$el, 'uk-active', 'uk-transition-active');

                },

                hideControls: function() {
                    removeClass(this.$el, 'uk-active', 'uk-transition-active');
                }

            }

        };

        function createEl(tag, attrs) {
            var el = fragment(("<" + tag + ">"));
            attr(el, attrs);
            return el;
        }

        var lightbox = {

            install: install$1,

            props: {toggle: String},

            data: {toggle: 'a'},

            computed: {

                toggles: {

                    get: function(ref, $el) {
                        var toggle = ref.toggle;

                        return $$(toggle, $el);
                    },

                    watch: function() {
                        this.hide();
                    }

                }

            },

            disconnected: function() {
                this.hide();
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.toggle) + ":not(.uk-disabled)");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(e.current);
                    }

                }

            ],

            methods: {

                show: function(index) {
                    var this$1$1 = this;


                    var items = uniqueBy(this.toggles.map(toItem), 'source');

                    if (isElement(index)) {
                        var ref = toItem(index);
                        var source = ref.source;
                        index = findIndex(items, function (ref) {
                            var src = ref.source;

                            return source === src;
                        });
                    }

                    this.panel = this.panel || this.$create('lightboxPanel', assign({}, this.$props, {items: items}));

                    on(this.panel.$el, 'hidden', function () { return this$1$1.panel = false; });

                    return this.panel.show(index);

                },

                hide: function() {

                    return this.panel && this.panel.hide();

                }

            }

        };

        function install$1(UIkit, Lightbox) {

            if (!UIkit.lightboxPanel) {
                UIkit.component('lightboxPanel', LightboxPanel);
            }

            assign(
                Lightbox.props,
                UIkit.component('lightboxPanel').options.props
            );

        }

        function toItem(el) {

            var item = {};

            ['href', 'caption', 'type', 'poster', 'alt', 'attrs'].forEach(function (attr) {
                item[attr === 'href' ? 'source' : attr] = data(el, attr);
            });

            item.attrs = parseOptions(item.attrs);

            return item;
        }

        var obj$1;

        var notification = {

            mixins: [Container],

            functional: true,

            args: ['message', 'status'],

            data: {
                message: '',
                status: '',
                timeout: 5000,
                group: null,
                pos: 'top-center',
                clsContainer: 'uk-notification',
                clsClose: 'uk-notification-close',
                clsMsg: 'uk-notification-message'
            },

            install: install,

            computed: {

                marginProp: function(ref) {
                    var pos = ref.pos;

                    return ("margin" + (startsWith(pos, 'top') ? 'Top' : 'Bottom'));
                },

                startProps: function() {
                    var obj;

                    return ( obj = {opacity: 0}, obj[this.marginProp] = -this.$el.offsetHeight, obj );
                }

            },

            created: function() {

                var container = $(("." + (this.clsContainer) + "-" + (this.pos)), this.container)
                    || append(this.container, ("<div class=\"" + (this.clsContainer) + " " + (this.clsContainer) + "-" + (this.pos) + "\" style=\"display: block\"></div>"));

                this.$mount(append(container,
                    ("<div class=\"" + (this.clsMsg) + (this.status ? (" " + (this.clsMsg) + "-" + (this.status)) : '') + "\"> <a href class=\"" + (this.clsClose) + "\" data-uk-close></a> <div>" + (this.message) + "</div> </div>")
                ));

            },

            connected: function() {
                var this$1$1 = this;
                var obj;


                var margin = toFloat(css(this.$el, this.marginProp));
                Transition.start(
                    css(this.$el, this.startProps),
                    ( obj = {opacity: 1}, obj[this.marginProp] = margin, obj )
                ).then(function () {
                    if (this$1$1.timeout) {
                        this$1$1.timer = setTimeout(this$1$1.close, this$1$1.timeout);
                    }
                });

            },

            events: ( obj$1 = {

                click: function(e) {
                    if (closest(e.target, 'a[href="#"],a[href=""]')) {
                        e.preventDefault();
                    }
                    this.close();
                }

            }, obj$1[pointerEnter] = function () {
                    if (this.timer) {
                        clearTimeout(this.timer);
                    }
                }, obj$1[pointerLeave] = function () {
                    if (this.timeout) {
                        this.timer = setTimeout(this.close, this.timeout);
                    }
                }, obj$1 ),

            methods: {

                close: function(immediate) {
                    var this$1$1 = this;


                    var removeFn = function (el) {

                        var container = parent(el);

                        trigger(el, 'close', [this$1$1]);
                        remove$1(el);

                        if (container && !container.hasChildNodes()) {
                            remove$1(container);
                        }

                    };

                    if (this.timer) {
                        clearTimeout(this.timer);
                    }

                    if (immediate) {
                        removeFn(this.$el);
                    } else {
                        Transition.start(this.$el, this.startProps).then(removeFn);
                    }
                }

            }

        };

        function install(UIkit) {
            UIkit.notification.closeAll = function (group, immediate) {
                apply$1(document.body, function (el) {
                    var notification = UIkit.getComponent(el, 'notification');
                    if (notification && (!group || group === notification.group)) {
                        notification.close(immediate);
                    }
                });
            };
        }

        var props = ['x', 'y', 'bgx', 'bgy', 'rotate', 'scale', 'color', 'backgroundColor', 'borderColor', 'opacity', 'blur', 'hue', 'grayscale', 'invert', 'saturate', 'sepia', 'fopacity', 'stroke'];

        var Parallax = {

            mixins: [Media],

            props: props.reduce(function (props, prop) {
                props[prop] = 'list';
                return props;
            }, {}),

            data: props.reduce(function (data, prop) {
                data[prop] = undefined;
                return data;
            }, {}),

            computed: {

                props: function(properties, $el) {
                    var this$1$1 = this;


                    return props.reduce(function (props, prop) {

                        if (isUndefined(properties[prop])) {
                            return props;
                        }

                        var isColor = prop.match(/color/i);
                        var isCssProp = isColor || prop === 'opacity';

                        var pos, bgPos, diff;
                        var steps = properties[prop].slice();

                        if (isCssProp) {
                            css($el, prop, '');
                        }

                        if (steps.length < 2) {
                            steps.unshift((prop === 'scale'
                                ? 1
                                : isCssProp
                                    ? css($el, prop)
                                    : 0) || 0);
                        }

                        var unit = getUnit(steps);

                        if (isColor) {

                            var ref = $el.style;
                            var color = ref.color;
                            steps = steps.map(function (step) { return parseColor($el, step); });
                            $el.style.color = color;

                        } else if (startsWith(prop, 'bg')) {

                            var attr = prop === 'bgy' ? 'height' : 'width';
                            steps = steps.map(function (step) { return toPx(step, attr, this$1$1.$el); });

                            css($el, ("background-position-" + (prop[2])), '');
                            bgPos = css($el, 'backgroundPosition').split(' ')[prop[2] === 'x' ? 0 : 1]; // IE 11 can't read background-position-[x|y]

                            if (this$1$1.covers) {

                                var min = Math.min.apply(Math, steps);
                                var max = Math.max.apply(Math, steps);
                                var down = steps.indexOf(min) < steps.indexOf(max);

                                diff = max - min;

                                steps = steps.map(function (step) { return step - (down ? min : max); });
                                pos = (down ? -diff : 0) + "px";

                            } else {

                                pos = bgPos;

                            }

                        } else {

                            steps = steps.map(toFloat);

                        }

                        if (prop === 'stroke') {

                            if (!steps.some(function (step) { return step; })) {
                                return props;
                            }

                            var length = getMaxPathLength(this$1$1.$el);
                            css($el, 'strokeDasharray', length);

                            if (unit === '%') {
                                steps = steps.map(function (step) { return step * length / 100; });
                            }

                            steps = steps.reverse();

                            prop = 'strokeDashoffset';
                        }

                        props[prop] = {steps: steps, unit: unit, pos: pos, bgPos: bgPos, diff: diff};

                        return props;

                    }, {});

                },

                bgProps: function() {
                    var this$1$1 = this;

                    return ['bgx', 'bgy'].filter(function (bg) { return bg in this$1$1.props; });
                },

                covers: function(_, $el) {
                    return covers($el);
                }

            },

            disconnected: function() {
                delete this._image;
            },

            update: {

                read: function(data) {
                    var this$1$1 = this;


                    if (!this.matchMedia) {
                        return;
                    }

                    if (!data.image && this.covers && this.bgProps.length) {
                        var src = css(this.$el, 'backgroundImage').replace(/^none|url\(["']?(.+?)["']?\)$/, '$1');

                        if (src) {
                            var img = new Image();
                            img.src = src;
                            data.image = img;

                            if (!img.naturalWidth) {
                                img.onload = function () { return this$1$1.$update(); };
                            }
                        }

                    }

                    var image = data.image;

                    if (!image || !image.naturalWidth) {
                        return;
                    }

                    var dimEl = {
                        width: this.$el.offsetWidth,
                        height: this.$el.offsetHeight
                    };
                    var dimImage = {
                        width: image.naturalWidth,
                        height: image.naturalHeight
                    };

                    var dim = Dimensions.cover(dimImage, dimEl);

                    this.bgProps.forEach(function (prop) {

                        var ref = this$1$1.props[prop];
                        var diff = ref.diff;
                        var bgPos = ref.bgPos;
                        var steps = ref.steps;
                        var attr = prop === 'bgy' ? 'height' : 'width';
                        var span = dim[attr] - dimEl[attr];

                        if (span < diff) {
                            dimEl[attr] = dim[attr] + diff - span;
                        } else if (span > diff) {

                            var posPercentage = dimEl[attr] / toPx(bgPos, attr, this$1$1.$el);

                            if (posPercentage) {
                                this$1$1.props[prop].steps = steps.map(function (step) { return step - (span - diff) / posPercentage; });
                            }
                        }

                        dim = Dimensions.cover(dimImage, dimEl);
                    });

                    data.dim = dim;
                },

                write: function(ref) {
                    var dim = ref.dim;


                    if (!this.matchMedia) {
                        css(this.$el, {backgroundSize: '', backgroundRepeat: ''});
                        return;
                    }

                    dim && css(this.$el, {
                        backgroundSize: ((dim.width) + "px " + (dim.height) + "px"),
                        backgroundRepeat: 'no-repeat'
                    });

                },

                events: ['resize']

            },

            methods: {

                reset: function() {
                    var this$1$1 = this;

                    each(this.getCss(0), function (_, prop) { return css(this$1$1.$el, prop, ''); });
                },

                getCss: function(percent) {

                    var ref = this;
                    var props = ref.props;
                    return Object.keys(props).reduce(function (css, prop) {

                        var ref = props[prop];
                        var steps = ref.steps;
                        var unit = ref.unit;
                        var pos = ref.pos;
                        var value = getValue(steps, percent);

                        switch (prop) {

                            // transforms
                            case 'x':
                            case 'y': {
                                unit = unit || 'px';
                                css.transform += " translate" + (ucfirst(prop)) + "(" + (toFloat(value).toFixed(unit === 'px' ? 0 : 2)) + unit + ")";
                                break;
                            }
                            case 'rotate':
                                unit = unit || 'deg';
                                css.transform += " rotate(" + (value + unit) + ")";
                                break;
                            case 'scale':
                                css.transform += " scale(" + value + ")";
                                break;

                            // bg image
                            case 'bgy':
                            case 'bgx':
                                css[("background-position-" + (prop[2]))] = "calc(" + pos + " + " + value + "px)";
                                break;

                            // color
                            case 'color':
                            case 'backgroundColor':
                            case 'borderColor': {

                                var ref$1 = getStep(steps, percent);
                                var start = ref$1[0];
                                var end = ref$1[1];
                                var p = ref$1[2];

                                css[prop] = "rgba(" + (start.map(function (value, i) {
                                        value = value + p * (end[i] - value);
                                        return i === 3 ? toFloat(value) : parseInt(value, 10);
                                    }).join(',')) + ")";
                                break;
                            }
                            // CSS Filter
                            case 'blur':
                                unit = unit || 'px';
                                css.filter += " blur(" + (value + unit) + ")";
                                break;
                            case 'hue':
                                unit = unit || 'deg';
                                css.filter += " hue-rotate(" + (value + unit) + ")";
                                break;
                            case 'fopacity':
                                unit = unit || '%';
                                css.filter += " opacity(" + (value + unit) + ")";
                                break;
                            case 'grayscale':
                            case 'invert':
                            case 'saturate':
                            case 'sepia':
                                unit = unit || '%';
                                css.filter += " " + prop + "(" + (value + unit) + ")";
                                break;
                            default:
                                css[prop] = value;
                        }

                        return css;

                    }, {transform: '', filter: ''});

                }

            }

        };

        function parseColor(el, color) {
            return css(css(el, 'color', color), 'color')
                .split(/[(),]/g)
                .slice(1, -1)
                .concat(1)
                .slice(0, 4)
                .map(toFloat);
        }

        function getStep(steps, percent) {
            var count = steps.length - 1;
            var index = Math.min(Math.floor(count * percent), count - 1);
            var step = steps.slice(index, index + 2);

            step.push(percent === 1 ? 1 : percent % (1 / count) * count);

            return step;
        }

        function getValue(steps, percent, digits) {
            if ( digits === void 0 ) digits = 2;

            var ref = getStep(steps, percent);
            var start = ref[0];
            var end = ref[1];
            var p = ref[2];
            return (isNumber(start)
                ? start + Math.abs(start - end) * p * (start < end ? 1 : -1)
                : +end
            ).toFixed(digits);
        }

        function getUnit(steps) {
            return steps.reduce(function (unit, step) { return isString(step) && step.replace(/-|\d/g, '').trim() || unit; }, '');
        }

        function covers(el) {
            var ref = el.style;
            var backgroundSize = ref.backgroundSize;
            var covers = css(css(el, 'backgroundSize', ''), 'backgroundSize') === 'cover';
            el.style.backgroundSize = backgroundSize;
            return covers;
        }

        var parallax = {

            mixins: [Parallax],

            props: {
                target: String,
                viewport: Number,
                easing: Number
            },

            data: {
                target: false,
                viewport: 1,
                easing: 1
            },

            computed: {

                target: function(ref, $el) {
                    var target = ref.target;

                    return getOffsetElement(target && query(target, $el) || $el);
                }

            },

            update: {

                read: function(ref, types) {
                    var percent = ref.percent;


                    if (!types.has('scroll')) {
                        percent = false;
                    }

                    if (!this.matchMedia) {
                        return;
                    }

                    var prev = percent;
                    percent = ease(scrolledOver(this.target) / (this.viewport || 1), this.easing);

                    return {
                        percent: percent,
                        style: prev !== percent ? this.getCss(percent) : false
                    };
                },

                write: function(ref) {
                    var style = ref.style;


                    if (!this.matchMedia) {
                        this.reset();
                        return;
                    }

                    style && css(this.$el, style);

                },

                events: ['scroll', 'resize']
            }

        };

        function ease(percent, easing) {
            return clamp(percent * (1 - (easing - easing * percent)));
        }

        // SVG elements do not inherit from HTMLElement
        function getOffsetElement(el) {
            return el
                ? 'offsetTop' in el
                    ? el
                    : getOffsetElement(parent(el))
                : document.body;
        }

        var SliderReactive = {

            update: {

                write: function() {

                    if (this.stack.length || this.dragging) {
                        return;
                    }

                    var index = this.getValidIndex(this.index);

                    if (!~this.prevIndex || this.index !== index) {
                        this.show(index);
                    }

                },

                events: ['resize']

            }

        };

        function Transitioner (prev, next, dir, ref) {
            var center = ref.center;
            var easing = ref.easing;
            var list = ref.list;


            var deferred = new Deferred();

            var from = prev
                ? getLeft(prev, list, center)
                : getLeft(next, list, center) + dimensions(next).width * dir;
            var to = next
                ? getLeft(next, list, center)
                : from + dimensions(prev).width * dir * (isRtl ? -1 : 1);

            return {

                dir: dir,

                show: function(duration, percent, linear) {
                    if ( percent === void 0 ) percent = 0;


                    var timing = linear ? 'linear' : easing;
                    duration -= Math.round(duration * clamp(percent, -1, 1));

                    this.translate(percent);

                    percent = prev ? percent : clamp(percent, 0, 1);
                    triggerUpdate(this.getItemIn(), 'itemin', {percent: percent, duration: duration, timing: timing, dir: dir});
                    prev && triggerUpdate(this.getItemIn(true), 'itemout', {percent: 1 - percent, duration: duration, timing: timing, dir: dir});

                    Transition
                        .start(list, {transform: translate(-to * (isRtl ? -1 : 1), 'px')}, duration, timing)
                        .then(deferred.resolve, noop);

                    return deferred.promise;

                },

                cancel: function() {
                    Transition.cancel(list);
                },

                reset: function() {
                    css(list, 'transform', '');
                },

                forward: function(duration, percent) {
                    if ( percent === void 0 ) percent = this.percent();

                    Transition.cancel(list);
                    return this.show(duration, percent, true);
                },

                translate: function(percent) {

                    var distance = this.getDistance() * dir * (isRtl ? -1 : 1);

                    css(list, 'transform', translate(clamp(
                        -to + (distance - distance * percent),
                        -getWidth(list),
                        dimensions(list).width
                    ) * (isRtl ? -1 : 1), 'px'));

                    var actives = this.getActives();
                    var itemIn = this.getItemIn();
                    var itemOut = this.getItemIn(true);

                    percent = prev ? clamp(percent, -1, 1) : 0;

                    children(list).forEach(function (slide) {
                        var isActive = includes(actives, slide);
                        var isIn = slide === itemIn;
                        var isOut = slide === itemOut;
                        var translateIn = isIn || !isOut && (isActive || dir * (isRtl ? -1 : 1) === -1 ^ getElLeft(slide, list) > getElLeft(prev || next));

                        triggerUpdate(slide, ("itemtranslate" + (translateIn ? 'in' : 'out')), {
                            dir: dir,
                            percent: isOut
                                ? 1 - percent
                                : isIn
                                    ? percent
                                    : isActive
                                        ? 1
                                        : 0
                        });
                    });

                },

                percent: function() {
                    return Math.abs((css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));
                },

                getDistance: function() {
                    return Math.abs(to - from);
                },

                getItemIn: function(out) {
                    if ( out === void 0 ) out = false;


                    var actives = this.getActives();
                    var nextActives = inView(list, getLeft(next || prev, list, center));

                    if (out) {
                        var temp = actives;
                        actives = nextActives;
                        nextActives = temp;
                    }

                    return nextActives[findIndex(nextActives, function (el) { return !includes(actives, el); })];

                },

                getActives: function() {
                    return inView(list, getLeft(prev || next, list, center));
                }

            };

        }

        function getLeft(el, list, center) {

            var left = getElLeft(el, list);

            return center
                ? left - centerEl(el, list)
                : Math.min(left, getMax(list));

        }

        function getMax(list) {
            return Math.max(0, getWidth(list) - dimensions(list).width);
        }

        function getWidth(list) {
            return children(list).reduce(function (right, el) { return dimensions(el).width + right; }, 0);
        }

        function centerEl(el, list) {
            return dimensions(list).width / 2 - dimensions(el).width / 2;
        }

        function getElLeft(el, list) {
            return el && (position(el).left + (isRtl ? dimensions(el).width - dimensions(list).width : 0)) * (isRtl ? -1 : 1) || 0;
        }

        function inView(list, listLeft) {

            listLeft -= 1;
            var listWidth = dimensions(list).width;
            var listRight = listLeft + listWidth + 2;

            return children(list).filter(function (slide) {
                var slideLeft = getElLeft(slide, list);
                var slideRight = slideLeft + Math.min(dimensions(slide).width, listWidth);

                return slideLeft >= listLeft && slideRight <= listRight;
            });
        }

        function triggerUpdate(el, type, data) {
            trigger(el, createEvent(type, false, false, data));
        }

        var slider = {

            mixins: [Class, Slider, SliderReactive],

            props: {
                center: Boolean,
                sets: Boolean
            },

            data: {
                center: false,
                sets: false,
                attrItem: 'uk-slider-item',
                selList: '.uk-slider-items',
                selNav: '.uk-slider-nav',
                clsContainer: 'uk-slider-container',
                Transitioner: Transitioner
            },

            computed: {

                avgWidth: function() {
                    return getWidth(this.list) / this.length;
                },

                finite: function(ref) {
                    var finite = ref.finite;

                    return finite || Math.ceil(getWidth(this.list)) < dimensions(this.list).width + getMaxElWidth(this.list) + this.center;
                },

                maxIndex: function() {

                    if (!this.finite || this.center && !this.sets) {
                        return this.length - 1;
                    }

                    if (this.center) {
                        return last(this.sets);
                    }

                    var lft = 0;
                    var max = getMax(this.list);
                    var index = findIndex(this.slides, function (el) {

                        if (lft >= max) {
                            return true;
                        }

                        lft += dimensions(el).width;

                    });

                    return ~index ? index : this.length - 1;
                },

                sets: function(ref) {
                    var this$1$1 = this;
                    var sets = ref.sets;


                    if (!sets) {
                        return;
                    }

                    var width = dimensions(this.list).width / (this.center ? 2 : 1);

                    var left = 0;
                    var leftCenter = width;
                    var slideLeft = 0;

                    sets = sortBy$1(this.slides, 'offsetLeft').reduce(function (sets, slide, i) {

                        var slideWidth = dimensions(slide).width;
                        var slideRight = slideLeft + slideWidth;

                        if (slideRight > left) {

                            if (!this$1$1.center && i > this$1$1.maxIndex) {
                                i = this$1$1.maxIndex;
                            }

                            if (!includes(sets, i)) {

                                var cmp = this$1$1.slides[i + 1];
                                if (this$1$1.center && cmp && slideWidth < leftCenter - dimensions(cmp).width / 2) {
                                    leftCenter -= slideWidth;
                                } else {
                                    leftCenter = width;
                                    sets.push(i);
                                    left = slideLeft + width + (this$1$1.center ? slideWidth / 2 : 0);
                                }

                            }
                        }

                        slideLeft += slideWidth;

                        return sets;

                    }, []);

                    return !isEmpty(sets) && sets;

                },

                transitionOptions: function() {
                    return {
                        center: this.center,
                        list: this.list
                    };
                }

            },

            connected: function() {
                toggleClass(this.$el, this.clsContainer, !$(("." + (this.clsContainer)), this.$el));
            },

            update: {

                write: function() {
                    var this$1$1 = this;

                    this.navItems.forEach(function (el) {
                        var index = toNumber(data(el, this$1$1.attrItem));
                        if (index !== false) {
                            el.hidden = !this$1$1.maxIndex || index > this$1$1.maxIndex || this$1$1.sets && !includes(this$1$1.sets, index);
                        }
                    });

                    if (this.length && !this.dragging && !this.stack.length) {
                        this.reorder();
                        this._translate(1);
                    }

                    var actives = this._getTransitioner(this.index).getActives();
                    this.slides.forEach(function (slide) { return toggleClass(slide, this$1$1.clsActive, includes(actives, slide)); });

                    if (this.clsActivated && (!this.sets || includes(this.sets, toFloat(this.index)))) {
                        this.slides.forEach(function (slide) { return toggleClass(slide, this$1$1.clsActivated || '', includes(actives, slide)); });
                    }
                },

                events: ['resize']

            },

            events: {

                beforeitemshow: function(e) {

                    if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) {
                        this.index = this.getValidIndex();
                    }

                    var diff = Math.abs(
                        this.index
                        - this.prevIndex
                        + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)
                    );

                    if (!this.dragging && diff > 1) {

                        for (var i = 0; i < diff; i++) {
                            this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');
                        }

                        e.preventDefault();
                        return;
                    }

                    var index = this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;
                    this.duration = speedUp(this.avgWidth / this.velocity) * (dimensions(this.slides[index]).width / this.avgWidth);

                    this.reorder();

                },

                itemshow: function() {
                    if (~this.prevIndex) {
                        addClass(this._getTransitioner().getItemIn(), this.clsActive);
                    }
                }

            },

            methods: {

                reorder: function() {
                    var this$1$1 = this;


                    if (this.finite) {
                        css(this.slides, 'order', '');
                        return;
                    }

                    var index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;

                    this.slides.forEach(function (slide, i) { return css(slide, 'order', this$1$1.dir > 0 && i < index
                            ? 1
                            : this$1$1.dir < 0 && i >= this$1$1.index
                                ? -1
                                : ''
                        ); }
                    );

                    if (!this.center) {
                        return;
                    }

                    var next = this.slides[index];
                    var width = dimensions(this.list).width / 2 - dimensions(next).width / 2;
                    var j = 0;

                    while (width > 0) {
                        var slideIndex = this.getIndex(--j + index, index);
                        var slide = this.slides[slideIndex];

                        css(slide, 'order', slideIndex > index ? -2 : -1);
                        width -= dimensions(slide).width;
                    }

                },

                getValidIndex: function(index, prevIndex) {
                    if ( index === void 0 ) index = this.index;
                    if ( prevIndex === void 0 ) prevIndex = this.prevIndex;


                    index = this.getIndex(index, prevIndex);

                    if (!this.sets) {
                        return index;
                    }

                    var prev;

                    do {

                        if (includes(this.sets, index)) {
                            return index;
                        }

                        prev = index;
                        index = this.getIndex(index + this.dir, prevIndex);

                    } while (index !== prev);

                    return index;
                }

            }

        };

        function getMaxElWidth(list) {
            return Math.max.apply(Math, [ 0 ].concat( children(list).map(function (el) { return dimensions(el).width; }) ));
        }

        var sliderParallax = {

            mixins: [Parallax],

            data: {
                selItem: '!li'
            },

            computed: {

                item: function(ref, $el) {
                    var selItem = ref.selItem;

                    return query(selItem, $el);
                }

            },

            events: [

                {
                    name: 'itemin itemout',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function(ref) {
                        var this$1$1 = this;
                        var type = ref.type;
                        var ref_detail = ref.detail;
                        var percent = ref_detail.percent;
                        var duration = ref_detail.duration;
                        var timing = ref_detail.timing;
                        var dir = ref_detail.dir;


                        fastdom.read(function () {
                            var propsFrom = this$1$1.getCss(getCurrentPercent(type, dir, percent));
                            var propsTo = this$1$1.getCss(isIn(type) ? .5 : dir > 0 ? 1 : 0);
                            fastdom.write(function () {
                                css(this$1$1.$el, propsFrom);
                                Transition.start(this$1$1.$el, propsTo, duration, timing).catch(noop);
                            });
                        });

                    }
                },

                {
                    name: 'transitioncanceled transitionend',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function() {
                        Transition.cancel(this.$el);
                    }

                },

                {
                    name: 'itemtranslatein itemtranslateout',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function(ref) {
                        var this$1$1 = this;
                        var type = ref.type;
                        var ref_detail = ref.detail;
                        var percent = ref_detail.percent;
                        var dir = ref_detail.dir;

                        fastdom.read(function () {
                            var props = this$1$1.getCss(getCurrentPercent(type, dir, percent));
                            fastdom.write(function () { return css(this$1$1.$el, props); });
                        });
                    }
                }

            ]

        };

        function isIn(type) {
            return endsWith(type, 'in');
        }

        function getCurrentPercent(type, dir, percent) {

            percent /= 2;

            return !isIn(type)
                ? dir < 0
                    ? percent
                    : 1 - percent
                : dir < 0
                    ? 1 - percent
                    : percent;
        }

        var Animations = assign({}, Animations$2, {

            fade: {

                show: function() {
                    return [
                        {opacity: 0, zIndex: 0},
                        {zIndex: -1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, zIndex: 0},
                        {zIndex: -1}
                    ];
                }

            },

            scale: {

                show: function() {
                    return [
                        {opacity: 0, transform: scale3d(1 + .5), zIndex: 0},
                        {zIndex: -1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, transform: scale3d(1 + .5 * percent), zIndex: 0},
                        {zIndex: -1}
                    ];
                }

            },

            pull: {

                show: function(dir) {
                    return dir < 0
                        ? [
                            {transform: translate(30), zIndex: -1},
                            {transform: translate(), zIndex: 0}
                        ]
                        : [
                            {transform: translate(-100), zIndex: 0},
                            {transform: translate(), zIndex: -1}
                        ];
                },

                percent: function(current, next, dir) {
                    return dir < 0
                        ? 1 - translated(next)
                        : translated(current);
                },

                translate: function(percent, dir) {
                    return dir < 0
                        ? [
                            {transform: translate(30 * percent), zIndex: -1},
                            {transform: translate(-100 * (1 - percent)), zIndex: 0}
                        ]
                        : [
                            {transform: translate(-percent * 100), zIndex: 0},
                            {transform: translate(30 * (1 - percent)), zIndex: -1}
                        ];
                }

            },

            push: {

                show: function(dir) {
                    return dir < 0
                        ? [
                            {transform: translate(100), zIndex: 0},
                            {transform: translate(), zIndex: -1}
                        ]
                        : [
                            {transform: translate(-30), zIndex: -1},
                            {transform: translate(), zIndex: 0}
                        ];
                },

                percent: function(current, next, dir) {
                    return dir > 0
                        ? 1 - translated(next)
                        : translated(current);
                },

                translate: function(percent, dir) {
                    return dir < 0
                        ? [
                            {transform: translate(percent * 100), zIndex: 0},
                            {transform: translate(-30 * (1 - percent)), zIndex: -1}
                        ]
                        : [
                            {transform: translate(-30 * percent), zIndex: -1},
                            {transform: translate(100 * (1 - percent)), zIndex: 0}
                        ];
                }

            }

        });

        var slideshow = {

            mixins: [Class, Slideshow, SliderReactive],

            props: {
                ratio: String,
                minHeight: Number,
                maxHeight: Number
            },

            data: {
                ratio: '16:9',
                minHeight: false,
                maxHeight: false,
                selList: '.uk-slideshow-items',
                attrItem: 'uk-slideshow-item',
                selNav: '.uk-slideshow-nav',
                Animations: Animations
            },

            update: {

                read: function() {

                    var ref = this.ratio.split(':').map(Number);
                    var width = ref[0];
                    var height = ref[1];

                    height = height * this.list.offsetWidth / width || 0;

                    if (this.minHeight) {
                        height = Math.max(this.minHeight, height);
                    }

                    if (this.maxHeight) {
                        height = Math.min(this.maxHeight, height);
                    }

                    return {height: height - boxModelAdjust(this.list, 'height', 'content-box')};
                },

                write: function(ref) {
                    var height = ref.height;

                    height > 0 && css(this.list, 'minHeight', height);
                },

                events: ['resize']

            }

        };

        var sortable = {

            mixins: [Class, Animate],

            props: {
                group: String,
                threshold: Number,
                clsItem: String,
                clsPlaceholder: String,
                clsDrag: String,
                clsDragState: String,
                clsBase: String,
                clsNoDrag: String,
                clsEmpty: String,
                clsCustom: String,
                handle: String
            },

            data: {
                group: false,
                threshold: 5,
                clsItem: 'uk-sortable-item',
                clsPlaceholder: 'uk-sortable-placeholder',
                clsDrag: 'uk-sortable-drag',
                clsDragState: 'uk-drag',
                clsBase: 'uk-sortable',
                clsNoDrag: 'uk-sortable-nodrag',
                clsEmpty: 'uk-sortable-empty',
                clsCustom: '',
                handle: false,
                pos: {}
            },

            created: function() {
                var this$1$1 = this;

                ['init', 'start', 'move', 'end'].forEach(function (key) {
                    var fn = this$1$1[key];
                    this$1$1[key] = function (e) {
                        assign(this$1$1.pos, getEventPos(e));
                        fn(e);
                    };
                });
            },

            events: {

                name: pointerDown,
                passive: false,
                handler: 'init'

            },

            computed: {

                target: function() {
                    return (this.$el.tBodies || [this.$el])[0];
                },

                items: function() {
                    return children(this.target);
                },

                isEmpty: {

                    get: function() {
                        return isEmpty(this.items);
                    },

                    watch: function(empty) {
                        toggleClass(this.target, this.clsEmpty, empty);
                    },

                    immediate: true

                },

                handles: {

                    get: function(ref, el) {
                        var handle = ref.handle;

                        return handle ? $$(handle, el) : this.items;
                    },

                    watch: function(handles, prev) {
                        css(prev, {touchAction: '', userSelect: ''});
                        css(handles, {touchAction: hasTouch ? 'none' : '', userSelect: 'none'}); // touchAction set to 'none' causes a performance drop in Chrome 80
                    },

                    immediate: true

                }

            },

            update: {

                write: function(data) {

                    if (!this.drag || !parent(this.placeholder)) {
                        return;
                    }

                    var ref = this;
                    var ref_pos = ref.pos;
                    var x = ref_pos.x;
                    var y = ref_pos.y;
                    var ref_origin = ref.origin;
                    var offsetTop = ref_origin.offsetTop;
                    var offsetLeft = ref_origin.offsetLeft;
                    var placeholder = ref.placeholder;

                    css(this.drag, {
                        top: y - offsetTop,
                        left: x - offsetLeft
                    });

                    var sortable = this.getSortable(document.elementFromPoint(x, y));

                    if (!sortable) {
                        return;
                    }

                    var items = sortable.items;

                    if (items.some(Transition.inProgress)) {
                        return;
                    }

                    var target = findTarget(items, {x: x, y: y});

                    if (items.length && (!target || target === placeholder)) {
                        return;
                    }

                    var previous = this.getSortable(placeholder);
                    var insertTarget = findInsertTarget(sortable.target, target, placeholder, x, y, sortable === previous && data.moved !== target);

                    if (insertTarget === false) {
                        return;
                    }

                    if (insertTarget && placeholder === insertTarget) {
                        return;
                    }

                    if (sortable !== previous) {
                        previous.remove(placeholder);
                        data.moved = target;
                    } else {
                        delete data.moved;
                    }

                    sortable.insert(placeholder, insertTarget);

                    this.touched.add(sortable);
                },

                events: ['move']

            },

            methods: {

                init: function(e) {

                    var target = e.target;
                    var button = e.button;
                    var defaultPrevented = e.defaultPrevented;
                    var ref = this.items.filter(function (el) { return within(target, el); });
                    var placeholder = ref[0];

                    if (!placeholder
                        || defaultPrevented
                        || button > 0
                        || isInput(target)
                        || within(target, ("." + (this.clsNoDrag)))
                        || this.handle && !within(target, this.handle)
                    ) {
                        return;
                    }

                    e.preventDefault();

                    this.touched = new Set([this]);
                    this.placeholder = placeholder;
                    this.origin = assign({target: target, index: index(placeholder)}, this.pos);

                    on(document, pointerMove, this.move);
                    on(document, pointerUp, this.end);

                    if (!this.threshold) {
                        this.start(e);
                    }

                },

                start: function(e) {

                    this.drag = appendDrag(this.$container, this.placeholder);
                    var ref = this.placeholder.getBoundingClientRect();
                    var left = ref.left;
                    var top = ref.top;
                    assign(this.origin, {offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top});

                    addClass(this.drag, this.clsDrag, this.clsCustom);
                    addClass(this.placeholder, this.clsPlaceholder);
                    addClass(this.items, this.clsItem);
                    addClass(document.documentElement, this.clsDragState);

                    trigger(this.$el, 'start', [this, this.placeholder]);

                    trackScroll(this.pos);

                    this.move(e);
                },

                move: function(e) {

                    if (this.drag) {
                        this.$emit('move');
                    } else if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {
                        this.start(e);
                    }

                },

                end: function() {
                    var this$1$1 = this;


                    off(document, pointerMove, this.move);
                    off(document, pointerUp, this.end);
                    off(window, 'scroll', this.scroll);

                    if (!this.drag) {
                        return;
                    }

                    untrackScroll();

                    var sortable = this.getSortable(this.placeholder);

                    if (this === sortable) {
                        if (this.origin.index !== index(this.placeholder)) {
                            trigger(this.$el, 'moved', [this, this.placeholder]);
                        }
                    } else {
                        trigger(sortable.$el, 'added', [sortable, this.placeholder]);
                        trigger(this.$el, 'removed', [this, this.placeholder]);
                    }

                    trigger(this.$el, 'stop', [this, this.placeholder]);

                    remove$1(this.drag);
                    this.drag = null;

                    this.touched.forEach(function (ref) {
                            var clsPlaceholder = ref.clsPlaceholder;
                            var clsItem = ref.clsItem;

                            return this$1$1.touched.forEach(function (sortable) { return removeClass(sortable.items, clsPlaceholder, clsItem); }
                        );
                    }
                    );
                    this.touched = null;
                    removeClass(document.documentElement, this.clsDragState);

                },

                insert: function(element, target) {
                    var this$1$1 = this;


                    addClass(this.items, this.clsItem);

                    var insert = function () { return target
                        ? before(target, element)
                        : append(this$1$1.target, element); };

                    this.animate(insert);

                },

                remove: function(element) {

                    if (!within(element, this.target)) {
                        return;
                    }

                    this.animate(function () { return remove$1(element); });

                },

                getSortable: function(element) {
                    do {
                        var sortable = this.$getComponent(element, 'sortable');

                        if (sortable && (sortable === this || this.group !== false && sortable.group === this.group)) {
                            return sortable;
                        }
                    } while ((element = parent(element)));
                }

            }

        };

        var trackTimer;
        function trackScroll(pos) {

            var last = Date.now();
            trackTimer = setInterval(function () {

                var x = pos.x;
                var y = pos.y;
                y += window.pageYOffset;

                var dist = (Date.now() - last) * .3;
                last = Date.now();

                scrollParents(document.elementFromPoint(x, pos.y)).reverse().some(function (scrollEl) {

                    var scroll = scrollEl.scrollTop;
                    var scrollHeight = scrollEl.scrollHeight;

                    var ref = offset(getViewport$1(scrollEl));
                    var top = ref.top;
                    var bottom = ref.bottom;
                    var height = ref.height;

                    if (top < y && top + 35 > y) {
                        scroll -= dist;
                    } else if (bottom > y && bottom - 35 < y) {
                        scroll += dist;
                    } else {
                        return;
                    }

                    if (scroll > 0 && scroll < scrollHeight - height) {
                        scrollTop(scrollEl, scroll);
                        return true;
                    }

                });

            }, 15);

        }

        function untrackScroll() {
            clearInterval(trackTimer);
        }

        function appendDrag(container, element) {
            var clone = append(container, element.outerHTML.replace(/(^<)(?:li|tr)|(?:li|tr)(\/>$)/g, '$1div$2'));

            css(clone, 'margin', '0', 'important');
            css(clone, assign({
                boxSizing: 'border-box',
                width: element.offsetWidth,
                height: element.offsetHeight
            }, css(element, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'])));

            height(clone.firstElementChild, height(element.firstElementChild));

            return clone;
        }

        function findTarget(items, point) {
            return items[findIndex(items, function (item) { return pointInRect(point, item.getBoundingClientRect()); })];
        }

        function findInsertTarget(list, target, placeholder, x, y, sameList) {

            if (!children(list).length) {
                return;
            }

            var rect = target.getBoundingClientRect();
            if (!sameList) {

                if (!isHorizontal(list, placeholder)) {
                    return y < rect.top + rect.height / 2
                        ? target
                        : target.nextElementSibling;
                }

                return target;
            }

            var placeholderRect = placeholder.getBoundingClientRect();
            var sameRow = linesIntersect(
                [rect.top, rect.bottom],
                [placeholderRect.top, placeholderRect.bottom]
            );

            var pointerPos = sameRow ? x : y;
            var lengthProp = sameRow ? 'width' : 'height';
            var startProp = sameRow ? 'left' : 'top';
            var endProp = sameRow ? 'right' : 'bottom';

            var diff = placeholderRect[lengthProp] < rect[lengthProp] ? rect[lengthProp] - placeholderRect[lengthProp] : 0;

            if (placeholderRect[startProp] < rect[startProp]) {

                if (diff && pointerPos < rect[startProp] + diff) {
                    return false;
                }

                return target.nextElementSibling;
            }

            if (diff && pointerPos > rect[endProp] - diff) {
                return false;
            }

            return target;
        }

        function isHorizontal(list, placeholder) {

            var single = children(list).length === 1;

            if (single) {
                append(list, placeholder);
            }

            var items = children(list);
            var isHorizontal = items.some(function (el, i) {
                var rectA = el.getBoundingClientRect();
                return items.slice(i + 1).some(function (el) {
                    var rectB = el.getBoundingClientRect();
                    return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);
                });
            });

            if (single) {
                remove$1(placeholder);
            }

            return isHorizontal;
        }

        function linesIntersect(lineA, lineB) {
            return lineA[1] > lineB[0] && lineB[1] > lineA[0];
        }

        var obj;

        var tooltip = {

            mixins: [Container, Togglable, Position],

            args: 'title',

            props: {
                delay: Number,
                title: String
            },

            data: {
                pos: 'top',
                title: '',
                delay: 0,
                animation: ['uk-animation-scale-up'],
                duration: 100,
                cls: 'uk-active',
                clsPos: 'uk-tooltip'
            },

            beforeConnect: function() {
                this._hasTitle = hasAttr(this.$el, 'title');
                attr(this.$el, 'title', '');
                this.updateAria(false);
                makeFocusable(this.$el);
            },

            disconnected: function() {
                this.hide();
                attr(this.$el, 'title', this._hasTitle ? this.title : null);
            },

            methods: {

                show: function() {
                    var this$1$1 = this;


                    if (this.isToggled(this.tooltip || null) || !this.title) {
                        return;
                    }

                    this._unbind = once(document, ("show keydown " + pointerDown), this.hide, false, function (e) { return e.type === pointerDown && !within(e.target, this$1$1.$el)
                        || e.type === 'keydown' && e.keyCode === 27
                        || e.type === 'show' && e.detail[0] !== this$1$1 && e.detail[0].$name === this$1$1.$name; }
                    );

                    clearTimeout(this.showTimer);
                    this.showTimer = setTimeout(this._show, this.delay);
                },

                hide: function() {
                    var this$1$1 = this;


                    if (matches(this.$el, 'input:focus')) {
                        return;
                    }

                    clearTimeout(this.showTimer);

                    if (!this.isToggled(this.tooltip || null)) {
                        return;
                    }

                    this.toggleElement(this.tooltip, false, false).then(function () {
                        this$1$1.tooltip = remove$1(this$1$1.tooltip);
                        this$1$1._unbind();
                    });
                },

                _show: function() {
                    var this$1$1 = this;


                    this.tooltip = append(this.container,
                        ("<div class=\"" + (this.clsPos) + "\"> <div class=\"" + (this.clsPos) + "-inner\">" + (this.title) + "</div> </div>")
                    );

                    on(this.tooltip, 'toggled', function (e, toggled) {

                        this$1$1.updateAria(toggled);

                        if (!toggled) {
                            return;
                        }

                        this$1$1.positionAt(this$1$1.tooltip, this$1$1.$el);

                        this$1$1.origin = this$1$1.getAxis() === 'y'
                            ? ((flipPosition(this$1$1.dir)) + "-" + (this$1$1.align))
                            : ((this$1$1.align) + "-" + (flipPosition(this$1$1.dir)));
                    });

                    this.toggleElement(this.tooltip, true);

                },

                updateAria: function(toggled) {
                    attr(this.$el, 'aria-expanded', toggled);
                }

            },

            events: ( obj = {

                focus: 'show',
                blur: 'hide'

            }, obj[(pointerEnter + " " + pointerLeave)] = function (e) {
                    if (!isTouch(e)) {
                        this[e.type === pointerEnter ? 'show' : 'hide']();
                    }
                }, obj[pointerDown] = function (e) {
                    if (isTouch(e)) {
                        this.show();
                    }
                }, obj )

        };

        function makeFocusable(el) {
            if (!isFocusable(el)) {
                attr(el, 'tabindex', '0');
            }
        }

        var upload = {

            props: {
                allow: String,
                clsDragover: String,
                concurrent: Number,
                maxSize: Number,
                method: String,
                mime: String,
                msgInvalidMime: String,
                msgInvalidName: String,
                msgInvalidSize: String,
                multiple: Boolean,
                name: String,
                params: Object,
                type: String,
                url: String
            },

            data: {
                allow: false,
                clsDragover: 'uk-dragover',
                concurrent: 1,
                maxSize: 0,
                method: 'POST',
                mime: false,
                msgInvalidMime: 'Invalid File Type: %s',
                msgInvalidName: 'Invalid File Name: %s',
                msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',
                multiple: false,
                name: 'files[]',
                params: {},
                type: '',
                url: '',
                abort: noop,
                beforeAll: noop,
                beforeSend: noop,
                complete: noop,
                completeAll: noop,
                error: noop,
                fail: noop,
                load: noop,
                loadEnd: noop,
                loadStart: noop,
                progress: noop
            },

            events: {

                change: function(e) {

                    if (!matches(e.target, 'input[type="file"]')) {
                        return;
                    }

                    e.preventDefault();

                    if (e.target.files) {
                        this.upload(e.target.files);
                    }

                    e.target.value = '';
                },

                drop: function(e) {
                    stop(e);

                    var transfer = e.dataTransfer;

                    if (!transfer || !transfer.files) {
                        return;
                    }

                    removeClass(this.$el, this.clsDragover);

                    this.upload(transfer.files);
                },

                dragenter: function(e) {
                    stop(e);
                },

                dragover: function(e) {
                    stop(e);
                    addClass(this.$el, this.clsDragover);
                },

                dragleave: function(e) {
                    stop(e);
                    removeClass(this.$el, this.clsDragover);
                }

            },

            methods: {

                upload: function(files) {
                    var this$1$1 = this;


                    if (!files.length) {
                        return;
                    }

                    trigger(this.$el, 'upload', [files]);

                    for (var i = 0; i < files.length; i++) {

                        if (this.maxSize && this.maxSize * 1000 < files[i].size) {
                            this.fail(this.msgInvalidSize.replace('%s', this.maxSize));
                            return;
                        }

                        if (this.allow && !match(this.allow, files[i].name)) {
                            this.fail(this.msgInvalidName.replace('%s', this.allow));
                            return;
                        }

                        if (this.mime && !match(this.mime, files[i].type)) {
                            this.fail(this.msgInvalidMime.replace('%s', this.mime));
                            return;
                        }

                    }

                    if (!this.multiple) {
                        files = [files[0]];
                    }

                    this.beforeAll(this, files);

                    var chunks = chunk(files, this.concurrent);
                    var upload = function (files) {

                        var data = new FormData();

                        files.forEach(function (file) { return data.append(this$1$1.name, file); });

                        for (var key in this$1$1.params) {
                            data.append(key, this$1$1.params[key]);
                        }

                        ajax(this$1$1.url, {
                            data: data,
                            method: this$1$1.method,
                            responseType: this$1$1.type,
                            beforeSend: function (env) {

                                var xhr = env.xhr;
                                xhr.upload && on(xhr.upload, 'progress', this$1$1.progress);
                                ['loadStart', 'load', 'loadEnd', 'abort'].forEach(function (type) { return on(xhr, type.toLowerCase(), this$1$1[type]); }
                                );

                                return this$1$1.beforeSend(env);

                            }
                        }).then(
                            function (xhr) {

                                this$1$1.complete(xhr);

                                if (chunks.length) {
                                    upload(chunks.shift());
                                } else {
                                    this$1$1.completeAll(xhr);
                                }

                            },
                            function (e) { return this$1$1.error(e); }
                        );

                    };

                    upload(chunks.shift());

                }

            }

        };

        function match(pattern, path) {
            return path.match(new RegExp(("^" + (pattern.replace(/\//g, '\\/').replace(/\*\*/g, '(\\/[^\\/]+)*').replace(/\*/g, '[^\\/]+').replace(/((?!\\))\?/g, '$1.')) + "$"), 'i'));
        }

        function chunk(files, size) {
            var chunks = [];
            for (var i = 0; i < files.length; i += size) {
                var chunk = [];
                for (var j = 0; j < size; j++) {
                    chunk.push(files[i + j]);
                }
                chunks.push(chunk);
            }
            return chunks;
        }

        function stop(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        var components = /*#__PURE__*/Object.freeze({
            __proto__: null,
            Countdown: countdown,
            Filter: filter,
            Lightbox: lightbox,
            LightboxPanel: LightboxPanel,
            Notification: notification,
            Parallax: parallax,
            Slider: slider,
            SliderParallax: sliderParallax,
            Slideshow: slideshow,
            SlideshowParallax: sliderParallax,
            Sortable: sortable,
            Tooltip: tooltip,
            Upload: upload
        });

        each(components, function (component, name) { return UIkit.component(name, component); }
        );

        return UIkit;

    }));
    });

    function notify_success(s) {
        uikit.notification({
            message: `<span uk-icon=\'icon: check\'></span> ${s}`,
            pos: 'bottom-center',
            status: 'success',
            timeout: 3000
        });
    }
    function notify_error(s) {
        uikit.notification({
            message: `<span uk-icon=\'icon: warning\'></span> ${s}`,
            pos: 'bottom-center',
            status: 'error',
            timeout: 10000
        });
    }

    var Level;
    (function (Level) {
        Level["Warn"] = "Warn";
        Level["Error"] = "Error";
    })(Level || (Level = {}));
    // error logging to terminal and text file
    const logger = async (level, msg) => {
        i$1("log_this", {
            level,
            msg,
        });
    };

    var ErrMap;
    (function (ErrMap) {
        ErrMap[ErrMap["NoClientCx"] = 404] = "NoClientCx";
        ErrMap[ErrMap["AccountDNE"] = 1004] = "AccountDNE";
        ErrMap[ErrMap["InsufficientBalance"] = 12015] = "InsufficientBalance";
        ErrMap[ErrMap["WrongDifficulty"] = 130102] = "WrongDifficulty";
        ErrMap[ErrMap["TooManyProofs"] = 130108] = "TooManyProofs";
        ErrMap[ErrMap["Discontinuity"] = 130109] = "Discontinuity";
        ErrMap[ErrMap["InvalidProof"] = 130110] = "InvalidProof";
    })(ErrMap || (ErrMap = {}));
    // let list_errors: CarpeError;
    // @ts-ignore
    const carpeErrorLog = writable([]);
    function raise_error(err, quiet = false, caller) {
        let hasCustomErrorDisplay = false;
        // maybe we need to take an action on this error type
        if (err.category) { // check this is the expected type
            // errAction(event.paylod);
            hasCustomErrorDisplay = errAction(err);
            err.msg = `${caller}: ${err.msg}`;
            console.log(err);
        }
        else {
            console.log(`WARN: ${caller}: error type returned is not a CarpeError. Payload: ${err}`);
        }
        let list = get_store_value(carpeErrorLog);
        list.push(err);
        carpeErrorLog.set(list);
        console.log(list);
        let display = `Error (${err.uid}): ${err.msg}`;
        if (!quiet && !hasCustomErrorDisplay) {
            notify_error(display);
        }
        logger(Level.Error, err.msg);
    }
    function clearErrors() {
        // @ts-ignore
        carpeErrorLog.set([]);
    }
    // returns true if there is a UI for the error, so we know to display generic error notification.
    const errAction = (err) => {
        switch (err.uid) {
            case ErrMap.NoClientCx:
                // window.alert("no client connection");
                return false; // todo
            case ErrMap.AccountDNE:
                // window.alert("account does not exist");
                return false; //todo
            case ErrMap.WrongDifficulty:
                // window.alert("wrong difficulty");
                displayWrongDifficulty.set(err);
                break;
            case ErrMap.TooManyProofs:
                displayTooManyProofs.set(err);
                // window.alert("too many proofs submitted in epoch");
                break;
            case ErrMap.Discontinuity:
                displayDiscontinuity.set(err);
                // window.alert("your proofs are not chained. Perhaps some proofs have not been sent?");
                break;
            // TODO: this last one may never/rarely occur. 
            case ErrMap.InvalidProof:
                // window.alert("proof does not verify");
                displayInvalidProof.set(err);
                break;
            case ErrMap.InsufficientBalance:
                // window.alert("insufficient balance");
                displayInsufficientBalance.set(err);
                break;
            default:
                return false;
        }
        return true;
    };

    const responses = writable("");
    const debugMode = writable(false);
    // set the Environment to debug or test
    function setDebugProdTest(env) {
        i$1("set_env", { env: env })
            .then((res) => {
            notify_success(`switched to ${res} mode`);
            nodeEnv.set(res);
        })
            .catch((error) => raise_error(error, false, "setDebugProdTest"));
    }
    const nodeEnv = writable("");
    const nodeEnvIsTest = writable(false);
    // helper to figure out what environment we are in TEST/PROD
    function getEnv() {
        console.log("getEnv");
        i$1("get_env", {})
            .then((res) => {
            console.log("get env");
            console.log(res);
            nodeEnv.set(res);
            if (res == "test") {
                nodeEnvIsTest.set(true);
            }
        })
            .catch((error) => raise_error(error, false, "getEnv"));
    }
    function debugModeToggle() {
        debugMode.set(!get_store_value(debugMode));
    }

    const tower = writable({});
    // is set to true if when the app starts and Rust emits the backlog-listener-ready event.
    const backlogListenerReady = writable(false);
    // is set to true when the user toggles the miner-toggle
    // is set to false when the user manually sets to off, or the mineOnce async invocation returns error.
    const minerLoopEnabled = writable(false);
    // is set to true when the window.emit event is received
    // is set to false when a new proof starts
    const minerEventReceived = writable(false);
    // is set to true when the asyc MineOnce returns a proof
    // is set to false when a new proof starts 
    const minerProofComplete = writable(false);
    // is set to true when a backlog event is emmitted, or invoking the async backlog command
    // is set to false when a backlog-success or -fail event is received 
    const backlogInProgress = writable(false);
    // is set to true when a backlog-success event is emmitted from rust, or when the async invoked command returns
    // is set to false when a backlog-fail event is received 
    const backlogSubmitted = writable(false);
    // TODO:
    const isTowerNewbie = writable(false);

    const loadAccounts = async () => {
        // fetch data from local DB
        return i$1('get_all_accounts')
            .then((result) => {
            all_accounts.set(result.accounts);
            if (get_store_value(signingAccount).account == "" && result.accounts.length > 0) {
                // set initial signingAccount
                let first = result.accounts[0];
                setAccount(first.account, false);
            }
            if (!get_store_value(isAccountsLoaded)) {
                isAccountsLoaded.set(true);
            }
            updateMakeWhole(result.accounts);
            // fetch data from the chain
            return refreshAccounts();
        })
            .catch((error) => raise_error(error, false, "loadAccounts"));
    };
    const refreshAccounts = async () => {
        isRefreshingAccounts.set(true);
        return i$1('refresh_accounts')
            .then((result) => {
            all_accounts.set(result.accounts);
            result.accounts.forEach(el => {
                tryRefreshSignerAccount(el);
            });
            isRefreshingAccounts.set(false);
        })
            .catch(_ => {
            isRefreshingAccounts.set(false);
        });
    };
    function tryRefreshSignerAccount(newData) {
        let a = get_store_value(signingAccount).account;
        if (newData.account == a) {
            signingAccount.set(newData);
        }
    }
    const isCarpeInit = async () => {
        i$1("is_init", {})
            .then((res) => {
            responses.set(res.toString());
            isInit.set(res);
        })
            .catch((e) => raise_error(e, false, "isCarpeInit"));
    };
    function findOneAccount(account) {
        let list = get_store_value(all_accounts);
        let found = list.find((i) => i.account == account);
        return found;
    }
    const setAccount = async (an_address, notifySucess = true) => {
        if (get_store_value(signingAccount).account == an_address) {
            return;
        }
        // cannot switch profile with miner running
        if (get_store_value(minerLoopEnabled)) {
            notify_error("To switch accounts you need to turn miner off first.");
            return;
        }
        let a = findOneAccount(an_address);
        // optimistic switch
        let previous = get_store_value(signingAccount);
        signingAccount.set(a);
        // reset user data
        tower.set({});
        mnem.set("");
        // initi account events for better UX
        getAccountEvents(a, () => { });
        i$1("switch_profile", {
            account: a.account,
        })
            .then((res) => {
            if (typeof res === "string") {
                responses.set(res);
            }
            if (notifySucess) {
                notify_success("Account switched to " + a.nickname);
            }
        })
            .catch((e) => {
            raise_error(e, false, "setAccount");
            // fallback optimistic change
            signingAccount.set(previous);
        });
    };
    function addNewAccount(account) {
        let list = get_store_value(all_accounts);
        // account.on_chain = false;
        list.push(account);
        all_accounts.set(list);
    }
    function checkSigningAccountBalance() {
        let selected = get_store_value(signingAccount);
        i$1('query_balance', { account: selected.account })
            .then((balance) => {
            // update signingAccount
            selected.on_chain = true;
            selected.balance = Number(balance);
            signingAccount.set(selected);
            // update all accounts set
            let list = get_store_value(all_accounts).map(each => {
                if (each.account == selected.account) {
                    each.on_chain = true;
                    each.balance = Number(balance);
                }
                return each;
            });
            all_accounts.set(list);
        })
            .catch((e) => raise_error(e, false, "checkSigningAccountBalance"));
    }
    function getAccountEvents(account, errorCallback = null) {
        account.account;
        if (!account.on_chain) {
            return errorCallback && errorCallback("account_not_on_chain");
        }
        return;
        /*
        invoke('get_account_events', {account: address.toUpperCase()})
          .then((events: Array<T>) => {
            let all = get(accountEvents);
            all[address] = events
              .sort((a, b) => (a.transaction_version < b.transaction_version)
                ? 1
                : (b.transaction_version < a.transaction_version)
                  ? -1
                  : 0
              );
            accountEvents.set(all);
          })
          .catch(e => {
            if (errorCallback) {
              errorCallback(e.msg);
            } else {
              raise_error(e, false, "getAccountEvents");
            }
          });
          */
    }
    /*
    export let invoke_makewhole = async (account: String): Promise<number> => {
     // let demo_account = "613b6d9599f72134a4fa20bba4c75c36";
     // account = demo_account;
      
      console.log(">>> calling make whole");
      return await invoke("query_makewhole", { account })
        .then((a) => {
          if (a.length > 0) {
            console.log("MakeWhole " + account + ", coins: " + a[0].coins.value)
            console.log(a)
          }
          console.log(a);
          return a[0].coins.value
        })
    }
    */
    function updateMakeWhole(accounts) {
        let mk = get_store_value(makeWhole);
        accounts.forEach(each => {
            let account = each.account;
            if (mk[account] == null) {
                console.log(">>> query_makewhole called");
                i$1("query_makewhole", { account })
                    .then((credits) => {
                    mk[account] = credits;
                    makeWhole.set(mk);
                });
            }
        });
    }
    /*
      Function to claim coins credit from makewhole
    */
    function claimMakeWhole(account, callback = null) {
        // account to claim must be the signingAccount
        if (get_store_value(signingAccount).account != account) {
            if (get_store_value(minerLoopEnabled)) {
                return callback("To claim coins you need to turn miner off first.");
            }
            else {
                // set sigining account
                setAccount(account, false);
            }
        }
        let mk = get_store_value(makeWhole);
        i$1('claim_make_whole', { account })
            .then(() => {
            // update account make_whole status
            let accountCredits = mk[account];
            mk[account] = accountCredits.map(each => { each.claimed = true; return each; });
            makeWhole.set(mk);
            // update account balance
            checkSigningAccountBalance();
            callback(null);
        })
            .catch(e => {
            if (callback) {
                callback(e.msg);
            }
            else {
                raise_error(e, false, "claim_make_whole");
            }
        });
    }

    // This matches a subset of NamedChain enum in Rust.
    var Networks;
    (function (Networks) {
        Networks["MAINNET"] = "MAINNET";
        Networks["TESTNET"] = "TESTNET";
        Networks["TESTING"] = "TESTING";
    })(Networks || (Networks = {}));
    const network_profile = writable({
        chain_id: Networks.MAINNET,
        urls: ["string"],
        waypoint: "string",
        profile: "string",
    });
    const connected = writable(true);
    const scanning_fullnodes = writable(true);
    function setNetwork(network) {
        i$1("toggle_network", { network: Networks[network] })
            .then((res) => {
            network_profile.set(res);
            // update accounts from current network
            loadAccounts(); // TODO notify as an event dependency
        })
            .catch((error) => raise_error(error, false, "setNetwork"));
    }
    function getNetwork() {
        i$1("get_networks", {})
            .then((res) => network_profile.set(res))
            .catch((error) => raise_error(error, false, "getNetwork"));
    }
    const refreshWaypoint = async () => {
        console.log("refreshWaypoint");
        return i$1("refresh_waypoint", {})
            .then((res) => {
            network_profile.set(res);
            connected.set(true);
            // scanning_fullnodes.set(false);
        })
            .catch((error) => {
            connected.set(false);
            raise_error(error, true, "refreshWaypoint"); // we have a purpose-built error component for this
        });
    };
    const refreshUpstreamPeerStats = async () => {
        console.log(">>> calling refresh_upstream_peer_stats");
        return i$1("refresh_upstream_peer_stats", {})
            .then((res) => {
            console.log("update peers finished");
            // network_profile.set(res);
            connected.set(res);
            scanning_fullnodes.set(false);
        })
            .catch((error) => {
            connected.set(false);
            raise_error(error, true, "refreshUpstreamPeerStats"); // we have a purpose-built error component for this
        });
    };

    /* src/components/wallet/NetworkIcon.svelte generated by Svelte v3.38.1 */
    const file$Z = "src/components/wallet/NetworkIcon.svelte";

    // (21:0) {:else}
    function create_else_block$g(ctx) {
    	let span0;
    	let t0;
    	let span1;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			span1.textContent = "TESTNET";
    			attr_dev(span0, "uk-icon", "icon: warning");
    			add_location(span0, file$Z, 22, 2, 504);
    			add_location(span1, file$Z, 23, 2, 538);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(21:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:0) {#if !isTestNet}
    function create_if_block$v(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: user");
    			add_location(span, file$Z, 19, 2, 390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(19:0) {#if !isTestNet}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*isTestNet*/ ctx[0]) return create_if_block$v;
    		return create_else_block$g;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NetworkIcon", slots, []);
    	let isTestNet = false;
    	let unsubs;

    	onMount(async () => {
    		unsubs = network_profile.subscribe(network => {
    			$$invalidate(0, isTestNet = network.chain_id == Networks.Rex);
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NetworkIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		Networks,
    		network_profile,
    		isTestNet,
    		unsubs
    	});

    	$$self.$inject_state = $$props => {
    		if ("isTestNet" in $$props) $$invalidate(0, isTestNet = $$props.isTestNet);
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isTestNet];
    }

    class NetworkIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NetworkIcon",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    const app_version = writable({
        version: null,
        hash: null,
        head: null
    });
    function getVersion() {
        console.log("getVersion");
        i$1("get_app_version")
            .then((res) => {
            app_version.set(res);
        })
            .catch((error) => raise_error(error, true, "getVersion"));
    }

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return target.propertyIsEnumerable(symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$2 = function() {
        __assign$2 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    var ErrorKind;
    (function (ErrorKind) {
        /** Argument is unclosed (e.g. `{0`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
        /** Argument is empty (e.g. `{}`). */
        ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
        /** Argument is malformed (e.g. `{foo!}``) */
        ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
        /** Expect an argument type (e.g. `{foo,}`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
        /** Unsupported argument type (e.g. `{foo,foo}`) */
        ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
        /** Expect an argument style (e.g. `{foo, number, }`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
        /** The number skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
        /** The date time skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
        /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */
        ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
        /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */
        ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
        /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */
        ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
        /** Missing select argument options (e.g. `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
        /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Expecting a selector in `select` argument (e.g `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
        /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
        /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
        /**
         * Expecting a message fragment after the `plural` or `selectordinal` selector
         * (e.g. `{foo, plural, one}`)
         */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
        /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
        /**
         * Duplicate selectors in `plural` or `selectordinal` argument.
         * (e.g. {foo, plural, one {#} one {#}})
         */
        ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
        /** Duplicate selectors in `select` argument.
         * (e.g. {foo, select, apple {apple} apple {apple}})
         */
        ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
        /** Plural or select argument option must have `other` clause. */
        ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
        /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */
        ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
        /** The tag name is invalid. (e.g. `<123>foo</123>`) */
        ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
        /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */
        ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
        /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */
        ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
    })(ErrorKind || (ErrorKind = {}));

    var TYPE;
    (function (TYPE) {
        /**
         * Raw text
         */
        TYPE[TYPE["literal"] = 0] = "literal";
        /**
         * Variable w/o any format, e.g `var` in `this is a {var}`
         */
        TYPE[TYPE["argument"] = 1] = "argument";
        /**
         * Variable w/ number format
         */
        TYPE[TYPE["number"] = 2] = "number";
        /**
         * Variable w/ date format
         */
        TYPE[TYPE["date"] = 3] = "date";
        /**
         * Variable w/ time format
         */
        TYPE[TYPE["time"] = 4] = "time";
        /**
         * Variable w/ select format
         */
        TYPE[TYPE["select"] = 5] = "select";
        /**
         * Variable w/ plural format
         */
        TYPE[TYPE["plural"] = 6] = "plural";
        /**
         * Only possible within plural argument.
         * This is the `#` symbol that will be substituted with the count.
         */
        TYPE[TYPE["pound"] = 7] = "pound";
        /**
         * XML-like tag
         */
        TYPE[TYPE["tag"] = 8] = "tag";
    })(TYPE || (TYPE = {}));
    var SKELETON_TYPE;
    (function (SKELETON_TYPE) {
        SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
        SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
    })(SKELETON_TYPE || (SKELETON_TYPE = {}));
    /**
     * Type Guards
     */
    function isLiteralElement(el) {
        return el.type === TYPE.literal;
    }
    function isArgumentElement(el) {
        return el.type === TYPE.argument;
    }
    function isNumberElement(el) {
        return el.type === TYPE.number;
    }
    function isDateElement(el) {
        return el.type === TYPE.date;
    }
    function isTimeElement(el) {
        return el.type === TYPE.time;
    }
    function isSelectElement(el) {
        return el.type === TYPE.select;
    }
    function isPluralElement(el) {
        return el.type === TYPE.plural;
    }
    function isPoundElement(el) {
        return el.type === TYPE.pound;
    }
    function isTagElement(el) {
        return el.type === TYPE.tag;
    }
    function isNumberSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
    }
    function isDateTimeSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
    }

    // @generated from regex-gen.ts
    var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

    /**
     * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
     * with some tweaks
     */
    var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
    /**
     * Parse Date time skeleton into Intl.DateTimeFormatOptions
     * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * @public
     * @param skeleton skeleton string
     */
    function parseDateTimeSkeleton(skeleton) {
        var result = {};
        skeleton.replace(DATE_TIME_REGEX, function (match) {
            var len = match.length;
            switch (match[0]) {
                // Era
                case 'G':
                    result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                    break;
                // Year
                case 'y':
                    result.year = len === 2 ? '2-digit' : 'numeric';
                    break;
                case 'Y':
                case 'u':
                case 'U':
                case 'r':
                    throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
                // Quarter
                case 'q':
                case 'Q':
                    throw new RangeError('`q/Q` (quarter) patterns are not supported');
                // Month
                case 'M':
                case 'L':
                    result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
                    break;
                // Week
                case 'w':
                case 'W':
                    throw new RangeError('`w/W` (week) patterns are not supported');
                case 'd':
                    result.day = ['numeric', '2-digit'][len - 1];
                    break;
                case 'D':
                case 'F':
                case 'g':
                    throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
                // Weekday
                case 'E':
                    result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';
                    break;
                case 'e':
                    if (len < 4) {
                        throw new RangeError('`e..eee` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                case 'c':
                    if (len < 4) {
                        throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                // Period
                case 'a': // AM, PM
                    result.hour12 = true;
                    break;
                case 'b': // am, pm, noon, midnight
                case 'B': // flexible day periods
                    throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
                // Hour
                case 'h':
                    result.hourCycle = 'h12';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'H':
                    result.hourCycle = 'h23';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'K':
                    result.hourCycle = 'h11';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'k':
                    result.hourCycle = 'h24';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'j':
                case 'J':
                case 'C':
                    throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
                // Minute
                case 'm':
                    result.minute = ['numeric', '2-digit'][len - 1];
                    break;
                // Second
                case 's':
                    result.second = ['numeric', '2-digit'][len - 1];
                    break;
                case 'S':
                case 'A':
                    throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
                // Zone
                case 'z': // 1..3, 4: specific non-location format
                    result.timeZoneName = len < 4 ? 'short' : 'long';
                    break;
                case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
                case 'O': // 1, 4: miliseconds in day short, long
                case 'v': // 1, 4: generic non-location format
                case 'V': // 1, 2, 3, 4: time zone ID or city
                case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
                case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
                    throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
            }
            return '';
        });
        return result;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    // @generated from regex-gen.ts
    var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

    function parseNumberSkeletonFromString(skeleton) {
        if (skeleton.length === 0) {
            throw new Error('Number skeleton cannot be empty');
        }
        // Parse the skeleton
        var stringTokens = skeleton
            .split(WHITE_SPACE_REGEX)
            .filter(function (x) { return x.length > 0; });
        var tokens = [];
        for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
            var stringToken = stringTokens_1[_i];
            var stemAndOptions = stringToken.split('/');
            if (stemAndOptions.length === 0) {
                throw new Error('Invalid number skeleton');
            }
            var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
            for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
                var option = options_1[_a];
                if (option.length === 0) {
                    throw new Error('Invalid number skeleton');
                }
            }
            tokens.push({ stem: stem, options: options });
        }
        return tokens;
    }
    function icuUnitToEcma(unit) {
        return unit.replace(/^(.*?)-/, '');
    }
    var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
    var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
    var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
    var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
    function parseSignificantPrecision(str) {
        var result = {};
        if (str[str.length - 1] === 'r') {
            result.roundingPriority = 'morePrecision';
        }
        else if (str[str.length - 1] === 's') {
            result.roundingPriority = 'lessPrecision';
        }
        str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
            // @@@ case
            if (typeof g2 !== 'string') {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits = g1.length;
            }
            // @@@+ case
            else if (g2 === '+') {
                result.minimumSignificantDigits = g1.length;
            }
            // .### case
            else if (g1[0] === '#') {
                result.maximumSignificantDigits = g1.length;
            }
            // .@@## or .@@@ case
            else {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits =
                    g1.length + (typeof g2 === 'string' ? g2.length : 0);
            }
            return '';
        });
        return result;
    }
    function parseSign(str) {
        switch (str) {
            case 'sign-auto':
                return {
                    signDisplay: 'auto',
                };
            case 'sign-accounting':
            case '()':
                return {
                    currencySign: 'accounting',
                };
            case 'sign-always':
            case '+!':
                return {
                    signDisplay: 'always',
                };
            case 'sign-accounting-always':
            case '()!':
                return {
                    signDisplay: 'always',
                    currencySign: 'accounting',
                };
            case 'sign-except-zero':
            case '+?':
                return {
                    signDisplay: 'exceptZero',
                };
            case 'sign-accounting-except-zero':
            case '()?':
                return {
                    signDisplay: 'exceptZero',
                    currencySign: 'accounting',
                };
            case 'sign-never':
            case '+_':
                return {
                    signDisplay: 'never',
                };
        }
    }
    function parseConciseScientificAndEngineeringStem(stem) {
        // Engineering
        var result;
        if (stem[0] === 'E' && stem[1] === 'E') {
            result = {
                notation: 'engineering',
            };
            stem = stem.slice(2);
        }
        else if (stem[0] === 'E') {
            result = {
                notation: 'scientific',
            };
            stem = stem.slice(1);
        }
        if (result) {
            var signDisplay = stem.slice(0, 2);
            if (signDisplay === '+!') {
                result.signDisplay = 'always';
                stem = stem.slice(2);
            }
            else if (signDisplay === '+?') {
                result.signDisplay = 'exceptZero';
                stem = stem.slice(2);
            }
            if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
                throw new Error('Malformed concise eng/scientific notation');
            }
            result.minimumIntegerDigits = stem.length;
        }
        return result;
    }
    function parseNotationOptions(opt) {
        var result = {};
        var signOpts = parseSign(opt);
        if (signOpts) {
            return signOpts;
        }
        return result;
    }
    /**
     * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
     */
    function parseNumberSkeleton(tokens) {
        var result = {};
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            switch (token.stem) {
                case 'percent':
                case '%':
                    result.style = 'percent';
                    continue;
                case '%x100':
                    result.style = 'percent';
                    result.scale = 100;
                    continue;
                case 'currency':
                    result.style = 'currency';
                    result.currency = token.options[0];
                    continue;
                case 'group-off':
                case ',_':
                    result.useGrouping = false;
                    continue;
                case 'precision-integer':
                case '.':
                    result.maximumFractionDigits = 0;
                    continue;
                case 'measure-unit':
                case 'unit':
                    result.style = 'unit';
                    result.unit = icuUnitToEcma(token.options[0]);
                    continue;
                case 'compact-short':
                case 'K':
                    result.notation = 'compact';
                    result.compactDisplay = 'short';
                    continue;
                case 'compact-long':
                case 'KK':
                    result.notation = 'compact';
                    result.compactDisplay = 'long';
                    continue;
                case 'scientific':
                    result = __assign(__assign(__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'engineering':
                    result = __assign(__assign(__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'notation-simple':
                    result.notation = 'standard';
                    continue;
                // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
                case 'unit-width-narrow':
                    result.currencyDisplay = 'narrowSymbol';
                    result.unitDisplay = 'narrow';
                    continue;
                case 'unit-width-short':
                    result.currencyDisplay = 'code';
                    result.unitDisplay = 'short';
                    continue;
                case 'unit-width-full-name':
                    result.currencyDisplay = 'name';
                    result.unitDisplay = 'long';
                    continue;
                case 'unit-width-iso-code':
                    result.currencyDisplay = 'symbol';
                    continue;
                case 'scale':
                    result.scale = parseFloat(token.options[0]);
                    continue;
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
                case 'integer-width':
                    if (token.options.length > 1) {
                        throw new RangeError('integer-width stems only accept a single optional option');
                    }
                    token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {
                        if (g1) {
                            result.minimumIntegerDigits = g2.length;
                        }
                        else if (g3 && g4) {
                            throw new Error('We currently do not support maximum integer digits');
                        }
                        else if (g5) {
                            throw new Error('We currently do not support exact integer digits');
                        }
                        return '';
                    });
                    continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
                result.minimumIntegerDigits = token.stem.length;
                continue;
            }
            if (FRACTION_PRECISION_REGEX.test(token.stem)) {
                // Precision
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
                // precision-integer case
                if (token.options.length > 1) {
                    throw new RangeError('Fraction-precision stems only accept a single optional option');
                }
                token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
                    // .000* case (before ICU67 it was .000+)
                    if (g2 === '*') {
                        result.minimumFractionDigits = g1.length;
                    }
                    // .### case
                    else if (g3 && g3[0] === '#') {
                        result.maximumFractionDigits = g3.length;
                    }
                    // .00## case
                    else if (g4 && g5) {
                        result.minimumFractionDigits = g4.length;
                        result.maximumFractionDigits = g4.length + g5.length;
                    }
                    else {
                        result.minimumFractionDigits = g1.length;
                        result.maximumFractionDigits = g1.length;
                    }
                    return '';
                });
                var opt = token.options[0];
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
                if (opt === 'w') {
                    result = __assign(__assign({}, result), { trailingZeroDisplay: 'stripIfInteger' });
                }
                else if (opt) {
                    result = __assign(__assign({}, result), parseSignificantPrecision(opt));
                }
                continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
            if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
                result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
                continue;
            }
            var signOpts = parseSign(token.stem);
            if (signOpts) {
                result = __assign(__assign({}, result), signOpts);
            }
            var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
            if (conciseScientificAndEngineeringOpts) {
                result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
            }
        }
        return result;
    }

    var _a;
    var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
    var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
    function createLocation(start, end) {
        return { start: start, end: end };
    }
    // #region Ponyfills
    // Consolidate these variables up top for easier toggling during debugging
    var hasNativeStartsWith = !!String.prototype.startsWith;
    var hasNativeFromCodePoint = !!String.fromCodePoint;
    var hasNativeFromEntries = !!Object.fromEntries;
    var hasNativeCodePointAt = !!String.prototype.codePointAt;
    var hasTrimStart = !!String.prototype.trimStart;
    var hasTrimEnd = !!String.prototype.trimEnd;
    var hasNativeIsSafeInteger = !!Number.isSafeInteger;
    var isSafeInteger = hasNativeIsSafeInteger
        ? Number.isSafeInteger
        : function (n) {
            return (typeof n === 'number' &&
                isFinite(n) &&
                Math.floor(n) === n &&
                Math.abs(n) <= 0x1fffffffffffff);
        };
    // IE11 does not support y and u.
    var REGEX_SUPPORTS_U_AND_Y = true;
    try {
        var re$1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        /**
         * legacy Edge or Xbox One browser
         * Unicode flag support: supported
         * Pattern_Syntax support: not supported
         * See https://github.com/formatjs/formatjs/issues/2822
         */
        REGEX_SUPPORTS_U_AND_Y = ((_a = re$1.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';
    }
    catch (_) {
        REGEX_SUPPORTS_U_AND_Y = false;
    }
    var startsWith = hasNativeStartsWith
        ? // Native
            function startsWith(s, search, position) {
                return s.startsWith(search, position);
            }
        : // For IE11
            function startsWith(s, search, position) {
                return s.slice(position, position + search.length) === search;
            };
    var fromCodePoint = hasNativeFromCodePoint
        ? String.fromCodePoint
        : // IE11
            function fromCodePoint() {
                var codePoints = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    codePoints[_i] = arguments[_i];
                }
                var elements = '';
                var length = codePoints.length;
                var i = 0;
                var code;
                while (length > i) {
                    code = codePoints[i++];
                    if (code > 0x10ffff)
                        throw RangeError(code + ' is not a valid code point');
                    elements +=
                        code < 0x10000
                            ? String.fromCharCode(code)
                            : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);
                }
                return elements;
            };
    var fromEntries = 
    // native
    hasNativeFromEntries
        ? Object.fromEntries
        : // Ponyfill
            function fromEntries(entries) {
                var obj = {};
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var _a = entries_1[_i], k = _a[0], v = _a[1];
                    obj[k] = v;
                }
                return obj;
            };
    var codePointAt = hasNativeCodePointAt
        ? // Native
            function codePointAt(s, index) {
                return s.codePointAt(index);
            }
        : // IE 11
            function codePointAt(s, index) {
                var size = s.length;
                if (index < 0 || index >= size) {
                    return undefined;
                }
                var first = s.charCodeAt(index);
                var second;
                return first < 0xd800 ||
                    first > 0xdbff ||
                    index + 1 === size ||
                    (second = s.charCodeAt(index + 1)) < 0xdc00 ||
                    second > 0xdfff
                    ? first
                    : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
            };
    var trimStart = hasTrimStart
        ? // Native
            function trimStart(s) {
                return s.trimStart();
            }
        : // Ponyfill
            function trimStart(s) {
                return s.replace(SPACE_SEPARATOR_START_REGEX, '');
            };
    var trimEnd = hasTrimEnd
        ? // Native
            function trimEnd(s) {
                return s.trimEnd();
            }
        : // Ponyfill
            function trimEnd(s) {
                return s.replace(SPACE_SEPARATOR_END_REGEX, '');
            };
    // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
    function RE(s, flag) {
        return new RegExp(s, flag);
    }
    // #endregion
    var matchIdentifierAtIndex;
    if (REGEX_SUPPORTS_U_AND_Y) {
        // Native
        var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var _a;
            IDENTIFIER_PREFIX_RE_1.lastIndex = index;
            var match = IDENTIFIER_PREFIX_RE_1.exec(s);
            return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
        };
    }
    else {
        // IE11
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var match = [];
            while (true) {
                var c = codePointAt(s, index);
                if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                    break;
                }
                match.push(c);
                index += c >= 0x10000 ? 2 : 1;
            }
            return fromCodePoint.apply(void 0, match);
        };
    }
    var Parser = /** @class */ (function () {
        function Parser(message, options) {
            if (options === void 0) { options = {}; }
            this.message = message;
            this.position = { offset: 0, line: 1, column: 1 };
            this.ignoreTag = !!options.ignoreTag;
            this.requiresOtherClause = !!options.requiresOtherClause;
            this.shouldParseSkeletons = !!options.shouldParseSkeletons;
        }
        Parser.prototype.parse = function () {
            if (this.offset() !== 0) {
                throw Error('parser can only be used once');
            }
            return this.parseMessage(0, '', false);
        };
        Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {
            var elements = [];
            while (!this.isEOF()) {
                var char = this.char();
                if (char === 123 /* `{` */) {
                    var result = this.parseArgument(nestingLevel, expectingCloseTag);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else if (char === 125 /* `}` */ && nestingLevel > 0) {
                    break;
                }
                else if (char === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                    var position = this.clonePosition();
                    this.bump();
                    elements.push({
                        type: TYPE.pound,
                        location: createLocation(position, this.clonePosition()),
                    });
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    this.peek() === 47 // char code for '/'
                ) {
                    if (expectingCloseTag) {
                        break;
                    }
                    else {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    _isAlpha(this.peek() || 0)) {
                    var result = this.parseTag(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else {
                    var result = this.parseLiteral(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
            }
            return { val: elements, err: null };
        };
        /**
         * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
         * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
         * are accepted:
         *
         * ```
         * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
         * tagName ::= [a-z] (PENChar)*
         * PENChar ::=
         *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
         *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
         *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
         * ```
         *
         * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
         * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
         * since other tag-based engines like React allow it
         */
        Parser.prototype.parseTag = function (nestingLevel, parentArgType) {
            var startPosition = this.clonePosition();
            this.bump(); // `<`
            var tagName = this.parseTagName();
            this.bumpSpace();
            if (this.bumpIf('/>')) {
                // Self closing tag
                return {
                    val: {
                        type: TYPE.literal,
                        value: "<".concat(tagName, "/>"),
                        location: createLocation(startPosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            else if (this.bumpIf('>')) {
                var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
                if (childrenResult.err) {
                    return childrenResult;
                }
                var children = childrenResult.val;
                // Expecting a close tag
                var endTagStartPosition = this.clonePosition();
                if (this.bumpIf('</')) {
                    if (this.isEOF() || !_isAlpha(this.char())) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    var closingTagNameStartPosition = this.clonePosition();
                    var closingTagName = this.parseTagName();
                    if (tagName !== closingTagName) {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                    }
                    this.bumpSpace();
                    if (!this.bumpIf('>')) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    return {
                        val: {
                            type: TYPE.tag,
                            value: tagName,
                            children: children,
                            location: createLocation(startPosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                else {
                    return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
                }
            }
            else {
                return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
            }
        };
        /**
         * This method assumes that the caller has peeked ahead for the first tag character.
         */
        Parser.prototype.parseTagName = function () {
            var startOffset = this.offset();
            this.bump(); // the first tag name character
            while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
                this.bump();
            }
            return this.message.slice(startOffset, this.offset());
        };
        Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {
            var start = this.clonePosition();
            var value = '';
            while (true) {
                var parseQuoteResult = this.tryParseQuote(parentArgType);
                if (parseQuoteResult) {
                    value += parseQuoteResult;
                    continue;
                }
                var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
                if (parseUnquotedResult) {
                    value += parseUnquotedResult;
                    continue;
                }
                var parseLeftAngleResult = this.tryParseLeftAngleBracket();
                if (parseLeftAngleResult) {
                    value += parseLeftAngleResult;
                    continue;
                }
                break;
            }
            var location = createLocation(start, this.clonePosition());
            return {
                val: { type: TYPE.literal, value: value, location: location },
                err: null,
            };
        };
        Parser.prototype.tryParseLeftAngleBracket = function () {
            if (!this.isEOF() &&
                this.char() === 60 /* `<` */ &&
                (this.ignoreTag ||
                    // If at the opening tag or closing tag position, bail.
                    !_isAlphaOrSlash(this.peek() || 0))) {
                this.bump(); // `<`
                return '<';
            }
            return null;
        };
        /**
         * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
         * a character that requires quoting (that is, "only where needed"), and works the same in
         * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
         */
        Parser.prototype.tryParseQuote = function (parentArgType) {
            if (this.isEOF() || this.char() !== 39 /* `'` */) {
                return null;
            }
            // Parse escaped char following the apostrophe, or early return if there is no escaped char.
            // Check if is valid escaped character
            switch (this.peek()) {
                case 39 /* `'` */:
                    // double quote, should return as a single quote.
                    this.bump();
                    this.bump();
                    return "'";
                // '{', '<', '>', '}'
                case 123:
                case 60:
                case 62:
                case 125:
                    break;
                case 35: // '#'
                    if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                        break;
                    }
                    return null;
                default:
                    return null;
            }
            this.bump(); // apostrophe
            var codePoints = [this.char()]; // escaped char
            this.bump();
            // read chars until the optional closing apostrophe is found
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch === 39 /* `'` */) {
                    if (this.peek() === 39 /* `'` */) {
                        codePoints.push(39);
                        // Bump one more time because we need to skip 2 characters.
                        this.bump();
                    }
                    else {
                        // Optional closing apostrophe.
                        this.bump();
                        break;
                    }
                }
                else {
                    codePoints.push(ch);
                }
                this.bump();
            }
            return fromCodePoint.apply(void 0, codePoints);
        };
        Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {
            if (this.isEOF()) {
                return null;
            }
            var ch = this.char();
            if (ch === 60 /* `<` */ ||
                ch === 123 /* `{` */ ||
                (ch === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||
                (ch === 125 /* `}` */ && nestingLevel > 0)) {
                return null;
            }
            else {
                this.bump();
                return fromCodePoint(ch);
            }
        };
        Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {
            var openingBracePosition = this.clonePosition();
            this.bump(); // `{`
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            if (this.char() === 125 /* `}` */) {
                this.bump();
                return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            // argument name
            var value = this.parseIdentifierIfPossible().value;
            if (!value) {
                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            switch (this.char()) {
                // Simple argument: `{name}`
                case 125 /* `}` */: {
                    this.bump(); // `}`
                    return {
                        val: {
                            type: TYPE.argument,
                            // value does not include the opening and closing braces.
                            value: value,
                            location: createLocation(openingBracePosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                // Argument with options: `{name, format, ...}`
                case 44 /* `,` */: {
                    this.bump(); // `,`
                    this.bumpSpace();
                    if (this.isEOF()) {
                        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                    }
                    return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
                }
                default:
                    return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
        };
        /**
         * Advance the parser until the end of the identifier, if it is currently on
         * an identifier character. Return an empty string otherwise.
         */
        Parser.prototype.parseIdentifierIfPossible = function () {
            var startingPosition = this.clonePosition();
            var startOffset = this.offset();
            var value = matchIdentifierAtIndex(this.message, startOffset);
            var endOffset = startOffset + value.length;
            this.bumpTo(endOffset);
            var endPosition = this.clonePosition();
            var location = createLocation(startingPosition, endPosition);
            return { value: value, location: location };
        };
        Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {
            var _a;
            // Parse this range:
            // {name, type, style}
            //        ^---^
            var typeStartPosition = this.clonePosition();
            var argType = this.parseIdentifierIfPossible().value;
            var typeEndPosition = this.clonePosition();
            switch (argType) {
                case '':
                    // Expecting a style string number, date, time, plural, selectordinal, or select.
                    return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
                case 'number':
                case 'date':
                case 'time': {
                    // Parse this range:
                    // {name, number, style}
                    //              ^-------^
                    this.bumpSpace();
                    var styleAndLocation = null;
                    if (this.bumpIf(',')) {
                        this.bumpSpace();
                        var styleStartPosition = this.clonePosition();
                        var result = this.parseSimpleArgStyleIfPossible();
                        if (result.err) {
                            return result;
                        }
                        var style = trimEnd(result.val);
                        if (style.length === 0) {
                            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                        styleAndLocation = { style: style, styleLocation: styleLocation };
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_1 = createLocation(openingBracePosition, this.clonePosition());
                    // Extract style or skeleton
                    if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                        // Skeleton starts with `::`.
                        var skeleton = trimStart(styleAndLocation.style.slice(2));
                        if (argType === 'number') {
                            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                            if (result.err) {
                                return result;
                            }
                            return {
                                val: { type: TYPE.number, value: value, location: location_1, style: result.val },
                                err: null,
                            };
                        }
                        else {
                            if (skeleton.length === 0) {
                                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
                            }
                            var style = {
                                type: SKELETON_TYPE.dateTime,
                                pattern: skeleton,
                                location: styleAndLocation.styleLocation,
                                parsedOptions: this.shouldParseSkeletons
                                    ? parseDateTimeSkeleton(skeleton)
                                    : {},
                            };
                            var type = argType === 'date' ? TYPE.date : TYPE.time;
                            return {
                                val: { type: type, value: value, location: location_1, style: style },
                                err: null,
                            };
                        }
                    }
                    // Regular style or no style.
                    return {
                        val: {
                            type: argType === 'number'
                                ? TYPE.number
                                : argType === 'date'
                                    ? TYPE.date
                                    : TYPE.time,
                            value: value,
                            location: location_1,
                            style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,
                        },
                        err: null,
                    };
                }
                case 'plural':
                case 'selectordinal':
                case 'select': {
                    // Parse this range:
                    // {name, plural, options}
                    //              ^---------^
                    var typeEndPosition_1 = this.clonePosition();
                    this.bumpSpace();
                    if (!this.bumpIf(',')) {
                        return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign$1({}, typeEndPosition_1)));
                    }
                    this.bumpSpace();
                    // Parse offset:
                    // {name, plural, offset:1, options}
                    //                ^-----^
                    //
                    // or the first option:
                    //
                    // {name, plural, one {...} other {...}}
                    //                ^--^
                    var identifierAndLocation = this.parseIdentifierIfPossible();
                    var pluralOffset = 0;
                    if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                        if (!this.bumpIf(':')) {
                            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        this.bumpSpace();
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                        if (result.err) {
                            return result;
                        }
                        // Parse another identifier for option parsing
                        this.bumpSpace();
                        identifierAndLocation = this.parseIdentifierIfPossible();
                        pluralOffset = result.val;
                    }
                    var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                    if (optionsResult.err) {
                        return optionsResult;
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_2 = createLocation(openingBracePosition, this.clonePosition());
                    if (argType === 'select') {
                        return {
                            val: {
                                type: TYPE.select,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                    else {
                        return {
                            val: {
                                type: TYPE.plural,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                offset: pluralOffset,
                                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                }
                default:
                    return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            }
        };
        Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {
            // Parse: {value, number, ::currency/GBP }
            //
            if (this.isEOF() || this.char() !== 125 /* `}` */) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bump(); // `}`
            return { val: true, err: null };
        };
        /**
         * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
         */
        Parser.prototype.parseSimpleArgStyleIfPossible = function () {
            var nestedBraces = 0;
            var startPosition = this.clonePosition();
            while (!this.isEOF()) {
                var ch = this.char();
                switch (ch) {
                    case 39 /* `'` */: {
                        // Treat apostrophe as quoting but include it in the style part.
                        // Find the end of the quoted literal text.
                        this.bump();
                        var apostrophePosition = this.clonePosition();
                        if (!this.bumpUntil("'")) {
                            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                        }
                        this.bump();
                        break;
                    }
                    case 123 /* `{` */: {
                        nestedBraces += 1;
                        this.bump();
                        break;
                    }
                    case 125 /* `}` */: {
                        if (nestedBraces > 0) {
                            nestedBraces -= 1;
                        }
                        else {
                            return {
                                val: this.message.slice(startPosition.offset, this.offset()),
                                err: null,
                            };
                        }
                        break;
                    }
                    default:
                        this.bump();
                        break;
                }
            }
            return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null,
            };
        };
        Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {
            var tokens = [];
            try {
                tokens = parseNumberSkeletonFromString(skeleton);
            }
            catch (e) {
                return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
            }
            return {
                val: {
                    type: SKELETON_TYPE.number,
                    tokens: tokens,
                    location: location,
                    parsedOptions: this.shouldParseSkeletons
                        ? parseNumberSkeleton(tokens)
                        : {},
                },
                err: null,
            };
        };
        /**
         * @param nesting_level The current nesting level of messages.
         *     This can be positive when parsing message fragment in select or plural argument options.
         * @param parent_arg_type The parent argument's type.
         * @param parsed_first_identifier If provided, this is the first identifier-like selector of
         *     the argument. It is a by-product of a previous parsing attempt.
         * @param expecting_close_tag If true, this message is directly or indirectly nested inside
         *     between a pair of opening and closing tags. The nested message will not parse beyond
         *     the closing tag boundary.
         */
        Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
            var _a;
            var hasOtherClause = false;
            var options = [];
            var parsedSelectors = new Set();
            var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
            // Parse:
            // one {one apple}
            // ^--^
            while (true) {
                if (selector.length === 0) {
                    var startPosition = this.clonePosition();
                    if (parentArgType !== 'select' && this.bumpIf('=')) {
                        // Try parse `={number}` selector
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
                        if (result.err) {
                            return result;
                        }
                        selectorLocation = createLocation(startPosition, this.clonePosition());
                        selector = this.message.slice(startPosition.offset, this.offset());
                    }
                    else {
                        break;
                    }
                }
                // Duplicate selector clauses
                if (parsedSelectors.has(selector)) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR
                        : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
                }
                if (selector === 'other') {
                    hasOtherClause = true;
                }
                // Parse:
                // one {one apple}
                //     ^----------^
                this.bumpSpace();
                var openingBracePosition = this.clonePosition();
                if (!this.bumpIf('{')) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
                        : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
                }
                var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
                if (fragmentResult.err) {
                    return fragmentResult;
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                options.push([
                    selector,
                    {
                        value: fragmentResult.val,
                        location: createLocation(openingBracePosition, this.clonePosition()),
                    },
                ]);
                // Keep track of the existing selectors
                parsedSelectors.add(selector);
                // Prep next selector clause.
                this.bumpSpace();
                (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);
            }
            if (options.length === 0) {
                return this.error(parentArgType === 'select'
                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR
                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
            }
            if (this.requiresOtherClause && !hasOtherClause) {
                return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            return { val: options, err: null };
        };
        Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {
            var sign = 1;
            var startingPosition = this.clonePosition();
            if (this.bumpIf('+')) ;
            else if (this.bumpIf('-')) {
                sign = -1;
            }
            var hasDigits = false;
            var decimal = 0;
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {
                    hasDigits = true;
                    decimal = decimal * 10 + (ch - 48);
                    this.bump();
                }
                else {
                    break;
                }
            }
            var location = createLocation(startingPosition, this.clonePosition());
            if (!hasDigits) {
                return this.error(expectNumberError, location);
            }
            decimal *= sign;
            if (!isSafeInteger(decimal)) {
                return this.error(invalidNumberError, location);
            }
            return { val: decimal, err: null };
        };
        Parser.prototype.offset = function () {
            return this.position.offset;
        };
        Parser.prototype.isEOF = function () {
            return this.offset() === this.message.length;
        };
        Parser.prototype.clonePosition = function () {
            // This is much faster than `Object.assign` or spread.
            return {
                offset: this.position.offset,
                line: this.position.line,
                column: this.position.column,
            };
        };
        /**
         * Return the code point at the current position of the parser.
         * Throws if the index is out of bound.
         */
        Parser.prototype.char = function () {
            var offset = this.position.offset;
            if (offset >= this.message.length) {
                throw Error('out of bound');
            }
            var code = codePointAt(this.message, offset);
            if (code === undefined) {
                throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
            }
            return code;
        };
        Parser.prototype.error = function (kind, location) {
            return {
                val: null,
                err: {
                    kind: kind,
                    message: this.message,
                    location: location,
                },
            };
        };
        /** Bump the parser to the next UTF-16 code unit. */
        Parser.prototype.bump = function () {
            if (this.isEOF()) {
                return;
            }
            var code = this.char();
            if (code === 10 /* '\n' */) {
                this.position.line += 1;
                this.position.column = 1;
                this.position.offset += 1;
            }
            else {
                this.position.column += 1;
                // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
                this.position.offset += code < 0x10000 ? 1 : 2;
            }
        };
        /**
         * If the substring starting at the current position of the parser has
         * the given prefix, then bump the parser to the character immediately
         * following the prefix and return true. Otherwise, don't bump the parser
         * and return false.
         */
        Parser.prototype.bumpIf = function (prefix) {
            if (startsWith(this.message, prefix, this.offset())) {
                for (var i = 0; i < prefix.length; i++) {
                    this.bump();
                }
                return true;
            }
            return false;
        };
        /**
         * Bump the parser until the pattern character is found and return `true`.
         * Otherwise bump to the end of the file and return `false`.
         */
        Parser.prototype.bumpUntil = function (pattern) {
            var currentOffset = this.offset();
            var index = this.message.indexOf(pattern, currentOffset);
            if (index >= 0) {
                this.bumpTo(index);
                return true;
            }
            else {
                this.bumpTo(this.message.length);
                return false;
            }
        };
        /**
         * Bump the parser to the target offset.
         * If target offset is beyond the end of the input, bump the parser to the end of the input.
         */
        Parser.prototype.bumpTo = function (targetOffset) {
            if (this.offset() > targetOffset) {
                throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
            }
            targetOffset = Math.min(targetOffset, this.message.length);
            while (true) {
                var offset = this.offset();
                if (offset === targetOffset) {
                    break;
                }
                if (offset > targetOffset) {
                    throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
                }
                this.bump();
                if (this.isEOF()) {
                    break;
                }
            }
        };
        /** advance the parser through all whitespace to the next non-whitespace code unit. */
        Parser.prototype.bumpSpace = function () {
            while (!this.isEOF() && _isWhiteSpace(this.char())) {
                this.bump();
            }
        };
        /**
         * Peek at the *next* Unicode codepoint in the input without advancing the parser.
         * If the input has been exhausted, then this returns null.
         */
        Parser.prototype.peek = function () {
            if (this.isEOF()) {
                return null;
            }
            var code = this.char();
            var offset = this.offset();
            var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
            return nextCode !== null && nextCode !== void 0 ? nextCode : null;
        };
        return Parser;
    }());
    /**
     * This check if codepoint is alphabet (lower & uppercase)
     * @param codepoint
     * @returns
     */
    function _isAlpha(codepoint) {
        return ((codepoint >= 97 && codepoint <= 122) ||
            (codepoint >= 65 && codepoint <= 90));
    }
    function _isAlphaOrSlash(codepoint) {
        return _isAlpha(codepoint) || codepoint === 47; /* '/' */
    }
    /** See `parseTag` function docs. */
    function _isPotentialElementNameChar(c) {
        return (c === 45 /* '-' */ ||
            c === 46 /* '.' */ ||
            (c >= 48 && c <= 57) /* 0..9 */ ||
            c === 95 /* '_' */ ||
            (c >= 97 && c <= 122) /** a..z */ ||
            (c >= 65 && c <= 90) /* A..Z */ ||
            c == 0xb7 ||
            (c >= 0xc0 && c <= 0xd6) ||
            (c >= 0xd8 && c <= 0xf6) ||
            (c >= 0xf8 && c <= 0x37d) ||
            (c >= 0x37f && c <= 0x1fff) ||
            (c >= 0x200c && c <= 0x200d) ||
            (c >= 0x203f && c <= 0x2040) ||
            (c >= 0x2070 && c <= 0x218f) ||
            (c >= 0x2c00 && c <= 0x2fef) ||
            (c >= 0x3001 && c <= 0xd7ff) ||
            (c >= 0xf900 && c <= 0xfdcf) ||
            (c >= 0xfdf0 && c <= 0xfffd) ||
            (c >= 0x10000 && c <= 0xeffff));
    }
    /**
     * Code point equivalent of regex `\p{White_Space}`.
     * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isWhiteSpace(c) {
        return ((c >= 0x0009 && c <= 0x000d) ||
            c === 0x0020 ||
            c === 0x0085 ||
            (c >= 0x200e && c <= 0x200f) ||
            c === 0x2028 ||
            c === 0x2029);
    }
    /**
     * Code point equivalent of regex `\p{Pattern_Syntax}`.
     * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isPatternSyntax(c) {
        return ((c >= 0x0021 && c <= 0x0023) ||
            c === 0x0024 ||
            (c >= 0x0025 && c <= 0x0027) ||
            c === 0x0028 ||
            c === 0x0029 ||
            c === 0x002a ||
            c === 0x002b ||
            c === 0x002c ||
            c === 0x002d ||
            (c >= 0x002e && c <= 0x002f) ||
            (c >= 0x003a && c <= 0x003b) ||
            (c >= 0x003c && c <= 0x003e) ||
            (c >= 0x003f && c <= 0x0040) ||
            c === 0x005b ||
            c === 0x005c ||
            c === 0x005d ||
            c === 0x005e ||
            c === 0x0060 ||
            c === 0x007b ||
            c === 0x007c ||
            c === 0x007d ||
            c === 0x007e ||
            c === 0x00a1 ||
            (c >= 0x00a2 && c <= 0x00a5) ||
            c === 0x00a6 ||
            c === 0x00a7 ||
            c === 0x00a9 ||
            c === 0x00ab ||
            c === 0x00ac ||
            c === 0x00ae ||
            c === 0x00b0 ||
            c === 0x00b1 ||
            c === 0x00b6 ||
            c === 0x00bb ||
            c === 0x00bf ||
            c === 0x00d7 ||
            c === 0x00f7 ||
            (c >= 0x2010 && c <= 0x2015) ||
            (c >= 0x2016 && c <= 0x2017) ||
            c === 0x2018 ||
            c === 0x2019 ||
            c === 0x201a ||
            (c >= 0x201b && c <= 0x201c) ||
            c === 0x201d ||
            c === 0x201e ||
            c === 0x201f ||
            (c >= 0x2020 && c <= 0x2027) ||
            (c >= 0x2030 && c <= 0x2038) ||
            c === 0x2039 ||
            c === 0x203a ||
            (c >= 0x203b && c <= 0x203e) ||
            (c >= 0x2041 && c <= 0x2043) ||
            c === 0x2044 ||
            c === 0x2045 ||
            c === 0x2046 ||
            (c >= 0x2047 && c <= 0x2051) ||
            c === 0x2052 ||
            c === 0x2053 ||
            (c >= 0x2055 && c <= 0x205e) ||
            (c >= 0x2190 && c <= 0x2194) ||
            (c >= 0x2195 && c <= 0x2199) ||
            (c >= 0x219a && c <= 0x219b) ||
            (c >= 0x219c && c <= 0x219f) ||
            c === 0x21a0 ||
            (c >= 0x21a1 && c <= 0x21a2) ||
            c === 0x21a3 ||
            (c >= 0x21a4 && c <= 0x21a5) ||
            c === 0x21a6 ||
            (c >= 0x21a7 && c <= 0x21ad) ||
            c === 0x21ae ||
            (c >= 0x21af && c <= 0x21cd) ||
            (c >= 0x21ce && c <= 0x21cf) ||
            (c >= 0x21d0 && c <= 0x21d1) ||
            c === 0x21d2 ||
            c === 0x21d3 ||
            c === 0x21d4 ||
            (c >= 0x21d5 && c <= 0x21f3) ||
            (c >= 0x21f4 && c <= 0x22ff) ||
            (c >= 0x2300 && c <= 0x2307) ||
            c === 0x2308 ||
            c === 0x2309 ||
            c === 0x230a ||
            c === 0x230b ||
            (c >= 0x230c && c <= 0x231f) ||
            (c >= 0x2320 && c <= 0x2321) ||
            (c >= 0x2322 && c <= 0x2328) ||
            c === 0x2329 ||
            c === 0x232a ||
            (c >= 0x232b && c <= 0x237b) ||
            c === 0x237c ||
            (c >= 0x237d && c <= 0x239a) ||
            (c >= 0x239b && c <= 0x23b3) ||
            (c >= 0x23b4 && c <= 0x23db) ||
            (c >= 0x23dc && c <= 0x23e1) ||
            (c >= 0x23e2 && c <= 0x2426) ||
            (c >= 0x2427 && c <= 0x243f) ||
            (c >= 0x2440 && c <= 0x244a) ||
            (c >= 0x244b && c <= 0x245f) ||
            (c >= 0x2500 && c <= 0x25b6) ||
            c === 0x25b7 ||
            (c >= 0x25b8 && c <= 0x25c0) ||
            c === 0x25c1 ||
            (c >= 0x25c2 && c <= 0x25f7) ||
            (c >= 0x25f8 && c <= 0x25ff) ||
            (c >= 0x2600 && c <= 0x266e) ||
            c === 0x266f ||
            (c >= 0x2670 && c <= 0x2767) ||
            c === 0x2768 ||
            c === 0x2769 ||
            c === 0x276a ||
            c === 0x276b ||
            c === 0x276c ||
            c === 0x276d ||
            c === 0x276e ||
            c === 0x276f ||
            c === 0x2770 ||
            c === 0x2771 ||
            c === 0x2772 ||
            c === 0x2773 ||
            c === 0x2774 ||
            c === 0x2775 ||
            (c >= 0x2794 && c <= 0x27bf) ||
            (c >= 0x27c0 && c <= 0x27c4) ||
            c === 0x27c5 ||
            c === 0x27c6 ||
            (c >= 0x27c7 && c <= 0x27e5) ||
            c === 0x27e6 ||
            c === 0x27e7 ||
            c === 0x27e8 ||
            c === 0x27e9 ||
            c === 0x27ea ||
            c === 0x27eb ||
            c === 0x27ec ||
            c === 0x27ed ||
            c === 0x27ee ||
            c === 0x27ef ||
            (c >= 0x27f0 && c <= 0x27ff) ||
            (c >= 0x2800 && c <= 0x28ff) ||
            (c >= 0x2900 && c <= 0x2982) ||
            c === 0x2983 ||
            c === 0x2984 ||
            c === 0x2985 ||
            c === 0x2986 ||
            c === 0x2987 ||
            c === 0x2988 ||
            c === 0x2989 ||
            c === 0x298a ||
            c === 0x298b ||
            c === 0x298c ||
            c === 0x298d ||
            c === 0x298e ||
            c === 0x298f ||
            c === 0x2990 ||
            c === 0x2991 ||
            c === 0x2992 ||
            c === 0x2993 ||
            c === 0x2994 ||
            c === 0x2995 ||
            c === 0x2996 ||
            c === 0x2997 ||
            c === 0x2998 ||
            (c >= 0x2999 && c <= 0x29d7) ||
            c === 0x29d8 ||
            c === 0x29d9 ||
            c === 0x29da ||
            c === 0x29db ||
            (c >= 0x29dc && c <= 0x29fb) ||
            c === 0x29fc ||
            c === 0x29fd ||
            (c >= 0x29fe && c <= 0x2aff) ||
            (c >= 0x2b00 && c <= 0x2b2f) ||
            (c >= 0x2b30 && c <= 0x2b44) ||
            (c >= 0x2b45 && c <= 0x2b46) ||
            (c >= 0x2b47 && c <= 0x2b4c) ||
            (c >= 0x2b4d && c <= 0x2b73) ||
            (c >= 0x2b74 && c <= 0x2b75) ||
            (c >= 0x2b76 && c <= 0x2b95) ||
            c === 0x2b96 ||
            (c >= 0x2b97 && c <= 0x2bff) ||
            (c >= 0x2e00 && c <= 0x2e01) ||
            c === 0x2e02 ||
            c === 0x2e03 ||
            c === 0x2e04 ||
            c === 0x2e05 ||
            (c >= 0x2e06 && c <= 0x2e08) ||
            c === 0x2e09 ||
            c === 0x2e0a ||
            c === 0x2e0b ||
            c === 0x2e0c ||
            c === 0x2e0d ||
            (c >= 0x2e0e && c <= 0x2e16) ||
            c === 0x2e17 ||
            (c >= 0x2e18 && c <= 0x2e19) ||
            c === 0x2e1a ||
            c === 0x2e1b ||
            c === 0x2e1c ||
            c === 0x2e1d ||
            (c >= 0x2e1e && c <= 0x2e1f) ||
            c === 0x2e20 ||
            c === 0x2e21 ||
            c === 0x2e22 ||
            c === 0x2e23 ||
            c === 0x2e24 ||
            c === 0x2e25 ||
            c === 0x2e26 ||
            c === 0x2e27 ||
            c === 0x2e28 ||
            c === 0x2e29 ||
            (c >= 0x2e2a && c <= 0x2e2e) ||
            c === 0x2e2f ||
            (c >= 0x2e30 && c <= 0x2e39) ||
            (c >= 0x2e3a && c <= 0x2e3b) ||
            (c >= 0x2e3c && c <= 0x2e3f) ||
            c === 0x2e40 ||
            c === 0x2e41 ||
            c === 0x2e42 ||
            (c >= 0x2e43 && c <= 0x2e4f) ||
            (c >= 0x2e50 && c <= 0x2e51) ||
            c === 0x2e52 ||
            (c >= 0x2e53 && c <= 0x2e7f) ||
            (c >= 0x3001 && c <= 0x3003) ||
            c === 0x3008 ||
            c === 0x3009 ||
            c === 0x300a ||
            c === 0x300b ||
            c === 0x300c ||
            c === 0x300d ||
            c === 0x300e ||
            c === 0x300f ||
            c === 0x3010 ||
            c === 0x3011 ||
            (c >= 0x3012 && c <= 0x3013) ||
            c === 0x3014 ||
            c === 0x3015 ||
            c === 0x3016 ||
            c === 0x3017 ||
            c === 0x3018 ||
            c === 0x3019 ||
            c === 0x301a ||
            c === 0x301b ||
            c === 0x301c ||
            c === 0x301d ||
            (c >= 0x301e && c <= 0x301f) ||
            c === 0x3020 ||
            c === 0x3030 ||
            c === 0xfd3e ||
            c === 0xfd3f ||
            (c >= 0xfe45 && c <= 0xfe46));
    }

    function pruneLocation(els) {
        els.forEach(function (el) {
            delete el.location;
            if (isSelectElement(el) || isPluralElement(el)) {
                for (var k in el.options) {
                    delete el.options[k].location;
                    pruneLocation(el.options[k].value);
                }
            }
            else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
                delete el.style.location;
            }
            else if ((isDateElement(el) || isTimeElement(el)) &&
                isDateTimeSkeleton(el.style)) {
                delete el.style.location;
            }
            else if (isTagElement(el)) {
                pruneLocation(el.children);
            }
        });
    }
    function parse(message, opts) {
        if (opts === void 0) { opts = {}; }
        opts = __assign$1({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
        var result = new Parser(message, opts).parse();
        if (result.err) {
            var error = SyntaxError(ErrorKind[result.err.kind]);
            // @ts-expect-error Assign to error object
            error.location = result.err.location;
            // @ts-expect-error Assign to error object
            error.originalMessage = result.err.message;
            throw error;
        }
        if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
            pruneLocation(result.val);
        }
        return result.val;
    }

    //
    // Main
    //
    function memoize(fn, options) {
        var cache = options && options.cache ? options.cache : cacheDefault;
        var serializer = options && options.serializer ? options.serializer : serializerDefault;
        var strategy = options && options.strategy ? options.strategy : strategyDefault;
        return strategy(fn, {
            cache: cache,
            serializer: serializer,
        });
    }
    //
    // Strategy
    //
    function isPrimitive(value) {
        return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
    }
    function monadic(fn, cache, serializer, arg) {
        var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.call(this, arg);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function variadic(fn, cache, serializer) {
        var args = Array.prototype.slice.call(arguments, 3);
        var cacheKey = serializer(args);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.apply(this, args);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function assemble(fn, context, strategy, cache, serialize) {
        return strategy.bind(context, fn, cache, serialize);
    }
    function strategyDefault(fn, options) {
        var strategy = fn.length === 1 ? monadic : variadic;
        return assemble(fn, this, strategy, options.cache.create(), options.serializer);
    }
    function strategyVariadic(fn, options) {
        return assemble(fn, this, variadic, options.cache.create(), options.serializer);
    }
    function strategyMonadic(fn, options) {
        return assemble(fn, this, monadic, options.cache.create(), options.serializer);
    }
    //
    // Serializer
    //
    var serializerDefault = function () {
        return JSON.stringify(arguments);
    };
    //
    // Cache
    //
    function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.get = function (key) {
        return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
        this.cache[key] = value;
    };
    var cacheDefault = {
        create: function create() {
            // @ts-ignore
            return new ObjectWithoutPrototypeCache();
        },
    };
    var strategies = {
        variadic: strategyVariadic,
        monadic: strategyMonadic,
    };

    var ErrorCode;
    (function (ErrorCode) {
        // When we have a placeholder but no value to format
        ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
        // When value supplied is invalid
        ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
        // When we need specific Intl API but it's not available
        ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
    })(ErrorCode || (ErrorCode = {}));
    var FormatError = /** @class */ (function (_super) {
        __extends(FormatError, _super);
        function FormatError(msg, code, originalMessage) {
            var _this = _super.call(this, msg) || this;
            _this.code = code;
            _this.originalMessage = originalMessage;
            return _this;
        }
        FormatError.prototype.toString = function () {
            return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
        };
        return FormatError;
    }(Error));
    var InvalidValueError = /** @class */ (function (_super) {
        __extends(InvalidValueError, _super);
        function InvalidValueError(variableId, value, options, originalMessage) {
            return _super.call(this, "Invalid values for \"".concat(variableId, "\": \"").concat(value, "\". Options are \"").concat(Object.keys(options).join('", "'), "\""), ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueError;
    }(FormatError));
    var InvalidValueTypeError = /** @class */ (function (_super) {
        __extends(InvalidValueTypeError, _super);
        function InvalidValueTypeError(value, type, originalMessage) {
            return _super.call(this, "Value for \"".concat(value, "\" must be of type ").concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueTypeError;
    }(FormatError));
    var MissingValueError = /** @class */ (function (_super) {
        __extends(MissingValueError, _super);
        function MissingValueError(variableId, originalMessage) {
            return _super.call(this, "The intl string context variable \"".concat(variableId, "\" was not provided to the string \"").concat(originalMessage, "\""), ErrorCode.MISSING_VALUE, originalMessage) || this;
        }
        return MissingValueError;
    }(FormatError));

    var PART_TYPE;
    (function (PART_TYPE) {
        PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
        PART_TYPE[PART_TYPE["object"] = 1] = "object";
    })(PART_TYPE || (PART_TYPE = {}));
    function mergeLiteral(parts) {
        if (parts.length < 2) {
            return parts;
        }
        return parts.reduce(function (all, part) {
            var lastPart = all[all.length - 1];
            if (!lastPart ||
                lastPart.type !== PART_TYPE.literal ||
                part.type !== PART_TYPE.literal) {
                all.push(part);
            }
            else {
                lastPart.value += part.value;
            }
            return all;
        }, []);
    }
    function isFormatXMLElementFn(el) {
        return typeof el === 'function';
    }
    // TODO(skeleton): add skeleton support
    function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
    // For debugging
    originalMessage) {
        // Hot path for straight simple msg translations
        if (els.length === 1 && isLiteralElement(els[0])) {
            return [
                {
                    type: PART_TYPE.literal,
                    value: els[0].value,
                },
            ];
        }
        var result = [];
        for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
            var el = els_1[_i];
            // Exit early for string parts.
            if (isLiteralElement(el)) {
                result.push({
                    type: PART_TYPE.literal,
                    value: el.value,
                });
                continue;
            }
            // TODO: should this part be literal type?
            // Replace `#` in plural rules with the actual numeric value.
            if (isPoundElement(el)) {
                if (typeof currentPluralValue === 'number') {
                    result.push({
                        type: PART_TYPE.literal,
                        value: formatters.getNumberFormat(locales).format(currentPluralValue),
                    });
                }
                continue;
            }
            var varName = el.value;
            // Enforce that all required values are provided by the caller.
            if (!(values && varName in values)) {
                throw new MissingValueError(varName, originalMessage);
            }
            var value = values[varName];
            if (isArgumentElement(el)) {
                if (!value || typeof value === 'string' || typeof value === 'number') {
                    value =
                        typeof value === 'string' || typeof value === 'number'
                            ? String(value)
                            : '';
                }
                result.push({
                    type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: value,
                });
                continue;
            }
            // Recursively format plural and select parts' option  which can be a
            // nested pattern structure. The choosing of the option to use is
            // abstracted-by and delegated-to the part helper object.
            if (isDateElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.date[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTimeElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.time[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isNumberElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.number[el.style]
                    : isNumberSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                if (style && style.scale) {
                    value =
                        value *
                            (style.scale || 1);
                }
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getNumberFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTagElement(el)) {
                var children = el.children, value_1 = el.value;
                var formatFn = values[value_1];
                if (!isFormatXMLElementFn(formatFn)) {
                    throw new InvalidValueTypeError(value_1, 'function', originalMessage);
                }
                var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
                var chunks = formatFn(parts.map(function (p) { return p.value; }));
                if (!Array.isArray(chunks)) {
                    chunks = [chunks];
                }
                result.push.apply(result, chunks.map(function (c) {
                    return {
                        type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                        value: c,
                    };
                }));
            }
            if (isSelectElement(el)) {
                var opt = el.options[value] || el.options.other;
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
                continue;
            }
            if (isPluralElement(el)) {
                var opt = el.options["=".concat(value)];
                if (!opt) {
                    if (!Intl.PluralRules) {
                        throw new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", ErrorCode.MISSING_INTL_API, originalMessage);
                    }
                    var rule = formatters
                        .getPluralRules(locales, { type: el.pluralType })
                        .select(value - (el.offset || 0));
                    opt = el.options[rule] || el.options.other;
                }
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
                continue;
            }
        }
        return mergeLiteral(result);
    }

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    // -- MessageFormat --------------------------------------------------------
    function mergeConfig(c1, c2) {
        if (!c2) {
            return c1;
        }
        return __assign$2(__assign$2(__assign$2({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
            all[k] = __assign$2(__assign$2({}, c1[k]), (c2[k] || {}));
            return all;
        }, {}));
    }
    function mergeConfigs(defaultConfig, configs) {
        if (!configs) {
            return defaultConfig;
        }
        return Object.keys(defaultConfig).reduce(function (all, k) {
            all[k] = mergeConfig(defaultConfig[k], configs[k]);
            return all;
        }, __assign$2({}, defaultConfig));
    }
    function createFastMemoizeCache(store) {
        return {
            create: function () {
                return {
                    get: function (key) {
                        return store[key];
                    },
                    set: function (key, value) {
                        store[key] = value;
                    },
                };
            },
        };
    }
    function createDefaultFormatters(cache) {
        if (cache === void 0) { cache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        }; }
        return {
            getNumberFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.number),
                strategy: strategies.variadic,
            }),
            getDateTimeFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.dateTime),
                strategy: strategies.variadic,
            }),
            getPluralRules: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.pluralRules),
                strategy: strategies.variadic,
            }),
        };
    }
    var IntlMessageFormat = /** @class */ (function () {
        function IntlMessageFormat(message, locales, overrideFormats, opts) {
            var _this = this;
            if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
            this.formatterCache = {
                number: {},
                dateTime: {},
                pluralRules: {},
            };
            this.format = function (values) {
                var parts = _this.formatToParts(values);
                // Hot path for straight simple msg translations
                if (parts.length === 1) {
                    return parts[0].value;
                }
                var result = parts.reduce(function (all, part) {
                    if (!all.length ||
                        part.type !== PART_TYPE.literal ||
                        typeof all[all.length - 1] !== 'string') {
                        all.push(part.value);
                    }
                    else {
                        all[all.length - 1] += part.value;
                    }
                    return all;
                }, []);
                if (result.length <= 1) {
                    return result[0] || '';
                }
                return result;
            };
            this.formatToParts = function (values) {
                return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
            };
            this.resolvedOptions = function () { return ({
                locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
            }); };
            this.getAst = function () { return _this.ast; };
            if (typeof message === 'string') {
                this.message = message;
                if (!IntlMessageFormat.__parse) {
                    throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
                }
                // Parse string messages into an AST.
                this.ast = IntlMessageFormat.__parse(message, {
                    ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
                });
            }
            else {
                this.ast = message;
            }
            if (!Array.isArray(this.ast)) {
                throw new TypeError('A message must be provided as a String or AST.');
            }
            // Creates a new object with the specified `formats` merged with the default
            // formats.
            this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
            // Defined first because it's used to build the format pattern.
            this.locales = locales;
            this.formatters =
                (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
        }
        Object.defineProperty(IntlMessageFormat, "defaultLocale", {
            get: function () {
                if (!IntlMessageFormat.memoizedDefaultLocale) {
                    IntlMessageFormat.memoizedDefaultLocale =
                        new Intl.NumberFormat().resolvedOptions().locale;
                }
                return IntlMessageFormat.memoizedDefaultLocale;
            },
            enumerable: false,
            configurable: true
        });
        IntlMessageFormat.memoizedDefaultLocale = null;
        IntlMessageFormat.__parse = parse;
        // Default format options used as the prototype of the `formats` provided to the
        // constructor. These are used when constructing the internal Intl.NumberFormat
        // and Intl.DateTimeFormat instances.
        IntlMessageFormat.formats = {
            number: {
                integer: {
                    maximumFractionDigits: 0,
                },
                currency: {
                    style: 'currency',
                },
                percent: {
                    style: 'percent',
                },
            },
            date: {
                short: {
                    month: 'numeric',
                    day: 'numeric',
                    year: '2-digit',
                },
                medium: {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                },
                long: {
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
                full: {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
            },
            time: {
                short: {
                    hour: 'numeric',
                    minute: 'numeric',
                },
                medium: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                },
                long: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
                full: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
            },
        };
        return IntlMessageFormat;
    }());

    const r={},i=(e,n,t)=>t?(n in r||(r[n]={}),e in r[n]||(r[n][e]=t),t):t,l$1=(e,n)=>{if(null==n)return;if(n in r&&e in r[n])return r[n][e];const t=E(n);for(let o=0;o<t.length;o++){const r=c$1(t[o],e);if(r)return i(e,n,r)}};let a;const s$1=writable({});function u(e){return e in a}function c$1(e,n){if(!u(e))return null;return function(e,n){if(null==n)return;if(n in e)return e[n];const t=n.split(".");let o=e;for(let e=0;e<t.length;e++)if("object"==typeof o){if(e>0){const n=t.slice(e,t.length).join(".");if(n in o){o=o[n];break}}o=o[t[e]];}else o=void 0;return o}(function(e){return a[e]||null}(e),n)}function m$1(e,...n){delete r[e],s$1.update((o=>(o[e]=cjs.all([o[e]||{},...n]),o)));}derived([s$1],(([e])=>Object.keys(e)));s$1.subscribe((e=>a=e));const d$1={};function g$1(e){return d$1[e]}function w$1(e){return null!=e&&E(e).some((e=>{var n;return null===(n=g$1(e))||void 0===n?void 0:n.size}))}function h$1(e,n){return Promise.all(n.map((n=>(function(e,n){d$1[e].delete(n),0===d$1[e].size&&delete d$1[e];}(e,n),n().then((e=>e.default||e)))))).then((n=>m$1(e,...n)))}const p$1={};function b$1(e){if(!w$1(e))return e in p$1?p$1[e]:Promise.resolve();const n=function(e){return E(e).map((e=>{const n=g$1(e);return [e,n?[...n]:[]]})).filter((([,e])=>e.length>0))}(e);return p$1[e]=Promise.all(n.map((([e,n])=>h$1(e,n)))).then((()=>{if(w$1(e))return b$1(e);delete p$1[e];})),p$1[e]}function y$1(e,n){g$1(e)||function(e){d$1[e]=new Set;}(e);const t=g$1(e);g$1(e).has(n)||(u(e)||s$1.update((n=>(n[e]={},n))),t.add(n));}
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function v$1(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&n.indexOf(o)<0&&(t[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(o=Object.getOwnPropertySymbols(e);r<o.length;r++)n.indexOf(o[r])<0&&Object.prototype.propertyIsEnumerable.call(e,o[r])&&(t[o[r]]=e[o[r]]);}return t}const O={fallbackLocale:null,loadingDelay:200,formats:{number:{scientific:{notation:"scientific"},engineering:{notation:"engineering"},compactLong:{notation:"compact",compactDisplay:"long"},compactShort:{notation:"compact",compactDisplay:"short"}},date:{short:{month:"numeric",day:"numeric",year:"2-digit"},medium:{month:"short",day:"numeric",year:"numeric"},long:{month:"long",day:"numeric",year:"numeric"},full:{weekday:"long",month:"long",day:"numeric",year:"numeric"}},time:{short:{hour:"numeric",minute:"numeric"},medium:{hour:"numeric",minute:"numeric",second:"numeric"},long:{hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"short"},full:{hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"short"}}},warnOnMissingMessages:!0,ignoreTag:!0};function j(){return O}function $(e){const{formats:n}=e,t=v$1(e,["formats"]),o=e.initialLocale||e.fallbackLocale;return Object.assign(O,t,{initialLocale:o}),n&&("number"in n&&Object.assign(O.formats.number,n.number),"date"in n&&Object.assign(O.formats.date,n.date),"time"in n&&Object.assign(O.formats.time,n.time)),M$1.set(o)}const k=writable(!1);let L;const T=writable(null);function x(e){return e.split("-").map(((e,n,t)=>t.slice(0,n+1).join("-"))).reverse()}function E(e,n=j().fallbackLocale){const t=x(e);return n?[...new Set([...t,...x(n)])]:t}function D(){return null!=L?L:void 0}T.subscribe((e=>{L=null!=e?e:void 0,"undefined"!=typeof window&&null!=e&&document.documentElement.setAttribute("lang",e);}));const M$1=Object.assign(Object.assign({},T),{set:e=>{if(e&&function(e){if(null==e)return;const n=E(e);for(let e=0;e<n.length;e++){const t=n[e];if(u(t))return t}}(e)&&w$1(e)){const{loadingDelay:n}=j();let t;return "undefined"!=typeof window&&null!=D()&&n?t=window.setTimeout((()=>k.set(!0)),n):k.set(!0),b$1(e).then((()=>{T.set(e);})).finally((()=>{clearTimeout(t),k.set(!1);}))}return T.set(e)}}),I=()=>"undefined"==typeof window?null:window.navigator.language||window.navigator.languages[0],Z=e=>{const n=Object.create(null);return t=>{const o=JSON.stringify(t);return o in n?n[o]:n[o]=e(t)}},C=(e,n)=>{const{formats:t}=j();if(e in t&&n in t[e])return t[e][n];throw new Error(`[svelte-i18n] Unknown "${n}" ${e} format.`)},G=Z((e=>{var{locale:n,format:t}=e,o=v$1(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format numbers');return t&&(o=C("number",t)),new Intl.NumberFormat(n,o)})),J=Z((e=>{var{locale:n,format:t}=e,o=v$1(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format dates');return t?o=C("date",t):0===Object.keys(o).length&&(o=C("date","short")),new Intl.DateTimeFormat(n,o)})),U=Z((e=>{var{locale:n,format:t}=e,o=v$1(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format time values');return t?o=C("time",t):0===Object.keys(o).length&&(o=C("time","short")),new Intl.DateTimeFormat(n,o)})),_$1=(e={})=>{var{locale:n=D()}=e,t=v$1(e,["locale"]);return G(Object.assign({locale:n},t))},q=(e={})=>{var{locale:n=D()}=e,t=v$1(e,["locale"]);return J(Object.assign({locale:n},t))},B=(e={})=>{var{locale:n=D()}=e,t=v$1(e,["locale"]);return U(Object.assign({locale:n},t))},H=Z(((e,n=D())=>new IntlMessageFormat(e,n,j().formats,{ignoreTag:j().ignoreTag}))),K=(e,n={})=>{let t=n;"object"==typeof e&&(t=e,e=t.id);const{values:o,locale:r=D(),default:i}=t;if(null==r)throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");let a=l$1(e,r);if(a){if("string"!=typeof a)return console.warn(`[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof a}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`),a}else j().warnOnMissingMessages&&console.warn(`[svelte-i18n] The message "${e}" was not found in "${E(r).join('", "')}".${w$1(D())?"\n\nNote: there are at least one loader still registered to this locale that wasn't executed.":""}`),a=null!=i?i:e;if(!o)return a;let s=a;try{s=H(a,r).format(o);}catch(n){console.warn(`[svelte-i18n] Message "${e}" has syntax error:`,n.message);}return s},Q=(e,n)=>B(n).format(e),R=(e,n)=>q(n).format(e),V=(e,n)=>_$1(n).format(e),W=(e,n=D())=>l$1(e,n),X=derived([M$1,s$1],(()=>K));derived([M$1],(()=>Q));derived([M$1],(()=>R));derived([M$1],(()=>V));derived([M$1,s$1],(()=>W));

    /* src/components/about/AboutLink.svelte generated by Svelte v3.38.1 */

    // (14:0) <Link to="about" class="uk-text-muted">
    function create_default_slot$6(ctx) {
    	let t0_value = /*$_*/ ctx[1]("about.about") + "";
    	let t0;
    	let t1;
    	let t2_value = /*appVersion*/ ctx[0].version + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" - v");
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("about.about") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*appVersion*/ 1 && t2_value !== (t2_value = /*appVersion*/ ctx[0].version + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(14:0) <Link to=\\\"about\\\" class=\\\"uk-text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: "about",
    				class: "uk-text-muted",
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};

    			if (dirty & /*$$scope, appVersion, $_*/ 7) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AboutLink", slots, []);
    	let appVersion = {};

    	onMount(async () => {
    		app_version.subscribe(v => $$invalidate(0, appVersion = v));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AboutLink> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Link,
    		app_version,
    		_: X,
    		appVersion,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("appVersion" in $$props) $$invalidate(0, appVersion = $$props.appVersion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [appVersion, $_];
    }

    class AboutLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AboutLink",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    /* src/components/wallet/AccountSwitcher.svelte generated by Svelte v3.38.1 */
    const file$Y = "src/components/wallet/AccountSwitcher.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (36:6) {#if account_list && account_list.length > 0}
    function create_if_block_2$8(ctx) {
    	let span;

    	function select_block_type(ctx, dirty) {
    		if (/*my_account*/ ctx[0]) return create_if_block_3$6;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "uk-margin-small-left");
    			add_location(span, file$Y, 36, 8, 1637);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(36:6) {#if account_list && account_list.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (40:10) {:else}
    function create_else_block_1$5(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_switcher.select_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_switcher.select_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(40:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:10) {#if my_account}
    function create_if_block_3$6(ctx) {
    	let t_value = /*my_account*/ ctx[0].nickname + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*my_account*/ 1 && t_value !== (t_value = /*my_account*/ ctx[0].nickname + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(38:10) {#if my_account}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {#if account_list && account_list.length > 0}
    function create_if_block$u(ctx) {
    	let li0;
    	let t0_value = /*$_*/ ctx[2]("wallet.account_switcher.switch_account") + "";
    	let t0;
    	let t1;
    	let li1;
    	let t2;
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (!/*account_list*/ ctx[1]) return create_if_block_1$f;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			li1 = element("li");
    			t2 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(li0, "class", "uk-text-muted");
    			add_location(li0, file$Y, 49, 10, 1996);
    			attr_dev(li1, "class", "uk-nav-divider");
    			add_location(li1, file$Y, 51, 10, 2097);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			append_dev(li0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, li1, anchor);
    			insert_dev(target, t2, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.account_switcher.switch_account") + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(li1);
    			if (detaching) detach_dev(t2);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(49:8) {#if account_list && account_list.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (55:10) {:else}
    function create_else_block$f(ctx) {
    	let t;
    	let li;
    	let each_value = /*account_list*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			li = element("li");
    			attr_dev(li, "class", "uk-nav-divider");
    			add_location(li, file$Y, 66, 12, 2606);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, li, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*my_account, account_list, setAccount*/ 3) {
    				each_value = /*account_list*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(55:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:10) {#if !account_list}
    function create_if_block_1$f(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "loading...";
    			add_location(p, file$Y, 53, 12, 2193);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(53:10) {#if !account_list}",
    		ctx
    	});

    	return block;
    }

    // (56:12) {#each account_list as acc}
    function create_each_block$7(ctx) {
    	let li;
    	let a;
    	let t_value = /*acc*/ ctx[7].nickname + "";
    	let t;
    	let a_class_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*acc*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#");

    			attr_dev(a, "class", a_class_value = /*my_account*/ ctx[0].account == /*acc*/ ctx[7].account
    			? "uk-text-primary"
    			: "");

    			add_location(a, file$Y, 57, 16, 2304);
    			add_location(li, file$Y, 56, 14, 2283);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*account_list*/ 2 && t_value !== (t_value = /*acc*/ ctx[7].nickname + "")) set_data_dev(t, t_value);

    			if (dirty & /*my_account, account_list*/ 3 && a_class_value !== (a_class_value = /*my_account*/ ctx[0].account == /*acc*/ ctx[7].account
    			? "uk-text-primary"
    			: "")) {
    				attr_dev(a, "class", a_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(56:12) {#each account_list as acc}",
    		ctx
    	});

    	return block;
    }

    // (72:12) <Link to="settings" class="uk-text-muted">
    function create_default_slot_1$3(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_switcher.setting") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_switcher.setting") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(72:12) <Link to=\\\"settings\\\" class=\\\"uk-text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    // (77:12) <Link to="dev" class="uk-text-muted">
    function create_default_slot$5(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_switcher.developers") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_switcher.developers") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(77:12) <Link to=\\\"dev\\\" class=\\\"uk-text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let main;
    	let div1;
    	let button;
    	let networkicon;
    	let t0;
    	let t1;
    	let div0;
    	let ul;
    	let t2;
    	let li0;
    	let a0;
    	let link0;
    	let t3;
    	let li1;
    	let a1;
    	let link1;
    	let t4;
    	let li2;
    	let aboutlink;
    	let current;
    	networkicon = new NetworkIcon({ $$inline: true });
    	let if_block0 = /*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0 && create_if_block_2$8(ctx);
    	let if_block1 = /*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0 && create_if_block$u(ctx);

    	link0 = new Link({
    			props: {
    				to: "settings",
    				class: "uk-text-muted",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: "dev",
    				class: "uk-text-muted",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	aboutlink = new AboutLink({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			button = element("button");
    			create_component(networkicon.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div0 = element("div");
    			ul = element("ul");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			li0 = element("li");
    			a0 = element("a");
    			create_component(link0.$$.fragment);
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			create_component(link1.$$.fragment);
    			t4 = space();
    			li2 = element("li");
    			create_component(aboutlink.$$.fragment);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$Y, 33, 4, 1495);
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$Y, 70, 10, 2689);
    			add_location(li0, file$Y, 69, 8, 2674);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$Y, 75, 10, 2861);
    			add_location(li1, file$Y, 74, 8, 2846);
    			attr_dev(li2, "class", "uk-text-muted");
    			add_location(li2, file$Y, 79, 8, 3016);
    			attr_dev(ul, "class", "uk-nav uk-dropdown-nav");
    			add_location(ul, file$Y, 47, 6, 1896);
    			attr_dev(div0, "uk-dropdown", "");
    			add_location(div0, file$Y, 46, 4, 1872);
    			add_location(div1, file$Y, 32, 2, 1485);
    			add_location(main, file$Y, 31, 0, 1476);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, button);
    			mount_component(networkicon, button, null);
    			append_dev(button, t0);
    			if (if_block0) if_block0.m(button, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, ul);
    			if (if_block1) if_block1.m(ul, null);
    			append_dev(ul, t2);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			mount_component(link0, a0, null);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			mount_component(link1, a1, null);
    			append_dev(ul, t4);
    			append_dev(ul, li2);
    			mount_component(aboutlink, li2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$8(ctx);
    					if_block0.c();
    					if_block0.m(button, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$u(ctx);
    					if_block1.c();
    					if_block1.m(ul, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 1028) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 1028) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(networkicon.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(aboutlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(networkicon.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(aboutlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(networkicon);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(aboutlink);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccountSwitcher", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let my_account;
    	let account_list;
    	let unsubsSigningAccount;
    	let unsubsAll_accounts;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsSigningAccount = signingAccount.subscribe(value => $$invalidate(0, my_account = value));
    		unsubsAll_accounts = all_accounts.subscribe(all => $$invalidate(1, account_list = all));
    	}));

    	onDestroy(() => {
    		unsubsSigningAccount && unsubsSigningAccount();
    		unsubsAll_accounts && unsubsAll_accounts();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccountSwitcher> was created with unknown prop '${key}'`);
    	});

    	const click_handler = acc => setAccount(acc.account);

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onDestroy,
    		onMount,
    		signingAccount,
    		all_accounts,
    		setAccount,
    		Link,
    		NetworkIcon,
    		AboutLink,
    		_: X,
    		my_account,
    		account_list,
    		unsubsSigningAccount,
    		unsubsAll_accounts,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("my_account" in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ("account_list" in $$props) $$invalidate(1, account_list = $$props.account_list);
    		if ("unsubsSigningAccount" in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ("unsubsAll_accounts" in $$props) unsubsAll_accounts = $$props.unsubsAll_accounts;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [my_account, account_list, $_, click_handler];
    }

    class AccountSwitcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountSwitcher",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    const routes = {
        home: '/',
        addAccount: '/add-account',
        accountFromMnem: '/account-from-mnem',
        keygen: '/keygen',
        miner: '/miner',
        transactions: '/txs',
        events: '/events',
        settings: '/settings',
        about: '/about',
        developer: '/dev',
        swarm: '/swarm',
        makeWhole: '/make-whole'
    };

    var nav$7={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout$7={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"},recovery_mode:{title:"Recovery Mode",body:"The network is up! But we are in Recovery Mode, and no rewards are being paid for proofs yet. Wait until Recovery Mode is finished to send proofs for rewards. Recovery ends when epoch {epoch_recovery_ends} changes to {epoch_recovery_ends_after}"}};var wallet$7={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Settings",developers:"Developers"}};var about$7={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$7={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"English",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner$7={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs$7={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",error_account_does_not_exist:"Recipient account does not exist.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events$7={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Events Temporarily Unavailable",corrupted_db:"The server you are connected to does not have all your event history available.",account_off_chain:"Account selected not onboarded yet, and has no events."}};var make_whole$7={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transaction confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var en = {nav:nav$7,layout:layout$7,wallet:wallet$7,about:about$7,settings:settings$7,miner:miner$7,txs:txs$7,events:events$7,make_whole:make_whole$7};

    var nav$6={wallet:"",miner:"",transactions:"",events:""};var layout$6={connection_error:{title:", OL",body:"<p> </p> <h3> .</h3> <p></p>"},error_accordion:{title:"",category:"",id:"ID"}};var wallet$6={wallet:"",carpe:"CARPE",btn_new_account:"",btn_restore_account:"",newbie_message:"",reminder_create:{card_title:"",message_headline:"",message_prefix:"",message_suffix:" ",onboard_key:"AuthKey"},account_list:{nickname:"",address:"",authkey:"",balance:"",offline:"",loading:"",account_on_chain:"",message:" "},keygen:{title:"",description:"10L",btn_generate_keys:"",btn_generate_keys_2:"",btn_create_account:"",account_address:"",onboard_key:"AuthKey",onboard_key_description:"",securite_recovery_phrase:"",securite_note:"",account_tips:""},account_from_mnem_submit:{title:" ",body:" <p></p> <p></p><p> </p>",btn_cancel:"",btn_submit:"",btn_submiting:""},account_from_mnem_from:{title:"",description:" CARPE ",placeholder:""},account_switcher:{select_account:"",switch_account:"",setting:"",developers:""}};var about$6={about:"",release:"",version:"",branch:"",commit:"Commit"};var settings$6={title:"",langapp_settings:{title:"",lang:"",lang_description:"",lang_button:"",theme:"",theme_description:""},network_settings:{title:"",list_of_peers:"",description:"Carpe  playlist.json ",playlist:"",override_peers:"",override_peers_description:" IP ",url_of_upstream_node:"URL",btn_update:"",upstream_title:"WAYPOINT",upstream_subtitle:" waypoint ",btn_fetch_new_waypoint:"Waypoint",btn_cancel:"",btn_submit:""},account_settings:{title:"",btn_remove:"",comfirm:"",description:""}};var miner$6={title:"",miner_backlog:{title:"Tower",subtitle:"",in_process:"",btn_submit:""},miner_phases:{backlog_started:"",backlog_in_process:"",backlog_complete:"",mining_enabled:"",proof_started:"",proof_complete:""},miner_process:{status_complete:"",status_in_process:"",notes:" <br> ",notes2:"100%"},tower_state:{local_height:"",on_chain_height:"",mined_in_last_epoch:"",sent_in_this_epoch:"",empty:"",proof_more:"72",proof_less:" (8)",proof_ok:"8"},cards:{cant_start:{title:"",body:"10L"},disco_error:{title:"",body:". "},epoch_status:{empty_title:"",empty_body:"",in_process_title:"",in_process_body:"epoch8epoch",complete_title:"",complete_body:"8epoch epoch",exceed_title:"",exceed_body:"72"},first_proof:{title:"",body:"<p>301</p> <p> . 8, epoch.</p> <p>  Carpe </p>",body_disabled:"!"},invalid_proof:{title:"",body:". "},oops:{title:"~",body:""},too_many_proofs:{title:"",body:"24. {maxNum}. ."},wrong_difficulty:{title:"",body:""},sync_proof:{title:"",body:" {delta} ",body_0:", "}}};var txs$6={deno_tx:"",account:"",balance:"",btn_onboard:"",btn_transfer:"",onboard:{title:"","await":"",btn_onboard:"",btn_cancel:"",no_balance_title:"",no_balance_body1:"{onboard_key}.",no_balance_body2:"2"},set_wallet_type:{title:"",subtitle:". . ",btn_slow:"",btn_confirm_slow:"",slow_confirm:"",btn_community:"",btn_confirm_community:"",community_confirm:""},transfer:{title:"",sender:"",balance:"",receiver:"",amount:"",amount_label:" ()",receiver_placeholder:"",amount_placeholder:"",confirm_title:"",please_confirm:":","await":"",btn_next:"",btn_confirm:"",btn_cancel:"",btn_close:"",error_amount_greater_than_balance:"",error_receiver_equals_sender:"",error_slow_wallet:"",success:"",failed:" : {code}"}};var events$6={account_events:"",version:"",type:"",amount:"",sender:"",receiver:"",received_payment:"",sent_payment:"",loading:{error:":",corrupted_db:". ",account_off_chain:""}};var make_whole$6={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var zh_cn = {nav:nav$6,layout:layout$6,wallet:wallet$6,about:about$6,settings:settings$6,miner:miner$6,txs:txs$6,events:events$6,make_whole:make_whole$6};

    var nav$5={wallet:"Wallet",miner:"Miner",transactions:"Transaktionen",events:"Ereignisse"};var layout$5={connection_error:{title:"Ups, wir knnen keine Verbindung zum 0L-Netzwerk herstellen",body:"<p> Dies liegt wahrscheinlich daran, dass der von dir verwendete Upstream-Peer (Server) nicht verfgbar ist.</p> <h3> Keine Sorge, dein Konto und deine Coins sind sicher.</h3> <p>Wenn Du Deine Peers ndern oder aktualisieren musst, kannst Du das hier tun:</p>"},error_accordion:{title:"Fehlerbericht",category:"Fehler-Kategorie",id:"ID"},recovery_mode:{title:"Wiederherstellungsmodus",body:"Das Netz ist wieder in Betrieb! Aber wir befinden uns im Wiederherstellungsmodus, und es werden noch keine Belohnungen fr Proofs gezahlt. Warte, bis der Wiederherstellungsmodus beendet ist, um Proofs fr Belohnungen zu senden. Die Wiederherstellung endet, wenn die Epoche {epoch_recovery_ends} auf {epoch_recovery_ends_after} wechselt."}};var wallet$5={wallet:"Wallet",carpe:"CARPE",btn_new_account:"Neues Konto",btn_restore_account:"Konto wiederherstellen",newbie_message:"Sieht aus, als httest du keine Konten",reminder_create:{card_title:"Onboarding",message_headline:"Du hast Keys fr ein Konto erzeugt, aber es existiert noch nicht auf der Chain.",message_prefix:"Tritt unserer Gemeinschaft bei auf ",message_suffix:" und gib uns deinen Onboard Key, um an Bord zu kommen.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Spitzname",address:"Adresse",authkey:"Authkey",balance:"Guthaben",offline:"offline",loading:"wird geladen",account_on_chain:"Konto nicht auf der Chain",message:" Dein Guthaben verringert sich bei jeder Transaktion, die du sendest, einschlielich Mining."},keygen:{title:"Neues Konto anlegen",description:"Nachdem du ein Konto und eine geheime Phrase erstellt hast, muss jemand einen 0L-Coin an dieses Konto senden, damit es auf der Chain erstellt wird.",btn_generate_keys:"Key erzeugen",btn_generate_keys_2:"Unterschiedliche Keys erzeugen",btn_create_account:"Dieses Konto anlegen",account_address:"Adresse des Kontos",onboard_key:"Onboarding Key",onboard_key_description:"Dieser wird auch als Auth Key bezeichnet. Du brauchst ihn, um das Konto auf der Chain erstellen zu knnen.",securite_recovery_phrase:"GEHEIME WIEDERHERSTELLUNGSPHRASE",securite_note:"Dies ist dein geheimes Kontopasswort (Mnemonic). Wenn du es verlierst, kann dir niemand helfen! Schreib es dir jetzt auf.",account_tips:"Dein Konto existiert noch nicht auf der Chain. Du musst jemandem deinen Onboarding Key geben, damit er dein Konto erzeugen kann."},account_from_mnem_submit:{title:" Aufgepasst!",body:" <p>Bist du sicher, dass du deine Mnemonic Phrase aufgeschrieben hast?</p> <p>Ohne sie kannst du dein Konto nicht wiederherstellen. Niemand kann dir helfen, wenn du sie verlierst.</p><p>Dies ist die letzte Chance, sie aufzuschreiben.</p>",btn_cancel:"Ich schaue nochmal nach",btn_submit:"Jetzt Abschicken",btn_submiting:"Abschicken"},account_from_mnem_from:{title:"KONTO WIEDERHERSTELLEN",description:"Mit deinen Wiederherstellungswrtern (Mnemonik) kannst du Carpe als Wallet zur berwachung und zum Senden von Transaktionen konfigurieren",placeholder:"Wiederherstellungs Mnemonik"},account_switcher:{select_account:"Konto auswhlen",switch_account:"Konto wechseln",setting:"Gehe zu Einstellung",developers:"Entwickler"}};var about$5={about:"ber",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$5={title:"EINSTELLUNGEN",langapp_settings:{title:"Sprache und Erscheinungsbild",lang:"Sprache",lang_description:"Whle die Anzeigesprache",lang_button:"Deutsch",theme:"Theme",theme_description:"Whle das Theme"},network_settings:{title:"NETZWERKEINSTELLUNGEN",list_of_peers:"LISTE DER PEERS",description:"Whlen Sie eine Playlist mit vorgelagerten Knoten, damit ein Zugriff auf die Kette mglich ist. Netzwerkverbindungen werden die Liste in zuflliger Reihenfolge ausprobieren, bis eine Verbindung hergestellt ist. Verweise hier einfach auf eine beliebige playlist.json-Datei, um die Peers zu aktualisieren.",playlist:"Playlist der Netzwerkserver aktualisieren",override_peers:"PEERS BERSCHREIBEN",override_peers_description:"Du kannst die Verwendung eines anderen Peers erzwingen. Mit dieser Einstellung kannst du nur einen Peer auswhlen. Dadurch wird die Playlist entfernt. Diese besteht nun aus einem einzigen Element.",url_of_upstream_node:"URL des vorgelagerten Knotens",btn_update:"AKTUALISIERUNG",upstream_title:"EINEN NEUEN WEGPUNKT VON OBERHALB ABRUFEN",upstream_subtitle:"Die meisten Probleme mit Wegpunkten lassen sich leicht beheben, indem man einen aktualisierten Wegpunkt von einem verbundenen Upstream-Peer abruft.",btn_fetch_new_waypoint:"Neuen Wegpunkt abrufen",btn_cancel:"Abbrechen",btn_submit:"PLAYLIST VERWENDEN"},account_settings:{title:"KONTOEINSTELLUNGEN",btn_remove:"KONTO LSCHEN",comfirm:"Das Lschen von Konten auf diesem Gert besttigen? Das kann nicht rckgngig gemacht werden.",description:"Dabei werden keine Konten von der Chain gelscht. Die Konten werden nur von diesem Gert entfernt. Wenn du deine Wiederherstellungscodes (Mnemonik) nicht irgendwo aufbewahrst, kann es sein, dass du dauerhaft aus diesem Konto ausgesperrt wirst. NIEMAND KANN DIR HELFEN, DIE MNEMONIK WIEDERZUBEKOMMEN. "}};var miner$5={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Lokale Proofs manuell erneut einreichen",in_process:"Backlog in Arbeit",btn_submit:"Lokalen Backlog einreichen"},miner_phases:{backlog_started:"Backlog Listener Gestartet",backlog_in_process:"Backlog in Arbeit",backlog_complete:"Backlog Fertig",mining_enabled:"Mining Aktiviert",proof_started:"Anforderung fr Proof-Start erhalten",proof_complete:"Proof Fertig"},miner_process:{status_complete:"Proof Fertig",status_in_process:"Mining Luft",notes:"Der Prozentsatz ist eine Schtzung. <br> Es basiert auf der fr den letzten Proof verwendeten Zeitspanne.",notes2:"ber 100% bedeutet nur, dass es lnger dauert als der vorherige Proof."},tower_state:{local_height:"Lokale Turmhhe",on_chain_height:"On-chain Turmhhe",mined_in_last_epoch:"Letzte Epoche gemined",sent_in_this_epoch:"In dieser Epoche bermittelte Proofs",empty:"Keine Proofs auf dem Gert gefunden",proof_more:"Du hast heute ein Maximum an Proofs bermittelt (max. 72)",proof_less:"Nicht gengend Proofs, um heute eine Belohnung zu erhalten (mindestens 8)",proof_ok:"Dein Konto hat heute gengend Proofs bermittelt (mindestens 8)"},cards:{cant_start:{title:"Dein Konto existiert noch nicht in der Chain ",body:"Der Miner kann erst starten, wenn das Konto auf der Chain gefunden werden kann. Vielleicht hast du lokal neue Schlssel generiert, aber niemand hat Coins an die Adresse geschickt?"},disco_error:{title:"Unterbrechung ",body:"Sieht aus, als gbe es eine Lcke in den von dir bermittelten Proofs. Jeder Proof muss auf den vorhergehenden verweisen, und der Proof wurde deshalb abgelehnt."},epoch_status:{empty_title:"Keine Proofs bermittelt",empty_body:"Es sind keine Proofs auf der Chain gespeichert. Wenn du deinen ersten Proof erfolgreich bermittelt hast, wirst du hier einige Statistiken sehen.",in_process_title:"Weiter so",in_process_body:"Dein Konto muss mindestens 8 Proofs pro Tag (Epoche) bermitteln, um eine Belohnung zu erhalten. Du erhltst die Belohnung am nchsten Tag.",complete_title:"Geschafft!",complete_body:"Dein Konto hat heute gengend Proofs geliefert (mindestens 8 Proofs pro Epoche). Du solltest die Belohnungen zu Beginn der nchsten Epoche erhalten.",exceed_title:"Brrrr",exceed_body:"Du hast 72 Proofs erzeugt, das ist die maximale Anzahl von Proofs pro Epoche. Der Turm kann weiterhin Proofs machen, aber sie werden erst in der nchsten Epoche akzeptiert."},first_proof:{title:"Machen wir uns an deinen ersten Proof",body:"<p> Abwarten! Das dauert mindestens 30 Minuten, vielleicht bis zu 1 Stunde.</p> <p> Whrend du Proofs schrfst, wird dein Kontostand sinken. Wenn du das Minimum pro Tag erreichst, erhltst du am nchsten Tag (Epoche) eine Belohnung.</p> <p> Prfe deine Computereinstellungen, damit der Computer nicht in den Ruhezustand geht, wenn sich der Bildschirm ausschaltet. Du mchtest, dass der Miner luft, wenn du nicht da bist.</p>",body_disabled:"Leg den Schalter um und fang an zu minen!"},invalid_proof:{title:"Kann den Proof nicht besttigen",body:"Seltsam. Dieser Proof wurde abgelehnt, weil er kein gltiger \"Delay Proof\" ist. Dies liegt in der Regel daran, dass die Parameter nicht korrekt eingestellt sind."},oops:{title:"Hoppla",body:"Sieht aus, als gbe es einen Fehler beim Mining eines Delay Proofs"},too_many_proofs:{title:"Zu Viele Proofs",body:"Sieht aus, als httest du in den letzten 24 Stunden mehr Proofs geschickt als erwartet. Die Chain erwartet maximal {maxNum} Proofs pro Epoche. In der nchsten Epoche werden deine Proofs wieder bermittelt."},wrong_difficulty:{title:"Falsche Difficulty",body:"Es sieht so aus, als wrdest du einen Proof mit den falschen Difficulty-Parametern an die Chain senden. Stelle sicher, dass du mit dem richtigen Netzwerk und den richtigen Difficulty-Einstellungen verbunden bist."},sync_proof:{title:"Synchronisierung Deiner Proofs",body:"Auf Transaktion wartende Proofs: {delta} ",body_0:"Irgendetwas stimmt nicht. Du hast mehr Proofs auf der Chain, als auf diesem Gert. Mglicherweise fehlen dir lokale Proofs."}}};var txs$5={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Konto Onboarden","await":"",btn_onboard:"Onboarden",btn_cancel:"Abbrechen",no_balance_title:"Niedriger Kontostand",no_balance_body1:"Das Onboarding von {onboard_key} war nicht erfolgreich.",no_balance_body2:"Sieht so aus, als httest du weniger als 2 Coins auf deinem Konto, das bedeutet, dass du niemanden onboarden kannst."},set_wallet_type:{title:"Kontotyp Auswhlen",subtitle:" Es ist wichtig, dass du weit, was du tust. Dies kann nicht mehr rckgngig gemacht werden. Slow und Community Wallets sind unvernderlich.",btn_slow:"Slow Wallet Whlen",btn_confirm_slow:"Slow Wallet besttigen? Dies kann nicht rckgngig gemacht werden.",slow_confirm:"Slow Whlen",btn_community:"Community Wallet Whlen",btn_confirm_community:"Community Whlen",community_confirm:"Community Wallet besttigen? Dies kann nicht rckgngig gemacht werden."},transfer:{title:"berweisung von Coins",sender:"Sender",balance:"Betrag",receiver:"Receiver",amount:"Empfnger",amount_label:"Empfnger (Dezimalstellen noch nicht untersttzt)",receiver_placeholder:"Empfnger Adresse",amount_placeholder:"berweisungsbetrag",confirm_title:"Achtung!",please_confirm:"Bitte die berweisungsdaten besttigen:","await":"Auf Txs warten",btn_next:"Weiter",btn_confirm:"Besttigen",btn_cancel:"Abbrechen",btn_close:"Schlieen",error_amount_greater_than_balance:"Der Betrag kann nicht grer als der Kontostand sein",error_receiver_equals_sender:"Die Empfngeradresse muss sich von der Absenderadresse unterscheiden",error_slow_wallet:"Die berweisung von Coins ist fr Slow Wallets deaktiviert.",success:"berweisung erfolgreich durchgefhrt",failed:"berweisung fehlgeschlagen. Code: {code}"}};var events$5={account_events:"Kontoereignisse",version:"Version",type:"Typ",amount:"Betrag",sender:"Sender",receiver:"Empfnger",received_payment:"Empfangene Zahlung",sent_payment:"Gesendete Zahlung",loading:{error:"Fehler beim Laden der Kontoereignisse:",corrupted_db:"Der aktuell verbundene Knoten verfgt nicht ber alle Kontoereignisse. Keine Sorge. Deine Wallet und Coins sind in Sicherheit auf der Chain. Probiere, dich mit einem anderen Upstream-Knoten zu verbinden.",account_off_chain:"Das ausgewhlte Konto wurde noch nicht geonboarded."}};var make_whole$5={link_title:"Coins einfordern",card:{title:"Deine Fehlenden Coins Einfordern",body:"<p>Hoppla. Gelegentlich machen Blockchains mathematische Fehler. 0L versucht, diese so schnell wie mglich zu beheben.</p><p>Vorfall bei Miner-Identitts-Subventionierung: Von Epoche 0 bis Epoche 52 waren die Auszahlungen an Miner geringer als erwartet. Nachfolgend kannst du deine fehlenden Coins aus diesem Zeitraum gutschreiben lassen.</p>"},table:{account:"Konto",amount:"Betrag",claim:"Forderung"},claim_btn:{"await":"Warten...",claim:"Jetzt Einfordern"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>Du hast <span class=\"uk-text-bold\">{coins} Coins</span> fr Konto <br><span class=\"uk-text-bold\">{account}</span> beansprucht.</p>",check_balance:"Du kannst dein Guthaben jetzt berprfen.",ok_btn:"OK"},modal_error:{title:"Fehler bei Anforderung",body:"Du musst den Miner abstellen, um die Coins fr dieses Konto zu beanspruchen.",ok_btn:"OK"}};var de = {nav:nav$5,layout:layout$5,wallet:wallet$5,about:about$5,settings:settings$5,miner:miner$5,txs:txs$5,events:events$5,make_whole:make_whole$5};

    var nav$4={wallet:"Porte-feuille",miner:"Mineur",transactions:"Transactions",events:"vnement"};var layout$4={connection_error:{title:"Oops, connexion au rseau 0L impossible",body:"<p> Il est probable que le noeud pair en amont (server) soit dconnect.</p> <h3> Ne vous inquitez pas, votre compte et vos coins sont en scurit.</h3> <p>Pour mettre  jour vos noeuds de paires, vous pouvez allez l:</p>"},error_accordion:{title:"Rapport d'erreurs",category:"Categorie d'erreur",id:"ID"}};var wallet$4={wallet:"Porte-feuille",carpe:"CARPE",btn_new_account:"Nouveau Compte",btn_restore_account:"Rcupration de Compte",newbie_message:"Pas de compte trouv.",reminder_create:{card_title:"Embarquement",message_headline:"Vous avez gnr les cls de votre compte, mais il n'existe pas encore sur la chaine.",message_prefix:"Rejoingnez notre communaut sur ",message_suffix:" et joingnez votre cl d'embarquement pour etre embarqu.",onboard_key:"CL D'EMBARQUEMENT"},account_list:{nickname:"Surnom",address:"Adresse",authkey:"Authkey",balance:"Solde",offline:"hors-ligne",loading:"chargement",account_on_chain:"Compte pas sur Chaine",message:" Votre solde diminera pour toutes transactions que vous envoyes, incluant celles du minage."},keygen:{title:"Creer un Nouveau Compte",description:"prs avoir gnr votre compte et phrase secrte, vous aurez besoin qu'une personne vous envoi un jeton 0L  ce compte pour qu'il soit sur la chaine.",btn_generate_keys:"Gnrer des cls",btn_generate_keys_2:"Gnrer diffrentes cls",btn_create_account:"Crer ce compte",account_address:"Adresse du compte",onboard_key:"Cl d'embarquement",onboard_key_description:"Aussi appele cl d'authenfication. Vous en avez besoin pour crer ce compte sur la chaine.",securite_recovery_phrase:"PHRASE SECRTE DE RECUPRATION",securite_note:"Cl secrte de votre compte (mnmonique). Si vous la perdez, personne ne pourra vous aider. Donc notez la et scurisez la.",account_tips:"Votre compte n'existe pas encore sur la chaine. Vous devrez fournir votre cl d'embarquement  quelqu'un pour qu'il soit cr."},account_from_mnem_submit:{title:" Attention!",body:" <p>Avez-vous bien not vore phrase mnemonique secrte?</p> <p>Vous ne pourrez pas rcuprer votre compte sans. Personne ne peut vous aider si vous la perdez.</p><p>Dernier avertissement pour la noter.</p>",btn_cancel:"Je veux re-vrifier",btn_submit:"Crer ce compte",btn_submiting:"Cration en cours"},account_from_mnem_from:{title:"RCUPRATION DE COMPTE",description:"En utilisant votre phrase de rcupration (mnmonique) vous pouvez configurer Carpe en porte-feuille pour surveiller et effectuer des transactions",placeholder:"Rcupration Mnmonique"},account_switcher:{select_account:"Selection du Compte",switch_account:"Changer de Compte",setting:"Paramtres",developers:"Dvelopeurs"}};var about$4={about:" propos",release:"Release",version:"Version",branch:"Branche",commit:"Commit"};var settings$4={title:"PARAMTRES",langapp_settings:{title:"Language and Apparence",lang:"Language",lang_description:"Choisissez le language  afficher",lang_button:"Franais",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"PARAMTRES RSEAU",list_of_peers:"LISTE DES PAIRES",description:"Choisissez une playlist de noeuds paires pour accder  la chane. Un noeud alatoire de la liste sera utilis pour se connecter au rseau. Fournissez un fichier playlist.json pour mettre  jour les paires.",playlist:"Rafraichir la Playlist des Serveurs",override_peers:"CRASER LES PAIRES",override_peers_description:"Vous pouvez forcer l'utilisation de paire different. Vous pouvez choisir qu'un seul paire avec ce paramtre. La playlist sera remplace par une liste d'un lment.",url_of_upstream_node:"URL du noeud en amont",btn_update:"RAFRAICHIR",upstream_title:"RECUPRER UN NOUVEAU POINT DE CHEMINEMENT DU NOEUD EN AMONT",upstream_subtitle:"La plupart des problmes de cheminement sont rsolu en rcuprant un nouveau point d'un noeud en amont.",btn_fetch_new_waypoint:"Rcuprer Nouveau Point deCheminement",btn_cancel:"Annuler",btn_submit:"UTILISER LA PLAYLIST"},account_settings:{title:"PARAMTRES DE COMPTE",btn_remove:"SUPPRIMER LE COMPE",comfirm:"Confirmer la suppression du compte de ce dispositif? Cela est irreversible.",description:"Votre compte sera toujours sur la chaine. Cela l'enlve juste de ce dispositif. Si vous n'avez plus votre phrase de rcupration (mnmonique), vous pourrez tre vrrouill de ce compte dfinitivement. PERSONNE NE PEUT RETROUVER VOTRE MNMONIQUE."}};var miner$4={title:"Mineur",miner_backlog:{title:"Synchroniser vos preuves",subtitle:"Re-soumettre les preuves locales",in_process:"Backlog en cours de soumission",btn_submit:"Soumettre le backlog"},miner_phases:{backlog_started:"Auditeur du backlog lanc",backlog_in_process:"Backlog en cours",backlog_complete:"Backlog complt",mining_enabled:"Minage activ",proof_started:"Requte de dmarrage recue",proof_complete:"Preuve complte"},miner_process:{status_complete:"Preuve complte",status_in_process:"Minage en cours",notes:"Le pourcentage est une estimation. <br>Il est bas sur le temps pris par les preuves prcdentes.",notes2:"Dpass 100% signifie juste que la preuve en cours prend plus de temps que la prcdente."},tower_state:{local_height:"Hauteur locale de la Tour",on_chain_height:"Hauteur On-chain de la Tour",mined_in_last_epoch:"Dernier Epoch Min",sent_in_this_epoch:"Preuves envoyes pour cette Epoch",empty:"Pas de preuve locales trouve",proof_more:"Vous avez soumis le maximum de preuves (max 72)",proof_less:"Nombre de preuves insuffisantes pour recevoir la rcompense (min 8)",proof_ok:"Vous avez soumis suffisament de preuve (min 8)"},cards:{cant_start:{title:"Votre compte n'est prsentement pas sur la chaine",body:"Le mineur ne peut dbuter tant que votre compte n'est pas sur la chaine. Si vous avez gnr vos cls localement, quelqu'un doit vous envoyer des coins."},disco_error:{title:"Discontinuit ",body:"Il semblerait qu'il y a une preuve manquante dans votre soumission. Chaque preuve a besoin de sa prcdente, et votre preuve a t rejete de fait."},epoch_status:{empty_title:"Pas de preuves envoyes",empty_body:"Aucune preuve prsente sur la chaine. Quand vous aurez soumis votre premire preuve, vous trouverez vos stats ici.",in_process_title:"Allez!",in_process_body:"Votre compte doit soumettre au moins 8 preuves par epoch pour recevoir une rcompense. Les rcompenses sont distribue au prochain epoch.",complete_title:"Victoire!",complete_body:"Votre compte a soumis assez de preuve pour cet epoch (minimum 8 preuves par epoch). Vous recevrez votre rcompense au dbut du prochain epoch.",exceed_title:"Whoa!!!",exceed_body:"Vous avez min 72 proofs, le nombre maximum de preuves par epoch. La Tower peut continuer de miner des preuves, mais elles seront soumises au prochain epoch."},first_proof:{title:"Minons votre premire preuve",body:"<p> Un peu de patience! Cela va prendre de 30mins  1hr</p> <p> Votre solde diminura en minant vos preuves. Si vous soumettez le minimum requis, vous recevrez votre rcompense au prochain epoch.</p> <p> Dsactivez les paramtres de Veille sur votre ordinateur afin que le mineur continue de tourner en votre absence.</p>",body_disabled:"Clickez sur le switch pour dmarrer le minage!"},invalid_proof:{title:"Vrification impossible des preuves",body:"Bizarre. Cette preuve a t rejete car elle n'est pas une \"delay proof\" valide. Ceci est habituellement d  des mauvais paramtres."},oops:{title:"Oops",body:"Une erreur s'est passe durant le minage de la \"delay proof\""},too_many_proofs:{title:"Trop de preuves",body:"Vous aurez soumis plus de preuves que prvu durant cet epoch. La chaine supporte un max de {maxNum} preuves durant chaque epoch. Vos preuves additionnelles seront soumises au prochain epoch."},wrong_difficulty:{title:"Mauvaise Difficult",body:"La difficult de votre preuve ne correspond pas  celle de la chane. Vrifiez que vous tes connect au bon rseau avec le bon paramtre de difficult."},sync_proof:{title:"Synchronisation des preuves",body:"Preuves en attente de la transaction : {delta} ",body_0:"Vous avez plus de preuves sur la chane que sur votre dispositif. Il vous manque des preuves localement."}}};var txs$4={deno_tx:"Demo Tx",account:"Compte",balance:"Solde",btn_onboard:"Embarquer Compte",btn_transfer:"Transfert de Coins",onboard:{title:"Embarquer un Compte","await":"",btn_onboard:"Embarquer",btn_cancel:"Annuler",no_balance_title:"Solde insuffisant",no_balance_body1:"L'embarquement de {onboard_key} a chou.",no_balance_body2:"Vous avez moins que 2 coins dans votre compte, vous ne pouvez donc pas embarquer d'autres comptes."},set_wallet_type:{title:"Modifier le Type de Compte",subtitle:" Soyez sr de vous, cette opration est irreversible! Les porte-feuilles \"Slow\" et \"Community\" sont permanents.",btn_slow:"Changer en \"Slow\"",btn_confirm_slow:"Confirmez le passage en \"Slow\"? Cet opration est irreversible.",slow_confirm:"Changer en \"Slow\"",btn_community:"Changer en \"Community\"",btn_confirm_community:"Changer en \"Community\"",community_confirm:"Confirmez le passage en \"Community\"? Cet opration est irreversible"},transfer:{title:"Transfert de Coins",sender:"Envoyeur",balance:"Solde",receiver:"Receveur",amount:"Montant",amount_label:"Montant (fractions non permises)",receiver_placeholder:"Adresse du Receveur",amount_placeholder:"Montant  transferer",confirm_title:"Attention!",please_confirm:"Veuillez confirmer les informations du transfert:","await":"Attente de txs",btn_next:"Suivant",btn_confirm:"Confirmer",btn_cancel:"Annuler",btn_close:"Fermer",error_amount_greater_than_balance:"Le montant ne peut pas tre suprieur au solde de compte",error_receiver_equals_sender:"Les adresses de l'Envoyeur et Receveur doivent tre differentes",error_slow_wallet:"Le transfert de Coin est dsactiv pour les porte-feuilles 'slow'.",success:"Transfert execut avec succs",failed:"Transfert chou. Code: {code}"}};var events$4={account_events:"vnements du compte",version:"Version",type:"Type",amount:"Montant",sender:"Expditeur",receiver:"Receveur",received_payment:"Paiement recu",sent_payment:"Paiement envoy",loading:{error:"Erreur durant le chargement des vnements:",corrupted_db:"Actuellement connect  un noeud n'ayant pas tous les vnements.",data_safe:"Ne vous inquitez pas, votre compte est scuris sur la chaine. Essayez de vous connecter  un autre noeud en amont."}};var make_whole$4={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var fr = {nav:nav$4,layout:layout$4,wallet:wallet$4,about:about$4,settings:settings$4,miner:miner$4,txs:txs$4,events:events$4,make_whole:make_whole$4};

    var nav$3={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout$3={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"}};var wallet$3={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Go To Setting",developers:"Developers"}};var about$3={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$3={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"Spanish",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner$3={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs$3={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events$3={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Error loading the account events:",corrupted_db:"Current connected node does not have all account events. Don't worry. Your wallet and coins are safe on the chain. Try connecting to another upstream node.",account_off_chain:"Account selected not onboarded yet."}};var make_whole$3={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var es = {nav:nav$3,layout:layout$3,wallet:wallet$3,about:about$3,settings:settings$3,miner:miner$3,txs:txs$3,events:events$3,make_whole:make_whole$3};

    var nav$2={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout$2={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"}};var wallet$2={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Go To Setting",developers:"Developers"}};var about$2={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$2={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"Italian",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner$2={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs$2={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events$2={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Error loading the account events:",corrupted_db:"Current connected node does not have all account events. Don't worry. Your wallet and coins are safe on the chain. Try connecting to another upstream node.",account_off_chain:"Account selected not onboarded yet."}};var make_whole$2={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var it = {nav:nav$2,layout:layout$2,wallet:wallet$2,about:about$2,settings:settings$2,miner:miner$2,txs:txs$2,events:events$2,make_whole:make_whole$2};

    var nav$1={wallet:"Carteira",miner:"Minerador",transactions:"Transaes",events:"Eventos"};var layout$1={connection_error:{title:"Opa, no foi possvel conectar  rede 0L",body:"<p>Isto geralmente acontece porque o node (servidor) que voc est usando est fora do ar.</p> <h3> No se preocupe, sua conta e moedas esto seguras.</h3> <p>Se voc precisar configurar ou atualizar seus nodes, voc pode fazer isso aqui:</p>"},error_accordion:{title:"Relatrio de Erros",category:"Categoria de Erro",id:"ID"}};var wallet$1={wallet:"Carteira",carpe:"CARPE",btn_new_account:"Criar Conta",btn_restore_account:"Restaurar Conta",newbie_message:"Parece que voc no tem nenhuma conta ainda",reminder_create:{card_title:"Integrao",message_headline:"Voc gerou chaves para uma conta, mas ela no existe na rede ainda.",message_prefix:"Junte-se  nossa comunidade no ",message_suffix:" e fornea-nos a sua Chave de Integrao para criar sua conta na rede.",onboard_key:"CHAVE DE INTEGRAO"},account_list:{nickname:"Apelido",address:"Conta",authkey:"Chave de autenticao",balance:"Saldo",offline:"offline",loading:"carregando",account_on_chain:"Conta no criada na rede",message:"Seu saldo diminuir para cada transao que voc enviar, incluindo as de minerao."},keygen:{title:"Criar nova conta",description:"Depois de gerar uma conta e a frase secreta, voc precisar que algum envie uma moeda do 0L para esta conta para que ela seja criada na rede.",btn_generate_keys:"Gerar Chaves",btn_generate_keys_2:"Gerar Chaves Diferentes",btn_create_account:"Criar Esta Conta",account_address:"Endereo da Conta",onboard_key:"Chave de Integrao",onboard_key_description:"Isto tambm  conhecido como Chave de Autenticao. Por enquanto, voc precisar dele para poder criar a conta na rede.",securite_recovery_phrase:"FRASE SECRETA DE RECUPERAO",securite_note:"Esta  a chave secreta da sua conta (mnemnico). Se voc perder ela, ningum poder te ajudar! Escreva ela em algum lugar agora.",account_tips:"Sua conta no existe na rede ainda. Voc precisar enviar para algum sua Chave de Integrao para que possam criar sua conta."},account_from_mnem_submit:{title:"Anteo!",body:"<p>Voc tem certeza que escreveu sua frase mnemnica?</p><p>Voc no conseguir recuperar sua conta sem ela de jeito algum. Ningum pode te ajudar se voc perd-la.</p><p>Esta  a sua ltima oportunidade de escrev-la em algum lugar.</p>",btn_cancel:"Deixe-me verificar novamente",btn_submit:"Enviar Agora",btn_submiting:"Enviando"},account_from_mnem_from:{title:"RESTAURAR CONTA",description:"Usando suas palavras de recuperao (mnemnicos), voc pode configurar o Carpe como uma carteira para monitorar e enviar transaes",placeholder:"Mnemnico de Recuperao"},account_switcher:{select_account:"Selecionar Conta",switch_account:"Mudar de Conta",setting:"Configuraes",developers:"Desenvolvedores"}};var about$1={about:"Sobre",release:"Lanamento",version:"Verso",branch:"Branch",commit:"Commit"};var settings$1={title:"CONFIGURAES",langapp_settings:{title:"Lngua e Aparncia",lang:"Lngua",lang_description:"Escolha o idioma",lang_button:"Portugus",theme:"Tema",theme_description:"Escolha o tema"},network_settings:{title:"CONFIGURAES DE REDE",list_of_peers:"LISTA DE PARES",description:"Escolha uma lista de ns ascendentes, para que voc possa acessar o blockchain. As conexes de rede tentaro a lista em ordem aleatria at que uma conexo seja estabelecida. Basta vincular a qualquer arquivo playlist.json aqui para atualizar os pares.",playlist:"Atualizar Lista de Servidores de Rede",override_peers:"SUBSTITUIR PARES",override_peers_description:"Voc pode forar usando um par diferente. Voc s pode escolher um par com essa configurao. Ela ir remover a lista de pares. Esta ser agora uma lista de um elemento.",url_of_upstream_node:"URL do n ascendente",btn_update:"ATUALIZAR",upstream_title:"BUSCAR UM NOVO PONTO DE CAMINHO DO NODE ASCENDENTE",upstream_subtitle:"A maioria dos problemas de Ponto de Caminho pode ser facilmente corrigida ao buscar um atualizado de um par ascendente conectado.",btn_fetch_new_waypoint:"Buscar Novo Ponto de Caminho",btn_cancel:"Cancelar",btn_submit:"USAR LISTA"},account_settings:{title:"CONFIGURAES DA CONTA",btn_remove:"REMOVER CONTA",comfirm:"Confirmar remover contas deste dispositivo? Isso no  reversvel.",description:"Isso no exclui nenhuma conta da rede. Apenas remove as contas deste dispositivo. Se voc no tiver seus cdigos de recuperao (mnemnicos) armazenados em algum lugar, poder ser bloqueado desta conta permanentemente. NINGUM PODE AJUD-LO A RECUPERAR O MNEMONIC."}};var miner$1={title:"Minerador",miner_backlog:{title:"Provas de Sincronizao da Torre",subtitle:"Reenviar manualmente as provas locais",in_process:"Backlog em Andamento",btn_submit:"Enviar Backlog Local"},miner_phases:{backlog_started:"Ouvinte de backlog iniciado",backlog_in_process:"Backlog em Andamento",backlog_complete:"Backlog Concludo",mining_enabled:"Minerao Ativada",proof_started:"Solicitao de incio de prova recebida",proof_complete:"Prova Concluda"},miner_process:{status_complete:"Prova Concluda",status_in_process:"Minerao em Andamento",notes:"A porcentagem  uma estimativa. <br>  baseada no tempo decorrido da sua prova anterior.",notes2:"Mais de 100% significa apenas que isso est demorando mais do que a prova anterior."},tower_state:{local_height:"Altura da Torre Local",on_chain_height:"Altura da Torre no Blockchain",mined_in_last_epoch:"ltima poca Minerada.",sent_in_this_epoch:"Provas enviadas nesta poca",empty:"Nenhuma prova encontrada no dispositivo",proof_more:"Voc enviou o mximo de provas hoje (mximo de 72)",proof_less:"Provas insuficientes para receber uma recompensa hoje (min 8)",proof_ok:"Sua conta enviou provas suficientes hoje (min 8)"},cards:{cant_start:{title:"Sua conta ainda no existe na rede",body:"O minerador no pode iniciar at que a conta seja encontrada na rede. Talvez voc tenha gerado novas chaves localmente, mas ningum enviou moedas para esse endereo ainda?"},disco_error:{title:"Descontinuidade",body:"Parece que h uma lacuna nas provas que voc est enviando. Cada prova precisa referenciar a anterior, e a prova foi rejeitada por causa disso."},epoch_status:{empty_title:"Nenhuma prova enviada",empty_body:"No h provas salvas na rede. Quando voc enviar sua primeira prova com sucesso, ver algumas estatsticas aqui.",in_process_title:"Continue assim",in_process_body:"Sua conta precisa enviar pelo menos 8 provas por dia (poca) para receber uma recompensa. Voc receber a recompensa no dia seguinte.",complete_title:"Sucesso!",complete_body:"Sua conta enviou provas suficientes hoje (mnimo de 8 provas por poca). Voc deve receber recompensas no incio da prxima poca.",exceed_title:"Uau",exceed_body:"Voc minerou 72 provas, o nmero mximo de provas por poca. A torre pode continuar fazendo provas, mas elas s sero aceitas na prxima poca."},first_proof:{title:"Vamos minerar sua primeira prova",body:"<p> Aguente firme! Isso levar pelo menos 30 minutos, talvez at 1 hora.</p> <p> Voc ver seu saldo cair enquanto voc minera provas. Se voc atingir o mnimo por dia, receber uma recompensa, no dia seguinte (poca).</p> <p> Verifique as configuraes do seu computador para que o computador no durma quando a tela for desligada. Voc quer que o minerador funcione enquanto voc no est aqui.</p>",body_disabled:"Ligue o interruptor para iniciar a minerao!"},invalid_proof:{title:"No  Possvel Verificar a Prova",body:"Esquisito. Esta prova foi rejeitada porque no  uma \"prova de atraso\" vlida. Isso geralmente ocorre porque os parmetros no esto definidos corretamente."},oops:{title:"Opa",body:"Parece que h um erro ao minerar uma prova de atraso"},too_many_proofs:{title:"Muitas Provas",body:"Parece que voc enviou mais provas do que o esperado nas ltimas 24 horas. A rede espera um mximo de {maxNum} provas durante cada poca. Na prxima poca suas provas comearo a ser submetidas novamente."},wrong_difficulty:{title:"Dificuldade Errada",body:"Parece que voc est enviando uma prova com os parmetros de dificuldade errados para a rede. Verifique se voc est conectado  rede correta com as configuraes de dificuldade corretas."},sync_proof:{title:"Sincronizando suas provas",body:"Provas aguardando transao: {delta} ",body_0:"Algo est errado, voc tem mais provas na rede do que neste dispositivo. Pode estar faltando provas localmente."}}};var txs$1={deno_tx:"Demo Tx",account:"Conta",balance:"Saldo",btn_onboard:"Integrar Conta",btn_transfer:"Transferir Moedas",onboard:{title:"Integrar uma conta","await":"Aguardando",btn_onboard:"Integrar",btn_cancel:"Cancelar",no_balance_title:"Saldo Insuficiente",no_balance_body1:"A integrao de {onboard_key} no foi bem-sucedida.",no_balance_body2:"Parece que voc tem menos de 2 moedas em sua conta, isso significa que voc no poder embarcar ningum."},set_wallet_type:{title:"Defina seu Tipo de Conta",subtitle:"Certifique-se de que voc sabe o que est fazendo. Essa operao no  reversvel. As carteiras lentas e comunitrias so permanentes.",btn_slow:"Definir Carteira Lenta",btn_confirm_slow:"Confirmar Definir Carteira Lenta? Esta operao no  reversvel.",slow_confirm:"Definir Lenta",btn_community:"Definir Carteira de Comunidade",btn_confirm_community:"Definir Comunidade",community_confirm:"Confirmar Definir Carteira de Comunidade? Esta operao no  reversvel."},transfer:{title:"Transferncia de Moedas",sender:"Pagador",balance:"Saldo",receiver:"Recebedor",amount:"Valor",amount_label:"Valor (fraes no so permitidas ainda)",receiver_placeholder:"Endereo do Recebedor",amount_placeholder:"Valor a ser transferido",confirm_title:"Ateno!",please_confirm:"Por favor, confirme as informaes da sua transferncia:","await":"Aguarde",btn_next:"Prximo",btn_confirm:"Confirmar",btn_cancel:"Cancelar",btn_close:"Fechar",error_amount_greater_than_balance:"Valor no pode ser maior que o saldo da conta",error_receiver_equals_sender:"Endereo do recebedor deve ser diferente do endereo do emissor.",error_slow_wallet:"Transferncia de moedas est desabilidato para slow wallets.",success:"Transferncia executada com sucesso!",failed:"Transferncia falhou. Cdigo: {code}"}};var events$1={account_events:"Eventos da Conta",version:"Verso",type:"Tipo",amount:"Valor",sender:"Pagador",receiver:"Recebedor",received_payment:"Pagamento Recebido",sent_payment:"Pagamento Enviado",loading:{error:"Erro ao carregar os eventos da conta:",corrupted_db:"O n conectado atual no possui todos os eventos da conta. No se preocupe. Sua carteira e moedas esto seguras na rede. Tente conectar-se a outro n ascendente.",account_off_chain:"Conta selecionada no foi integrada ainda."}};var make_whole$1={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var pt = {nav:nav$1,layout:layout$1,wallet:wallet$1,about:about$1,settings:settings$1,miner:miner$1,txs:txs$1,events:events$1,make_whole:make_whole$1};

    var nav={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"}};var wallet={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Go To Setting",developers:"Developers"}};var about={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"Arabic",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Error loading the account events:",corrupted_db:"Current connected node does not have all account events. Don't worry. Your wallet and coins are safe on the chain. Try connecting to another upstream node.",account_off_chain:"Account selected not onboarded yet."}};var make_whole={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var ar = {nav:nav,layout:layout,wallet:wallet,about:about,settings:settings,miner:miner,txs:txs,events:events,make_whole:make_whole};

    y$1('en', async () => en);
    y$1('zh_cn', async () => zh_cn);
    y$1('de', async () => de);
    y$1('fr', async () => fr);
    y$1('es', async () => es);
    y$1('it', async () => it);
    y$1('pt', async () => pt);
    y$1('ar', async () => ar);
    function setupI18n(options) {
        const { withLocale: locale_ } = options;
        // Initialize svelte-i18n
        $({
            initialLocale: locale_,
            fallbackLocale: 'en',
        });
    }

    function init_preferences() {
        console.log(">>> call init_preferences");
        // avoid using lib without init finished
        setupI18n({
            withLocale: 'en',
            fallbackLocale: 'en',
        });
        i$1('get_preferences')
            .then((result) => {
            // init locale preference
            const locale = result.locale
                ? result.locale
                : I();
            setupI18n({
                withLocale: locale,
                fallbackLocale: 'en',
            });
        });
    }
    function setLocale(locale) {
        i$1('set_preferences_locale', { locale: locale })
            .then(() => {
            setupI18n({
                withLocale: locale,
                fallbackLocale: 'en',
            });
        });
    }

    /* src/components/Nav.svelte generated by Svelte v3.38.1 */
    const file$X = "src/components/Nav.svelte";

    // (42:4) {#if secondaryRoutes.includes($location.pathname)}
    function create_if_block_1$e(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				to: routes.home,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(42:4) {#if secondaryRoutes.includes($location.pathname)}",
    		ctx
    	});

    	return block;
    }

    // (43:6) <Link to={routes.home}>
    function create_default_slot_3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-muted");
    			attr_dev(span, "uk-icon", "icon: arrow-left; ratio: 2");
    			add_location(span, file$X, 42, 29, 1819);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(43:6) <Link to={routes.home}>",
    		ctx
    	});

    	return block;
    }

    // (47:12) <Link to={routes.home}>
    function create_default_slot_2(ctx) {
    	let t_value = /*$_*/ ctx[3]("nav.wallet") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("nav.wallet") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(47:12) <Link to={routes.home}>",
    		ctx
    	});

    	return block;
    }

    // (48:12) <Link to={routes.miner}>
    function create_default_slot_1$2(ctx) {
    	let t_value = /*$_*/ ctx[3]("nav.miner") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("nav.miner") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(48:12) <Link to={routes.miner}>",
    		ctx
    	});

    	return block;
    }

    // (49:12) <Link to={routes.transactions}>
    function create_default_slot$4(ctx) {
    	let t_value = /*$_*/ ctx[3]("nav.transactions") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("nav.transactions") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(49:12) <Link to={routes.transactions}>",
    		ctx
    	});

    	return block;
    }

    // (57:4) {#if init }
    function create_if_block$t(ctx) {
    	let div;
    	let ul;
    	let li;
    	let accountswitcher;
    	let current;
    	accountswitcher = new AccountSwitcher({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");
    			li = element("li");
    			create_component(accountswitcher.$$.fragment);
    			add_location(li, file$X, 59, 8, 2611);
    			attr_dev(ul, "class", "uk-navbar-nav");
    			add_location(ul, file$X, 58, 6, 2576);
    			attr_dev(div, "class", "uk-navbar-right");
    			add_location(div, file$X, 57, 4, 2540);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);
    			append_dev(ul, li);
    			mount_component(accountswitcher, li, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountswitcher.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountswitcher.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(accountswitcher);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(57:4) {#if init }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let main;
    	let nav;
    	let show_if = /*secondaryRoutes*/ ctx[4].includes(/*$location*/ ctx[2].pathname);
    	let t0;
    	let div;
    	let ul;
    	let li0;
    	let link0;
    	let t1;
    	let li1;
    	let link1;
    	let t2;
    	let li2;
    	let link2;
    	let ul_class_value;
    	let t3;
    	let current;
    	let if_block0 = show_if && create_if_block_1$e(ctx);

    	link0 = new Link({
    			props: {
    				to: routes.home,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: routes.miner,
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link({
    			props: {
    				to: routes.transactions,
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = /*init*/ ctx[1] && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			nav = element("nav");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			create_component(link0.$$.fragment);
    			t1 = space();
    			li1 = element("li");
    			create_component(link1.$$.fragment);
    			t2 = space();
    			li2 = element("li");
    			create_component(link2.$$.fragment);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			add_location(li0, file$X, 46, 8, 2032);
    			add_location(li1, file$X, 47, 8, 2100);
    			add_location(li2, file$X, 48, 8, 2166);

    			attr_dev(ul, "class", ul_class_value = "uk-navbar-nav " + (/*init*/ ctx[1] && /*myAccountIsOnChain*/ ctx[0]
    			? ""
    			: "uk-invisible"));

    			add_location(ul, file$X, 45, 6, 1945);
    			attr_dev(div, "class", "uk-navbar-center");
    			add_location(div, file$X, 44, 4, 1908);
    			attr_dev(nav, "class", "uk-navbar-container");
    			attr_dev(nav, "uk-navbar", "");
    			add_location(nav, file$X, 40, 2, 1691);
    			attr_dev(main, "class", "uk-margin-top");
    			add_location(main, file$X, 39, 0, 1660);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, nav);
    			if (if_block0) if_block0.m(nav, null);
    			append_dev(nav, t0);
    			append_dev(nav, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			mount_component(link0, li0, null);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			mount_component(link1, li1, null);
    			append_dev(ul, t2);
    			append_dev(ul, li2);
    			mount_component(link2, li2, null);
    			append_dev(nav, t3);
    			if (if_block1) if_block1.m(nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$location*/ 4) show_if = /*secondaryRoutes*/ ctx[4].includes(/*$location*/ ctx[2].pathname);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$location*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$e(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(nav, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 136) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 136) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope, $_*/ 136) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);

    			if (!current || dirty & /*init, myAccountIsOnChain*/ 3 && ul_class_value !== (ul_class_value = "uk-navbar-nav " + (/*init*/ ctx[1] && /*myAccountIsOnChain*/ ctx[0]
    			? ""
    			: "uk-invisible"))) {
    				attr_dev(ul, "class", ul_class_value);
    			}

    			if (/*init*/ ctx[1]) {
    				if (if_block1) {
    					if (dirty & /*init*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$t(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(nav, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(link2);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $location;
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(3, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Nav", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	// import MakeWholeLink from "./make-whole/MakeWholeLink.svelte";
    	init_preferences();

    	const secondaryRoutes = [
    		routes.settings,
    		routes.about,
    		routes.developer,
    		routes.keygen,
    		routes.accountFromMnem
    	];

    	const location = useLocation();
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(2, $location = value));
    	let myAccountIsOnChain = false; // assume initialized until not
    	let init = false; // assume initialized until not

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		isInit.subscribe(i => $$invalidate(1, init = i));

    		signingAccount.subscribe(myAccount => {
    			if (myAccount) {
    				$$invalidate(0, myAccountIsOnChain = myAccount.on_chain);
    			}

    			
    		});
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Nav> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		Link,
    		useLocation,
    		signingAccount,
    		isInit,
    		AccountSwitcher,
    		routes,
    		_: X,
    		init_preferences,
    		secondaryRoutes,
    		location,
    		myAccountIsOnChain,
    		init,
    		$location,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("myAccountIsOnChain" in $$props) $$invalidate(0, myAccountIsOnChain = $$props.myAccountIsOnChain);
    		if ("init" in $$props) $$invalidate(1, init = $$props.init);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [myAccountIsOnChain, init, $location, $_, secondaryRoutes, location];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src/components/dev/DebugCard.svelte generated by Svelte v3.38.1 */
    const file$W = "src/components/dev/DebugCard.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (47:8) {#if this_error != undefined}
    function create_if_block_1$d(ctx) {
    	let each_1_anchor;
    	let each_value = /*this_error*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*this_error*/ 2) {
    				each_value = /*this_error*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(47:8) {#if this_error != undefined}",
    		ctx
    	});

    	return block;
    }

    // (48:10) {#each this_error as e}
    function create_each_block$6(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*e*/ ctx[5].uid + "";
    	let t1;
    	let t2;
    	let br0;
    	let t3;
    	let t4_value = /*e*/ ctx[5].msg + "";
    	let t4;
    	let t5;
    	let br1;
    	let t6;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Error ID: ");
    			t1 = text(t1_value);
    			t2 = space();
    			br0 = element("br");
    			t3 = text("\n              Message: ");
    			t4 = text(t4_value);
    			t5 = space();
    			br1 = element("br");
    			t6 = space();
    			add_location(br0, file$W, 49, 32, 2237);
    			add_location(br1, file$W, 51, 14, 2289);
    			attr_dev(p, "class", "uk-text-break");
    			add_location(p, file$W, 48, 12, 2179);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, br0);
    			append_dev(p, t3);
    			append_dev(p, t4);
    			append_dev(p, t5);
    			append_dev(p, br1);
    			append_dev(p, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*this_error*/ 2 && t1_value !== (t1_value = /*e*/ ctx[5].uid + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*this_error*/ 2 && t4_value !== (t4_value = /*e*/ ctx[5].msg + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(48:10) {#each this_error as e}",
    		ctx
    	});

    	return block;
    }

    // (60:10) {#if result_string && result_string.length !== 0}
    function create_if_block$s(ctx) {
    	let span;
    	let t1;
    	let br;
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "LATEST REQUEST";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			t3 = text(/*result_string*/ ctx[0]);
    			add_location(span, file$W, 60, 10, 2487);
    			add_location(br, file$W, 62, 12, 2540);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*result_string*/ 1) set_data_dev(t3, /*result_string*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(60:10) {#if result_string && result_string.length !== 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let main;
    	let div5;
    	let div0;
    	let h5;
    	let t1;
    	let div3;
    	let div2;
    	let span0;
    	let t3;
    	let div1;
    	let span1;
    	let t4;
    	let span2;
    	let t5;
    	let t6;
    	let hr;
    	let t7;
    	let div4;
    	let p;
    	let t8;
    	let br;
    	let mounted;
    	let dispose;
    	let if_block0 = /*this_error*/ ctx[1] != undefined && create_if_block_1$d(ctx);
    	let if_block1 = /*result_string*/ ctx[0] && /*result_string*/ ctx[0].length !== 0 && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div5 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "LOGS";
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "ERRORS";
    			t3 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t4 = space();
    			span2 = element("span");
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			hr = element("hr");
    			t7 = space();
    			div4 = element("div");
    			p = element("p");
    			if (if_block1) if_block1.c();
    			t8 = space();
    			br = element("br");
    			attr_dev(h5, "class", "uk-card-title uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h5, file$W, 30, 10, 1522);
    			attr_dev(div0, "class", "uk-row");
    			add_location(div0, file$W, 29, 6, 1491);
    			attr_dev(span0, "class", "uk-margin-small-right");
    			add_location(span0, file$W, 38, 10, 1712);
    			attr_dev(span1, "class", "uk-margin-medium");
    			attr_dev(span1, "uk-icon", "trash");
    			attr_dev(span1, "uk-tooltip", "title: Clear Errors");
    			add_location(span1, file$W, 40, 12, 1816);
    			attr_dev(span2, "uk-icon", "sign-out");
    			attr_dev(span2, "uk-tooltip", "title: Exit Debug Mode");
    			add_location(span2, file$W, 41, 12, 1948);
    			attr_dev(div1, "class", "uk-align-right");
    			add_location(div1, file$W, 39, 10, 1775);
    			attr_dev(div2, "class", "uk-vertical-align-middle");
    			add_location(div2, file$W, 37, 8, 1663);
    			add_location(div3, file$W, 36, 6, 1649);
    			add_location(hr, file$W, 56, 6, 2364);
    			add_location(br, file$W, 65, 10, 2601);
    			attr_dev(p, "class", "uk-text-break");
    			add_location(p, file$W, 58, 8, 2391);
    			add_location(div4, file$W, 57, 6, 2377);
    			set_style(div5, "margin", "0px", 1);
    			set_style(div5, "min-height", "100%");
    			attr_dev(div5, "class", "uk-margin-top uk-margin-bottom uk-card uk-card-default uk-card-body uk-width-1-1");
    			add_location(div5, file$W, 26, 4, 1330);
    			set_style(main, "position", "fixed");
    			set_style(main, "bottom", "0px");
    			set_style(main, "left", "0px");
    			set_style(main, "right", "0px");
    			set_style(main, "height", "280px");
    			set_style(main, "overflow-y", "auto");
    			set_style(main, "z-index", "10");
    			set_style(main, "border-style", "ridge");
    			add_location(main, file$W, 25, 0, 1191);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h5);
    			append_dev(div5, t1);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, span0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, span1);
    			append_dev(div1, t4);
    			append_dev(div1, span2);
    			append_dev(div3, t5);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div5, t6);
    			append_dev(div5, hr);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, p);
    			if (if_block1) if_block1.m(p, null);
    			append_dev(p, t8);
    			append_dev(p, br);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span1, "click", /*click_handler*/ ctx[2], false, false, false),
    					listen_dev(span2, "click", /*click_handler_1*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*this_error*/ ctx[1] != undefined) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$d(ctx);
    					if_block0.c();
    					if_block0.m(div3, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*result_string*/ ctx[0] && /*result_string*/ ctx[0].length !== 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$s(ctx);
    					if_block1.c();
    					if_block1.m(p, t8);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DebugCard", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let result_string = "";
    	let this_error = get_store_value(carpeErrorLog);

    	afterUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
    		responses.subscribe(value => {
    			$$invalidate(0, result_string = value);
    		});

    		carpeErrorLog.subscribe(value => {
    			$$invalidate(1, this_error = value);
    		});
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DebugCard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => clearErrors();
    	const click_handler_1 = () => debugModeToggle();

    	$$self.$capture_state = () => ({
    		__awaiter,
    		afterUpdate,
    		get: get_store_value,
    		carpeErrorLog,
    		clearErrors,
    		responses,
    		debugModeToggle,
    		result_string,
    		this_error
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("result_string" in $$props) $$invalidate(0, result_string = $$props.result_string);
    		if ("this_error" in $$props) $$invalidate(1, this_error = $$props.this_error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [result_string, this_error, click_handler, click_handler_1];
    }

    class DebugCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugCard",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src/components/wallet/Newbie.svelte generated by Svelte v3.38.1 */
    const file$V = "src/components/wallet/Newbie.svelte";

    // (15:4) <Link to={routes.keygen}>
    function create_default_slot_1$1(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[0]("wallet.btn_new_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-secondary");
    			add_location(button, file$V, 15, 6, 662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("wallet.btn_new_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(15:4) <Link to={routes.keygen}>",
    		ctx
    	});

    	return block;
    }

    // (18:4) <Link to={routes.accountFromMnem}>
    function create_default_slot$3(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[0]("wallet.btn_restore_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$V, 18, 6, 805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("wallet.btn_restore_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(18:4) <Link to={routes.accountFromMnem}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let main;
    	let div0;
    	let h1;
    	let t0_value = /*$_*/ ctx[0]("wallet.carpe") + "";
    	let t0;
    	let t1;
    	let h5;
    	let t2_value = /*$_*/ ctx[0]("wallet.newbie_message") + "";
    	let t2;
    	let t3;
    	let div1;
    	let link0;
    	let t4;
    	let link1;
    	let current;

    	link0 = new Link({
    			props: {
    				to: routes.keygen,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: routes.accountFromMnem,
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			h5 = element("h5");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t4 = space();
    			create_component(link1.$$.fragment);
    			attr_dev(h1, "class", "uk-text-light uk-text-muted uk-text-uppercase uk-text-center");
    			add_location(h1, file$V, 9, 4, 346);
    			attr_dev(h5, "class", "uk-text-light uk-text-muted uk-text-uppercase uk-text-center");
    			add_location(h5, file$V, 10, 4, 449);
    			attr_dev(div0, "class", "uk-container uk-align-center");
    			add_location(div0, file$V, 8, 2, 299);
    			attr_dev(div1, "uk-grid", "");
    			attr_dev(div1, "class", "uk-margin uk-flex uk-flex-center");
    			add_location(div1, file$V, 13, 4, 571);
    			set_style(main, "position", "absolute");
    			attr_dev(main, "class", "uk-position-center uk-margin-large");
    			add_location(main, file$V, 7, 0, 221);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, h1);
    			append_dev(h1, t0);
    			append_dev(div0, t1);
    			append_dev(div0, h5);
    			append_dev(h5, t2);
    			append_dev(main, t3);
    			append_dev(main, div1);
    			mount_component(link0, div1, null);
    			append_dev(div1, t4);
    			mount_component(link1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("wallet.carpe") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$_*/ 1) && t2_value !== (t2_value = /*$_*/ ctx[0]("wallet.newbie_message") + "")) set_data_dev(t2, t2_value);
    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Newbie", slots, []);
    	init_preferences();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Newbie> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, Link, routes, init_preferences, $_ });
    	return [$_];
    }

    class Newbie extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newbie",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src/components/icons/IconMining.svelte generated by Svelte v3.38.1 */

    const file$U = "src/components/icons/IconMining.svelte";

    function create_fragment$U(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			attr_dev(path0, "d", "M5.393 1.072v0c-.12-.07-.16-.23-.1-.35 .04-.08.12-.13.21-.13 4.881-.06 10.185 1.6 14.6 8v0 0c.27.39.23.92-.1 1.26l-1.44 1.48v0c-.39.39-1.02.4-1.42.01 -.08-.08-.14-.16-.19-.25l-.37-.7C14.35 6.12 8.953 3.14 5.35 1.03Z");
    			add_location(path0, file$U, 0, 162, 162);
    			attr_dev(path1, "d", "M11.947 5.266L.95 15.609H.95c-.59.55-.62 1.47-.07 2.05 .01.01.02.02.03.03v0h0c.56.56 1.49.56 2.05 0 .01-.02.02-.03.02-.04l10.47-11.12");
    			add_location(path1, file$U, 0, 389, 389);
    			attr_dev(path2, "d", "M10.752 15.961l0 0c-.16.08-.26.25-.26.43v2.92 0c0 .17.09.34.25.43l3 1.71v0c.15.08.34.08.5 0l3-1.72v-.001c.15-.09.25-.26.25-.44v-2.92 0c-.01-.18-.1-.35-.26-.44l-3-1.72v0c-.16-.09-.35-.09-.5 0Z");
    			add_location(path2, file$U, 0, 534, 534);
    			attr_dev(path3, "d", "M19.7 14.05v0c-.13.09-.2.24-.2.4v.99 0c0 .16.07.31.21.4l1.5 1.05v0c.17.12.4.12.57-.001l1.5-1.05v0c.13-.1.21-.25.21-.41v-.99h0c0-.16-.08-.31-.2-.4l-1.5-1.13v0c-.18-.14-.43-.14-.6 0Z");
    			add_location(path3, file$U, 0, 737, 737);
    			attr_dev(path4, "d", "M19.7 20.455v0c-.13.09-.2.24-.2.4v.99 0c0 .16.07.31.21.4l1.5 1.05v0c.17.12.4.12.57-.001l1.5-1.05v0c.13-.1.21-.25.21-.41v-.99h0c0-.16-.08-.31-.2-.4l-1.5-1.13v0c-.18-.14-.43-.14-.6 0Z");
    			add_location(path4, file$U, 0, 929, 929);
    			attr_dev(g, "stroke-linecap", "round");
    			attr_dev(g, "stroke", "#1e87f0");
    			attr_dev(g, "fill", "none");
    			attr_dev(g, "stroke-linejoin", "round");
    			add_location(g, file$U, 0, 83, 83);
    			attr_dev(svg, "width", "20");
    			attr_dev(svg, "height", "20");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$U, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(g, path2);
    			append_dev(g, path3);
    			append_dev(g, path4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("IconMining", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMining> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconMining extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconMining",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /*! UIkit 3.8.1 | https://www.getuikit.com | (c) 2014 - 2021 YOOtheme | MIT License */

    var uikitIcons = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        function plugin(UIkit) {

            if (plugin.installed) {
                return;
            }

            UIkit.icon.add({
            "500px": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\"/><path d=\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\"/><path d=\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\"/><path d=\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\"/></svg>",
            "album": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"5\" y=\"2\" width=\"10\" height=\"1\"/><rect x=\"3\" y=\"4\" width=\"14\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"6.5\" width=\"17\" height=\"11\"/></svg>",
            "arrow-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"4\" x2=\"10.5\" y2=\"15\"/></svg>",
            "arrow-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 14 5 9.5 10 5\"/><line fill=\"none\" stroke=\"#000\" x1=\"16\" y1=\"9.5\" x2=\"5\" y2=\"9.52\"/></svg>",
            "arrow-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 5 15 9.5 10 14\"/><line fill=\"none\" stroke=\"#000\" x1=\"4\" y1=\"9.5\" x2=\"15\" y2=\"9.5\"/></svg>",
            "arrow-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"16\" x2=\"10.5\" y2=\"5\"/></svg>",
            "bag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5\"/><polygon fill=\"none\" stroke=\"#000\" points=\"16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5\"/></svg>",
            "ban": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"4\" y1=\"3.5\" x2=\"16\" y2=\"16.5\"/></svg>",
            "behance": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\"/><path d=\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\"/><rect x=\"13\" y=\"4\" width=\"5\" height=\"1.4\"/></svg>",
            "bell": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\"/></svg>",
            "bold": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\"/></svg>",
            "bolt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\"/></svg>",
            "bookmark": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\"/></svg>",
            "calendar": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\"/><rect width=\"1\" height=\"3\" x=\"6\" y=\"2\"/><rect width=\"1\" height=\"3\" x=\"13\" y=\"2\"/></svg>",
            "camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10.8\" r=\"3.8\"/><path fill=\"none\" stroke=\"#000\" d=\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\"/></svg>",
            "cart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"7.3\" cy=\"17.3\" r=\"1.4\"/><circle cx=\"13.3\" cy=\"17.3\" r=\"1.4\"/><polyline fill=\"none\" stroke=\"#000\" points=\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\"/></svg>",
            "check": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"4,10 8,15 17,4\"/></svg>",
            "chevron-double-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 14 6 10 10 6\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"14 14 10 10 14 6\"/></svg>",
            "chevron-double-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 6 14 10 10 14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"6 6 10 10 6 14\"/></svg>",
            "chevron-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"16 7 10 13 4 7\"/></svg>",
            "chevron-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"13 16 7 10 13 4\"/></svg>",
            "chevron-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"7 4 13 10 7 16\"/></svg>",
            "chevron-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"4 13 10 7 16 13\"/></svg>",
            "clock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
            "close": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,16 L4,4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,4 L4,16\"/></svg>",
            "cloud-download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"11.75 16 9.5 18.25 7.25 16\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
            "cloud-upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"7.25 11.75 9.5 9.5 11.75 11.75\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
            "code": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"13,4 19,10 13,16\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"7,4 1,10 7,16\"/></svg>",
            "cog": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"9.997\" cy=\"10\" r=\"3.31\"/><path fill=\"none\" stroke=\"#000\" d=\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\"/></svg>",
            "comment": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\"/></svg>",
            "commenting": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\"/><circle cx=\"10\" cy=\"8\" r=\"1\"/><circle cx=\"6\" cy=\"8\" r=\"1\"/><circle cx=\"14\" cy=\"8\" r=\"1\"/></svg>",
            "comments": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"2 0.5 19.5 0.5 19.5 13\"/><path d=\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\"/></svg>",
            "copy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"2.5\" width=\"12\" height=\"16\"/><polyline fill=\"none\" stroke=\"#000\" points=\"5 0.5 17.5 0.5 17.5 17\"/></svg>",
            "credit-card": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"4.5\" width=\"17\" height=\"12\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"3\"/></svg>",
            "database": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"4.64\" rx=\"7.5\" ry=\"3.14\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\"/></svg>",
            "desktop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"8\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"11\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"16\" width=\"10\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"3.5\" width=\"17\" height=\"11\"/></svg>",
            "discord": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z\"/></svg>",
            "download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"14,10 9.5,14.5 5,10\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"13.91\" x2=\"9.5\" y2=\"3\"/></svg>",
            "dribbble": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
            "etsy": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\"/></svg>",
            "expand": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13 2 18 2 18 7 17 7 17 3 13 3\"/><polygon points=\"2 13 3 13 3 17 7 17 7 18 2 18\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11,9 L17,3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M3,17 L9,11\"/></svg>",
            "facebook": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\"/></svg>",
            "file-edit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\"/><polyline fill=\"none\" stroke=\"#000\" points=\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\"/></svg>",
            "file-pdf": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><path d=\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\"/></svg>",
            "file-text": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"12\" y1=\"12.5\" y2=\"12.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"8.5\" y2=\"8.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"6.5\" y2=\"6.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"10.5\" y2=\"10.5\"/></svg>",
            "file": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"1.5\" width=\"13\" height=\"17\"/></svg>",
            "flickr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"5.5\" cy=\"9.5\" r=\"3.5\"/><circle cx=\"14.5\" cy=\"9.5\" r=\"3.5\"/></svg>",
            "folder": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\"/></svg>",
            "forward": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\"/></svg>",
            "foursquare": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\"/></svg>",
            "future": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path d=\"M13.018,14.197 L9.445,10.625\" fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\"/></svg>",
            "git-branch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"3\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14\" cy=\"6\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"17\" r=\"2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\"/></svg>",
            "git-fork": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"5.79\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14.19\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"10.03\" cy=\"16.79\" r=\"1.79\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\"/></svg>",
            "github-alt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\"/></svg>",
            "github": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\"/></svg>",
            "gitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3.5\" y=\"1\" width=\"1.531\" height=\"11.471\"/><rect x=\"7.324\" y=\"4.059\" width=\"1.529\" height=\"15.294\"/><rect x=\"11.148\" y=\"4.059\" width=\"1.527\" height=\"15.294\"/><rect x=\"14.971\" y=\"4.059\" width=\"1.529\" height=\"8.412\"/></svg>",
            "google": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\"/></svg>",
            "grid": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"14\" width=\"3\" height=\"3\"/></svg>",
            "happy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"13\" cy=\"7\" r=\"1\"/><circle cx=\"7\" cy=\"7\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"8.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\"/></svg>",
            "hashtag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\"/></svg>",
            "heart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" d=\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\"/></svg>",
            "history": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"#000\" points=\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
            "home": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\"/><polygon points=\"15 4 18 4 18 7 17 7 17 5 15 5\"/><polygon points=\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\"/></svg>",
            "image": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"16.1\" cy=\"6.1\" r=\"1.1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"2.5\" width=\"19\" height=\"15\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"4,13 8,9 13,14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"11,12 12.5,10.5 16,14\"/></svg>",
            "info": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
            "instagram": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\"/><circle cx=\"14.87\" cy=\"5.26\" r=\"1.09\"/><path d=\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\"/></svg>",
            "italic": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\"/></svg>",
            "joomla": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\"/><path d=\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\"/><path d=\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\"/><path d=\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\"/></svg>",
            "laptop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"16\" width=\"20\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"2.5\" y=\"4.5\" width=\"15\" height=\"10\"/></svg>",
            "lifesaver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\"/></svg>",
            "link": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M7.925,11.875 L11.925,7.975\"/></svg>",
            "linkedin": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\"/><path d=\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\"/></svg>",
            "list": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"6\" y=\"4\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"9\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"14\" width=\"12\" height=\"1\"/><rect x=\"2\" y=\"4\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"2\" height=\"1\"/></svg>",
            "location": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"6.8\" r=\"2.3\"/></svg>",
            "lock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" height=\"10\" width=\"13\" y=\"8.5\" x=\"3.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\"/></svg>",
            "mail": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"1.4,6.5 10,11 18.6,6.5\"/><path d=\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\"/></svg>",
            "menu": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"4\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"16\" height=\"1\"/></svg>",
            "microphone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" x1=\"10\" x2=\"10\" y1=\"16.44\" y2=\"18.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"7\" x2=\"13\" y1=\"18.5\" y2=\"18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\"/></svg>",
            "minus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
            "minus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect height=\"1\" width=\"18\" y=\"9\" x=\"1\"/></svg>",
            "more-vertical": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"3\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"17\" r=\"2\"/></svg>",
            "more": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"17\" cy=\"10\" r=\"2\"/></svg>",
            "move": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"4,5 1,5 1,9 2,9 2,6 4,6\"/><polygon points=\"1,16 2,16 2,18 4,18 4,19 1,19\"/><polygon points=\"14,16 14,19 11,19 11,18 13,18 13,16\"/><rect fill=\"none\" stroke=\"#000\" x=\"5.5\" y=\"1.5\" width=\"13\" height=\"13\"/><rect x=\"1\" y=\"11\" width=\"1\" height=\"3\"/><rect x=\"6\" y=\"18\" width=\"3\" height=\"1\"/></svg>",
            "nut": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"3.5\"/></svg>",
            "pagekit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\"/></svg>",
            "paint-bucket": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.42,2.33 L11.7,7.61\"/><path d=\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\"/></svg>",
            "pencil": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M15.98,7.268 L13.851,5.148\"/></svg>",
            "phone-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\"/><circle cx=\"3.8\" cy=\"10.5\" r=\".8\"/></svg>",
            "phone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\"/><circle cx=\"10.5\" cy=\"16.5\" r=\".8\"/></svg>",
            "pinterest": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\"/></svg>",
            "play-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"8.5 7 13.5 10 8.5 13\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
            "play": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"6.5,5 14.5,10 6.5,15\"/></svg>",
            "plus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"5\" x2=\"9.5\" y2=\"14\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
            "plus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"1\" width=\"1\" height=\"17\"/><rect x=\"1\" y=\"9\" width=\"17\" height=\"1\"/></svg>",
            "print": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\"/><rect fill=\"none\" stroke=\"#000\" width=\"11\" height=\"6\" x=\"4.5\" y=\"11.5\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"13\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"15\"/></svg>",
            "pull": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"11\" x2=\"9.5\" y2=\"2\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\"/></svg>",
            "push": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"10\" x2=\"9.5\" y2=\"1\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\"/></svg>",
            "question": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><circle cx=\"10.44\" cy=\"14.42\" r=\"1.05\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\"/></svg>",
            "quote-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\"/><path d=\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\"/></svg>",
            "receiver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\"/></svg>",
            "reddit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\"/><path d=\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\"/><path d=\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\"/><path d=\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\"/></svg>",
            "refresh": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"9.9 2 12.79 4.89 9.79 7.9\"/></svg>",
            "reply": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\"/></svg>",
            "rss": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3.12\" cy=\"16.8\" r=\"1.85\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\"/></svg>",
            "search": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>",
            "server": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"7\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"16\" y=\"3\" width=\"1\" height=\"1\"/><rect x=\"16\" y=\"10\" width=\"1\" height=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"9.9\" cy=\"17.4\" r=\"1.4\"/><rect x=\"3\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"9.5\" y=\"14\" width=\"1\" height=\"2\"/><rect x=\"3\" y=\"17\" width=\"6\" height=\"1\"/><rect x=\"11\" y=\"17\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"1.5\" width=\"17\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"8.5\" width=\"17\" height=\"5\"/></svg>",
            "settings": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"3.55\" rx=\"2.11\" ry=\"2.15\"/><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"15.55\" rx=\"2.11\" ry=\"2.15\"/><circle fill=\"none\" stroke=\"#000\" cx=\"13.15\" cy=\"9.55\" r=\"2.15\"/><rect x=\"1\" y=\"3\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"3\" width=\"8\" height=\"1\"/><rect x=\"1\" y=\"9\" width=\"8\" height=\"1\"/><rect x=\"15\" y=\"9\" width=\"3\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"15\" width=\"8\" height=\"1\"/></svg>",
            "shrink": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"11 4 12 4 12 8 16 8 16 9 11 9\"/><polygon points=\"4 11 9 11 9 16 8 16 8 12 4 12\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M12,8 L18,2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2,18 L8,12\"/></svg>",
            "sign-in": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\"/><polygon points=\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\"/></svg>",
            "sign-out": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\"/><polygon points=\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\"/></svg>",
            "social": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.4\" y1=\"14\" x2=\"6.3\" y2=\"10.7\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.5\" y1=\"5.5\" x2=\"6.5\" y2=\"8.8\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"4.6\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"14.8\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"4.5\" cy=\"9.8\" r=\"2.3\"/></svg>",
            "soundcloud": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\"/><rect x=\"6\" y=\"6.5\" width=\"1.5\" height=\"8.5\"/><rect x=\"3\" y=\"8\" width=\"1.5\" height=\"7\"/><rect y=\"10\" width=\"1.5\" height=\"5\"/></svg>",
            "star": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\"/></svg>",
            "strikethrough": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\"/><rect x=\"3\" y=\"10\" width=\"15\" height=\"1\"/></svg>",
            "table": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"1\" y=\"3\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"11\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"18\" height=\"1\"/></svg>",
            "tablet-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\"/><circle cx=\"3.7\" cy=\"10.5\" r=\".8\"/></svg>",
            "tablet": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\"/><circle cx=\"10.5\" cy=\"16.3\" r=\".8\"/></svg>",
            "tag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\"/><circle cx=\"14\" cy=\"6\" r=\"1\"/></svg>",
            "thumbnails": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"11.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"11.5\" width=\"5\" height=\"5\"/></svg>",
            "tiktok": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z\"/></svg>",
            "trash": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\"/><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\"/><rect x=\"8\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"11\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"2\" y=\"3\" width=\"16\" height=\"1\"/></svg>",
            "triangle-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 7 15 7 10 12\"/></svg>",
            "triangle-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12 5 7 10 12 15\"/></svg>",
            "triangle-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"8 5 13 10 8 15\"/></svg>",
            "triangle-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 13 10 8 15 13\"/></svg>",
            "tripadvisor": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\"/></svg>",
            "tumblr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\"/></svg>",
            "tv": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"7\" y=\"16\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"3.5\" width=\"19\" height=\"11\"/></svg>",
            "twitch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z\"/><rect x=\"12.98\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/><rect x=\"9.43\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/></svg>",
            "twitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\"/></svg>",
            "uikit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\"/><polygon points=\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\"/></svg>",
            "unlock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"8.5\" width=\"13\" height=\"10\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\"/></svg>",
            "upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"5 8 9.5 3.5 14 8\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"15\" x2=\"9.5\" y2=\"4\"/></svg>",
            "user": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.9\" cy=\"6.4\" r=\"4.4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\"/></svg>",
            "users": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"7.7\" cy=\"8.6\" r=\"3.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\"/></svg>",
            "video-camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\"/></svg>",
            "vimeo": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\"/></svg>",
            "warning": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"14\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\"/></svg>",
            "whatsapp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\"/></svg>",
            "wordpress": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\"/></svg>",
            "world": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1,10.5 L19,10.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,15.5 L17.65,15.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,5.5 L17.523,5.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10.5\" r=\"9\"/></svg>",
            "xing": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\"/><path d=\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\"/></svg>",
            "yelp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\"/></svg>",
            "youtube": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\"/></svg>"
        });

        }

        if (typeof window !== 'undefined' && window.UIkit) {
            window.UIkit.use(plugin);
        }

        return plugin;

    }));
    });

    const scaleFactor = 1000000;
    const fixedLocales = {
        "zh_cn": "zh"
    };
    function getLocale() {
        let res = get_store_value(M$1);
        return fixLocale(res);
    }
    function printCoins(amount) {
        const scaled = unscaledCoins(amount);
        const selectedLocale = getLocale();
        return scaled.toLocaleString(selectedLocale, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        });
    }
    function printUnscaledCoins(amount, min = 2, max = 6) {
        const selectedLocale = getLocale();
        return amount.toLocaleString(selectedLocale, {
            minimumFractionDigits: min,
            maximumFractionDigits: max,
        });
    }
    function unscaledCoins(amount) {
        return amount / scaleFactor;
    }
    function fixLocale(locale) {
        return fixedLocales[locale] || locale;
    }

    /* src/components/wallet/AccountsList.svelte generated by Svelte v3.38.1 */
    const file$T = "src/components/wallet/AccountsList.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (18:35) 
    function create_if_block_1$c(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let th1;
    	let t1_value = /*$_*/ ctx[4]("wallet.account_list.nickname") + "";
    	let t1;
    	let t2;
    	let th2;
    	let t3_value = /*$_*/ ctx[4]("wallet.account_list.address") + "";
    	let t3;
    	let t4;
    	let th3;
    	let t5_value = /*$_*/ ctx[4]("wallet.account_list.authkey") + "";
    	let t5;
    	let t6;
    	let th4;
    	let t7_value = /*$_*/ ctx[4]("wallet.account_list.balance") + "";
    	let t7;
    	let t8;
    	let tbody;
    	let current;
    	let each_value = /*accountList*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			t1 = text(t1_value);
    			t2 = space();
    			th2 = element("th");
    			t3 = text(t3_value);
    			t4 = space();
    			th3 = element("th");
    			t5 = text(t5_value);
    			t6 = space();
    			th4 = element("th");
    			t7 = text(t7_value);
    			t8 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$T, 21, 10, 593);
    			add_location(th1, file$T, 22, 10, 610);
    			add_location(th2, file$T, 23, 10, 666);
    			add_location(th3, file$T, 24, 10, 721);
    			attr_dev(th4, "class", "uk-text-right");
    			add_location(th4, file$T, 25, 10, 776);
    			add_location(tr, file$T, 20, 8, 578);
    			add_location(thead, file$T, 19, 6, 562);
    			add_location(tbody, file$T, 28, 6, 878);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$T, 18, 4, 514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(th1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, th2);
    			append_dev(th2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, th3);
    			append_dev(th3, t5);
    			append_dev(tr, t6);
    			append_dev(tr, th4);
    			append_dev(th4, t7);
    			append_dev(table, t8);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 16) && t1_value !== (t1_value = /*$_*/ ctx[4]("wallet.account_list.nickname") + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*$_*/ 16) && t3_value !== (t3_value = /*$_*/ ctx[4]("wallet.account_list.address") + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*$_*/ 16) && t5_value !== (t5_value = /*$_*/ ctx[4]("wallet.account_list.authkey") + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*$_*/ 16) && t7_value !== (t7_value = /*$_*/ ctx[4]("wallet.account_list.balance") + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*isMining, accountList, my_account, setAccount, $_, printCoins, unscaledCoins, isConnected*/ 31) {
    				each_value = /*accountList*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(18:35) ",
    		ctx
    	});

    	return block;
    }

    // (16:2) {#if accountList == null}
    function create_if_block$r(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			add_location(span, file$T, 16, 4, 454);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(16:2) {#if accountList == null}",
    		ctx
    	});

    	return block;
    }

    // (39:14) {#if a.account == my_account.account}
    function create_if_block_7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_8, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*isMining*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(39:14) {#if a.account == my_account.account}",
    		ctx
    	});

    	return block;
    }

    // (42:16) {:else}
    function create_else_block_1$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "user");
    			add_location(span, file$T, 42, 18, 1344);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(42:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:16) {#if isMining}
    function create_if_block_8(ctx) {
    	let iconmining;
    	let current;
    	iconmining = new IconMining({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconmining.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconmining, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconmining.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconmining.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconmining, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(40:16) {#if isMining}",
    		ctx
    	});

    	return block;
    }

    // (73:14) {:else}
    function create_else_block$e(ctx) {
    	let t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(73:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:37) 
    function create_if_block_6(ctx) {
    	let t0_value = /*$_*/ ctx[4]("wallet.account_list.offline") + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.account_list.offline") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(71:37) ",
    		ctx
    	});

    	return block;
    }

    // (69:42) 
    function create_if_block_5$1(ctx) {
    	let t0_value = /*$_*/ ctx[4]("wallet.account_list.loading") + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.account_list.loading") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(69:42) ",
    		ctx
    	});

    	return block;
    }

    // (53:35) 
    function create_if_block_3$5(ctx) {
    	let div;
    	let show_if = unscaledCoins(/*a*/ ctx[6].balance) < 1;
    	let t0;
    	let t1_value = printCoins(/*a*/ ctx[6].balance) + "";
    	let t1;
    	let if_block = show_if && create_if_block_4$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(div, "class", "uk-inline");
    			add_location(div, file$T, 53, 16, 1761);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*accountList*/ 2) show_if = unscaledCoins(/*a*/ ctx[6].balance) < 1;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$3(ctx);
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*accountList*/ 2 && t1_value !== (t1_value = printCoins(/*a*/ ctx[6].balance) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(53:35) ",
    		ctx
    	});

    	return block;
    }

    // (51:14) {#if (a.on_chain != null) && (a.on_chain == false)}
    function create_if_block_2$7(ctx) {
    	let t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(51:14) {#if (a.on_chain != null) && (a.on_chain == false)}",
    		ctx
    	});

    	return block;
    }

    // (56:18) {#if unscaledCoins(a.balance) < 1}
    function create_if_block_4$3(ctx) {
    	let span;
    	let t0;
    	let div;
    	let t1_value = /*$_*/ ctx[4]("wallet.account_list.message") + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = space();
    			div = element("div");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "uk-margin uk-text-warning");
    			attr_dev(span, "uk-icon", "icon: info");
    			add_location(span, file$T, 57, 20, 1949);
    			attr_dev(div, "uk-dropdown", "");
    			add_location(div, file$T, 61, 20, 2097);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t1_value !== (t1_value = /*$_*/ ctx[4]("wallet.account_list.message") + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(56:18) {#if unscaledCoins(a.balance) < 1}",
    		ctx
    	});

    	return block;
    }

    // (30:8) {#each accountList as a, i}
    function create_each_block$5(ctx) {
    	let tr;
    	let td0;
    	let t0;
    	let td1;
    	let t1_value = /*a*/ ctx[6].nickname + "";
    	let t1;
    	let t2;
    	let td2;
    	let t3_value = /*a*/ ctx[6].account + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5_value = /*a*/ ctx[6].authkey.slice(0, 5) + "";
    	let t5;
    	let t6;
    	let t7;
    	let td4;
    	let t8;
    	let tr_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*a*/ ctx[6].account == /*my_account*/ ctx[0].account && create_if_block_7(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*a*/ ctx[6].on_chain != null && /*a*/ ctx[6].on_chain == false) return create_if_block_2$7;
    		if (/*a*/ ctx[6].on_chain) return create_if_block_3$5;
    		if (/*a*/ ctx[6].balance == null) return create_if_block_5$1;
    		if (!/*isConnected*/ ctx[3]) return create_if_block_6;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block1 = current_block_type(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*a*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = text(t5_value);
    			t6 = text("...");
    			t7 = space();
    			td4 = element("td");
    			if_block1.c();
    			t8 = space();
    			add_location(td0, file$T, 37, 12, 1181);
    			add_location(td1, file$T, 46, 12, 1440);
    			add_location(td2, file$T, 47, 12, 1474);
    			add_location(td3, file$T, 48, 12, 1507);
    			attr_dev(td4, "class", "uk-text-right");
    			add_location(td4, file$T, 49, 12, 1555);

    			attr_dev(tr, "class", tr_class_value = /*isMining*/ ctx[2] && /*a*/ ctx[6].account == /*my_account*/ ctx[0].account
    			? "uk-text-primary"
    			: "");

    			add_location(tr, file$T, 31, 10, 985);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			if (if_block0) if_block0.m(td0, null);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, t5);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			if_block1.m(td4, null);
    			append_dev(tr, t8);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*a*/ ctx[6].account == /*my_account*/ ctx[0].account) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*accountList, my_account*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(td0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*accountList*/ 2) && t1_value !== (t1_value = /*a*/ ctx[6].nickname + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*accountList*/ 2) && t3_value !== (t3_value = /*a*/ ctx[6].account + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*accountList*/ 2) && t5_value !== (t5_value = /*a*/ ctx[6].authkey.slice(0, 5) + "")) set_data_dev(t5, t5_value);

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(td4, null);
    				}
    			}

    			if (!current || dirty & /*isMining, accountList, my_account*/ 7 && tr_class_value !== (tr_class_value = /*isMining*/ ctx[2] && /*a*/ ctx[6].account == /*my_account*/ ctx[0].account
    			? "uk-text-primary"
    			: "")) {
    				attr_dev(tr, "class", tr_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(30:8) {#each accountList as a, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$r, create_if_block_1$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*accountList*/ ctx[1] == null) return 0;
    		if (/*accountList*/ ctx[1].length > 0) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$T, 14, 0, 415);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccountsList", slots, []);
    	
    	uikit.use(uikitIcons);
    	let { my_account } = $$props;
    	let { accountList } = $$props;
    	let { isMining } = $$props;
    	let { isConnected } = $$props;
    	const writable_props = ["my_account", "accountList", "isMining", "isConnected"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccountsList> was created with unknown prop '${key}'`);
    	});

    	const click_handler = a => setAccount(a.account);

    	$$self.$$set = $$props => {
    		if ("my_account" in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ("accountList" in $$props) $$invalidate(1, accountList = $$props.accountList);
    		if ("isMining" in $$props) $$invalidate(2, isMining = $$props.isMining);
    		if ("isConnected" in $$props) $$invalidate(3, isConnected = $$props.isConnected);
    	};

    	$$self.$capture_state = () => ({
    		_: X,
    		setAccount,
    		IconMining,
    		UIkit: uikit,
    		Icons: uikitIcons,
    		printCoins,
    		unscaledCoins,
    		my_account,
    		accountList,
    		isMining,
    		isConnected,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("my_account" in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ("accountList" in $$props) $$invalidate(1, accountList = $$props.accountList);
    		if ("isMining" in $$props) $$invalidate(2, isMining = $$props.isMining);
    		if ("isConnected" in $$props) $$invalidate(3, isConnected = $$props.isConnected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [my_account, accountList, isMining, isConnected, $_, click_handler];
    }

    class AccountsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {
    			my_account: 0,
    			accountList: 1,
    			isMining: 2,
    			isConnected: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountsList",
    			options,
    			id: create_fragment$T.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*my_account*/ ctx[0] === undefined && !("my_account" in props)) {
    			console.warn("<AccountsList> was created without expected prop 'my_account'");
    		}

    		if (/*accountList*/ ctx[1] === undefined && !("accountList" in props)) {
    			console.warn("<AccountsList> was created without expected prop 'accountList'");
    		}

    		if (/*isMining*/ ctx[2] === undefined && !("isMining" in props)) {
    			console.warn("<AccountsList> was created without expected prop 'isMining'");
    		}

    		if (/*isConnected*/ ctx[3] === undefined && !("isConnected" in props)) {
    			console.warn("<AccountsList> was created without expected prop 'isConnected'");
    		}
    	}

    	get my_account() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set my_account(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accountList() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accountList(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMining() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMining(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isConnected() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isConnected(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/wallet/ReminderCreate.svelte generated by Svelte v3.38.1 */
    const file$S = "src/components/wallet/ReminderCreate.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (8:2) {#if pendingAccounts.length > 0 && isConnected }
    function create_if_block$q(ctx) {
    	let div1;
    	let div0;
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("wallet.reminder_create.card_title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[2]("wallet.reminder_create.message_headline") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[2]("wallet.reminder_create.message_prefix") + "";
    	let t4;
    	let t5;
    	let a;
    	let t6;
    	let span;
    	let t7;
    	let t8_value = /*$_*/ ctx[2]("wallet.reminder_create.message_suffix") + "";
    	let t8;
    	let t9;
    	let each_value = /*pendingAccounts*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			a = element("a");
    			t6 = text("Discord ");
    			span = element("span");
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h3, "class", "uk-card-title");
    			add_location(h3, file$S, 10, 8, 296);
    			add_location(p0, file$S, 11, 8, 377);
    			attr_dev(span, "uk-icon", "icon: link;ratio:0.8");
    			add_location(span, file$S, 12, 158, 590);
    			attr_dev(a, "href", "https://discord.com/channels/833074824447655976/909866360060932127");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$S, 12, 57, 489);
    			add_location(p1, file$S, 12, 8, 440);
    			attr_dev(div0, "class", "uk-card uk-card-primary uk-card-hover uk-card-body uk-light");
    			add_location(div0, file$S, 9, 6, 214);
    			attr_dev(div1, "class", "uk-margin-large");
    			add_location(div1, file$S, 8, 4, 178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h3);
    			append_dev(h3, t0);
    			append_dev(div0, t1);
    			append_dev(div0, p0);
    			append_dev(p0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(p1, t4);
    			append_dev(p1, t5);
    			append_dev(p1, a);
    			append_dev(a, t6);
    			append_dev(a, span);
    			append_dev(p1, t7);
    			append_dev(p1, t8);
    			append_dev(div0, t9);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.reminder_create.card_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("wallet.reminder_create.message_headline") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 4 && t4_value !== (t4_value = /*$_*/ ctx[2]("wallet.reminder_create.message_prefix") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 4 && t8_value !== (t8_value = /*$_*/ ctx[2]("wallet.reminder_create.message_suffix") + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*pendingAccounts, $_*/ 5) {
    				each_value = /*pendingAccounts*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(8:2) {#if pendingAccounts.length > 0 && isConnected }",
    		ctx
    	});

    	return block;
    }

    // (14:8) {#each pendingAccounts as a}
    function create_each_block$4(ctx) {
    	let p;
    	let t0_value = /*a*/ ctx[3].nickname + "";
    	let t0;
    	let t1;
    	let t2_value = /*$_*/ ctx[2]("wallet.reminder_create.onboard_key") + "";
    	let t2;
    	let t3;
    	let span;
    	let t4_value = /*a*/ ctx[3].authkey + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" - ");
    			t2 = text(t2_value);
    			t3 = text(" : ");
    			span = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(span, "class", "uk-text-uppercase");
    			add_location(span, file$S, 15, 72, 813);
    			add_location(p, file$S, 14, 10, 736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(p, span);
    			append_dev(span, t4);
    			append_dev(p, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pendingAccounts*/ 1 && t0_value !== (t0_value = /*a*/ ctx[3].nickname + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("wallet.reminder_create.onboard_key") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*pendingAccounts*/ 1 && t4_value !== (t4_value = /*a*/ ctx[3].authkey + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(14:8) {#each pendingAccounts as a}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let main;
    	let if_block = /*pendingAccounts*/ ctx[0].length > 0 && /*isConnected*/ ctx[1] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$S, 6, 0, 116);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*pendingAccounts*/ ctx[0].length > 0 && /*isConnected*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ReminderCreate", slots, []);
    	
    	let { pendingAccounts } = $$props;
    	let { isConnected } = $$props;
    	const writable_props = ["pendingAccounts", "isConnected"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ReminderCreate> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("pendingAccounts" in $$props) $$invalidate(0, pendingAccounts = $$props.pendingAccounts);
    		if ("isConnected" in $$props) $$invalidate(1, isConnected = $$props.isConnected);
    	};

    	$$self.$capture_state = () => ({ _: X, pendingAccounts, isConnected, $_ });

    	$$self.$inject_state = $$props => {
    		if ("pendingAccounts" in $$props) $$invalidate(0, pendingAccounts = $$props.pendingAccounts);
    		if ("isConnected" in $$props) $$invalidate(1, isConnected = $$props.isConnected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pendingAccounts, isConnected, $_];
    }

    class ReminderCreate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { pendingAccounts: 0, isConnected: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ReminderCreate",
    			options,
    			id: create_fragment$S.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pendingAccounts*/ ctx[0] === undefined && !("pendingAccounts" in props)) {
    			console.warn("<ReminderCreate> was created without expected prop 'pendingAccounts'");
    		}

    		if (/*isConnected*/ ctx[1] === undefined && !("isConnected" in props)) {
    			console.warn("<ReminderCreate> was created without expected prop 'isConnected'");
    		}
    	}

    	get pendingAccounts() {
    		throw new Error("<ReminderCreate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pendingAccounts(value) {
    		throw new Error("<ReminderCreate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isConnected() {
    		throw new Error("<ReminderCreate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isConnected(value) {
    		throw new Error("<ReminderCreate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/settings/SetNetworkPlaylist.svelte generated by Svelte v3.38.1 */
    const file$R = "src/components/settings/SetNetworkPlaylist.svelte";

    // (45:8) <Link to={routes.home}>
    function create_default_slot$2(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("settings.network_settings.btn_cancel") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "uk-button uk-button-default uk-align-right");
    			add_location(span, file$R, 45, 10, 1466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("settings.network_settings.btn_cancel") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(45:8) <Link to={routes.home}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let main;
    	let form;
    	let fieldset;
    	let div0;
    	let span0;
    	let t0_value = /*$_*/ ctx[1]("settings.network_settings.playlist") + "";
    	let t0;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let span1;
    	let t3_value = /*$_*/ ctx[1]("settings.network_settings.btn_submit") + "";
    	let t3;
    	let t4;
    	let link;
    	let current;
    	let mounted;
    	let dispose;

    	link = new Link({
    			props: {
    				to: routes.home,
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			form = element("form");
    			fieldset = element("fieldset");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(link.$$.fragment);
    			add_location(span0, file$R, 29, 8, 988);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", /*playlist_json_url*/ ctx[0]);
    			add_location(input, file$R, 30, 8, 1054);
    			attr_dev(div0, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div0, file$R, 28, 6, 927);
    			attr_dev(span1, "class", "uk-button uk-button-primary uk-align-right");
    			attr_dev(span1, "id", "add-btn");
    			add_location(span1, file$R, 39, 8, 1238);
    			add_location(div1, file$R, 38, 6, 1224);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$R, 27, 4, 890);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$R, 26, 2, 861);
    			add_location(main, file$R, 25, 0, 852);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*playlist_json_url*/ ctx[0]);
    			append_dev(fieldset, t2);
    			append_dev(fieldset, div1);
    			append_dev(div1, span1);
    			append_dev(span1, t3);
    			append_dev(div1, t4);
    			mount_component(link, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[3]),
    					listen_dev(span1, "click", /*updateNetwork*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("settings.network_settings.playlist") + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*playlist_json_url*/ 1) {
    				attr_dev(input, "placeholder", /*playlist_json_url*/ ctx[0]);
    			}

    			if (dirty & /*playlist_json_url*/ 1 && input.value !== /*playlist_json_url*/ ctx[0]) {
    				set_input_value(input, /*playlist_json_url*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 2) && t3_value !== (t3_value = /*$_*/ ctx[1]("settings.network_settings.btn_submit") + "")) set_data_dev(t3, t3_value);
    			const link_changes = {};

    			if (dirty & /*$$scope, $_*/ 18) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(link);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SetNetworkPlaylist", slots, []);
    	
    	

    	// default playlist which is provided in Carpe.
    	let playlist_json_url = "https://raw.githubusercontent.com/OLSF/seed-peers/main/fullnode_seed_playlist.json";

    	function updateNetwork() {
    		// check input data
    		// submit
    		i$1("override_playlist", { url: playlist_json_url }).then(res => {
    			network_profile.set(res);
    			notify_success("Network Settings Updated");
    		}).catch(error => {
    			raise_error(error, false, "updateNetwork");
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SetNetworkPlaylist> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		playlist_json_url = this.value;
    		$$invalidate(0, playlist_json_url);
    	}

    	$$self.$capture_state = () => ({
    		Link,
    		raise_error,
    		network_profile,
    		refreshWaypoint,
    		invoke: i$1,
    		routes,
    		notify_success,
    		_: X,
    		playlist_json_url,
    		updateNetwork,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("playlist_json_url" in $$props) $$invalidate(0, playlist_json_url = $$props.playlist_json_url);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [playlist_json_url, $_, updateNetwork, input_input_handler];
    }

    class SetNetworkPlaylist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SetNetworkPlaylist",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src/components/dev/DebugSwitcher.svelte generated by Svelte v3.38.1 */
    const file$Q = "src/components/dev/DebugSwitcher.svelte";

    function create_fragment$Q(ctx) {
    	let div1;
    	let h4;
    	let t1;
    	let label;
    	let input;
    	let t2;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Debug Mode";
    			t1 = space();
    			label = element("label");
    			input = element("input");
    			t2 = space();
    			div0 = element("div");
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$Q, 12, 1, 234);
    			attr_dev(input, "type", "checkbox");
    			input.checked = /*debugEnabled*/ ctx[0];
    			add_location(input, file$Q, 16, 2, 355);
    			attr_dev(div0, "class", "uk-switch-slider uk-switch-on-off round");
    			add_location(div0, file$Q, 21, 2, 452);
    			attr_dev(label, "class", "uk-switch");
    			add_location(label, file$Q, 15, 1, 327);
    			add_location(div1, file$Q, 11, 0, 227);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			append_dev(div1, t1);
    			append_dev(div1, label);
    			append_dev(label, input);
    			append_dev(label, t2);
    			append_dev(label, div0);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*debugEnabled*/ 1) {
    				prop_dev(input, "checked", /*debugEnabled*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DebugSwitcher", slots, []);
    	let debugEnabled = false;

    	onMount(async () => {
    		debugMode.subscribe(boo => $$invalidate(0, debugEnabled = boo));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DebugSwitcher> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => debugModeToggle();

    	$$self.$capture_state = () => ({
    		onMount,
    		debugMode,
    		debugModeToggle,
    		debugEnabled
    	});

    	$$self.$inject_state = $$props => {
    		if ("debugEnabled" in $$props) $$invalidate(0, debugEnabled = $$props.debugEnabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [debugEnabled, click_handler];
    }

    class DebugSwitcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugSwitcher",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src/components/layout/CardError.svelte generated by Svelte v3.38.1 */
    const file$P = "src/components/layout/CardError.svelte";
    const get_body_slot_changes$1 = dirty => ({});
    const get_body_slot_context$1 = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});

    function create_fragment$P(ctx) {
    	let main;
    	let div1;
    	let h3;
    	let t0;
    	let div0;
    	let t1;
    	let debugswitcher;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[1].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[0], get_title_slot_context$1);
    	const body_slot_template = /*#slots*/ ctx[1].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[0], get_body_slot_context$1);
    	debugswitcher = new DebugSwitcher({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			h3 = element("h3");
    			if (title_slot) title_slot.c();
    			t0 = space();
    			div0 = element("div");
    			if (body_slot) body_slot.c();
    			t1 = space();
    			create_component(debugswitcher.$$.fragment);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase");
    			add_location(h3, file$P, 5, 6, 180);
    			add_location(div0, file$P, 6, 6, 257);
    			attr_dev(div1, "class", "uk-card uk-card-secondary uk-card-hover uk-card-body uk-light ");
    			add_location(div1, file$P, 4, 4, 97);
    			add_location(main, file$P, 3, 0, 86);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, h3);

    			if (title_slot) {
    				title_slot.m(h3, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (body_slot) {
    				body_slot.m(div0, null);
    			}

    			append_dev(div1, t1);
    			mount_component(debugswitcher, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_title_slot_changes$1, get_title_slot_context$1);
    				}
    			}

    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot(body_slot, body_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_body_slot_changes$1, get_body_slot_context$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(body_slot, local);
    			transition_in(debugswitcher.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(body_slot, local);
    			transition_out(debugswitcher.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (title_slot) title_slot.d(detaching);
    			if (body_slot) body_slot.d(detaching);
    			destroy_component(debugswitcher);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardError", slots, ['title','body']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ DebugSwitcher });
    	return [$$scope, slots];
    }

    class CardError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardError",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src/components/layout/ConnectionError.svelte generated by Svelte v3.38.1 */
    const file$O = "src/components/layout/ConnectionError.svelte";

    // (9:4) 
    function create_title_slot$9(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[0]("layout.connection_error.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$O, 8, 4, 204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("layout.connection_error.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$9.name,
    		type: "slot",
    		source: "(9:4) ",
    		ctx
    	});

    	return block;
    }

    // (10:4) 
    function create_body_slot$9(ctx) {
    	let div;
    	let html_tag;
    	let raw_value = /*$_*/ ctx[0]("layout.connection_error.body") + "";
    	let t;
    	let setnetworkplaylist;
    	let current;
    	setnetworkplaylist = new SetNetworkPlaylist({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			create_component(setnetworkplaylist.$$.fragment);
    			html_tag = new HtmlTag(t);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$O, 9, 4, 272);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			html_tag.m(raw_value, div);
    			append_dev(div, t);
    			mount_component(setnetworkplaylist, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 1) && raw_value !== (raw_value = /*$_*/ ctx[0]("layout.connection_error.body") + "")) html_tag.p(raw_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(setnetworkplaylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(setnetworkplaylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(setnetworkplaylist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$9.name,
    		type: "slot",
    		source: "(10:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$9],
    					title: [create_title_slot$9]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$O, 5, 0, 178);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ConnectionError", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ConnectionError> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, SetNetworkPlaylist, CardError, $_ });
    	return [$_];
    }

    class ConnectionError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConnectionError",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/components/wallet/AccountsListSkeleton.svelte generated by Svelte v3.38.1 */
    const file$N = "src/components/wallet/AccountsListSkeleton.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (26:44) {#if obj.isSelected}
    function create_if_block$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("XX");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(26:44) {#if obj.isSelected}",
    		ctx
    	});

    	return block;
    }

    // (24:6) {#each dummyList as obj}
    function create_each_block$3(ctx) {
    	let tr;
    	let td0;
    	let span0;
    	let t0;
    	let td1;
    	let span1;
    	let t1_value = /*obj*/ ctx[2].nick + "";
    	let t1;
    	let t2;
    	let td2;
    	let span2;
    	let t3_value = /*obj*/ ctx[2].account + "";
    	let t3;
    	let t4;
    	let td3;
    	let span3;
    	let t5_value = /*obj*/ ctx[2].authkey + "";
    	let t5;
    	let t6;
    	let t7;
    	let td4;
    	let span4;
    	let t8_value = /*obj*/ ctx[2].balance + "";
    	let t8;
    	let t9;
    	let if_block = /*obj*/ ctx[2].isSelected && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			span0 = element("span");
    			if (if_block) if_block.c();
    			t0 = space();
    			td1 = element("td");
    			span1 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			td2 = element("td");
    			span2 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			span3 = element("span");
    			t5 = text(t5_value);
    			t6 = text("...");
    			t7 = space();
    			td4 = element("td");
    			span4 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			attr_dev(span0, "class", "dummy-container svelte-1adt5y8");
    			add_location(span0, file$N, 25, 14, 1141);
    			add_location(td0, file$N, 25, 10, 1137);
    			attr_dev(span1, "class", "dummy-container svelte-1adt5y8");
    			add_location(span1, file$N, 26, 14, 1225);
    			add_location(td1, file$N, 26, 10, 1221);
    			attr_dev(span2, "class", "dummy-container svelte-1adt5y8");
    			add_location(span2, file$N, 27, 14, 1292);
    			add_location(td2, file$N, 27, 10, 1288);
    			attr_dev(span3, "class", "dummy-container svelte-1adt5y8");
    			add_location(span3, file$N, 28, 14, 1362);
    			add_location(td3, file$N, 28, 10, 1358);
    			attr_dev(span4, "class", "dummy-container svelte-1adt5y8");
    			add_location(span4, file$N, 29, 36, 1457);
    			attr_dev(td4, "class", "uk-text-right");
    			add_location(td4, file$N, 29, 10, 1431);
    			add_location(tr, file$N, 24, 8, 1122);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, span0);
    			if (if_block) if_block.m(span0, null);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, span1);
    			append_dev(span1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, span2);
    			append_dev(span2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, span3);
    			append_dev(span3, t5);
    			append_dev(span3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, span4);
    			append_dev(span4, t8);
    			append_dev(tr, t9);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(24:6) {#each dummyList as obj}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let main;
    	let div;
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("wallet.wallet") + "";
    	let t0;
    	let t1;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t2;
    	let th1;
    	let span0;
    	let t3_value = /*$_*/ ctx[0]("wallet.account_list.nickname") + "";
    	let t3;
    	let t4;
    	let th2;
    	let span1;
    	let t5_value = /*$_*/ ctx[0]("wallet.account_list.address") + "";
    	let t5;
    	let t6;
    	let th3;
    	let span2;
    	let t7_value = /*$_*/ ctx[0]("wallet.account_list.authkey") + "";
    	let t7;
    	let t8;
    	let th4;
    	let span3;
    	let t9_value = /*$_*/ ctx[0]("wallet.account_list.balance") + "";
    	let t9;
    	let t10;
    	let tbody;
    	let each_value = /*dummyList*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t2 = space();
    			th1 = element("th");
    			span0 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			th2 = element("th");
    			span1 = element("span");
    			t5 = text(t5_value);
    			t6 = space();
    			th3 = element("th");
    			span2 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			th4 = element("th");
    			span3 = element("span");
    			t9 = text(t9_value);
    			t10 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$N, 10, 4, 484);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$N, 9, 2, 443);
    			add_location(th0, file$N, 15, 8, 653);
    			attr_dev(span0, "class", "dummy-container svelte-1adt5y8");
    			add_location(span0, file$N, 16, 12, 675);
    			add_location(th1, file$N, 16, 8, 671);
    			attr_dev(span1, "class", "dummy-container svelte-1adt5y8");
    			add_location(span1, file$N, 17, 12, 766);
    			add_location(th2, file$N, 17, 8, 762);
    			attr_dev(span2, "class", "dummy-container svelte-1adt5y8");
    			add_location(span2, file$N, 18, 12, 856);
    			add_location(th3, file$N, 18, 8, 852);
    			attr_dev(span3, "class", "dummy-container svelte-1adt5y8");
    			add_location(span3, file$N, 19, 34, 968);
    			attr_dev(th4, "class", "uk-text-right");
    			add_location(th4, file$N, 19, 8, 942);
    			add_location(tr, file$N, 14, 6, 640);
    			add_location(thead, file$N, 13, 4, 626);
    			add_location(tbody, file$N, 22, 4, 1075);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$N, 12, 2, 580);
    			add_location(main, file$N, 8, 0, 434);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			append_dev(main, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t2);
    			append_dev(tr, th1);
    			append_dev(th1, span0);
    			append_dev(span0, t3);
    			append_dev(tr, t4);
    			append_dev(tr, th2);
    			append_dev(th2, span1);
    			append_dev(span1, t5);
    			append_dev(tr, t6);
    			append_dev(tr, th3);
    			append_dev(th3, span2);
    			append_dev(span2, t7);
    			append_dev(tr, t8);
    			append_dev(tr, th4);
    			append_dev(th4, span3);
    			append_dev(span3, t9);
    			append_dev(table, t10);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("wallet.wallet") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t3_value !== (t3_value = /*$_*/ ctx[0]("wallet.account_list.nickname") + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*$_*/ 1 && t5_value !== (t5_value = /*$_*/ ctx[0]("wallet.account_list.address") + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*$_*/ 1 && t7_value !== (t7_value = /*$_*/ ctx[0]("wallet.account_list.authkey") + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*$_*/ 1 && t9_value !== (t9_value = /*$_*/ ctx[0]("wallet.account_list.balance") + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*dummyList*/ 2) {
    				each_value = /*dummyList*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccountsListSkeleton", slots, []);

    	const dummyList = [
    		{
    			isSelected: true,
    			nick: "999",
    			account: "00000000000000000000000000000000",
    			authkey: "00000",
    			balance: 100
    		},
    		{
    			isSelected: false,
    			nick: "999",
    			account: "00000000000000000000000000000000",
    			authkey: "00000",
    			balance: 100
    		},
    		{
    			isSelected: false,
    			nick: "999",
    			account: "00000000000000000000000000000000",
    			authkey: "00000",
    			balance: 100
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccountsListSkeleton> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, dummyList, $_ });
    	return [$_, dummyList];
    }

    class AccountsListSkeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountsListSkeleton",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src/components/wallet/Wallet.svelte generated by Svelte v3.38.1 */
    const file$M = "src/components/wallet/Wallet.svelte";

    // (62:4) {#if isRefreshing}
    function create_if_block_4$2(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			set_style(span, "position", "absolute");
    			set_style(span, "top", "0px");
    			set_style(span, "left", "0px");
    			add_location(span, file$M, 63, 8, 2851);
    			set_style(div, "position", "relative");
    			add_location(div, file$M, 62, 6, 2811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(62:4) {#if isRefreshing}",
    		ctx
    	});

    	return block;
    }

    // (68:4) {#if !isLoaded && !isRefreshing && !accountList }
    function create_if_block_3$4(ctx) {
    	let newbie;
    	let current;
    	newbie = new Newbie({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(newbie.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newbie, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newbie.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newbie.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newbie, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(68:4) {#if !isLoaded && !isRefreshing && !accountList }",
    		ctx
    	});

    	return block;
    }

    // (72:4) {#if !isLoaded && accountList && accountList.length == 0}
    function create_if_block_2$6(ctx) {
    	let newbie;
    	let current;
    	newbie = new Newbie({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(newbie.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newbie, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newbie.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newbie.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newbie, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(72:4) {#if !isLoaded && accountList && accountList.length == 0}",
    		ctx
    	});

    	return block;
    }

    // (76:4) {#if isLoaded && accountList && accountList.length > 0}
    function create_if_block$o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$b, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*isConnected*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(76:4) {#if isLoaded && accountList && accountList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (79:6) {:else}
    function create_else_block$d(ctx) {
    	let div0;
    	let h2;
    	let t0_value = /*$_*/ ctx[7]("wallet.wallet") + "";
    	let t0;
    	let t1;
    	let accountslist;
    	let t2;
    	let remindercreate;
    	let t3;
    	let div1;
    	let link0;
    	let t4;
    	let link1;
    	let current;

    	accountslist = new AccountsList({
    			props: {
    				my_account: /*my_account*/ ctx[0],
    				accountList: /*accountList*/ ctx[1],
    				isMining: /*isMining*/ ctx[3],
    				isConnected: /*isConnected*/ ctx[5]
    			},
    			$$inline: true
    		});

    	remindercreate = new ReminderCreate({
    			props: {
    				pendingAccounts: /*pendingAccounts*/ ctx[2],
    				isConnected: /*isConnected*/ ctx[5]
    			},
    			$$inline: true
    		});

    	link0 = new Link({
    			props: {
    				to: routes.keygen,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				to: routes.accountFromMnem,
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(accountslist.$$.fragment);
    			t2 = space();
    			create_component(remindercreate.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t4 = space();
    			create_component(link1.$$.fragment);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$M, 80, 10, 3294);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$M, 79, 8, 3247);
    			attr_dev(div1, "uk-grid", "");
    			attr_dev(div1, "class", "uk-flex uk-flex-center");
    			add_location(div1, file$M, 89, 8, 3565);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(accountslist, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(remindercreate, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(link0, div1, null);
    			append_dev(div1, t4);
    			mount_component(link1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 128) && t0_value !== (t0_value = /*$_*/ ctx[7]("wallet.wallet") + "")) set_data_dev(t0, t0_value);
    			const accountslist_changes = {};
    			if (dirty & /*my_account*/ 1) accountslist_changes.my_account = /*my_account*/ ctx[0];
    			if (dirty & /*accountList*/ 2) accountslist_changes.accountList = /*accountList*/ ctx[1];
    			if (dirty & /*isMining*/ 8) accountslist_changes.isMining = /*isMining*/ ctx[3];
    			if (dirty & /*isConnected*/ 32) accountslist_changes.isConnected = /*isConnected*/ ctx[5];
    			accountslist.$set(accountslist_changes);
    			const remindercreate_changes = {};
    			if (dirty & /*pendingAccounts*/ 4) remindercreate_changes.pendingAccounts = /*pendingAccounts*/ ctx[2];
    			if (dirty & /*isConnected*/ 32) remindercreate_changes.isConnected = /*isConnected*/ ctx[5];
    			remindercreate.$set(remindercreate_changes);
    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 32896) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 32896) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountslist.$$.fragment, local);
    			transition_in(remindercreate.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountslist.$$.fragment, local);
    			transition_out(remindercreate.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			destroy_component(accountslist, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(remindercreate, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(79:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (77:6) {#if !isConnected}
    function create_if_block_1$b(ctx) {
    	let connectionerror;
    	let current;
    	connectionerror = new ConnectionError({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(connectionerror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(connectionerror, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(connectionerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(connectionerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(connectionerror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(77:6) {#if !isConnected}",
    		ctx
    	});

    	return block;
    }

    // (91:10) <Link to={routes.keygen}>
    function create_default_slot_1(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[7]("wallet.btn_new_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-secondary");
    			add_location(button, file$M, 91, 12, 3658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 128 && t_value !== (t_value = /*$_*/ ctx[7]("wallet.btn_new_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(91:10) <Link to={routes.keygen}>",
    		ctx
    	});

    	return block;
    }

    // (96:10) <Link to={routes.accountFromMnem}>
    function create_default_slot$1(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[7]("wallet.btn_restore_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$M, 96, 12, 3847);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 128 && t_value !== (t_value = /*$_*/ ctx[7]("wallet.btn_restore_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(96:10) <Link to={routes.accountFromMnem}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let main;
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = /*isRefreshing*/ ctx[4] && create_if_block_4$2(ctx);
    	let if_block1 = !/*isLoaded*/ ctx[6] && !/*isRefreshing*/ ctx[4] && !/*accountList*/ ctx[1] && create_if_block_3$4(ctx);
    	let if_block2 = !/*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length == 0 && create_if_block_2$6(ctx);
    	let if_block3 = /*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length > 0 && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			add_location(div, file$M, 60, 2, 2776);
    			add_location(main, file$M, 59, 0, 2767);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isRefreshing*/ ctx[4]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*isLoaded*/ ctx[6] && !/*isRefreshing*/ ctx[4] && !/*accountList*/ ctx[1]) {
    				if (if_block1) {
    					if (dirty & /*isLoaded, isRefreshing, accountList*/ 82) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length == 0) {
    				if (if_block2) {
    					if (dirty & /*isLoaded, accountList*/ 66) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*isLoaded, accountList*/ 66) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$o(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(7, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Wallet", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	uikit.use(uikitIcons);
    	let my_account;
    	let accountList = null;
    	let pendingAccounts = [];
    	let isMining = false;
    	let isRefreshing = true;
    	let isConnected = true;
    	let isLoaded = false;
    	let unsubsConnected;
    	let unsubsAll_accounts;
    	let unsubsSigningAccount;
    	let unsubsIsAccountsLoaded;
    	let unsubsMinerLoopEnabled;
    	let unsubsIsRefreshingAccounts;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsConnected = connected.subscribe(b => $$invalidate(5, isConnected = b));

    		unsubsAll_accounts = all_accounts.subscribe(all => {
    			$$invalidate(1, accountList = all);
    			$$invalidate(2, pendingAccounts = all.filter(x => !x.on_chain));
    		});

    		unsubsSigningAccount = signingAccount.subscribe(a => $$invalidate(0, my_account = a));
    		unsubsIsAccountsLoaded = isAccountsLoaded.subscribe(boo => $$invalidate(6, isLoaded = boo));
    		unsubsMinerLoopEnabled = minerLoopEnabled.subscribe(boo => $$invalidate(3, isMining = boo));
    		unsubsIsRefreshingAccounts = isRefreshingAccounts.subscribe(boo => $$invalidate(4, isRefreshing = boo));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsConnected && unsubsConnected();
    		unsubsAll_accounts && unsubsAll_accounts();
    		unsubsSigningAccount && unsubsSigningAccount();
    		unsubsIsAccountsLoaded && unsubsIsAccountsLoaded();
    		unsubsMinerLoopEnabled && unsubsMinerLoopEnabled();
    		unsubsIsRefreshingAccounts && unsubsIsRefreshingAccounts();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Wallet> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onDestroy,
    		onMount,
    		Link,
    		isRefreshingAccounts,
    		all_accounts,
    		signingAccount,
    		isAccountsLoaded,
    		routes,
    		Newbie,
    		AccountsList,
    		ReminderCreate,
    		minerLoopEnabled,
    		UIkit: uikit,
    		Icons: uikitIcons,
    		connected,
    		ConnectionError,
    		AccountsListSkeleton,
    		my_account,
    		accountList,
    		pendingAccounts,
    		isMining,
    		isRefreshing,
    		isConnected,
    		isLoaded,
    		unsubsConnected,
    		unsubsAll_accounts,
    		unsubsSigningAccount,
    		unsubsIsAccountsLoaded,
    		unsubsMinerLoopEnabled,
    		unsubsIsRefreshingAccounts,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("my_account" in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ("accountList" in $$props) $$invalidate(1, accountList = $$props.accountList);
    		if ("pendingAccounts" in $$props) $$invalidate(2, pendingAccounts = $$props.pendingAccounts);
    		if ("isMining" in $$props) $$invalidate(3, isMining = $$props.isMining);
    		if ("isRefreshing" in $$props) $$invalidate(4, isRefreshing = $$props.isRefreshing);
    		if ("isConnected" in $$props) $$invalidate(5, isConnected = $$props.isConnected);
    		if ("isLoaded" in $$props) $$invalidate(6, isLoaded = $$props.isLoaded);
    		if ("unsubsConnected" in $$props) unsubsConnected = $$props.unsubsConnected;
    		if ("unsubsAll_accounts" in $$props) unsubsAll_accounts = $$props.unsubsAll_accounts;
    		if ("unsubsSigningAccount" in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ("unsubsIsAccountsLoaded" in $$props) unsubsIsAccountsLoaded = $$props.unsubsIsAccountsLoaded;
    		if ("unsubsMinerLoopEnabled" in $$props) unsubsMinerLoopEnabled = $$props.unsubsMinerLoopEnabled;
    		if ("unsubsIsRefreshingAccounts" in $$props) unsubsIsRefreshingAccounts = $$props.unsubsIsRefreshingAccounts;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		my_account,
    		accountList,
    		pendingAccounts,
    		isMining,
    		isRefreshing,
    		isConnected,
    		isLoaded,
    		$_
    	];
    }

    class Wallet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Wallet",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    var s,d=function(t,e){this.type="Logical",this.width=t,this.height=e;},l=function(){function t(t,e){this.type="Physical",this.width=t,this.height=e;}return t.prototype.toLogical=function(t){return new d(this.width/t,this.height/t)},t}(),c=function(t,e){this.type="Logical",this.x=t,this.y=e;},h=function(){function t(t,e){this.type="Physical",this.x=t,this.y=e;}return t.prototype.toLogical=function(t){return new c(this.x/t,this.y/t)},t}();function m(){return new v(window.__TAURI__.__currentWindow.label,{skip:!0})}function p(){return window.__TAURI__.__windows.map((function(t){return new v(t.label,{skip:!0})}))}!function(t){t[t.Critical=1]="Critical",t[t.Informational=2]="Informational";}(s||(s={}));var f=["tauri://created","tauri://error"],y=function(){function t(t){this.label=t,this.listeners=Object.create(null);}return t.prototype.listen=function(t,n){return r$2(this,void 0,void 0,(function(){var e=this;return o$1(this,(function(i){return this._handleTauriEvent(t,n)?[2,Promise.resolve((function(){var i=e.listeners[t];i.splice(i.indexOf(n),1);}))]:[2,o(t,n)]}))}))},t.prototype.once=function(t,n){return r$2(this,void 0,void 0,(function(){var e=this;return o$1(this,(function(i){return this._handleTauriEvent(t,n)?[2,Promise.resolve((function(){var i=e.listeners[t];i.splice(i.indexOf(n),1);}))]:[2,s$2(t,n)]}))}))},t.prototype.emit=function(t,n){return r$2(this,void 0,void 0,(function(){var e,o;return o$1(this,(function(i){if(f.includes(t)){for(e=0,o=this.listeners[t]||[];e<o.length;e++)(0, o[e])({event:t,id:-1,payload:n});return [2,Promise.resolve()]}return [2,r$1(t,this.label,n)]}))}))},t.prototype._handleTauriEvent=function(t,e){return !!f.includes(t)&&(t in this.listeners?this.listeners[t].push(e):this.listeners[t]=[e],!0)},t}(),g=function(n$2){function r(){return null!==n$2&&n$2.apply(this,arguments)||this}return n$1(r,n$2),r.prototype.scaleFactor=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"scaleFactor"}}}})]}))}))},r.prototype.innerPosition=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"innerPosition"}}}})]}))}))},r.prototype.outerPosition=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"outerPosition"}}}})]}))}))},r.prototype.innerSize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"innerSize"}}}})]}))}))},r.prototype.outerSize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"outerSize"}}}})]}))}))},r.prototype.isFullscreen=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isFullscreen"}}}})]}))}))},r.prototype.isMaximized=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isMaximized"}}}})]}))}))},r.prototype.isDecorated=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isDecorated"}}}})]}))}))},r.prototype.isResizable=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isResizable"}}}})]}))}))},r.prototype.isVisible=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isVisible"}}}})]}))}))},r.prototype.center=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"center"}}}})]}))}))},r.prototype.requestUserAttention=function(t){return r$2(this,void 0,void 0,(function(){var e;return o$1(this,(function(i){return e=null,t&&(e=t===s.Critical?{type:"Critical"}:{type:"Informational"}),[2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"requestUserAttention",payload:e}}}})]}))}))},r.prototype.setResizable=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setResizable",payload:t}}}})]}))}))},r.prototype.setTitle=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setTitle",payload:t}}}})]}))}))},r.prototype.maximize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"maximize"}}}})]}))}))},r.prototype.unmaximize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"unmaximize"}}}})]}))}))},r.prototype.toggleMaximize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"toggleMaximize"}}}})]}))}))},r.prototype.minimize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"minimize"}}}})]}))}))},r.prototype.unminimize=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"unminimize"}}}})]}))}))},r.prototype.show=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"show"}}}})]}))}))},r.prototype.hide=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"hide"}}}})]}))}))},r.prototype.close=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"close"}}}})]}))}))},r.prototype.setDecorations=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setDecorations",payload:t}}}})]}))}))},r.prototype.setAlwaysOnTop=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setAlwaysOnTop",payload:t}}}})]}))}))},r.prototype.setSize=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){if(!t||"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `size` argument must be either a LogicalSize or a PhysicalSize instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setSize",payload:{type:t.type,data:{width:t.width,height:t.height}}}}}})]}))}))},r.prototype.setMinSize=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){if(t&&"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `size` argument must be either a LogicalSize or a PhysicalSize instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setMinSize",payload:t?{type:t.type,data:{width:t.width,height:t.height}}:null}}}})]}))}))},r.prototype.setMaxSize=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){if(t&&"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `size` argument must be either a LogicalSize or a PhysicalSize instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setMaxSize",payload:t?{type:t.type,data:{width:t.width,height:t.height}}:null}}}})]}))}))},r.prototype.setPosition=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){if(!t||"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `position` argument must be either a LogicalPosition or a PhysicalPosition instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setPosition",payload:{type:t.type,data:{x:t.x,y:t.y}}}}}})]}))}))},r.prototype.setFullscreen=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setFullscreen",payload:t}}}})]}))}))},r.prototype.setFocus=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setFocus"}}}})]}))}))},r.prototype.setIcon=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setIcon",payload:{icon:t}}}}})]}))}))},r.prototype.setSkipTaskbar=function(t){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setSkipTaskbar",payload:t}}}})]}))}))},r.prototype.startDragging=function(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"startDragging"}}}})]}))}))},r}(y),v=function(r){function a(t,a){void 0===a&&(a={});var u=r.call(this,t)||this;return (null==a?void 0:a.skip)||n({__tauriModule:"Window",message:{cmd:"createWebview",data:{options:e({label:t},a)}}}).then((function(){return r$2(u,void 0,void 0,(function(){return o$1(this,(function(t){return [2,this.emit("tauri://created")]}))}))})).catch((function(t){return r$2(u,void 0,void 0,(function(){return o$1(this,(function(e){return [2,this.emit("tauri://error",t)]}))}))})),u}return n$1(a,r),a.getByLabel=function(t){return p().some((function(e){return e.label===t}))?new a(t,{skip:!0}):null},a}(g),b=new v(null,{skip:!0});function _(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{cmd:{type:"currentMonitor"}}}})]}))}))}function w(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{cmd:{type:"primaryMonitor"}}}})]}))}))}function M(){return r$2(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{cmd:{type:"availableMonitors"}}}})]}))}))}Object.freeze({__proto__:null,WebviewWindow:v,WebviewWindowHandle:y,WindowManager:g,getCurrent:m,getAll:p,appWindow:b,LogicalSize:d,PhysicalSize:l,LogicalPosition:c,PhysicalPosition:h,get UserAttentionType(){return s},currentMonitor:_,primaryMonitor:w,availableMonitors:M});

    const current_window = m();
    const towerOnce = async () => {
        console.log("mine tower once");
        minerEventReceived.set(false);
        minerProofComplete.set(false);
        // defaults for newbies
        let previous_duration = get_store_value(network_profile).chain_id == Networks.TESTING
            ? 5 * 1000 // Test difficulty 
            : 60 * 60 * 1000; // Default to Prod difficulty, assume 60 minutes for newbies 
        let t = get_store_value(tower);
        if (t.last_local_proof && t.last_local_proof.elapsed_secs != null) {
            previous_duration = 1 + (t.last_local_proof.elapsed_secs * 1000); // at least 1
        }
        let progress = {
            proof_in_progress: t.local_height ? t.local_height + 1 : 1,
            time_start: Date.now(),
            previous_duration,
            complete: false,
            error: false,
            time_elapsed: 0,
            pct_complete: 0,
        };
        t.progress = progress;
        tower.set(t);
        // This is a long running async call.
        // when miner_once returnsm, it's with the response of the proof, or error.
        return i$1("miner_once", {})
            .then(res => {
            console.log('miner_once proof completed' + res);
            responses.set(res);
            setProofComplete();
            // start the sending of txs
            // TODO: unsure why when it emits immediately thre is no action on rust side, perhaps listener startup.
            setTimeout(emitBacklog, 1000);
            // refresh local proofs view, also wait for file to be written
            setTimeout(getLocalHeight, 1000);
            return res;
        })
            .catch(e => {
            console.log('miner_once error: ' + e);
            // disable mining when there is a proof error.
            minerLoopEnabled.set(false);
            raise_error(e, false, "towerOnce");
            proofError();
            return false;
        });
    };
    const maybeStartMiner = async () => {
        // maybe try to start a new proof
        console.log("maybeStartMiner");
        let t = get_store_value(tower);
        let proofComplete = (t && t.progress && t.progress.complete);
        if (
        // user must have set mining switch on
        get_store_value(minerLoopEnabled) &&
            // there should be no backlog in progress
            !get_store_value(backlogInProgress) &&
            // only try to restart if a proof has completed.
            proofComplete) {
            return towerOnce();
        }
    };
    // Only the backlog service needs a listener
    const startBacklogListener = async () => {
        await i$1("start_backlog_sender_listener", {})
            .then((res) => {
            responses.set(res);
            backlogListenerReady.set(true);
            return res;
        })
            .catch((e) => raise_error(e, false, "startBacklogListener"));
    };
    // Stop listening on the rust side for new requests to mine a proof.
    const killBacklogListener = async () => {
        console.log("kill listener");
        return current_window.emit("kill-backlog-listener").then(_ => backlogListenerReady.set(false));
    };
    const emitBacklog = async () => {
        console.log("emit backlog");
        // NOTE: backlog is only in progress is rust emits ack-backlog-request
        clearDisplayErrors();
        current_window.emit('send-backlog', 'please...');
    };
    const hasProofsPending = () => {
        let t = get_store_value(tower);
        // is the user a newbie?
        // if so, any local height needs to be submitted.
        if (t.local_height && get_store_value(isTowerNewbie)) {
            return true;
        }
        // if the user has local height and has tower state
        if (t.local_height && t.on_chain && t.on_chain.verified_tower_height) {
            // only do this if there is a delta
            if ((t.local_height - t.on_chain.verified_tower_height) > 0) {
                return true;
            }
        }
        return false;
    };
    const maybeEmitBacklog = async () => {
        // only emit a backlog event, if there are any proofs pending 
        // and there is no backlog already in progress
        // and finally check that the listener has started.
        if (hasProofsPending() &&
            !get_store_value(backlogInProgress) &&
            get_store_value(backlogListenerReady)) {
            maybeEmitBacklog();
        }
    };
    const getTowerChainView = async () => {
        console.log("getTowerChainView");
        isRefreshingAccounts.set(true);
        return i$1("get_onchain_tower_state", {
            account: get_store_value(signingAccount).account
        })
            .then((res) => {
            let t = get_store_value(tower);
            t.on_chain = res;
            tower.set(t);
            responses.set(JSON.stringify(res));
            if (t.on_chain && t.on_chain.verified_tower_height) {
                isTowerNewbie.set(false);
            }
            isRefreshingAccounts.set(false);
        })
            .catch((e) => {
            //need to reset, otherwise may be looking at wrong account
            let t = get_store_value(tower);
            t.on_chain = {};
            tower.set(t);
            if (t.on_chain && !t.on_chain.verified_tower_height) {
                isTowerNewbie.set(true);
            }
            raise_error(e, true, "getTowerChainView");
            isRefreshingAccounts.set(false);
        });
    };
    // update the `tower.local_proof`
    const getLocalHeight = async () => {
        console.log("getLocalHeight");
        return i$1("get_last_local_proof", {})
            .then((res) => {
            // console.log(res);
            // if res.
            let t = get_store_value(tower);
            t.last_local_proof = res;
            t.local_height = res.height;
            tower.set(t);
            responses.set(JSON.stringify(res));
        })
            .catch((e) => {
            let t = get_store_value(tower);
            t.local_height = -1;
            tower.set(t);
            raise_error(e, true, "getLocalHeight");
        });
    };
    const getEpochRules = async () => {
        console.log("getEpochRules");
        i$1("get_epoch_rules", {})
            .then((res) => {
            // console.log(res);
            // if res.
            let t = get_store_value(tower);
            t.rules = res;
            tower.set(t);
            responses.set(JSON.stringify(res));
        })
            .catch((e) => {
            raise_error(e, true, "getEpochRules");
        });
    };
    function proofError() {
        let t = get_store_value(tower);
        t.progress.error = true;
        tower.set(t);
    }
    function setProofComplete() {
        let t = get_store_value(tower);
        t.progress.complete = true;
        tower.set(t);
        minerProofComplete.set(true);
    }
    function setProofProgres() {
        let t = get_store_value(tower);
        let done = get_store_value(minerProofComplete);
        if (t.progress && !done) {
            t.progress.time_elapsed = Date.now() - t.progress.time_start;
            t.progress.pct_complete = t.progress.time_elapsed / t.progress.previous_duration;
            tower.set(t);
        }
    }
    // submit any transactions that are in the backlog. Proofs that have been mined but for any reason were not committed.
    const submitBacklog = async () => {
        console.log('submitBacklog called');
        clearDisplayErrors();
        backlogInProgress.set(true);
        i$1("submit_backlog", {})
            .then(res => {
            backlogInProgress.set(false);
            backlogSubmitted.set(true);
            console.log('submit_backlog response: ' + res);
            responses.set(res);
            notify_success("Backlog submitted");
            return res;
        })
            .catch(e => {
            backlogInProgress.set(false);
            backlogSubmitted.set(false);
            console.log('>>> submit_backlog error: ' + e);
            raise_error(e, false, "submitBacklog");
        });
    };
    // For debugging or rescue purposes. Sometimes the user may have a proof that for some reason was not committed to the chain.
    const submitProofZero = async () => {
        backlogInProgress.set(true);
        i$1("submit_proof_zero", {})
            .then((res) => {
            console.log(res);
            responses.set(res);
            return res;
        })
            .catch((e) => {
            raise_error(e, false, "submitProofZero");
        });
    };

    let tick_in_progress = false;
    const carpeTick = async () => {
        if (!tick_in_progress) {
            console.log("carpeTick");
            tick_in_progress = true;
            // this should be instant
            await getEpochRules();
            // also should be instant
            await getLocalHeight();
            // fetch a waypoint to see if we can connect to any fullnode.
            // If successful this will set the `network.connected` bool to true. And wallet will display a view.
            if (!get_store_value(scanning_fullnodes)) { // don't try to connect while we are booting up the app and looking for fullnodes
                refreshWaypoint()
                    .then(loadAccounts)
                    .then(getTowerChainView)
                    .finally(() => {
                    maybeEmitBacklog(); // do this no matter what
                    maybeStartMiner();
                    tick_in_progress = false;
                });
            }
        }
        else {
            console.log("deduplicate tick");
        }
    };

    async function enableMining() {
        if (!get_store_value(minerLoopEnabled)) {
            minerLoopEnabled.set(true);
            // When the user turns on the toggle, they will be prompted for OS password.
            // the backlog listener prevents the user from having to re-enter the password everytime
            // a new proof needs to be submitted.
            // The backlog listener requires the OS login of the user.
            // we should only ask for this once. We ask for it when the user toggles the miner.
            // if the user has stuck proofs, we will show an error screen with a button for
            // manually triggering the backlog.
            startBacklogListener();
            // start the first iteration of the loop.
            carpeTick();
            towerOnce();
            return true;
        }
    }
    async function disableMining() {
        // stop the envent listener.
        // set mining to disabled
        minerLoopEnabled.set(false);
        killBacklogListener(); // TODO: how do we prevent zombie listeners from makeing duplicates.
        return true;
    }
    function toggleMining() {
        if (get_store_value(minerLoopEnabled)) {
            disableMining();
        }
        else {
            enableMining();
        }
    }

    /* src/components/miner/ToggleMiner.svelte generated by Svelte v3.38.1 */
    const file$L = "src/components/miner/ToggleMiner.svelte";

    function create_fragment$L(ctx) {
    	let main;
    	let div1;
    	let label;
    	let input;
    	let t;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			label = element("label");
    			input = element("input");
    			t = space();
    			div0 = element("div");
    			attr_dev(input, "type", "checkbox");
    			input.checked = /*enabled*/ ctx[0];
    			add_location(input, file$L, 21, 6, 486);
    			attr_dev(div0, "class", "uk-switch-slider uk-switch-on-off round");
    			add_location(div0, file$L, 26, 6, 598);
    			attr_dev(label, "class", "uk-switch");
    			add_location(label, file$L, 20, 4, 454);
    			attr_dev(div1, "class", "uk-text-center uk-margin");
    			set_style(div1, "position", "relative");
    			add_location(div1, file$L, 19, 2, 384);
    			add_location(main, file$L, 18, 0, 375);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, label);
    			append_dev(label, input);
    			append_dev(label, t);
    			append_dev(label, div0);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*enabled*/ 1) {
    				prop_dev(input, "checked", /*enabled*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ToggleMiner", slots, []);
    	let enabled;
    	let unsubscribe;

    	onMount(async () => {
    		unsubscribe = minerLoopEnabled.subscribe(boo => $$invalidate(0, enabled = boo));
    	});

    	onDestroy(async () => {
    		unsubscribe && unsubscribe();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToggleMiner> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => toggleMining();

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		toggleMining,
    		minerLoopEnabled,
    		enabled,
    		unsubscribe
    	});

    	$$self.$inject_state = $$props => {
    		if ("enabled" in $$props) $$invalidate(0, enabled = $$props.enabled);
    		if ("unsubscribe" in $$props) unsubscribe = $$props.unsubscribe;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [enabled, click_handler];
    }

    class ToggleMiner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToggleMiner",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src/components/miner/MinerProgress.svelte generated by Svelte v3.38.1 */
    const file$K = "src/components/miner/MinerProgress.svelte";

    // (65:6) {:else}
    function create_else_block$c(ctx) {
    	let t0_value = /*$_*/ ctx[3]("miner.miner_process.status_in_process") + "";
    	let t0;
    	let t1;
    	let t2_value = formatPercent(/*percent*/ ctx[0]) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("miner.miner_process.status_in_process") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*percent*/ 1 && t2_value !== (t2_value = formatPercent(/*percent*/ ctx[0]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(65:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (63:6) {#if proofDone }
    function create_if_block_1$a(ctx) {
    	let t_value = /*$_*/ ctx[3]("miner.miner_process.status_complete") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("miner.miner_process.status_complete") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(63:6) {#if proofDone }",
    		ctx
    	});

    	return block;
    }

    // (80:6) {#if percent > 1.01 }
    function create_if_block$n(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[3]("miner.miner_process.notes2") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$K, 80, 8, 3047);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("miner.miner_process.notes2") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(80:6) {#if percent > 1.01 }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let main;
    	let div2;
    	let div1;
    	let span0;
    	let t0;
    	let div0;
    	let raw_value = /*$_*/ ctx[3]("miner.miner_process.notes") + "";
    	let t1;
    	let progress;
    	let t2;
    	let span1;
    	let div2_class_value;

    	function select_block_type(ctx, dirty) {
    		if (/*proofDone*/ ctx[1]) return create_if_block_1$a;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*percent*/ ctx[0] > 1.01 && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div2 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			progress = element("progress");
    			t2 = space();
    			span1 = element("span");
    			if (if_block1) if_block1.c();
    			attr_dev(span0, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(span0, file$K, 61, 4, 2335);
    			attr_dev(div0, "uk-dropdown", "");
    			attr_dev(div0, "class", "uk-text-light uk-text-muted uk-text-thin");
    			add_location(div0, file$K, 71, 8, 2721);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$K, 60, 4, 2307);
    			attr_dev(progress, "id", "mining-progressbar");
    			attr_dev(progress, "class", "uk-progress");
    			progress.value = "0";
    			attr_dev(progress, "max", "1");
    			add_location(progress, file$K, 76, 4, 2871);
    			attr_dev(span1, "class", "uk-text-light uk-text-muted uk-text-thin");
    			add_location(span1, file$K, 78, 4, 2955);
    			attr_dev(div2, "class", div2_class_value = "" + ((/*enable*/ ctx[2] ? "" : "uk-invisible") + " uk-margin-top"));
    			add_location(div2, file$K, 58, 2, 2243);
    			add_location(main, file$K, 57, 0, 2234);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div2);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			if_block0.m(span0, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div2, t1);
    			append_dev(div2, progress);
    			append_dev(div2, t2);
    			append_dev(div2, span1);
    			if (if_block1) if_block1.m(span1, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span0, null);
    				}
    			}

    			if (dirty & /*$_*/ 8 && raw_value !== (raw_value = /*$_*/ ctx[3]("miner.miner_process.notes") + "")) div0.innerHTML = raw_value;
    			if (/*percent*/ ctx[0] > 1.01) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$n(ctx);
    					if_block1.c();
    					if_block1.m(span1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*enable*/ 4 && div2_class_value !== (div2_class_value = "" + ((/*enable*/ ctx[2] ? "" : "uk-invisible") + " uk-margin-top"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function formatPercent(decimal) {
    	return (decimal * 100).toFixed(0) + "%";
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(3, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MinerProgress", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { tower } = $$props;
    	let percent = 0;
    	let looper;
    	let proofDone = false;
    	let enable = false;
    	let unsubsProofComplete;
    	let unsubsLoopEnabled;

    	afterUpdate(() => {
    		// Progress bar only starts when Rust confirms it is starting the miner.
    		// Progress bar ends when:
    		// - Rust side sends event with a proof completed
    		// - Rust side send event with a failure
    		if (tower.progress && tower.progress.pct_complete) {
    			let bar = document.getElementById("mining-progressbar");
    			bar.value = $$invalidate(0, percent = tower.progress.pct_complete);
    		}
    	});

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsProofComplete = minerProofComplete.subscribe(b => {
    			$$invalidate(1, proofDone = b);

    			if (b) {
    				$$invalidate(0, percent = 1);
    			}
    		});

    		unsubsLoopEnabled = minerLoopEnabled.subscribe(b => {
    			$$invalidate(2, enable = b);

    			if (enable) {
    				// create the bar if not yet started.
    				// for safety clear the interval
    				clearInterval(looper);

    				looper = setInterval(() => setProofProgres(), 1000);
    			}
    		});
    	}));

    	onDestroy(() => {
    		clearInterval(looper);
    		unsubsProofComplete && unsubsProofComplete();
    		unsubsLoopEnabled && unsubsLoopEnabled();
    	});

    	const writable_props = ["tower"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MinerProgress> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("tower" in $$props) $$invalidate(4, tower = $$props.tower);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		_: X,
    		minerProofComplete,
    		minerLoopEnabled,
    		setProofProgres,
    		tower,
    		percent,
    		looper,
    		proofDone,
    		enable,
    		unsubsProofComplete,
    		unsubsLoopEnabled,
    		formatPercent,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("tower" in $$props) $$invalidate(4, tower = $$props.tower);
    		if ("percent" in $$props) $$invalidate(0, percent = $$props.percent);
    		if ("looper" in $$props) looper = $$props.looper;
    		if ("proofDone" in $$props) $$invalidate(1, proofDone = $$props.proofDone);
    		if ("enable" in $$props) $$invalidate(2, enable = $$props.enable);
    		if ("unsubsProofComplete" in $$props) unsubsProofComplete = $$props.unsubsProofComplete;
    		if ("unsubsLoopEnabled" in $$props) unsubsLoopEnabled = $$props.unsubsLoopEnabled;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [percent, proofDone, enable, $_, tower];
    }

    class MinerProgress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { tower: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerProgress",
    			options,
    			id: create_fragment$K.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tower*/ ctx[4] === undefined && !("tower" in props)) {
    			console.warn("<MinerProgress> was created without expected prop 'tower'");
    		}
    	}

    	get tower() {
    		throw new Error("<MinerProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tower(value) {
    		throw new Error("<MinerProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/TowerStateSkeleton.svelte generated by Svelte v3.38.1 */
    const file$J = "src/components/miner/TowerStateSkeleton.svelte";

    function create_fragment$J(ctx) {
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let span0;
    	let t0_value = /*$_*/ ctx[0]("miner.tower_state.local_height") + "";
    	let t0;
    	let t1;
    	let th1;
    	let span1;
    	let t2_value = /*$_*/ ctx[0]("miner.tower_state.on_chain_height") + "";
    	let t2;
    	let t3;
    	let th2;
    	let span2;
    	let t4_value = /*$_*/ ctx[0]("miner.tower_state.mined_in_last_epoch") + "";
    	let t4;
    	let t5;
    	let th3;
    	let span3;
    	let t6_value = /*$_*/ ctx[0]("miner.tower_state.sent_in_this_epoch") + "";
    	let t6;
    	let t7;
    	let tbody;
    	let tr1;
    	let td0;
    	let span4;
    	let t9;
    	let td1;
    	let span5;
    	let t11;
    	let td2;
    	let span6;
    	let t13;
    	let td3;
    	let span7;

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			span4 = element("span");
    			span4.textContent = "0000";
    			t9 = space();
    			td1 = element("td");
    			span5 = element("span");
    			span5.textContent = "0000";
    			t11 = space();
    			td2 = element("td");
    			span6 = element("span");
    			span6.textContent = "0000";
    			t13 = space();
    			td3 = element("td");
    			span7 = element("span");
    			span7.textContent = "0000";
    			attr_dev(span0, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span0, file$J, 6, 33, 156);
    			attr_dev(th0, "class", "uk-text-center");
    			add_location(th0, file$J, 6, 6, 129);
    			attr_dev(span1, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span1, file$J, 7, 33, 273);
    			attr_dev(th1, "class", "uk-text-center");
    			add_location(th1, file$J, 7, 6, 246);
    			attr_dev(span2, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span2, file$J, 8, 33, 393);
    			attr_dev(th2, "class", "uk-text-center");
    			add_location(th2, file$J, 8, 6, 366);
    			attr_dev(span3, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span3, file$J, 9, 33, 517);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$J, 9, 6, 490);
    			add_location(tr0, file$J, 5, 4, 118);
    			add_location(thead, file$J, 4, 2, 106);
    			attr_dev(span4, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span4, file$J, 14, 10, 680);
    			add_location(td0, file$J, 14, 6, 676);
    			attr_dev(span5, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span5, file$J, 15, 10, 740);
    			add_location(td1, file$J, 15, 6, 736);
    			attr_dev(span6, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span6, file$J, 16, 10, 800);
    			add_location(td2, file$J, 16, 6, 796);
    			attr_dev(span7, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span7, file$J, 17, 10, 860);
    			add_location(td3, file$J, 17, 6, 856);
    			attr_dev(tr1, "class", "uk-text-center");
    			add_location(tr1, file$J, 13, 4, 642);
    			add_location(tbody, file$J, 12, 2, 630);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$J, 3, 0, 62);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(th0, span0);
    			append_dev(span0, t0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(th1, span1);
    			append_dev(span1, t2);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(th2, span2);
    			append_dev(span2, t4);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(th3, span3);
    			append_dev(span3, t6);
    			append_dev(table, t7);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, span4);
    			append_dev(tr1, t9);
    			append_dev(tr1, td1);
    			append_dev(td1, span5);
    			append_dev(tr1, t11);
    			append_dev(tr1, td2);
    			append_dev(td2, span6);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(td3, span7);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("miner.tower_state.local_height") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("miner.tower_state.on_chain_height") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("miner.tower_state.mined_in_last_epoch") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("miner.tower_state.sent_in_this_epoch") + "")) set_data_dev(t6, t6_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TowerStateSkeleton", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TowerStateSkeleton> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, $_ });
    	return [$_];
    }

    class TowerStateSkeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TowerStateSkeleton",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src/components/miner/TowerState.svelte generated by Svelte v3.38.1 */
    const file$I = "src/components/miner/TowerState.svelte";

    // (60:2) {:else}
    function create_else_block_3(ctx) {
    	let towerstateskeleton;
    	let current;
    	towerstateskeleton = new TowerStateSkeleton({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(towerstateskeleton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(towerstateskeleton, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(towerstateskeleton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(towerstateskeleton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(towerstateskeleton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(60:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (7:2) {#if minerTower && minerTower.on_chain && minerTower.on_chain.previous_proof_hash}
    function create_if_block$m(ctx) {
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t0_value = /*$_*/ ctx[1]("miner.tower_state.local_height") + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*$_*/ ctx[1]("miner.tower_state.on_chain_height") + "";
    	let t2;
    	let t3;
    	let th2;
    	let t4_value = /*$_*/ ctx[1]("miner.tower_state.mined_in_last_epoch") + "";
    	let t4;
    	let t5;
    	let th3;
    	let t6_value = /*$_*/ ctx[1]("miner.tower_state.sent_in_this_epoch") + "";
    	let t6;
    	let t7;
    	let tbody;
    	let tr1;
    	let td0;
    	let t8;
    	let td1;
    	let t9_value = /*minerTower*/ ctx[0].on_chain.verified_tower_height + "";
    	let t9;
    	let t10;
    	let td2;
    	let t11_value = /*minerTower*/ ctx[0].on_chain.latest_epoch_mining + "";
    	let t11;
    	let t12;
    	let td3;
    	let div1;
    	let t13;
    	let t14_value = /*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch + "";
    	let t14;
    	let t15;
    	let div0;

    	function select_block_type_1(ctx, dirty) {
    		if (/*minerTower*/ ctx[0].local_height >= 0) return create_if_block_4$1;
    		return create_else_block_2$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch >= 8) return create_if_block_3$3;
    		return create_else_block_1$3;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch >= 72) return create_if_block_1$9;
    		if (/*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch >= 8) return create_if_block_2$5;
    		return create_else_block$b;
    	}

    	let current_block_type_2 = select_block_type_3(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			t6 = text(t6_value);
    			t7 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			if_block0.c();
    			t8 = space();
    			td1 = element("td");
    			t9 = text(t9_value);
    			t10 = space();
    			td2 = element("td");
    			t11 = text(t11_value);
    			t12 = space();
    			td3 = element("td");
    			div1 = element("div");
    			if_block1.c();
    			t13 = space();
    			t14 = text(t14_value);
    			t15 = space();
    			div0 = element("div");
    			if_block2.c();
    			attr_dev(th0, "class", "uk-text-center");
    			add_location(th0, file$I, 10, 10, 322);
    			attr_dev(th1, "class", "uk-text-center");
    			add_location(th1, file$I, 11, 10, 403);
    			attr_dev(th2, "class", "uk-text-center");
    			add_location(th2, file$I, 12, 10, 487);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$I, 13, 10, 575);
    			add_location(tr0, file$I, 9, 8, 307);
    			add_location(thead, file$I, 8, 6, 291);
    			add_location(td0, file$I, 19, 10, 788);
    			add_location(td1, file$I, 33, 10, 1153);
    			add_location(td2, file$I, 34, 10, 1216);
    			attr_dev(div0, "uk-dropdown", "");
    			add_location(div0, file$I, 43, 14, 1680);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$I, 36, 12, 1294);
    			add_location(td3, file$I, 35, 10, 1277);
    			attr_dev(tr1, "class", "uk-text-center");
    			add_location(tr1, file$I, 17, 8, 703);
    			add_location(tbody, file$I, 16, 6, 687);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$I, 7, 4, 243);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(th0, t0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(th1, t2);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(th2, t4);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(th3, t6);
    			append_dev(table, t7);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			if_block0.m(td0, null);
    			append_dev(tr1, t8);
    			append_dev(tr1, td1);
    			append_dev(td1, t9);
    			append_dev(tr1, t10);
    			append_dev(tr1, td2);
    			append_dev(td2, t11);
    			append_dev(tr1, t12);
    			append_dev(tr1, td3);
    			append_dev(td3, div1);
    			if_block1.m(div1, null);
    			append_dev(div1, t13);
    			append_dev(div1, t14);
    			append_dev(div1, t15);
    			append_dev(div1, div0);
    			if_block2.m(div0, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.tower_state.local_height") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("miner.tower_state.on_chain_height") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 2 && t4_value !== (t4_value = /*$_*/ ctx[1]("miner.tower_state.mined_in_last_epoch") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 2 && t6_value !== (t6_value = /*$_*/ ctx[1]("miner.tower_state.sent_in_this_epoch") + "")) set_data_dev(t6, t6_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(td0, null);
    				}
    			}

    			if (dirty & /*minerTower*/ 1 && t9_value !== (t9_value = /*minerTower*/ ctx[0].on_chain.verified_tower_height + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*minerTower*/ 1 && t11_value !== (t11_value = /*minerTower*/ ctx[0].on_chain.latest_epoch_mining + "")) set_data_dev(t11, t11_value);

    			if (current_block_type_1 !== (current_block_type_1 = select_block_type_2(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, t13);
    				}
    			}

    			if (dirty & /*minerTower*/ 1 && t14_value !== (t14_value = /*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch + "")) set_data_dev(t14, t14_value);

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_3(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(7:2) {#if minerTower && minerTower.on_chain && minerTower.on_chain.previous_proof_hash}",
    		ctx
    	});

    	return block;
    }

    // (23:12) {:else}
    function create_else_block_2$1(ctx) {
    	let div1;
    	let span;
    	let t0;
    	let div0;
    	let t1_value = /*$_*/ ctx[1]("miner.tower_state.empty") + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			attr_dev(span, "uk-icon", "icon: minus-circle");
    			add_location(span, file$I, 25, 14, 951);
    			attr_dev(div0, "uk-dropdown", "");
    			add_location(div0, file$I, 26, 14, 1002);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$I, 24, 12, 913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t1_value !== (t1_value = /*$_*/ ctx[1]("miner.tower_state.empty") + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(23:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:12) {#if minerTower.local_height >= 0}
    function create_if_block_4$1(ctx) {
    	let t_value = /*minerTower*/ ctx[0].local_height + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*minerTower*/ 1 && t_value !== (t_value = /*minerTower*/ ctx[0].local_height + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(21:12) {#if minerTower.local_height >= 0}",
    		ctx
    	});

    	return block;
    }

    // (40:14) {:else}
    function create_else_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-warning uk-margin");
    			attr_dev(span, "uk-icon", "icon: minus-circle");
    			add_location(span, file$I, 40, 16, 1509);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(40:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:14) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 8}
    function create_if_block_3$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-muted uk-margin");
    			attr_dev(span, "uk-icon", "icon: check");
    			add_location(span, file$I, 38, 16, 1408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(38:14) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 8}",
    		ctx
    	});

    	return block;
    }

    // (49:16) {:else}
    function create_else_block$b(ctx) {
    	let t_value = /*$_*/ ctx[1]("miner.tower_state.proof_less") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.tower_state.proof_less") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(49:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:80) 
    function create_if_block_2$5(ctx) {
    	let t_value = /*$_*/ ctx[1]("miner.tower_state.proof_ok") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.tower_state.proof_ok") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(47:80) ",
    		ctx
    	});

    	return block;
    }

    // (45:16) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 72}
    function create_if_block_1$9(ctx) {
    	let t_value = /*$_*/ ctx[1]("miner.tower_state.proof_more") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.tower_state.proof_more") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(45:16) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 72}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$m, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*minerTower*/ ctx[0] && /*minerTower*/ ctx[0].on_chain && /*minerTower*/ ctx[0].on_chain.previous_proof_hash) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if_block.c();
    			add_location(main, file$I, 5, 0, 147);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TowerState", slots, []);
    	let { minerTower } = $$props;
    	const writable_props = ["minerTower"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TowerState> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("minerTower" in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    	};

    	$$self.$capture_state = () => ({ _: X, TowerStateSkeleton, minerTower, $_ });

    	$$self.$inject_state = $$props => {
    		if ("minerTower" in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [minerTower, $_];
    }

    class TowerState extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, { minerTower: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TowerState",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*minerTower*/ ctx[0] === undefined && !("minerTower" in props)) {
    			console.warn("<TowerState> was created without expected prop 'minerTower'");
    		}
    	}

    	get minerTower() {
    		throw new Error("<TowerState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<TowerState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/MinerPhases.svelte generated by Svelte v3.38.1 */

    const file$H = "src/components/miner/MinerPhases.svelte";

    function create_fragment$H(ctx) {
    	let main;
    	let div;
    	let ul;
    	let li0;
    	let span0;
    	let span0_uk_icon_value;
    	let t0;
    	let t1_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_started") + "";
    	let t1;
    	let t2;
    	let t3;
    	let li1;
    	let span1;
    	let span1_uk_icon_value;
    	let t4;
    	let t5_value = /*$_*/ ctx[6]("miner.miner_phrases.mining_enabled") + "";
    	let t5;
    	let t6;
    	let t7;
    	let li2;
    	let span2;
    	let span2_uk_icon_value;
    	let t8;
    	let t9_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_started") + "";
    	let t9;
    	let t10;
    	let t11;
    	let li3;
    	let span3;
    	let span3_uk_icon_value;
    	let t12;
    	let t13_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_complete") + "";
    	let t13;
    	let t14;
    	let t15;
    	let li4;
    	let span4;
    	let span4_uk_icon_value;
    	let t16;
    	let t17_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_in_process") + "";
    	let t17;
    	let t18;
    	let t19;
    	let li5;
    	let span5;
    	let span5_uk_icon_value;
    	let t20;
    	let t21_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_complete") + "";
    	let t21;
    	let t22;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			span0 = element("span");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(":");
    			t3 = space();
    			li1 = element("li");
    			span1 = element("span");
    			t4 = space();
    			t5 = text(t5_value);
    			t6 = text(":");
    			t7 = space();
    			li2 = element("li");
    			span2 = element("span");
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = text(":");
    			t11 = space();
    			li3 = element("li");
    			span3 = element("span");
    			t12 = space();
    			t13 = text(t13_value);
    			t14 = text(":");
    			t15 = space();
    			li4 = element("li");
    			span4 = element("span");
    			t16 = space();
    			t17 = text(t17_value);
    			t18 = text(":");
    			t19 = space();
    			li5 = element("li");
    			span5 = element("span");
    			t20 = space();
    			t21 = text(t21_value);
    			t22 = text(":");
    			attr_dev(span0, "uk-icon", span0_uk_icon_value = /*listenerReady*/ ctx[0] ? "check" : "close");
    			add_location(span0, file$H, 49, 8, 1652);
    			add_location(li0, file$H, 48, 6, 1639);
    			attr_dev(span1, "uk-icon", span1_uk_icon_value = /*loopEnabled*/ ctx[1] ? "check" : "close");
    			add_location(span1, file$H, 54, 8, 1790);
    			add_location(li1, file$H, 53, 6, 1777);
    			attr_dev(span2, "uk-icon", span2_uk_icon_value = /*proofStarted*/ ctx[2] ? "check" : "close");
    			add_location(span2, file$H, 59, 8, 1925);
    			add_location(li2, file$H, 58, 6, 1912);
    			attr_dev(span3, "uk-icon", span3_uk_icon_value = /*isProofComplete*/ ctx[3] ? "check" : "close");
    			add_location(span3, file$H, 64, 8, 2060);
    			add_location(li3, file$H, 63, 6, 2047);
    			attr_dev(span4, "uk-icon", span4_uk_icon_value = /*isBacklogInProgress*/ ctx[4] ? "check" : "close");
    			add_location(span4, file$H, 69, 8, 2199);
    			add_location(li4, file$H, 68, 6, 2186);
    			attr_dev(span5, "uk-icon", span5_uk_icon_value = /*isBacklogComplete*/ ctx[5] ? "check" : "close");
    			add_location(span5, file$H, 74, 8, 2346);
    			add_location(li5, file$H, 73, 6, 2333);
    			attr_dev(ul, "class", "uk-list uk-list-divider");
    			add_location(ul, file$H, 47, 4, 1596);
    			attr_dev(div, "class", "uk-margin");
    			add_location(div, file$H, 46, 2, 1568);
    			add_location(main, file$H, 45, 0, 1559);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			append_dev(li0, span0);
    			append_dev(li0, t0);
    			append_dev(li0, t1);
    			append_dev(li0, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, span1);
    			append_dev(li1, t4);
    			append_dev(li1, t5);
    			append_dev(li1, t6);
    			append_dev(ul, t7);
    			append_dev(ul, li2);
    			append_dev(li2, span2);
    			append_dev(li2, t8);
    			append_dev(li2, t9);
    			append_dev(li2, t10);
    			append_dev(ul, t11);
    			append_dev(ul, li3);
    			append_dev(li3, span3);
    			append_dev(li3, t12);
    			append_dev(li3, t13);
    			append_dev(li3, t14);
    			append_dev(ul, t15);
    			append_dev(ul, li4);
    			append_dev(li4, span4);
    			append_dev(li4, t16);
    			append_dev(li4, t17);
    			append_dev(li4, t18);
    			append_dev(ul, t19);
    			append_dev(ul, li5);
    			append_dev(li5, span5);
    			append_dev(li5, t20);
    			append_dev(li5, t21);
    			append_dev(li5, t22);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*listenerReady*/ 1 && span0_uk_icon_value !== (span0_uk_icon_value = /*listenerReady*/ ctx[0] ? "check" : "close")) {
    				attr_dev(span0, "uk-icon", span0_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t1_value !== (t1_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_started") + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*loopEnabled*/ 2 && span1_uk_icon_value !== (span1_uk_icon_value = /*loopEnabled*/ ctx[1] ? "check" : "close")) {
    				attr_dev(span1, "uk-icon", span1_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t5_value !== (t5_value = /*$_*/ ctx[6]("miner.miner_phrases.mining_enabled") + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*proofStarted*/ 4 && span2_uk_icon_value !== (span2_uk_icon_value = /*proofStarted*/ ctx[2] ? "check" : "close")) {
    				attr_dev(span2, "uk-icon", span2_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t9_value !== (t9_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_started") + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*isProofComplete*/ 8 && span3_uk_icon_value !== (span3_uk_icon_value = /*isProofComplete*/ ctx[3] ? "check" : "close")) {
    				attr_dev(span3, "uk-icon", span3_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t13_value !== (t13_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_complete") + "")) set_data_dev(t13, t13_value);

    			if (dirty & /*isBacklogInProgress*/ 16 && span4_uk_icon_value !== (span4_uk_icon_value = /*isBacklogInProgress*/ ctx[4] ? "check" : "close")) {
    				attr_dev(span4, "uk-icon", span4_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t17_value !== (t17_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_in_process") + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*isBacklogComplete*/ 32 && span5_uk_icon_value !== (span5_uk_icon_value = /*isBacklogComplete*/ ctx[5] ? "check" : "close")) {
    				attr_dev(span5, "uk-icon", span5_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t21_value !== (t21_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_complete") + "")) set_data_dev(t21, t21_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(6, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MinerPhases", slots, []);
    	let listenerReady;
    	let loopEnabled;
    	let proofStarted;
    	let isProofComplete;
    	let isBacklogInProgress;
    	let isBacklogComplete;
    	let unsubsBacklogListenerReady;
    	let unsubsMinerLoopEnabled;
    	let unsubsMinerEventReceived;
    	let unsubsMinerProofComplete;
    	let unsubsBacklogInProgress;
    	let unsubsBacklogSubmitted;

    	onMount(async () => {
    		unsubsBacklogListenerReady = backlogListenerReady.subscribe(b => $$invalidate(0, listenerReady = b));
    		unsubsMinerLoopEnabled = minerLoopEnabled.subscribe(b => $$invalidate(1, loopEnabled = b));
    		unsubsMinerEventReceived = minerEventReceived.subscribe(b => $$invalidate(2, proofStarted = b));
    		unsubsMinerProofComplete = minerProofComplete.subscribe(b => $$invalidate(3, isProofComplete = b));
    		unsubsBacklogInProgress = backlogInProgress.subscribe(b => $$invalidate(4, isBacklogInProgress = b));
    		unsubsBacklogSubmitted = backlogSubmitted.subscribe(b => $$invalidate(5, isBacklogComplete = b));
    	});

    	onDestroy(async () => {
    		unsubsBacklogListenerReady && unsubsBacklogListenerReady();
    		unsubsMinerLoopEnabled && unsubsMinerLoopEnabled();
    		unsubsMinerEventReceived && unsubsMinerEventReceived();
    		unsubsMinerProofComplete && unsubsMinerProofComplete();
    		unsubsBacklogInProgress && unsubsBacklogInProgress();
    		unsubsBacklogSubmitted && unsubsBacklogSubmitted();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MinerPhases> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		_: X,
    		backlogListenerReady,
    		minerLoopEnabled,
    		minerEventReceived,
    		backlogInProgress,
    		backlogSubmitted,
    		minerProofComplete,
    		listenerReady,
    		loopEnabled,
    		proofStarted,
    		isProofComplete,
    		isBacklogInProgress,
    		isBacklogComplete,
    		unsubsBacklogListenerReady,
    		unsubsMinerLoopEnabled,
    		unsubsMinerEventReceived,
    		unsubsMinerProofComplete,
    		unsubsBacklogInProgress,
    		unsubsBacklogSubmitted,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("listenerReady" in $$props) $$invalidate(0, listenerReady = $$props.listenerReady);
    		if ("loopEnabled" in $$props) $$invalidate(1, loopEnabled = $$props.loopEnabled);
    		if ("proofStarted" in $$props) $$invalidate(2, proofStarted = $$props.proofStarted);
    		if ("isProofComplete" in $$props) $$invalidate(3, isProofComplete = $$props.isProofComplete);
    		if ("isBacklogInProgress" in $$props) $$invalidate(4, isBacklogInProgress = $$props.isBacklogInProgress);
    		if ("isBacklogComplete" in $$props) $$invalidate(5, isBacklogComplete = $$props.isBacklogComplete);
    		if ("unsubsBacklogListenerReady" in $$props) unsubsBacklogListenerReady = $$props.unsubsBacklogListenerReady;
    		if ("unsubsMinerLoopEnabled" in $$props) unsubsMinerLoopEnabled = $$props.unsubsMinerLoopEnabled;
    		if ("unsubsMinerEventReceived" in $$props) unsubsMinerEventReceived = $$props.unsubsMinerEventReceived;
    		if ("unsubsMinerProofComplete" in $$props) unsubsMinerProofComplete = $$props.unsubsMinerProofComplete;
    		if ("unsubsBacklogInProgress" in $$props) unsubsBacklogInProgress = $$props.unsubsBacklogInProgress;
    		if ("unsubsBacklogSubmitted" in $$props) unsubsBacklogSubmitted = $$props.unsubsBacklogSubmitted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		listenerReady,
    		loopEnabled,
    		proofStarted,
    		isProofComplete,
    		isBacklogInProgress,
    		isBacklogComplete,
    		$_
    	];
    }

    class MinerPhases extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerPhases",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/components/miner/MinerDebug.svelte generated by Svelte v3.38.1 */
    const file$G = "src/components/miner/MinerDebug.svelte";

    // (26:0) {#if debug}
    function create_if_block$l(ctx) {
    	let main;
    	let div7;
    	let div5;
    	let div0;
    	let button0;
    	let t1;
    	let div1;
    	let button1;
    	let t3;
    	let div2;
    	let button2;
    	let t5;
    	let div3;
    	let button3;
    	let t7;
    	let div4;
    	let button4;
    	let t9;
    	let div6;
    	let minerphases;
    	let t10;
    	let current;
    	let mounted;
    	let dispose;
    	minerphases = new MinerPhases({ $$inline: true });
    	let if_block = /*minerTower*/ ctx[0] && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div7 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Start Tower";
    			t1 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Start Backlog Listener";
    			t3 = space();
    			div2 = element("div");
    			button2 = element("button");
    			button2.textContent = "Kill Listener";
    			t5 = space();
    			div3 = element("div");
    			button3 = element("button");
    			button3.textContent = "Emit Backlog Event";
    			t7 = space();
    			div4 = element("div");
    			button4 = element("button");
    			button4.textContent = "Resend Proof Zero";
    			t9 = space();
    			div6 = element("div");
    			create_component(minerphases.$$.fragment);
    			t10 = space();
    			if (if_block) if_block.c();
    			attr_dev(button0, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button0, file$G, 30, 10, 1390);
    			attr_dev(div0, "class", "uk-margin");
    			add_location(div0, file$G, 29, 8, 1356);
    			attr_dev(button1, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button1, file$G, 36, 10, 1571);
    			attr_dev(div1, "class", "uk-margin");
    			add_location(div1, file$G, 35, 8, 1537);
    			attr_dev(button2, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button2, file$G, 43, 10, 1793);
    			attr_dev(div2, "class", "uk-margin");
    			add_location(div2, file$G, 42, 8, 1759);
    			attr_dev(button3, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button3, file$G, 50, 10, 1997);
    			attr_dev(div3, "class", "uk-margin");
    			add_location(div3, file$G, 49, 8, 1963);
    			attr_dev(button4, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button4, file$G, 57, 10, 2198);
    			attr_dev(div4, "class", "uk-margin");
    			add_location(div4, file$G, 56, 8, 2164);
    			attr_dev(div5, "class", "uk-width-1-2");
    			add_location(div5, file$G, 28, 6, 1321);
    			attr_dev(div6, "class", "uk-width-1-2");
    			add_location(div6, file$G, 66, 6, 2403);
    			attr_dev(div7, "class", "uk-grid");
    			add_location(div7, file$G, 27, 4, 1293);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$G, 26, 2, 1264);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div0);
    			append_dev(div0, button0);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div1, button1);
    			append_dev(div5, t3);
    			append_dev(div5, div2);
    			append_dev(div2, button2);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div3, button3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button4);
    			append_dev(div7, t9);
    			append_dev(div7, div6);
    			mount_component(minerphases, div6, null);
    			append_dev(main, t10);
    			if (if_block) if_block.m(main, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", towerOnce, false, false, false),
    					listen_dev(button1, "click", startBacklogListener, false, false, false),
    					listen_dev(button2, "click", killBacklogListener, false, false, false),
    					listen_dev(button3, "click", emitBacklog, false, false, false),
    					listen_dev(button4, "click", submitProofZero, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*minerTower*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(minerphases.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(minerphases.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(minerphases);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(26:0) {#if debug}",
    		ctx
    	});

    	return block;
    }

    // (72:4) {#if minerTower}
    function create_if_block_1$8(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*minerTower*/ ctx[0].on_chain.previous_proof_hash + "";
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Latest on-chain proof hash: ");
    			t1 = text(t1_value);
    			add_location(p, file$G, 72, 6, 2506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*minerTower*/ 1 && t1_value !== (t1_value = /*minerTower*/ ctx[0].on_chain.previous_proof_hash + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(72:4) {#if minerTower}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*debug*/ ctx[1] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*debug*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*debug*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MinerDebug", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let { minerTower } = $$props;
    	let debug;
    	let unsubsDebug;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsDebug = debugMode.subscribe(boo => $$invalidate(1, debug = boo));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsDebug && unsubsDebug();
    	}));

    	const writable_props = ["minerTower"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MinerDebug> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("minerTower" in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		emitBacklog,
    		killBacklogListener,
    		startBacklogListener,
    		submitProofZero,
    		towerOnce,
    		debugMode,
    		onMount,
    		onDestroy,
    		MinerPhases,
    		minerTower,
    		debug,
    		unsubsDebug
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("minerTower" in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    		if ("debug" in $$props) $$invalidate(1, debug = $$props.debug);
    		if ("unsubsDebug" in $$props) unsubsDebug = $$props.unsubsDebug;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [minerTower, debug];
    }

    class MinerDebug extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { minerTower: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerDebug",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*minerTower*/ ctx[0] === undefined && !("minerTower" in props)) {
    			console.warn("<MinerDebug> was created without expected prop 'minerTower'");
    		}
    	}

    	get minerTower() {
    		throw new Error("<MinerDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<MinerDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/layout/CardAlert.svelte generated by Svelte v3.38.1 */

    const file$F = "src/components/layout/CardAlert.svelte";
    const get_body_slot_changes = dirty => ({});
    const get_body_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});

    function create_fragment$F(ctx) {
    	let main;
    	let div1;
    	let h4;
    	let t;
    	let div0;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[1].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[0], get_title_slot_context);
    	const body_slot_template = /*#slots*/ ctx[1].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[0], get_body_slot_context);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			h4 = element("h4");
    			if (title_slot) title_slot.c();
    			t = space();
    			div0 = element("div");
    			if (body_slot) body_slot.c();
    			attr_dev(h4, "class", "uk-card-title uk-text-uppercase");
    			add_location(h4, file$F, 4, 6, 120);
    			add_location(div0, file$F, 5, 6, 197);
    			attr_dev(div1, "class", "uk-card uk-card-primary uk-card-hover uk-card-body uk-light");
    			add_location(div1, file$F, 3, 4, 40);
    			add_location(main, file$F, 2, 0, 29);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, h4);

    			if (title_slot) {
    				title_slot.m(h4, null);
    			}

    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (body_slot) {
    				body_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_title_slot_changes, get_title_slot_context);
    				}
    			}

    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot(body_slot, body_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_body_slot_changes, get_body_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(body_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(body_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (title_slot) title_slot.d(detaching);
    			if (body_slot) body_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardAlert", slots, ['title','body']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CardAlert> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class CardAlert extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardAlert",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src/components/miner/cards/CantStart.svelte generated by Svelte v3.38.1 */
    const file$E = "src/components/miner/cards/CantStart.svelte";

    // (7:4) 
    function create_title_slot$8(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[0]("miner.cards.cant_start.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$E, 6, 4, 142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("miner.cards.cant_start.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$8.name,
    		type: "slot",
    		source: "(7:4) ",
    		ctx
    	});

    	return block;
    }

    // (8:4) 
    function create_body_slot$8(ctx) {
    	let div;
    	let p;
    	let t_value = /*$_*/ ctx[0]("miner.cards.cant_start.body") + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$E, 8, 6, 234);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$E, 7, 4, 210);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("miner.cards.cant_start.body") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$8.name,
    		type: "slot",
    		source: "(8:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let main;
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot$8],
    					title: [create_title_slot$8]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(cardalert.$$.fragment);
    			add_location(main, file$E, 4, 0, 117);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(cardalert, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(cardalert);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CantStart", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CantStart> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, CardAlert, $_ });
    	return [$_];
    }

    class CantStart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CantStart",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/components/miner/cards/FirstProof.svelte generated by Svelte v3.38.1 */
    const file$D = "src/components/miner/cards/FirstProof.svelte";

    // (25:2) 
    function create_title_slot$7(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.first_proof.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$D, 24, 2, 1210);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.first_proof.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$7.name,
    		type: "slot",
    		source: "(25:2) ",
    		ctx
    	});

    	return block;
    }

    // (29:4) {:else}
    function create_else_block$a(ctx) {
    	let p;
    	let t_value = /*$_*/ ctx[1]("miner.cards.first_proof.body_disabled") + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$D, 29, 6, 1379);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.first_proof.body_disabled") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(29:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (27:4) {#if enabled}
    function create_if_block$k(ctx) {
    	let html_tag;
    	let raw_value = /*$_*/ ctx[1]("miner.cards.first_proof.body") + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && raw_value !== (raw_value = /*$_*/ ctx[1]("miner.cards.first_proof.body") + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(27:4) {#if enabled}",
    		ctx
    	});

    	return block;
    }

    // (26:2) 
    function create_body_slot$7(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*enabled*/ ctx[0]) return create_if_block$k;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "slot", "body");
    			add_location(div, file$D, 25, 2, 1276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$7.name,
    		type: "slot",
    		source: "(26:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot$7],
    					title: [create_title_slot$7]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardalert.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardalert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_, enabled*/ 19) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardalert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FirstProof", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let enabled = false;
    	let unsubsLoopEnabled;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsLoopEnabled = minerLoopEnabled.subscribe(boo => $$invalidate(0, enabled = boo));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsLoopEnabled && unsubsLoopEnabled();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FirstProof> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		onDestroy,
    		CardAlert,
    		minerLoopEnabled,
    		_: X,
    		enabled,
    		unsubsLoopEnabled,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("enabled" in $$props) $$invalidate(0, enabled = $$props.enabled);
    		if ("unsubsLoopEnabled" in $$props) unsubsLoopEnabled = $$props.unsubsLoopEnabled;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [enabled, $_];
    }

    class FirstProof extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FirstProof",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src/components/miner/MinerBacklog.svelte generated by Svelte v3.38.1 */
    const file$C = "src/components/miner/MinerBacklog.svelte";

    // (35:6) {:else}
    function create_else_block$9(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[1]("miner.miner_backlog.btn_submit") + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$C, 35, 8, 1541);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.miner_backlog.btn_submit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(35:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (33:6) {#if inProgress}
    function create_if_block$j(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[1]("miner.miner_backlog.in_process") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button");
    			button.disabled = true;
    			add_location(button, file$C, 33, 8, 1436);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.miner_backlog.in_process") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(33:6) {#if inProgress}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[1]("miner.miner_backlog.title") + "";
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let p;
    	let t2_value = /*$_*/ ctx[1]("miner.miner_backlog.subtitle") + "";
    	let t2;
    	let t3;

    	function select_block_type(ctx, dirty) {
    		if (/*inProgress*/ ctx[0]) return create_if_block$j;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			if_block.c();
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$C, 24, 2, 1177);
    			add_location(p, file$C, 29, 6, 1345);
    			add_location(div0, file$C, 28, 4, 1333);
    			attr_dev(div1, "class", "uk-margin uk-grid");
    			add_location(div1, file$C, 27, 2, 1297);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$C, 23, 0, 1150);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t2);
    			append_dev(div0, t3);
    			if_block.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.miner_backlog.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("miner.miner_backlog.subtitle") + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MinerBacklog", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let unsubs;
    	let inProgress = false;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = backlogInProgress.subscribe(b => $$invalidate(0, inProgress = b));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MinerBacklog> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => submitBacklog();

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onMount,
    		onDestroy,
    		submitBacklog,
    		backlogInProgress,
    		unsubs,
    		inProgress,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    		if ("inProgress" in $$props) $$invalidate(0, inProgress = $$props.inProgress);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [inProgress, $_, click_handler];
    }

    class MinerBacklog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerBacklog",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* src/components/miner/cards/SyncProofsError.svelte generated by Svelte v3.38.1 */
    const file$B = "src/components/miner/cards/SyncProofsError.svelte";

    // (13:4) 
    function create_title_slot$6(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*delta*/ ctx[0]);
    			t1 = text(" proofs missing");
    			attr_dev(span, "slot", "title");
    			add_location(span, file$B, 12, 4, 337);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*delta*/ 1) set_data_dev(t0, /*delta*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$6.name,
    		type: "slot",
    		source: "(13:4) ",
    		ctx
    	});

    	return block;
    }

    // (14:4) 
    function create_body_slot$6(ctx) {
    	let div;
    	let minerbacklog;
    	let current;
    	minerbacklog = new MinerBacklog({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(minerbacklog.$$.fragment);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$B, 13, 4, 392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(minerbacklog, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(minerbacklog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(minerbacklog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(minerbacklog);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$6.name,
    		type: "slot",
    		source: "(14:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$6],
    					title: [create_title_slot$6]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$B, 10, 0, 312);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, delta*/ 5) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SyncProofsError", slots, []);
    	let { minerTower } = $$props;
    	let delta;

    	afterUpdate(() => {
    		$$invalidate(0, delta = minerTower.local_height - minerTower.on_chain.verified_tower_height);
    	});

    	const writable_props = ["minerTower"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SyncProofsError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("minerTower" in $$props) $$invalidate(1, minerTower = $$props.minerTower);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		MinerBacklog,
    		CardError,
    		minerTower,
    		delta
    	});

    	$$self.$inject_state = $$props => {
    		if ("minerTower" in $$props) $$invalidate(1, minerTower = $$props.minerTower);
    		if ("delta" in $$props) $$invalidate(0, delta = $$props.delta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [delta, minerTower];
    }

    class SyncProofsError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { minerTower: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SyncProofsError",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*minerTower*/ ctx[1] === undefined && !("minerTower" in props)) {
    			console.warn("<SyncProofsError> was created without expected prop 'minerTower'");
    		}
    	}

    	get minerTower() {
    		throw new Error("<SyncProofsError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<SyncProofsError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/cards/SyncProofs.svelte generated by Svelte v3.38.1 */
    const file$A = "src/components/miner/cards/SyncProofs.svelte";

    // (51:43) 
    function create_if_block_3$2(ctx) {
    	let syncproofserror;
    	let current;

    	syncproofserror = new SyncProofsError({
    			props: { minerTower: /*minerTower*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(syncproofserror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(syncproofserror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const syncproofserror_changes = {};
    			if (dirty & /*minerTower*/ 1) syncproofserror_changes.minerTower = /*minerTower*/ ctx[0];
    			syncproofserror.$set(syncproofserror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(syncproofserror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(syncproofserror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(syncproofserror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(51:43) ",
    		ctx
    	});

    	return block;
    }

    // (32:2) {#if listenerReady}
    function create_if_block$i(ctx) {
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot$5],
    					title: [create_title_slot$5]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardalert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardalert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_, delta*/ 148) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardalert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(32:2) {#if listenerReady}",
    		ctx
    	});

    	return block;
    }

    // (34:6) 
    function create_title_slot$5(ctx) {
    	let span1;
    	let t0_value = /*$_*/ ctx[4]("miner.cards.sync_proof.title") + "";
    	let t0;
    	let t1;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span0 = element("span");
    			attr_dev(span0, "class", "uk-margin");
    			attr_dev(span0, "uk-spinner", "ratio: 0.5");
    			add_location(span0, file$A, 35, 8, 1595);
    			attr_dev(span1, "slot", "title");
    			attr_dev(span1, "class", "uk-text-uppercase");
    			add_location(span1, file$A, 33, 6, 1495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t0);
    			append_dev(span1, t1);
    			append_dev(span1, span0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("miner.cards.sync_proof.title") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$5.name,
    		type: "slot",
    		source: "(34:6) ",
    		ctx
    	});

    	return block;
    }

    // (44:28) 
    function create_if_block_2$4(ctx) {
    	let p;
    	let t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body_0") + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "uk-text-muted uk-text-uppercase");
    			add_location(p, file$A, 44, 10, 1945);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body_0") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(44:28) ",
    		ctx
    	});

    	return block;
    }

    // (40:8) {#if delta > 0 }
    function create_if_block_1$7(ctx) {
    	let p;
    	let t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body", { values: { delta: /*delta*/ ctx[2] } }) + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "uk-text-muted uk-text-uppercase");
    			add_location(p, file$A, 40, 10, 1778);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, delta*/ 20 && t_value !== (t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body", { values: { delta: /*delta*/ ctx[2] } }) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(40:8) {#if delta > 0 }",
    		ctx
    	});

    	return block;
    }

    // (38:6) 
    function create_body_slot$5(ctx) {
    	let div;

    	function select_block_type_1(ctx, dirty) {
    		if (/*delta*/ ctx[2] > 0) return create_if_block_1$7;
    		if (/*delta*/ ctx[2] < 0) return create_if_block_2$4;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "slot", "body");
    			add_location(div, file$A, 37, 6, 1666);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$5.name,
    		type: "slot",
    		source: "(38:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$i, create_if_block_3$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*listenerReady*/ ctx[3]) return 0;
    		if (!/*loading*/ ctx[1] && /*delta*/ ctx[2] && /*delta*/ ctx[2] > 0) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$A, 30, 0, 1444);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SyncProofs", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { minerTower } = $$props;
    	let { loading = true } = $$props;
    	let delta = null;
    	let listenerReady = false;
    	let unsubsListener;

    	afterUpdate(() => {
    		$$invalidate(2, delta = minerTower.local_height - minerTower.on_chain.verified_tower_height);
    	});

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsListener = backlogListenerReady.subscribe(b => $$invalidate(3, listenerReady = b));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsListener && unsubsListener();
    	}));

    	const writable_props = ["minerTower", "loading"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SyncProofs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("minerTower" in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    		if ("loading" in $$props) $$invalidate(1, loading = $$props.loading);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onDestroy,
    		onMount,
    		afterUpdate,
    		backlogListenerReady,
    		CardAlert,
    		SyncProofsError,
    		minerTower,
    		loading,
    		delta,
    		listenerReady,
    		unsubsListener,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("minerTower" in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    		if ("loading" in $$props) $$invalidate(1, loading = $$props.loading);
    		if ("delta" in $$props) $$invalidate(2, delta = $$props.delta);
    		if ("listenerReady" in $$props) $$invalidate(3, listenerReady = $$props.listenerReady);
    		if ("unsubsListener" in $$props) unsubsListener = $$props.unsubsListener;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [minerTower, loading, delta, listenerReady, $_];
    }

    class SyncProofs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { minerTower: 0, loading: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SyncProofs",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*minerTower*/ ctx[0] === undefined && !("minerTower" in props)) {
    			console.warn("<SyncProofs> was created without expected prop 'minerTower'");
    		}
    	}

    	get minerTower() {
    		throw new Error("<SyncProofs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<SyncProofs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<SyncProofs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<SyncProofs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/layout/ErrorAccordion.svelte generated by Svelte v3.38.1 */
    const file$z = "src/components/layout/ErrorAccordion.svelte";

    function create_fragment$z(ctx) {
    	let main;
    	let ul;
    	let li;
    	let a;
    	let t0_value = /*$_*/ ctx[1]("layout.error_accordion.title") + "";
    	let t0;
    	let t1;
    	let div;
    	let p0;
    	let t2_value = /*$_*/ ctx[1]("layout.error_accordion.category") + "";
    	let t2;
    	let t3;
    	let t4_value = /*error*/ ctx[0].category + "";
    	let t4;
    	let t5;
    	let p1;
    	let t6_value = /*$_*/ ctx[1]("layout.error_accordion.id") + "";
    	let t6;
    	let t7;
    	let t8_value = /*error*/ ctx[0].uid + "";
    	let t8;
    	let t9;
    	let p2;
    	let t10_value = /*error*/ ctx[0].msg + "";
    	let t10;

    	const block = {
    		c: function create() {
    			main = element("main");
    			ul = element("ul");
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = text(" - ");
    			t4 = text(t4_value);
    			t5 = space();
    			p1 = element("p");
    			t6 = text(t6_value);
    			t7 = text(" - ");
    			t8 = text(t8_value);
    			t9 = space();
    			p2 = element("p");
    			t10 = text(t10_value);
    			attr_dev(a, "class", "uk-accordion-title");
    			attr_dev(a, "href", "#");
    			add_location(a, file$z, 8, 6, 124);
    			add_location(p0, file$z, 11, 8, 256);
    			add_location(p1, file$z, 12, 8, 330);
    			add_location(p2, file$z, 13, 8, 393);
    			attr_dev(div, "class", "uk-accordion-content");
    			add_location(div, file$z, 10, 6, 213);
    			add_location(li, file$z, 7, 4, 113);
    			attr_dev(ul, "uk-accordion", "");
    			add_location(ul, file$z, 6, 2, 91);
    			add_location(main, file$z, 5, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, ul);
    			append_dev(ul, li);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    			append_dev(li, div);
    			append_dev(div, p0);
    			append_dev(p0, t2);
    			append_dev(p0, t3);
    			append_dev(p0, t4);
    			append_dev(div, t5);
    			append_dev(div, p1);
    			append_dev(p1, t6);
    			append_dev(p1, t7);
    			append_dev(p1, t8);
    			append_dev(div, t9);
    			append_dev(div, p2);
    			append_dev(p2, t10);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("layout.error_accordion.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("layout.error_accordion.category") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*error*/ 1 && t4_value !== (t4_value = /*error*/ ctx[0].category + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 2 && t6_value !== (t6_value = /*$_*/ ctx[1]("layout.error_accordion.id") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*error*/ 1 && t8_value !== (t8_value = /*error*/ ctx[0].uid + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*error*/ 1 && t10_value !== (t10_value = /*error*/ ctx[0].msg + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ErrorAccordion", slots, []);
    	
    	let { error } = $$props;
    	const writable_props = ["error"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ErrorAccordion> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("error" in $$props) $$invalidate(0, error = $$props.error);
    	};

    	$$self.$capture_state = () => ({ _: X, error, $_ });

    	$$self.$inject_state = $$props => {
    		if ("error" in $$props) $$invalidate(0, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [error, $_];
    }

    class ErrorAccordion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { error: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ErrorAccordion",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*error*/ ctx[0] === undefined && !("error" in props)) {
    			console.warn("<ErrorAccordion> was created without expected prop 'error'");
    		}
    	}

    	get error() {
    		throw new Error("<ErrorAccordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<ErrorAccordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/cards/DiscoError.svelte generated by Svelte v3.38.1 */
    const file$y = "src/components/miner/cards/DiscoError.svelte";

    // (29:0) {#if display}
    function create_if_block$h(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$4],
    					title: [create_title_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$y, 29, 2, 1290);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 19) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(29:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (32:6) 
    function create_title_slot$4(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.disco_error.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$y, 31, 6, 1319);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.disco_error.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$4.name,
    		type: "slot",
    		source: "(32:6) ",
    		ctx
    	});

    	return block;
    }

    // (33:6) 
    function create_body_slot$4(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.disco_error.body") + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$y, 33, 8, 1416);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$y, 32, 6, 1390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.disco_error.body") + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$4.name,
    		type: "slot",
    		source: "(33:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DiscoError", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let display = null;
    	let unsubs;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = displayDiscontinuity.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DiscoError> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onDestroy,
    		onMount,
    		ErrorAccordion,
    		CardError,
    		displayDiscontinuity,
    		_: X,
    		display,
    		unsubs,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("display" in $$props) $$invalidate(0, display = $$props.display);
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_];
    }

    class DiscoError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DiscoError",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src/components/miner/cards/InvalidProof.svelte generated by Svelte v3.38.1 */
    const file$x = "src/components/miner/cards/InvalidProof.svelte";

    // (28:0) {#if display}
    function create_if_block$g(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$3],
    					title: [create_title_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$x, 28, 2, 1287);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 19) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(28:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (31:6) 
    function create_title_slot$3(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$x, 30, 6, 1316);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$3.name,
    		type: "slot",
    		source: "(31:6) ",
    		ctx
    	});

    	return block;
    }

    // (32:6) 
    function create_body_slot$3(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.body") + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$x, 32, 8, 1414);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$x, 31, 6, 1388);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.body") + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$3.name,
    		type: "slot",
    		source: "(32:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InvalidProof", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let display = null;
    	let unsubs;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = displayInvalidProof.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InvalidProof> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		onDestroy,
    		ErrorAccordion,
    		CardError,
    		displayInvalidProof,
    		_: X,
    		display,
    		unsubs,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("display" in $$props) $$invalidate(0, display = $$props.display);
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_];
    }

    class InvalidProof extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InvalidProof",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src/components/miner/cards/TooManyProofs.svelte generated by Svelte v3.38.1 */
    const file$w = "src/components/miner/cards/TooManyProofs.svelte";

    // (29:0) {#if display}
    function create_if_block$f(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$2],
    					title: [create_title_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$w, 29, 2, 1349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 35) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(29:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (32:6) 
    function create_title_slot$2(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$w, 31, 6, 1378);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$2.name,
    		type: "slot",
    		source: "(32:6) ",
    		ctx
    	});

    	return block;
    }

    // (33:6) 
    function create_body_slot$2(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.body", { values: { maxNum: /*maxNum*/ ctx[2] } }) + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$w, 33, 8, 1478);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$w, 32, 6, 1452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.body", { values: { maxNum: /*maxNum*/ ctx[2] } }) + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$2.name,
    		type: "slot",
    		source: "(33:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TooManyProofs", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let unsubs;
    	let display = null;
    	let maxNum = 72; // TODO: this someday needs to be dynamic.

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = displayTooManyProofs.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TooManyProofs> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onMount,
    		onDestroy,
    		ErrorAccordion,
    		CardError,
    		displayTooManyProofs,
    		unsubs,
    		display,
    		maxNum,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    		if ("display" in $$props) $$invalidate(0, display = $$props.display);
    		if ("maxNum" in $$props) $$invalidate(2, maxNum = $$props.maxNum);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_, maxNum];
    }

    class TooManyProofs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TooManyProofs",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/components/miner/cards/WrongDifficulty.svelte generated by Svelte v3.38.1 */
    const file$v = "src/components/miner/cards/WrongDifficulty.svelte";

    // (28:0) {#if display}
    function create_if_block$e(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$1],
    					title: [create_title_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$v, 28, 2, 1293);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 19) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(28:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (31:6) 
    function create_title_slot$1(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$v, 30, 6, 1322);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$1.name,
    		type: "slot",
    		source: "(31:6) ",
    		ctx
    	});

    	return block;
    }

    // (32:6) 
    function create_body_slot$1(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.body") + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$v, 32, 8, 1423);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$v, 31, 6, 1397);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.body") + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$1.name,
    		type: "slot",
    		source: "(32:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WrongDifficulty", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let unsubs;
    	let display = null;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = displayWrongDifficulty.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WrongDifficulty> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onMount,
    		onDestroy,
    		ErrorAccordion,
    		CardError,
    		displayWrongDifficulty,
    		unsubs,
    		display,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    		if ("display" in $$props) $$invalidate(0, display = $$props.display);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_];
    }

    class WrongDifficulty extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WrongDifficulty",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src/components/miner/CommonErrors.svelte generated by Svelte v3.38.1 */
    const file$u = "src/components/miner/CommonErrors.svelte";

    function create_fragment$u(ctx) {
    	let main;
    	let div;
    	let wrongdifficulty;
    	let t0;
    	let toomanyproofs;
    	let t1;
    	let invalidproof;
    	let t2;
    	let discoerror;
    	let current;
    	wrongdifficulty = new WrongDifficulty({ $$inline: true });
    	toomanyproofs = new TooManyProofs({ $$inline: true });
    	invalidproof = new InvalidProof({ $$inline: true });
    	discoerror = new DiscoError({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			create_component(wrongdifficulty.$$.fragment);
    			t0 = space();
    			create_component(toomanyproofs.$$.fragment);
    			t1 = space();
    			create_component(invalidproof.$$.fragment);
    			t2 = space();
    			create_component(discoerror.$$.fragment);
    			attr_dev(div, "class", "uk-grid uk-child-width-expand");
    			add_location(div, file$u, 7, 2, 284);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$u, 6, 0, 257);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			mount_component(wrongdifficulty, div, null);
    			append_dev(div, t0);
    			mount_component(toomanyproofs, div, null);
    			append_dev(div, t1);
    			mount_component(invalidproof, div, null);
    			append_dev(div, t2);
    			mount_component(discoerror, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wrongdifficulty.$$.fragment, local);
    			transition_in(toomanyproofs.$$.fragment, local);
    			transition_in(invalidproof.$$.fragment, local);
    			transition_in(discoerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wrongdifficulty.$$.fragment, local);
    			transition_out(toomanyproofs.$$.fragment, local);
    			transition_out(invalidproof.$$.fragment, local);
    			transition_out(discoerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(wrongdifficulty);
    			destroy_component(toomanyproofs);
    			destroy_component(invalidproof);
    			destroy_component(discoerror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CommonErrors", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CommonErrors> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		DiscoError,
    		InvalidProof,
    		TooManyProofs,
    		WrongDifficulty
    	});

    	return [];
    }

    class CommonErrors extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CommonErrors",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src/components/miner/cards/EpochStatus.svelte generated by Svelte v3.38.1 */
    const file$t = "src/components/miner/cards/EpochStatus.svelte";

    // (37:6) {:else}
    function create_else_block$8(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 37, 6, 1380);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 38, 6, 1513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(37:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (31:23) 
    function create_if_block_2$3(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 32, 6, 1129);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 33, 6, 1257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(31:23) ",
    		ctx
    	});

    	return block;
    }

    // (25:33) 
    function create_if_block_1$6(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 25, 6, 803);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 26, 6, 934);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(25:33) ",
    		ctx
    	});

    	return block;
    }

    // (20:4) {#if actual_proofs >= 72}
    function create_if_block$d(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 20, 6, 530);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 21, 6, 659);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(20:4) {#if actual_proofs >= 72}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let main;
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*actual_proofs*/ ctx[0] >= 72) return create_if_block$d;
    		if (/*actual_proofs*/ ctx[0] >= 8) return create_if_block_1$6;
    		if (/*newbie*/ ctx[1]) return create_if_block_2$3;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "uk-card uk-card-default uk-card-body");
    			add_location(div, file$t, 18, 2, 443);
    			add_location(main, file$t, 17, 0, 434);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EpochStatus", slots, []);
    	let actual_proofs;
    	let newbie = false;

    	onMount(() => {
    		tower.subscribe(t => {
    			if (t && t.on_chain) {
    				$$invalidate(0, actual_proofs = t.on_chain.actual_count_proofs_in_epoch);
    			}

    			isTowerNewbie.subscribe(n => {
    				$$invalidate(1, newbie = n);
    			});
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EpochStatus> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: X,
    		onMount,
    		isTowerNewbie,
    		tower,
    		actual_proofs,
    		newbie,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("actual_proofs" in $$props) $$invalidate(0, actual_proofs = $$props.actual_proofs);
    		if ("newbie" in $$props) $$invalidate(1, newbie = $$props.newbie);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actual_proofs, newbie, $_];
    }

    class EpochStatus extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EpochStatus",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src/components/miner/Miner.svelte generated by Svelte v3.38.1 */
    const file$s = "src/components/miner/Miner.svelte";

    // (66:2) {#if loading}
    function create_if_block_5(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			set_style(span, "position", "absolute");
    			set_style(span, "left", "0px");
    			set_style(span, "top", "0px");
    			attr_dev(span, "uk-spinner", "");
    			add_location(span, file$s, 67, 6, 2905);
    			set_style(div, "position", "relative");
    			add_location(div, file$s, 66, 4, 2867);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(66:2) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (77:2) {#if isDevTest}
    function create_if_block_4(ctx) {
    	let div;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "DEV MODE, RUNNING IN TEST DIFFICULTY";
    			attr_dev(p, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(p, file$s, 78, 6, 3203);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$s, 77, 4, 3160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(77:2) {#if isDevTest}",
    		ctx
    	});

    	return block;
    }

    // (113:24) 
    function create_if_block_3$1(ctx) {
    	let cantstart;
    	let current;
    	cantstart = new CantStart({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(cantstart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cantstart, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cantstart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cantstart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cantstart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(113:24) ",
    		ctx
    	});

    	return block;
    }

    // (85:6) {#if (account && account.on_chain) ||             // so we don't get a flash of the error card on an intermittent local network connection if we are in fact mining            (minerTower && minerTower.progress.pct_complete)       }
    function create_if_block$c(ctx) {
    	let div0;
    	let toggleminer;
    	let t0;
    	let minerprogress;
    	let t1;
    	let div1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	toggleminer = new ToggleMiner({ $$inline: true });

    	minerprogress = new MinerProgress({
    			props: { tower: /*minerTower*/ ctx[6] },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_1$5, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*newbie*/ ctx[0] && !/*hasProofs*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(toggleminer.$$.fragment);
    			t0 = space();
    			create_component(minerprogress.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "uk-width-1-1 uk-align-center");
    			add_location(div0, file$s, 88, 8, 3625);
    			attr_dev(div1, "class", "uk-width-1-1");
    			add_location(div1, file$s, 94, 8, 3816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(toggleminer, div0, null);
    			append_dev(div0, t0);
    			mount_component(minerprogress, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const minerprogress_changes = {};
    			if (dirty & /*minerTower*/ 64) minerprogress_changes.tower = /*minerTower*/ ctx[6];
    			minerprogress.$set(minerprogress_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggleminer.$$.fragment, local);
    			transition_in(minerprogress.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggleminer.$$.fragment, local);
    			transition_out(minerprogress.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(toggleminer);
    			destroy_component(minerprogress);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(85:6) {#if (account && account.on_chain) ||             // so we don't get a flash of the error card on an intermittent local network connection if we are in fact mining            (minerTower && minerTower.progress.pct_complete)       }",
    		ctx
    	});

    	return block;
    }

    // (98:10) {:else}
    function create_else_block$7(ctx) {
    	let div2;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let towerstate;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*isSendInProgress*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	towerstate = new TowerState({
    			props: { minerTower: /*minerTower*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			create_component(towerstate.$$.fragment);
    			attr_dev(div0, "class", "uk-width-1-3");
    			add_location(div0, file$s, 99, 14, 3988);
    			attr_dev(div1, "class", "uk-width-2-3");
    			add_location(div1, file$s, 106, 14, 4260);
    			attr_dev(div2, "class", "uk-grid uk-grid-match");
    			add_location(div2, file$s, 98, 12, 3938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			mount_component(towerstate, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const towerstate_changes = {};
    			if (dirty & /*minerTower*/ 64) towerstate_changes.minerTower = /*minerTower*/ ctx[6];
    			towerstate.$set(towerstate_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(towerstate.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(towerstate.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_component(towerstate);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(98:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (96:10) {#if newbie && !hasProofs }
    function create_if_block_1$5(ctx) {
    	let firstproof;
    	let current;
    	firstproof = new FirstProof({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(firstproof.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(firstproof, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(firstproof.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(firstproof.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(firstproof, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(96:10) {#if newbie && !hasProofs }",
    		ctx
    	});

    	return block;
    }

    // (103:16) {:else}
    function create_else_block_1$2(ctx) {
    	let epochstatus;
    	let current;

    	epochstatus = new EpochStatus({
    			props: {
    				minerTower: /*minerTower*/ ctx[6],
    				isTowerNewbie: /*newbie*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(epochstatus.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(epochstatus, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const epochstatus_changes = {};
    			if (dirty & /*minerTower*/ 64) epochstatus_changes.minerTower = /*minerTower*/ ctx[6];
    			if (dirty & /*newbie*/ 1) epochstatus_changes.isTowerNewbie = /*newbie*/ ctx[0];
    			epochstatus.$set(epochstatus_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(epochstatus.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(epochstatus.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(epochstatus, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(103:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (101:16) {#if isSendInProgress}
    function create_if_block_2$2(ctx) {
    	let syncproofs;
    	let current;

    	syncproofs = new SyncProofs({
    			props: {
    				minerTower: /*minerTower*/ ctx[6],
    				loading: /*loading*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(syncproofs.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(syncproofs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const syncproofs_changes = {};
    			if (dirty & /*minerTower*/ 64) syncproofs_changes.minerTower = /*minerTower*/ ctx[6];
    			if (dirty & /*loading*/ 2) syncproofs_changes.loading = /*loading*/ ctx[1];
    			syncproofs.$set(syncproofs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(syncproofs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(syncproofs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(syncproofs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(101:16) {#if isSendInProgress}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let main;
    	let t0;
    	let div0;
    	let h2;
    	let t1_value = /*$_*/ ctx[7]("miner.title") + "";
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let commonerrors;
    	let t5;
    	let minerdebug;
    	let current;
    	let if_block0 = /*loading*/ ctx[1] && create_if_block_5(ctx);
    	let if_block1 = /*isDevTest*/ ctx[3] && create_if_block_4(ctx);
    	const if_block_creators = [create_if_block$c, create_if_block_3$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*account*/ ctx[2] && /*account*/ ctx[2].on_chain || // so we don't get a flash of the error card on an intermittent local network connection if we are in fact mining
    		/*minerTower*/ ctx[6] && /*minerTower*/ ctx[6].progress.pct_complete) return 0;

    		if (/*account*/ ctx[2]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	commonerrors = new CommonErrors({ $$inline: true });

    	minerdebug = new MinerDebug({
    			props: { minerTower: /*minerTower*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			h2 = element("h2");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div1 = element("div");
    			if (if_block2) if_block2.c();
    			t4 = space();
    			create_component(commonerrors.$$.fragment);
    			t5 = space();
    			create_component(minerdebug.$$.fragment);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$s, 71, 4, 3033);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$s, 70, 2, 2992);
    			attr_dev(div1, "class", "uk-grid uk-margin-small");
    			add_location(div1, file$s, 83, 4, 3340);
    			attr_dev(main, "class", "uk-height-viewport");
    			add_location(main, file$s, 64, 0, 2813);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t0);
    			append_dev(main, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t1);
    			append_dev(main, t2);
    			if (if_block1) if_block1.m(main, null);
    			append_dev(main, t3);
    			append_dev(main, div1);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div1, null);
    			}

    			append_dev(main, t4);
    			mount_component(commonerrors, main, null);
    			append_dev(main, t5);
    			mount_component(minerdebug, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loading*/ ctx[1]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					if_block0.m(main, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || dirty & /*$_*/ 128) && t1_value !== (t1_value = /*$_*/ ctx[7]("miner.title") + "")) set_data_dev(t1, t1_value);

    			if (/*isDevTest*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(main, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block2) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block2 = if_blocks[current_block_type_index];

    					if (!if_block2) {
    						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block2.c();
    					} else {
    						if_block2.p(ctx, dirty);
    					}

    					transition_in(if_block2, 1);
    					if_block2.m(div1, null);
    				} else {
    					if_block2 = null;
    				}
    			}

    			const minerdebug_changes = {};
    			if (dirty & /*minerTower*/ 64) minerdebug_changes.minerTower = /*minerTower*/ ctx[6];
    			minerdebug.$set(minerdebug_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			transition_in(commonerrors.$$.fragment, local);
    			transition_in(minerdebug.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			transition_out(commonerrors.$$.fragment, local);
    			transition_out(minerdebug.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			destroy_component(commonerrors);
    			destroy_component(minerdebug);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(7, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Miner", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	
    	let newbie = false;
    	let loading = true;
    	let account;
    	let isDevTest = false;
    	let isSendInProgress = false;
    	let hasProofs = false;
    	let minerTower;

    	// unsubscribe functions
    	let unsubsTower;

    	let unsubsIsTowerNewbie;
    	let unsubsBacklogInProgress;
    	let unsubsSigningAccount;
    	let unsubsIsRefreshingAccounts;
    	let unsubsIsDevTest;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		getTowerChainView();

    		unsubsTower = tower.subscribe(t => {
    			$$invalidate(6, minerTower = t);
    			$$invalidate(5, hasProofs = minerTower.last_local_proof ? true : false);
    		});

    		unsubsIsTowerNewbie = isTowerNewbie.subscribe(b => $$invalidate(0, newbie = b));
    		unsubsBacklogInProgress = backlogInProgress.subscribe(b => $$invalidate(4, isSendInProgress = b));
    		unsubsSigningAccount = signingAccount.subscribe(a => $$invalidate(2, account = a));
    		unsubsIsRefreshingAccounts = isRefreshingAccounts.subscribe(a => $$invalidate(1, loading = a));
    		unsubsIsDevTest = $$invalidate(3, isDevTest = get_store_value(nodeEnv) == "test");
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsTower && unsubsTower();
    		unsubsIsTowerNewbie && unsubsIsTowerNewbie();
    		unsubsBacklogInProgress && unsubsBacklogInProgress();
    		unsubsSigningAccount && unsubsSigningAccount();
    		unsubsIsRefreshingAccounts && unsubsIsRefreshingAccounts();
    		unsubsIsDevTest && unsubsIsDevTest();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Miner> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		onDestroy,
    		ToggleMiner,
    		MinerProgress,
    		TowerState,
    		MinerDebug,
    		CantStart,
    		isRefreshingAccounts,
    		signingAccount,
    		FirstProof,
    		backlogInProgress,
    		isTowerNewbie,
    		tower,
    		nodeEnv,
    		get: get_store_value,
    		SyncProofs,
    		CommonErrors,
    		getTowerChainView,
    		EpochStatus,
    		_: X,
    		newbie,
    		loading,
    		account,
    		isDevTest,
    		isSendInProgress,
    		hasProofs,
    		minerTower,
    		unsubsTower,
    		unsubsIsTowerNewbie,
    		unsubsBacklogInProgress,
    		unsubsSigningAccount,
    		unsubsIsRefreshingAccounts,
    		unsubsIsDevTest,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("newbie" in $$props) $$invalidate(0, newbie = $$props.newbie);
    		if ("loading" in $$props) $$invalidate(1, loading = $$props.loading);
    		if ("account" in $$props) $$invalidate(2, account = $$props.account);
    		if ("isDevTest" in $$props) $$invalidate(3, isDevTest = $$props.isDevTest);
    		if ("isSendInProgress" in $$props) $$invalidate(4, isSendInProgress = $$props.isSendInProgress);
    		if ("hasProofs" in $$props) $$invalidate(5, hasProofs = $$props.hasProofs);
    		if ("minerTower" in $$props) $$invalidate(6, minerTower = $$props.minerTower);
    		if ("unsubsTower" in $$props) unsubsTower = $$props.unsubsTower;
    		if ("unsubsIsTowerNewbie" in $$props) unsubsIsTowerNewbie = $$props.unsubsIsTowerNewbie;
    		if ("unsubsBacklogInProgress" in $$props) unsubsBacklogInProgress = $$props.unsubsBacklogInProgress;
    		if ("unsubsSigningAccount" in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ("unsubsIsRefreshingAccounts" in $$props) unsubsIsRefreshingAccounts = $$props.unsubsIsRefreshingAccounts;
    		if ("unsubsIsDevTest" in $$props) unsubsIsDevTest = $$props.unsubsIsDevTest;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		newbie,
    		loading,
    		account,
    		isDevTest,
    		isSendInProgress,
    		hasProofs,
    		minerTower,
    		$_
    	];
    }

    class Miner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Miner",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/components/settings/AccountSettings.svelte generated by Svelte v3.38.1 */
    const file$r = "src/components/settings/AccountSettings.svelte";

    function create_fragment$r(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[0]("settings.account_settings.title") + "";
    	let t0;
    	let t1;
    	let div4;
    	let div2;
    	let div1;
    	let button0;
    	let t2_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "";
    	let t2;
    	let t3;
    	let div0;
    	let p;
    	let t4_value = /*$_*/ ctx[0]("settings.account_settings.confirm") + "";
    	let t4;
    	let t5;
    	let button1;
    	let t6_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "";
    	let t6;
    	let t7;
    	let div3;
    	let span;
    	let t8_value = /*$_*/ ctx[0]("settings.account_settings.description") + "";
    	let t8;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");
    			p = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			button1 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			span = element("span");
    			t8 = text(t8_value);
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$r, 29, 2, 1351);
    			attr_dev(button0, "class", "uk-button uk-button-danger");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$r, 37, 4, 1553);
    			add_location(p, file$r, 39, 10, 1712);
    			attr_dev(button1, "class", "uk-button uk-button-danger");
    			add_location(button1, file$r, 40, 10, 1771);
    			attr_dev(div0, "uk-dropdown", "mode: click");
    			add_location(div0, file$r, 38, 6, 1670);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$r, 36, 4, 1525);
    			add_location(div2, file$r, 34, 4, 1514);
    			add_location(span, file$r, 48, 6, 1970);
    			add_location(div3, file$r, 47, 4, 1958);
    			attr_dev(div4, "class", "uk-margin");
    			attr_dev(div4, "uk-grid", "");
    			add_location(div4, file$r, 33, 2, 1478);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$r, 28, 0, 1323);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(button0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t4);
    			append_dev(div0, t5);
    			append_dev(div0, button1);
    			append_dev(button1, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, span);
    			append_dev(span, t8);

    			if (!mounted) {
    				dispose = listen_dev(button1, "click", /*removeAccounts*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("settings.account_settings.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("settings.account_settings.confirm") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 1 && t8_value !== (t8_value = /*$_*/ ctx[0]("settings.account_settings.description") + "")) set_data_dev(t8, t8_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccountSettings", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	const removeAccounts = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("remove_accounts", {}).then(res => {
    			responses.set(res);
    			notify_success("accounts removed successfully");
    			loadAccounts();
    		}).catch(e => {
    			raise_error(e, false, "removeAccounts");
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccountSettings> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		invoke: i$1,
    		_: X,
    		loadAccounts,
    		raise_error,
    		notify_success,
    		responses,
    		removeAccounts,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$_, removeAccounts];
    }

    class AccountSettings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountSettings",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src/components/settings/UpdateNetwork.svelte generated by Svelte v3.38.1 */
    const file$q = "src/components/settings/UpdateNetwork.svelte";

    function create_fragment$q(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[2]("settings.network_settings.title") + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let h50;
    	let t4_value = /*$_*/ ctx[2]("settings.network_settings.list_of_peers") + "";
    	let t4;
    	let t5;
    	let p0;
    	let t6_value = /*$_*/ ctx[2]("settings.network_settings.description") + "";
    	let t6;
    	let t7;
    	let setnetworkplaylist;
    	let t8;
    	let h51;
    	let t9_value = /*$_*/ ctx[2]("settings.network_settings.override_peers") + "";
    	let t9;
    	let t10;
    	let p1;
    	let t11_value = /*$_*/ ctx[2]("settings.network_settings.override_peers_description") + "";
    	let t11;
    	let t12;
    	let form;
    	let fieldset;
    	let div;
    	let span0;
    	let t13_value = /*$_*/ ctx[2]("settings.network_settings.url_of_upstream_node") + "";
    	let t13;
    	let t14;
    	let input;
    	let t15;
    	let span1;
    	let t16_value = /*$_*/ ctx[2]("settings.network_settings.btn_update") + "";
    	let t16;
    	let t17;
    	let h52;
    	let t18_value = /*$_*/ ctx[2]("settings.network_settings.upstream_title") + "";
    	let t18;
    	let t19;
    	let p2;
    	let t20_value = /*$_*/ ctx[2]("settings.network_settings.upstream_subtitle") + "";
    	let t20;
    	let t21;
    	let button;
    	let t22_value = /*$_*/ ctx[2]("settings.network_settings.btn_fetch_new_waypoint") + "";
    	let t22;
    	let current;
    	let mounted;
    	let dispose;
    	setnetworkplaylist = new SetNetworkPlaylist({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(/*current_chain_id*/ ctx[1]);
    			t3 = space();
    			h50 = element("h5");
    			t4 = text(t4_value);
    			t5 = space();
    			p0 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(setnetworkplaylist.$$.fragment);
    			t8 = space();
    			h51 = element("h5");
    			t9 = text(t9_value);
    			t10 = space();
    			p1 = element("p");
    			t11 = text(t11_value);
    			t12 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div = element("div");
    			span0 = element("span");
    			t13 = text(t13_value);
    			t14 = space();
    			input = element("input");
    			t15 = space();
    			span1 = element("span");
    			t16 = text(t16_value);
    			t17 = space();
    			h52 = element("h5");
    			t18 = text(t18_value);
    			t19 = space();
    			p2 = element("p");
    			t20 = text(t20_value);
    			t21 = space();
    			button = element("button");
    			t22 = text(t22_value);
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$q, 42, 2, 1744);
    			attr_dev(h50, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h50, file$q, 44, 2, 1883);
    			add_location(p0, file$q, 45, 2, 2011);
    			attr_dev(h51, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h51, file$q, 48, 2, 2094);
    			add_location(p1, file$q, 49, 2, 2221);
    			add_location(span0, file$q, 54, 8, 2419);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "http://1.1.1.1:8080");
    			add_location(input, file$q, 55, 8, 2495);
    			attr_dev(div, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div, file$q, 53, 6, 2358);
    			attr_dev(span1, "class", "uk-button uk-button-primary uk-align-right");
    			attr_dev(span1, "id", "add-btn");
    			add_location(span1, file$q, 63, 6, 2662);
    			attr_dev(h52, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h52, file$q, 69, 6, 2855);
    			add_location(p2, file$q, 70, 6, 2986);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$q, 71, 6, 3051);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$q, 52, 4, 2321);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$q, 51, 2, 2292);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$q, 41, 0, 1717);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, t2);
    			append_dev(main, t3);
    			append_dev(main, h50);
    			append_dev(h50, t4);
    			append_dev(main, t5);
    			append_dev(main, p0);
    			append_dev(p0, t6);
    			append_dev(main, t7);
    			mount_component(setnetworkplaylist, main, null);
    			append_dev(main, t8);
    			append_dev(main, h51);
    			append_dev(h51, t9);
    			append_dev(main, t10);
    			append_dev(main, p1);
    			append_dev(p1, t11);
    			append_dev(main, t12);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div);
    			append_dev(div, span0);
    			append_dev(span0, t13);
    			append_dev(div, t14);
    			append_dev(div, input);
    			set_input_value(input, /*upstream_url*/ ctx[0]);
    			append_dev(fieldset, t15);
    			append_dev(fieldset, span1);
    			append_dev(span1, t16);
    			append_dev(fieldset, t17);
    			append_dev(fieldset, h52);
    			append_dev(h52, t18);
    			append_dev(fieldset, t19);
    			append_dev(fieldset, p2);
    			append_dev(p2, t20);
    			append_dev(fieldset, t21);
    			append_dev(fieldset, button);
    			append_dev(button, t22);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
    					listen_dev(span1, "click", /*forceUpstream*/ ctx[3], false, false, false),
    					listen_dev(button, "click", refreshWaypoint, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 4) && t0_value !== (t0_value = /*$_*/ ctx[2]("settings.network_settings.title") + "")) set_data_dev(t0, t0_value);
    			if (!current || dirty & /*current_chain_id*/ 2) set_data_dev(t2, /*current_chain_id*/ ctx[1]);
    			if ((!current || dirty & /*$_*/ 4) && t4_value !== (t4_value = /*$_*/ ctx[2]("settings.network_settings.list_of_peers") + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty & /*$_*/ 4) && t6_value !== (t6_value = /*$_*/ ctx[2]("settings.network_settings.description") + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*$_*/ 4) && t9_value !== (t9_value = /*$_*/ ctx[2]("settings.network_settings.override_peers") + "")) set_data_dev(t9, t9_value);
    			if ((!current || dirty & /*$_*/ 4) && t11_value !== (t11_value = /*$_*/ ctx[2]("settings.network_settings.override_peers_description") + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*$_*/ 4) && t13_value !== (t13_value = /*$_*/ ctx[2]("settings.network_settings.url_of_upstream_node") + "")) set_data_dev(t13, t13_value);

    			if (dirty & /*upstream_url*/ 1 && input.value !== /*upstream_url*/ ctx[0]) {
    				set_input_value(input, /*upstream_url*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 4) && t16_value !== (t16_value = /*$_*/ ctx[2]("settings.network_settings.btn_update") + "")) set_data_dev(t16, t16_value);
    			if ((!current || dirty & /*$_*/ 4) && t18_value !== (t18_value = /*$_*/ ctx[2]("settings.network_settings.upstream_title") + "")) set_data_dev(t18, t18_value);
    			if ((!current || dirty & /*$_*/ 4) && t20_value !== (t20_value = /*$_*/ ctx[2]("settings.network_settings.upstream_subtitle") + "")) set_data_dev(t20, t20_value);
    			if ((!current || dirty & /*$_*/ 4) && t22_value !== (t22_value = /*$_*/ ctx[2]("settings.network_settings.btn_fetch_new_waypoint") + "")) set_data_dev(t22, t22_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(setnetworkplaylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(setnetworkplaylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(setnetworkplaylist);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UpdateNetwork", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	
    	let upstream_url = "";
    	let current_chain_id = "";

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		getNetwork();

    		network_profile.subscribe(n => {
    			$$invalidate(0, upstream_url = n.urls.length == 1 ? n.urls[0] : ""); // just used to show OVERRIDE PEERS url
    			$$invalidate(1, current_chain_id = n.chain_id);
    		});
    	}));

    	function forceUpstream() {
    		// check input data
    		// submit
    		i$1("force_upstream", { url: upstream_url }).then(res => {
    			network_profile.set(res);
    			notify_success("Network Settings Updated");
    		}).catch(error => {
    			raise_error(error, false, "forceUpstream");
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UpdateNetwork> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		upstream_url = this.value;
    		$$invalidate(0, upstream_url);
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		raise_error,
    		network_profile,
    		getNetwork,
    		refreshWaypoint,
    		invoke: i$1,
    		notify_success,
    		SetNetworkPlaylist,
    		_: X,
    		upstream_url,
    		current_chain_id,
    		forceUpstream,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("upstream_url" in $$props) $$invalidate(0, upstream_url = $$props.upstream_url);
    		if ("current_chain_id" in $$props) $$invalidate(1, current_chain_id = $$props.current_chain_id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [upstream_url, current_chain_id, $_, forceUpstream, input_input_handler];
    }

    class UpdateNetwork extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpdateNetwork",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src/components/settings/LangAppearanceSettings.svelte generated by Svelte v3.38.1 */
    const file$p = "src/components/settings/LangAppearanceSettings.svelte";

    function create_fragment$p(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[0]("settings.langapp_settings.title") + "";
    	let t0;
    	let t1;
    	let form;
    	let fieldset;
    	let h5;
    	let t2_value = /*$_*/ ctx[0]("settings.langapp_settings.lang") + "";
    	let t2;
    	let t3;
    	let p;
    	let t4_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_description") + "";
    	let t4;
    	let t5;
    	let button;
    	let t6_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_button") + "";
    	let t6;
    	let t7;
    	let div;
    	let ul;
    	let li0;
    	let a0;
    	let t9;
    	let li1;
    	let a1;
    	let t11;
    	let li2;
    	let a2;
    	let t13;
    	let li3;
    	let a3;
    	let t15;
    	let li4;
    	let a4;
    	let t17;
    	let li5;
    	let a5;
    	let t19;
    	let li6;
    	let a6;
    	let t21;
    	let li7;
    	let a7;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			h5 = element("h5");
    			t2 = text(t2_value);
    			t3 = space();
    			p = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			button = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "English";
    			t9 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "";
    			t11 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "French";
    			t13 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "German";
    			t15 = space();
    			li4 = element("li");
    			a4 = element("a");
    			a4.textContent = "Spanish";
    			t17 = space();
    			li5 = element("li");
    			a5 = element("a");
    			a5.textContent = "Italian";
    			t19 = space();
    			li6 = element("li");
    			a6 = element("a");
    			a6.textContent = "Portuguese";
    			t21 = space();
    			li7 = element("li");
    			a7 = element("a");
    			a7.textContent = "Arabic";
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$p, 5, 2, 140);
    			attr_dev(h5, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h5, file$p, 9, 6, 328);
    			add_location(p, file$p, 10, 6, 451);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$p, 11, 6, 515);
    			attr_dev(a0, "class", "uk-text-muted");
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$p, 14, 14, 724);
    			add_location(li0, file$p, 14, 10, 720);
    			attr_dev(a1, "class", "uk-text-muted");
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$p, 15, 14, 824);
    			add_location(li1, file$p, 15, 10, 820);
    			attr_dev(a2, "class", "uk-text-muted");
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$p, 16, 14, 922);
    			add_location(li2, file$p, 16, 10, 918);
    			attr_dev(a3, "class", "uk-text-muted");
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$p, 17, 14, 1021);
    			add_location(li3, file$p, 17, 10, 1017);
    			attr_dev(a4, "class", "uk-text-muted");
    			attr_dev(a4, "href", "#");
    			add_location(a4, file$p, 18, 14, 1120);
    			add_location(li4, file$p, 18, 10, 1116);
    			attr_dev(a5, "class", "uk-text-muted");
    			attr_dev(a5, "href", "#");
    			add_location(a5, file$p, 19, 14, 1220);
    			add_location(li5, file$p, 19, 10, 1216);
    			attr_dev(a6, "class", "uk-text-muted");
    			attr_dev(a6, "href", "#");
    			add_location(a6, file$p, 20, 14, 1320);
    			add_location(li6, file$p, 20, 10, 1316);
    			attr_dev(a7, "class", "uk-text-muted");
    			attr_dev(a7, "href", "#");
    			add_location(a7, file$p, 21, 14, 1423);
    			add_location(li7, file$p, 21, 10, 1419);
    			attr_dev(ul, "class", "uk-nav uk-dropdown-nav");
    			add_location(ul, file$p, 13, 8, 674);
    			attr_dev(div, "uk-dropdown", "mode: click");
    			add_location(div, file$p, 12, 6, 634);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$p, 8, 4, 291);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$p, 7, 2, 262);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$p, 4, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, h5);
    			append_dev(h5, t2);
    			append_dev(fieldset, t3);
    			append_dev(fieldset, p);
    			append_dev(p, t4);
    			append_dev(fieldset, t5);
    			append_dev(fieldset, button);
    			append_dev(button, t6);
    			append_dev(fieldset, t7);
    			append_dev(fieldset, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(ul, t9);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(ul, t11);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(ul, t13);
    			append_dev(ul, li3);
    			append_dev(li3, a3);
    			append_dev(ul, t15);
    			append_dev(ul, li4);
    			append_dev(li4, a4);
    			append_dev(ul, t17);
    			append_dev(ul, li5);
    			append_dev(li5, a5);
    			append_dev(ul, t19);
    			append_dev(ul, li6);
    			append_dev(li6, a6);
    			append_dev(ul, t21);
    			append_dev(ul, li7);
    			append_dev(li7, a7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[2], false, false, false),
    					listen_dev(a2, "click", /*click_handler_2*/ ctx[3], false, false, false),
    					listen_dev(a3, "click", /*click_handler_3*/ ctx[4], false, false, false),
    					listen_dev(a4, "click", /*click_handler_4*/ ctx[5], false, false, false),
    					listen_dev(a5, "click", /*click_handler_5*/ ctx[6], false, false, false),
    					listen_dev(a6, "click", /*click_handler_6*/ ctx[7], false, false, false),
    					listen_dev(a7, "click", /*click_handler_7*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("settings.langapp_settings.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("settings.langapp_settings.lang") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_description") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_button") + "")) set_data_dev(t6, t6_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LangAppearanceSettings", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LangAppearanceSettings> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setLocale("en");
    	const click_handler_1 = () => setLocale("zh_cn");
    	const click_handler_2 = () => setLocale("fr");
    	const click_handler_3 = () => setLocale("de");
    	const click_handler_4 = () => setLocale("es");
    	const click_handler_5 = () => setLocale("it");
    	const click_handler_6 = () => setLocale("pt");
    	const click_handler_7 = () => setLocale("ar");
    	$$self.$capture_state = () => ({ _: X, setLocale, $_ });

    	return [
    		$_,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7
    	];
    }

    class LangAppearanceSettings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LangAppearanceSettings",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src/components/txs/SetWalletType.svelte generated by Svelte v3.38.1 */
    const file$o = "src/components/txs/SetWalletType.svelte";

    // (53:6) {#if loading}
    function create_if_block$b(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			add_location(span, file$o, 54, 10, 1977);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$o, 53, 8, 1930);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(53:6) {#if loading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[1]("txs.set_wallet_type.title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[1]("txs.set_wallet_type.subtitle") + "";
    	let t2;
    	let t3;
    	let div4;
    	let div1;
    	let button0;
    	let t4_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_slow") + "";
    	let t4;
    	let button0_disabled_value;
    	let t5;
    	let div0;
    	let p1;
    	let t6_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_slow") + "";
    	let t6;
    	let t7;
    	let button1;
    	let t8_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_slow") + "";
    	let t8;
    	let t9;
    	let div3;
    	let button2;
    	let t10_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_community") + "";
    	let t10;
    	let button2_disabled_value;
    	let t11;
    	let div2;
    	let p2;
    	let t12_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_community") + "";
    	let t12;
    	let t13;
    	let button3;
    	let t14_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_community") + "";
    	let t14;
    	let t15;
    	let mounted;
    	let dispose;
    	let if_block = /*loading*/ ctx[0] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			div4 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			t4 = text(t4_value);
    			t5 = space();
    			div0 = element("div");
    			p1 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			button2 = element("button");
    			t10 = text(t10_value);
    			t11 = space();
    			div2 = element("div");
    			p2 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			button3 = element("button");
    			t14 = text(t14_value);
    			t15 = space();
    			if (if_block) if_block.c();
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$o, 26, 2, 738);
    			add_location(p0, file$o, 28, 2, 855);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			button0.disabled = button0_disabled_value = /*loading*/ ctx[0] ? true : false;
    			add_location(button0, file$o, 31, 4, 940);
    			add_location(p1, file$o, 33, 12, 1145);
    			attr_dev(button1, "class", "uk-button uk-button-danger");
    			add_location(button1, file$o, 34, 12, 1205);
    			attr_dev(div0, "class", "send-drop");
    			attr_dev(div0, "uk-dropdown", "mode: click");
    			add_location(div0, file$o, 32, 6, 1083);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$o, 30, 4, 912);
    			attr_dev(button2, "class", "uk-button uk-button-default");
    			attr_dev(button2, "type", "button");
    			button2.disabled = button2_disabled_value = /*loading*/ ctx[0] ? true : false;
    			add_location(button2, file$o, 42, 4, 1429);
    			add_location(p2, file$o, 44, 12, 1639);
    			attr_dev(button3, "class", "uk-button uk-button-danger");
    			add_location(button3, file$o, 45, 12, 1704);
    			attr_dev(div2, "class", "send-drop");
    			attr_dev(div2, "uk-dropdown", "mode: click");
    			add_location(div2, file$o, 43, 6, 1577);
    			attr_dev(div3, "class", "uk-inline");
    			add_location(div3, file$o, 41, 4, 1401);
    			add_location(div4, file$o, 29, 2, 902);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$o, 25, 0, 711);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, p0);
    			append_dev(p0, t2);
    			append_dev(main, t3);
    			append_dev(main, div4);
    			append_dev(div4, div1);
    			append_dev(div1, button0);
    			append_dev(button0, t4);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			append_dev(div0, p1);
    			append_dev(p1, t6);
    			append_dev(div0, t7);
    			append_dev(div0, button1);
    			append_dev(button1, t8);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, button2);
    			append_dev(button2, t10);
    			append_dev(div3, t11);
    			append_dev(div3, div2);
    			append_dev(div2, p2);
    			append_dev(p2, t12);
    			append_dev(div2, t13);
    			append_dev(div2, button3);
    			append_dev(button3, t14);
    			append_dev(div4, t15);
    			if (if_block) if_block.m(div4, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button1, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(button3, "click", /*click_handler_1*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("txs.set_wallet_type.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("txs.set_wallet_type.subtitle") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 2 && t4_value !== (t4_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_slow") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*loading*/ 1 && button0_disabled_value !== (button0_disabled_value = /*loading*/ ctx[0] ? true : false)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (dirty & /*$_*/ 2 && t6_value !== (t6_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_slow") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 2 && t8_value !== (t8_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_slow") + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*$_*/ 2 && t10_value !== (t10_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_community") + "")) set_data_dev(t10, t10_value);

    			if (dirty & /*loading*/ 1 && button2_disabled_value !== (button2_disabled_value = /*loading*/ ctx[0] ? true : false)) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (dirty & /*$_*/ 2 && t12_value !== (t12_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_community") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$_*/ 2 && t14_value !== (t14_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_community") + "")) set_data_dev(t14, t14_value);

    			if (/*loading*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(div4, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SetWalletType", slots, []);
    	
    	let loading = false;

    	function setWallet(num) {
    		$$invalidate(0, loading = true);

    		i$1("wallet_type", { typeInt: num }).then(res => {
    			$$invalidate(0, loading = false);
    			notify_success("Account set to Slow Wallet");
    			responses.set(res);
    		}).catch(e => {
    			$$invalidate(0, loading = false);
    			raise_error(e, false, "setWallet");
    		});

    		uikit.dropdown(document.getElementsByClassName("send-drop")).hide(500);
    	}

    	
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SetWalletType> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setWallet(0);
    	const click_handler_1 = () => setWallet(1);

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		raise_error,
    		notify_success,
    		responses,
    		UIkit: uikit,
    		_: X,
    		loading,
    		setWallet,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("loading" in $$props) $$invalidate(0, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loading, $_, setWallet, click_handler, click_handler_1];
    }

    class SetWalletType extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SetWalletType",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src/components/settings/Settings.svelte generated by Svelte v3.38.1 */
    const file$n = "src/components/settings/Settings.svelte";

    function create_fragment$n(ctx) {
    	let main;
    	let div;
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("settings.title") + "";
    	let t0;
    	let t1;
    	let langappearancesettings;
    	let t2;
    	let updatenetwork;
    	let t3;
    	let accountsettings;
    	let t4;
    	let minerbacklog;
    	let t5;
    	let setwallettype;
    	let current;
    	langappearancesettings = new LangAppearanceSettings({ $$inline: true });
    	updatenetwork = new UpdateNetwork({ $$inline: true });
    	accountsettings = new AccountSettings({ $$inline: true });
    	minerbacklog = new MinerBacklog({ $$inline: true });
    	setwallettype = new SetWalletType({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(langappearancesettings.$$.fragment);
    			t2 = space();
    			create_component(updatenetwork.$$.fragment);
    			t3 = space();
    			create_component(accountsettings.$$.fragment);
    			t4 = space();
    			create_component(minerbacklog.$$.fragment);
    			t5 = space();
    			create_component(setwallettype.$$.fragment);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$n, 10, 4, 404);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$n, 9, 2, 363);
    			add_location(main, file$n, 8, 0, 354);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			mount_component(langappearancesettings, main, null);
    			append_dev(main, t2);
    			mount_component(updatenetwork, main, null);
    			append_dev(main, t3);
    			mount_component(accountsettings, main, null);
    			append_dev(main, t4);
    			mount_component(minerbacklog, main, null);
    			append_dev(main, t5);
    			mount_component(setwallettype, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("settings.title") + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(langappearancesettings.$$.fragment, local);
    			transition_in(updatenetwork.$$.fragment, local);
    			transition_in(accountsettings.$$.fragment, local);
    			transition_in(minerbacklog.$$.fragment, local);
    			transition_in(setwallettype.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(langappearancesettings.$$.fragment, local);
    			transition_out(updatenetwork.$$.fragment, local);
    			transition_out(accountsettings.$$.fragment, local);
    			transition_out(minerbacklog.$$.fragment, local);
    			transition_out(setwallettype.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(langappearancesettings);
    			destroy_component(updatenetwork);
    			destroy_component(accountsettings);
    			destroy_component(minerbacklog);
    			destroy_component(setwallettype);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Settings", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		MinerBacklog,
    		AccountSettings,
    		UpdateNetwork,
    		LangAppearanceSettings,
    		SetWalletType,
    		_: X,
    		$_
    	});

    	return [$_];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src/components/txs/DemoTx.svelte generated by Svelte v3.38.1 */
    const file$m = "src/components/txs/DemoTx.svelte";

    function create_fragment$m(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Demo Tx";
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$m, 23, 2, 535);
    			attr_dev(div, "class", "uk-margin-medium-bottom");
    			add_location(div, file$m, 22, 0, 495);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*demoTx*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DemoTx", slots, []);
    	let account_string = "";

    	signingAccount.subscribe(n => {
    		account_string = n.account;
    	});

    	const demoTx = async () => {
    		i$1("demo_tx", {}).then(res => {
    			responses.set(res);
    		}).catch(e => {
    			raise_error(e);
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DemoTx> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		signingAccount,
    		raise_error,
    		responses,
    		account_string,
    		demoTx
    	});

    	$$self.$inject_state = $$props => {
    		if ("account_string" in $$props) account_string = $$props.account_string;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [demoTx];
    }

    class DemoTx extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DemoTx",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src/components/dev/DebugActions.svelte generated by Svelte v3.38.1 */

    const { console: console_1$3 } = globals;
    const file$l = "src/components/dev/DebugActions.svelte";

    function create_fragment$l(ctx) {
    	let main;
    	let div4;
    	let div0;
    	let h40;
    	let t1;
    	let button0;
    	let t3;
    	let button1;
    	let t5;
    	let button2;
    	let t7;
    	let button3;
    	let t9;
    	let div1;
    	let h41;
    	let t11;
    	let button4;
    	let t13;
    	let button5;
    	let t15;
    	let button6;
    	let t17;
    	let div2;
    	let h42;
    	let t19;
    	let button7;
    	let t21;
    	let button8;
    	let t23;
    	let button9;
    	let t25;
    	let div3;
    	let button10;
    	let t27;
    	let demotx;
    	let current;
    	let mounted;
    	let dispose;
    	demotx = new DemoTx({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div4 = element("div");
    			div0 = element("div");
    			h40 = element("h4");
    			h40.textContent = "Helpers";
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Make Error";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Receive Event";
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = "Start Listener";
    			t7 = space();
    			button3 = element("button");
    			button3.textContent = "Send Event";
    			t9 = space();
    			div1 = element("div");
    			h41 = element("h4");
    			h41.textContent = "Tower";
    			t11 = space();
    			button4 = element("button");
    			button4.textContent = "Start Mock Tower Listener";
    			t13 = space();
    			button5 = element("button");
    			button5.textContent = "Mock Tower Once";
    			t15 = space();
    			button6 = element("button");
    			button6.textContent = "Mock Tower Once Fail";
    			t17 = space();
    			div2 = element("div");
    			h42 = element("h4");
    			h42.textContent = "Tests";
    			t19 = space();
    			button7 = element("button");
    			button7.textContent = "Async";
    			t21 = space();
    			button8 = element("button");
    			button8.textContent = "Start Forever";
    			t23 = space();
    			button9 = element("button");
    			button9.textContent = "Kill Forever";
    			t25 = space();
    			div3 = element("div");
    			button10 = element("button");
    			button10.textContent = "Init";
    			t27 = space();
    			create_component(demotx.$$.fragment);
    			attr_dev(h40, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h40, file$l, 94, 6, 3586);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			add_location(button0, file$l, 95, 6, 3678);
    			attr_dev(button1, "class", "uk-button uk-button-default");
    			add_location(button1, file$l, 96, 6, 3769);
    			attr_dev(button2, "class", "uk-button uk-button-default");
    			add_location(button2, file$l, 97, 6, 3878);
    			attr_dev(button3, "class", "uk-button uk-button-default");
    			add_location(button3, file$l, 98, 6, 3982);
    			attr_dev(div0, "class", "uk-margin-medium-bottom");
    			add_location(div0, file$l, 93, 4, 3542);
    			attr_dev(h41, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h41, file$l, 102, 6, 4141);
    			attr_dev(button4, "class", "uk-button uk-button-default");
    			add_location(button4, file$l, 103, 6, 4231);
    			attr_dev(button5, "class", "uk-button uk-button-default");
    			add_location(button5, file$l, 104, 6, 4351);
    			attr_dev(button6, "class", "uk-button uk-button-default");
    			add_location(button6, file$l, 105, 6, 4451);
    			attr_dev(div1, "class", "uk-margin-medium-bottom");
    			add_location(div1, file$l, 101, 4, 4097);
    			attr_dev(h42, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h42, file$l, 110, 6, 4615);
    			attr_dev(button7, "class", "uk-button uk-button-default");
    			add_location(button7, file$l, 111, 6, 4705);
    			attr_dev(button8, "class", "uk-button uk-button-default");
    			add_location(button8, file$l, 112, 6, 4791);
    			attr_dev(button9, "class", "uk-button uk-button-default");
    			add_location(button9, file$l, 113, 6, 4888);
    			attr_dev(div2, "class", "uk-margin-medium-bottom");
    			add_location(div2, file$l, 109, 4, 4571);
    			attr_dev(button10, "class", "uk-button uk-button-default");
    			add_location(button10, file$l, 117, 6, 5037);
    			attr_dev(div3, "class", "uk-margin-medium-bottom");
    			add_location(div3, file$l, 116, 4, 4993);
    			add_location(div4, file$l, 92, 2, 3532);
    			add_location(main, file$l, 91, 0, 3523);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div4);
    			append_dev(div4, div0);
    			append_dev(div0, h40);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			append_dev(div0, t5);
    			append_dev(div0, button2);
    			append_dev(div0, t7);
    			append_dev(div0, button3);
    			append_dev(div4, t9);
    			append_dev(div4, div1);
    			append_dev(div1, h41);
    			append_dev(div1, t11);
    			append_dev(div1, button4);
    			append_dev(div1, t13);
    			append_dev(div1, button5);
    			append_dev(div1, t15);
    			append_dev(div1, button6);
    			append_dev(div4, t17);
    			append_dev(div4, div2);
    			append_dev(div2, h42);
    			append_dev(div2, t19);
    			append_dev(div2, button7);
    			append_dev(div2, t21);
    			append_dev(div2, button8);
    			append_dev(div2, t23);
    			append_dev(div2, button9);
    			append_dev(div4, t25);
    			append_dev(div4, div3);
    			append_dev(div3, button10);
    			append_dev(div4, t27);
    			mount_component(demotx, div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*makeError*/ ctx[0], false, false, false),
    					listen_dev(button1, "click", /*triggerEventFromRustToJs*/ ctx[1], false, false, false),
    					listen_dev(button2, "click", /*debugStartListener*/ ctx[3], false, false, false),
    					listen_dev(button3, "click", /*emitEventFromHereToRust*/ ctx[2], false, false, false),
    					listen_dev(button4, "click", /*startMockTowerListener*/ ctx[8], false, false, false),
    					listen_dev(button5, "click", /*mockTowerOnce*/ ctx[9], false, false, false),
    					listen_dev(button6, "click", /*mockTowerOnceFail*/ ctx[10], false, false, false),
    					listen_dev(button7, "click", /*testAsync*/ ctx[5], false, false, false),
    					listen_dev(button8, "click", /*startForever*/ ctx[6], false, false, false),
    					listen_dev(button9, "click", /*killForever*/ ctx[7], false, false, false),
    					listen_dev(button10, "click", /*init*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(demotx.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(demotx.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(demotx);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DebugActions", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	const makeError = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("debug_error", { debugErr: false }).then(res => responses.set(res)).catch(e => raise_error(e, false, "makeError"));
    	});

    	const triggerEventFromRustToJs = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("debug_emit_event", {}).then(res => responses.set(res)).catch(e => raise_error(e, false, "triggerEventFromRustToJs"));
    	});

    	function emitEventFromHereToRust() {
    		// emit an event that are only visible to the current window
    		const current = m();

    		current.emit("emit-from-window", "Tauri is awesome!");
    	}

    	

    	const debugStartListener = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("debug_start_listener", {}).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	});

    	const init = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("init_user", {
    			authkey: authkey_string,
    			account: account_string
    		}).then(res => {
    			responses.set(res); // pathStr: home,
    		}).catch(e => console.error(e));
    	});

    	const testAsync = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("delay_async", {}).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	});

    	const startForever = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("start_forever_task", {}).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	});

    	const killForever = () => __awaiter(void 0, void 0, void 0, function* () {
    		const current = m();
    		current.emit("kill_forever", "Tauri is awesome!");
    	});

    	const startMockTowerListener = () => __awaiter(void 0, void 0, void 0, function* () {
    		console.log("start tower listener");

    		i$1("mock_build_tower", { success: true }).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	});

    	const mockTowerOnce = () => __awaiter(void 0, void 0, void 0, function* () {
    		const current = m();
    		current.emit("mock-tower-make-proof", "Tauri is awesome!");
    	});

    	const mockTowerOnceFail = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("mock_build_tower", { success: false }).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<DebugActions> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		invoke: i$1,
    		responses,
    		DemoTx,
    		raise_error,
    		listen: o,
    		onMount,
    		getCurrent: m,
    		makeError,
    		triggerEventFromRustToJs,
    		emitEventFromHereToRust,
    		debugStartListener,
    		init,
    		testAsync,
    		startForever,
    		killForever,
    		startMockTowerListener,
    		mockTowerOnce,
    		mockTowerOnceFail
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		makeError,
    		triggerEventFromRustToJs,
    		emitEventFromHereToRust,
    		debugStartListener,
    		init,
    		testAsync,
    		startForever,
    		killForever,
    		startMockTowerListener,
    		mockTowerOnce,
    		mockTowerOnceFail
    	];
    }

    class DebugActions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugActions",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src/components/dev/DebugSwitchProdTest.svelte generated by Svelte v3.38.1 */
    const file$k = "src/components/dev/DebugSwitchProdTest.svelte";

    function create_fragment$k(ctx) {
    	let main;
    	let h4;
    	let t1;
    	let div1;
    	let div0;
    	let label0;
    	let input0;
    	let input0_checked_value;
    	let t2;
    	let t3;
    	let label1;
    	let input1;
    	let input1_checked_value;
    	let t4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			h4.textContent = "Miner Difficulty";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = text(" Prod");
    			t3 = space();
    			label1 = element("label");
    			input1 = element("input");
    			t4 = text(" Test");
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$k, 10, 2, 288);
    			attr_dev(input0, "class", "uk-radio");
    			attr_dev(input0, "type", "radio");
    			attr_dev(input0, "name", "radio2");
    			input0.checked = input0_checked_value = /*current_env*/ ctx[0] == "prod";
    			add_location(input0, file$k, 14, 9, 481);
    			add_location(label0, file$k, 13, 6, 465);
    			attr_dev(input1, "class", "uk-radio");
    			attr_dev(input1, "type", "radio");
    			attr_dev(input1, "name", "radio2");
    			input1.checked = input1_checked_value = /*current_env*/ ctx[0] == "test";
    			add_location(input1, file$k, 23, 9, 709);
    			add_location(label1, file$k, 22, 6, 693);
    			attr_dev(div0, "class", "uk-margin uk-grid-small uk-child-width-auto uk-grid");
    			add_location(div0, file$k, 12, 4, 393);
    			add_location(div1, file$k, 11, 2, 383);
    			add_location(main, file$k, 9, 0, 279);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			append_dev(div0, label0);
    			append_dev(label0, input0);
    			append_dev(label0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, label1);
    			append_dev(label1, input1);
    			append_dev(label1, t4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(input1, "click", /*click_handler_1*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*current_env*/ 1 && input0_checked_value !== (input0_checked_value = /*current_env*/ ctx[0] == "prod")) {
    				prop_dev(input0, "checked", input0_checked_value);
    			}

    			if (dirty & /*current_env*/ 1 && input1_checked_value !== (input1_checked_value = /*current_env*/ ctx[0] == "test")) {
    				prop_dev(input1, "checked", input1_checked_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DebugSwitchProdTest", slots, []);
    	let current_env = "prod";

    	onMount(() => {
    		getEnv(); // TODO: this should be async and awaited
    		nodeEnv.subscribe(env => $$invalidate(0, current_env = env));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DebugSwitchProdTest> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setDebugProdTest("prod");
    	const click_handler_1 = () => setDebugProdTest("test");

    	$$self.$capture_state = () => ({
    		onMount,
    		getEnv,
    		nodeEnv,
    		setDebugProdTest,
    		current_env
    	});

    	$$self.$inject_state = $$props => {
    		if ("current_env" in $$props) $$invalidate(0, current_env = $$props.current_env);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [current_env, click_handler, click_handler_1];
    }

    class DebugSwitchProdTest extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugSwitchProdTest",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src/components/dev/DebugSwitchRexMainnet.svelte generated by Svelte v3.38.1 */
    const file$j = "src/components/dev/DebugSwitchRexMainnet.svelte";

    function create_fragment$j(ctx) {
    	let div2;
    	let h4;
    	let t1;
    	let div0;
    	let label0;
    	let input0;
    	let input0_checked_value;
    	let t2;
    	let t3;
    	let label1;
    	let input1;
    	let input1_checked_value;
    	let t4;
    	let t5;
    	let label2;
    	let input2;
    	let input2_checked_value;
    	let t6;
    	let t7;
    	let h5;
    	let t9;
    	let p;
    	let t11;
    	let div1;
    	let span0;
    	let t13;
    	let input3;
    	let t14;
    	let span1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Network Connection";
    			t1 = space();
    			div0 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = text(" Mainnet");
    			t3 = space();
    			label1 = element("label");
    			input1 = element("input");
    			t4 = text(" Rex (testnet)");
    			t5 = space();
    			label2 = element("label");
    			input2 = element("input");
    			t6 = text(" Swarm (devnet)");
    			t7 = space();
    			h5 = element("h5");
    			h5.textContent = "Override The Waypoint";
    			t9 = space();
    			p = element("p");
    			p.textContent = "You need to know what you are doing here.";
    			t11 = space();
    			div1 = element("div");
    			span0 = element("span");
    			span0.textContent = "Waypoint";
    			t13 = space();
    			input3 = element("input");
    			t14 = space();
    			span1 = element("span");
    			span1.textContent = "Override Waypoint";
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$j, 40, 2, 1579);
    			attr_dev(input0, "class", "uk-radio");
    			attr_dev(input0, "type", "radio");
    			attr_dev(input0, "name", "networkCb");
    			input0.checked = input0_checked_value = /*current_chain_id*/ ctx[0] == Networks.MAINNET;
    			add_location(input0, file$j, 45, 7, 1768);
    			add_location(label0, file$j, 44, 4, 1754);
    			attr_dev(input1, "class", "uk-radio");
    			attr_dev(input1, "type", "radio");
    			attr_dev(input1, "name", "networkCb");
    			input1.checked = input1_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTNET;
    			add_location(input1, file$j, 54, 7, 2003);
    			add_location(label1, file$j, 53, 4, 1989);
    			attr_dev(input2, "class", "uk-radio");
    			attr_dev(input2, "type", "radio");
    			attr_dev(input2, "name", "networkCb");
    			input2.checked = input2_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTING;
    			add_location(input2, file$j, 63, 7, 2244);
    			add_location(label2, file$j, 62, 4, 2230);
    			attr_dev(div0, "class", "uk-margin uk-grid-small uk-child-width-auto uk-grid");
    			add_location(div0, file$j, 43, 2, 1684);
    			attr_dev(h5, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h5, file$j, 73, 2, 2480);
    			add_location(p, file$j, 76, 2, 2588);
    			add_location(span0, file$j, 78, 4, 2696);
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", /*waypoint*/ ctx[1]);
    			add_location(input3, file$j, 79, 4, 2724);
    			attr_dev(div1, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div1, file$j, 77, 2, 2639);
    			attr_dev(span1, "class", "uk-button uk-button-primary uk-align-right");
    			attr_dev(span1, "id", "add-btn");
    			add_location(span1, file$j, 88, 6, 2853);
    			attr_dev(div2, "class", "uk-margin-medium-bottom");
    			add_location(div2, file$j, 39, 0, 1539);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h4);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, label0);
    			append_dev(label0, input0);
    			append_dev(label0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, label1);
    			append_dev(label1, input1);
    			append_dev(label1, t4);
    			append_dev(div0, t5);
    			append_dev(div0, label2);
    			append_dev(label2, input2);
    			append_dev(label2, t6);
    			append_dev(div2, t7);
    			append_dev(div2, h5);
    			append_dev(div2, t9);
    			append_dev(div2, p);
    			append_dev(div2, t11);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(div1, t13);
    			append_dev(div1, input3);
    			set_input_value(input3, /*waypoint*/ ctx[1]);
    			append_dev(div2, t14);
    			append_dev(div2, span1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(input1, "click", /*click_handler_1*/ ctx[4], false, false, false),
    					listen_dev(input2, "click", /*click_handler_2*/ ctx[5], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[6]),
    					listen_dev(span1, "click", /*updateWaypoint*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*current_chain_id*/ 1 && input0_checked_value !== (input0_checked_value = /*current_chain_id*/ ctx[0] == Networks.MAINNET)) {
    				prop_dev(input0, "checked", input0_checked_value);
    			}

    			if (dirty & /*current_chain_id*/ 1 && input1_checked_value !== (input1_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTNET)) {
    				prop_dev(input1, "checked", input1_checked_value);
    			}

    			if (dirty & /*current_chain_id*/ 1 && input2_checked_value !== (input2_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTING)) {
    				prop_dev(input2, "checked", input2_checked_value);
    			}

    			if (dirty & /*waypoint*/ 2) {
    				attr_dev(input3, "placeholder", /*waypoint*/ ctx[1]);
    			}

    			if (dirty & /*waypoint*/ 2 && input3.value !== /*waypoint*/ ctx[1]) {
    				set_input_value(input3, /*waypoint*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DebugSwitchRexMainnet", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	
    	let current_chain_id;
    	let waypoint = "";

    	function updateWaypoint() {
    		// check input data
    		// submit
    		i$1("force_waypoint", { wp: waypoint }).then(res => {
    			network_profile.set(res);
    			notify_success("Waypoint Updated");
    		}).catch(error => {
    			raise_error(error, false, "updateWaypoint");
    		});
    	}

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		getNetwork();

    		network_profile.subscribe(n => {
    			$$invalidate(1, waypoint = n.waypoint);
    			$$invalidate(0, current_chain_id = n.chain_id);
    		});
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DebugSwitchRexMainnet> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setNetwork(Networks.MAINNET);
    	const click_handler_1 = () => setNetwork(Networks.TESTNET);
    	const click_handler_2 = () => setNetwork(Networks.TESTING);

    	function input3_input_handler() {
    		waypoint = this.value;
    		$$invalidate(1, waypoint);
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		invoke: i$1,
    		onMount,
    		raise_error,
    		notify_success,
    		setNetwork,
    		getNetwork,
    		network_profile,
    		Networks,
    		current_chain_id,
    		waypoint,
    		updateWaypoint
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("current_chain_id" in $$props) $$invalidate(0, current_chain_id = $$props.current_chain_id);
    		if ("waypoint" in $$props) $$invalidate(1, waypoint = $$props.waypoint);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		current_chain_id,
    		waypoint,
    		updateWaypoint,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		input3_input_handler
    	];
    }

    class DebugSwitchRexMainnet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugSwitchRexMainnet",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/components/dev/DebugPaths.svelte generated by Svelte v3.38.1 */
    const file$i = "src/components/dev/DebugPaths.svelte";

    function create_fragment$i(ctx) {
    	let main;
    	let div4;
    	let h4;
    	let t1;
    	let div0;
    	let span0;
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let span1;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let div2;
    	let span2;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let div3;
    	let span3;
    	let t13;
    	let t14;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div4 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Local Files";
    			t1 = space();
    			div0 = element("div");
    			span0 = element("span");
    			t2 = text("Configs Path: ");
    			t3 = text(/*config_path*/ ctx[0]);
    			t4 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t5 = text("App Configs: ");
    			t6 = text(/*config_path*/ ctx[0]);
    			t7 = text("/0L.toml");
    			t8 = space();
    			div2 = element("div");
    			span2 = element("span");
    			t9 = text("App Logs: ");
    			t10 = text(/*config_path*/ ctx[0]);
    			t11 = text("/carpe.log");
    			t12 = space();
    			div3 = element("div");
    			span3 = element("span");
    			t13 = text("Latest Proof Path: ");
    			t14 = text(/*last_proof_path*/ ctx[1]);
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$i, 17, 4, 408);
    			add_location(span0, file$i, 21, 6, 524);
    			add_location(div0, file$i, 20, 4, 512);
    			add_location(span1, file$i, 24, 6, 593);
    			add_location(div1, file$i, 23, 4, 581);
    			add_location(span2, file$i, 27, 6, 669);
    			add_location(div2, file$i, 26, 4, 657);
    			add_location(span3, file$i, 30, 6, 744);
    			add_location(div3, file$i, 29, 4, 732);
    			attr_dev(div4, "class", "uk-margin-bottom");
    			add_location(div4, file$i, 16, 2, 373);
    			add_location(main, file$i, 15, 0, 364);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div4);
    			append_dev(div4, h4);
    			append_dev(div4, t1);
    			append_dev(div4, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t2);
    			append_dev(span0, t3);
    			append_dev(div4, t4);
    			append_dev(div4, div1);
    			append_dev(div1, span1);
    			append_dev(span1, t5);
    			append_dev(span1, t6);
    			append_dev(span1, t7);
    			append_dev(div4, t8);
    			append_dev(div4, div2);
    			append_dev(div2, span2);
    			append_dev(span2, t9);
    			append_dev(span2, t10);
    			append_dev(span2, t11);
    			append_dev(div4, t12);
    			append_dev(div4, div3);
    			append_dev(div3, span3);
    			append_dev(span3, t13);
    			append_dev(span3, t14);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*config_path*/ 1) set_data_dev(t3, /*config_path*/ ctx[0]);
    			if (dirty & /*config_path*/ 1) set_data_dev(t6, /*config_path*/ ctx[0]);
    			if (dirty & /*config_path*/ 1) set_data_dev(t10, /*config_path*/ ctx[0]);
    			if (dirty & /*last_proof_path*/ 2) set_data_dev(t14, /*last_proof_path*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DebugPaths", slots, []);
    	let config_path;
    	let last_proof_path;

    	i$1("debug_highest_proof_path", {}).then(path => {
    		$$invalidate(1, last_proof_path = path);
    	});

    	i$1("debug_preferences_path", {}).then(path => {
    		$$invalidate(0, config_path = path);
    	}).catch(err => {
    		$$invalidate(0, config_path = "no local tower proofs found");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DebugPaths> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ invoke: i$1, config_path, last_proof_path });

    	$$self.$inject_state = $$props => {
    		if ("config_path" in $$props) $$invalidate(0, config_path = $$props.config_path);
    		if ("last_proof_path" in $$props) $$invalidate(1, last_proof_path = $$props.last_proof_path);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [config_path, last_proof_path];
    }

    class DebugPaths extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugPaths",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src/components/dev/DevMode.svelte generated by Svelte v3.38.1 */
    const file$h = "src/components/dev/DevMode.svelte";

    function create_fragment$h(ctx) {
    	let main;
    	let div;
    	let debugcard;
    	let t0;
    	let debugpaths;
    	let t1;
    	let debugswitcher;
    	let t2;
    	let p;
    	let t4;
    	let debugswitchrexmainnet;
    	let t5;
    	let debugswitchprodtest;
    	let t6;
    	let debugactions;
    	let current;
    	debugcard = new DebugCard({ $$inline: true });
    	debugpaths = new DebugPaths({ $$inline: true });
    	debugswitcher = new DebugSwitcher({ $$inline: true });
    	debugswitchrexmainnet = new DebugSwitchRexMainnet({ $$inline: true });
    	debugswitchprodtest = new DebugSwitchProdTest({ $$inline: true });
    	debugactions = new DebugActions({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			create_component(debugcard.$$.fragment);
    			t0 = space();
    			create_component(debugpaths.$$.fragment);
    			t1 = space();
    			create_component(debugswitcher.$$.fragment);
    			t2 = space();
    			p = element("p");
    			p.textContent = "Turn on debug actions on all screens";
    			t4 = space();
    			create_component(debugswitchrexmainnet.$$.fragment);
    			t5 = space();
    			create_component(debugswitchprodtest.$$.fragment);
    			t6 = space();
    			create_component(debugactions.$$.fragment);
    			attr_dev(p, "class", "uk-margin-bottom");
    			add_location(p, file$h, 13, 4, 526);
    			attr_dev(div, "class", "uk-margin uk-container uk-dark");
    			set_style(div, "margin-bottom", "280px");
    			add_location(div, file$h, 9, 2, 389);
    			attr_dev(main, "class", "uk-height-viewport");
    			add_location(main, file$h, 8, 0, 353);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			mount_component(debugcard, div, null);
    			append_dev(div, t0);
    			mount_component(debugpaths, div, null);
    			append_dev(div, t1);
    			mount_component(debugswitcher, div, null);
    			append_dev(div, t2);
    			append_dev(div, p);
    			append_dev(div, t4);
    			mount_component(debugswitchrexmainnet, div, null);
    			append_dev(div, t5);
    			mount_component(debugswitchprodtest, div, null);
    			append_dev(div, t6);
    			mount_component(debugactions, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(debugcard.$$.fragment, local);
    			transition_in(debugpaths.$$.fragment, local);
    			transition_in(debugswitcher.$$.fragment, local);
    			transition_in(debugswitchrexmainnet.$$.fragment, local);
    			transition_in(debugswitchprodtest.$$.fragment, local);
    			transition_in(debugactions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(debugcard.$$.fragment, local);
    			transition_out(debugpaths.$$.fragment, local);
    			transition_out(debugswitcher.$$.fragment, local);
    			transition_out(debugswitchrexmainnet.$$.fragment, local);
    			transition_out(debugswitchprodtest.$$.fragment, local);
    			transition_out(debugactions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(debugcard);
    			destroy_component(debugpaths);
    			destroy_component(debugswitcher);
    			destroy_component(debugswitchrexmainnet);
    			destroy_component(debugswitchprodtest);
    			destroy_component(debugactions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DevMode", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DevMode> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		DebugCard,
    		DebugActions,
    		DebugSwitchProdTest,
    		DebugSwitchRexMainnet,
    		DebugSwitcher,
    		DebugPaths
    	});

    	return [];
    }

    class DevMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DevMode",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/components/wallet/AccountFromMnemSubmit.svelte generated by Svelte v3.38.1 */
    const file$g = "src/components/wallet/AccountFromMnemSubmit.svelte";

    // (114:0) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function select_block_type_2(ctx, dirty) {
    		if (/*isSubmitting*/ ctx[1]) return create_if_block_2$1;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			attr_dev(button, "class", "uk-button uk-button-primary");
    			attr_dev(button, "type", "button");
    			button.disabled = /*isSubmitting*/ ctx[1];
    			add_location(button, file$g, 114, 2, 4271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_block.m(button, null);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*handleAdd*/ ctx[4]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button, null);
    				}
    			}

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button, "disabled", /*isSubmitting*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(114:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:0) {#if isNewAccount}
    function create_if_block$a(ctx) {
    	let button0;
    	let t0_value = /*$_*/ ctx[2]("wallet.keygen.btn_create_account") + "";
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let h2;
    	let t2_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.title") + "";
    	let t2;
    	let t3;
    	let p0;
    	let raw_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.body") + "";
    	let t4;
    	let p1;
    	let button1;
    	let t5_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_cancel") + "";
    	let t5;
    	let t6;
    	let button2;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isSubmitting*/ ctx[1]) return create_if_block_1$4;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			p0 = element("p");
    			t4 = space();
    			p1 = element("p");
    			button1 = element("button");
    			t5 = text(t5_value);
    			t6 = space();
    			button2 = element("button");
    			if_block.c();
    			attr_dev(button0, "class", "uk-button uk-button-secondary uk-margin-small-right");
    			button0.disabled = /*isSubmitting*/ ctx[1];
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$g, 75, 2, 3064);
    			attr_dev(h2, "class", "uk-modal-title uk-text-uppercase uk-text-alert");
    			add_location(h2, file$g, 86, 6, 3398);
    			add_location(p0, file$g, 89, 6, 3530);
    			attr_dev(button1, "class", "uk-button uk-button-default uk-modal-close");
    			attr_dev(button1, "type", "button");
    			button1.disabled = /*isSubmitting*/ ctx[1];
    			add_location(button1, file$g, 91, 8, 3628);
    			attr_dev(button2, "class", "uk-button uk-button-primary");
    			attr_dev(button2, "type", "button");
    			button2.disabled = /*isSubmitting*/ ctx[1];
    			add_location(button2, file$g, 98, 8, 3852);
    			attr_dev(p1, "class", "uk-text-right");
    			add_location(p1, file$g, 90, 6, 3594);
    			attr_dev(div0, "class", "uk-modal-dialog uk-modal-body");
    			add_location(div0, file$g, 85, 4, 3348);
    			attr_dev(div1, "id", "submit-confirmation-modal");
    			attr_dev(div1, "uk-modal", "");
    			add_location(div1, file$g, 84, 2, 3298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			append_dev(button0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p0);
    			p0.innerHTML = raw_value;
    			append_dev(div0, t4);
    			append_dev(div0, p1);
    			append_dev(p1, button1);
    			append_dev(button1, t5);
    			append_dev(p1, t6);
    			append_dev(p1, button2);
    			if_block.m(button2, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*openConfirmationModal*/ ctx[3]), false, true, false),
    					listen_dev(button2, "click", prevent_default(/*handleAdd*/ ctx[4]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.keygen.btn_create_account") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button0, "disabled", /*isSubmitting*/ ctx[1]);
    			}

    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.title") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 4 && raw_value !== (raw_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.body") + "")) p0.innerHTML = raw_value;			if (dirty & /*$_*/ 4 && t5_value !== (t5_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_cancel") + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button1, "disabled", /*isSubmitting*/ ctx[1]);
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button2, null);
    				}
    			}

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button2, "disabled", /*isSubmitting*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(75:0) {#if isNewAccount}",
    		ctx
    	});

    	return block;
    }

    // (123:4) {:else}
    function create_else_block_2(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(123:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (121:4) {#if isSubmitting}
    function create_if_block_2$1(ctx) {
    	let t0_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(121:4) {#if isSubmitting}",
    		ctx
    	});

    	return block;
    }

    // (107:10) {:else}
    function create_else_block$6(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(107:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (105:10) {#if isSubmitting}
    function create_if_block_1$4(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(105:10) {#if isSubmitting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*isNewAccount*/ ctx[0]) return create_if_block$a;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccountFromMnemSubmit", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let { danger_temp_mnem } = $$props;
    	let { isNewAccount = true } = $$props;
    	let unsubs;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = mnem.subscribe(m => $$invalidate(5, danger_temp_mnem = m));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	// const re = /[0-9A-Fa-f]{32}/g;
    	function openConfirmationModal() {
    		uikit.modal("#submit-confirmation-modal").show();
    	}

    	let isSubmitting = false;

    	function handleAdd() {
    		$$invalidate(1, isSubmitting = true);

    		// submit
    		i$1("init_from_mnem", { mnem: danger_temp_mnem.trim() }).then(res => {
    			if (isNewAccount) {
    				uikit.modal("#submit-confirmation-modal").$destroy(true); // known bug https://github.com/uikit/uikit/issues/1370
    				addNewAccount(res);
    			}

    			responses.set(JSON.stringify(res));
    			signingAccount.set(res);
    			$$invalidate(1, isSubmitting = false);
    			notify_success(`Account Added: ${res.nickname}`);

    			// load the account restored localy right away. Balance may takes few seconds to be fetched from the chain.
    			loadAccounts();

    			// set as init so we don't get sent back to Newbie account creation.
    			isInit.set(true);

    			connected.set(true); // provisionally set to true so we don't get flashed an error page.
    			scanning_fullnodes.set(false);

    			carpeTick().then(() => {
    				navigate("/");
    			}).catch(e => {
    				raise_error(e, true, "carpeTick");
    			});
    		}).catch(error => {
    			if (isNewAccount) {
    				uikit.modal("#submit-confirmation-modal").hide(); // navigate("/");
    			}

    			$$invalidate(1, isSubmitting = false);
    			raise_error(error, false, "handleAdd");
    		});
    	}

    	const writable_props = ["danger_temp_mnem", "isNewAccount"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccountFromMnemSubmit> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("danger_temp_mnem" in $$props) $$invalidate(5, danger_temp_mnem = $$props.danger_temp_mnem);
    		if ("isNewAccount" in $$props) $$invalidate(0, isNewAccount = $$props.isNewAccount);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		navigate,
    		responses,
    		signingAccount,
    		mnem,
    		isInit,
    		raise_error,
    		invoke: i$1,
    		notify_success,
    		onDestroy,
    		onMount,
    		connected,
    		scanning_fullnodes,
    		addNewAccount,
    		loadAccounts,
    		UIkit: uikit,
    		carpeTick,
    		danger_temp_mnem,
    		isNewAccount,
    		unsubs,
    		openConfirmationModal,
    		isSubmitting,
    		handleAdd,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("danger_temp_mnem" in $$props) $$invalidate(5, danger_temp_mnem = $$props.danger_temp_mnem);
    		if ("isNewAccount" in $$props) $$invalidate(0, isNewAccount = $$props.isNewAccount);
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    		if ("isSubmitting" in $$props) $$invalidate(1, isSubmitting = $$props.isSubmitting);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isNewAccount,
    		isSubmitting,
    		$_,
    		openConfirmationModal,
    		handleAdd,
    		danger_temp_mnem
    	];
    }

    class AccountFromMnemSubmit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { danger_temp_mnem: 5, isNewAccount: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountFromMnemSubmit",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*danger_temp_mnem*/ ctx[5] === undefined && !("danger_temp_mnem" in props)) {
    			console.warn("<AccountFromMnemSubmit> was created without expected prop 'danger_temp_mnem'");
    		}
    	}

    	get danger_temp_mnem() {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set danger_temp_mnem(value) {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNewAccount() {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNewAccount(value) {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/wallet/AccountFromMnemForm.svelte generated by Svelte v3.38.1 */
    const file$f = "src/components/wallet/AccountFromMnemForm.svelte";

    function create_fragment$f(ctx) {
    	let main;
    	let h3;
    	let t0_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.description") + "";
    	let t2;
    	let t3;
    	let form;
    	let fieldset;
    	let div;
    	let input;
    	let input_placeholder_value;
    	let t4;
    	let accountfrommnemsubmit;
    	let current;
    	let mounted;
    	let dispose;

    	accountfrommnemsubmit = new AccountFromMnemSubmit({
    			props: {
    				danger_temp_mnem: /*danger_temp_mnem*/ ctx[0],
    				isNewAccount: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div = element("div");
    			input = element("input");
    			t4 = space();
    			create_component(accountfrommnemsubmit.$$.fragment);
    			attr_dev(h3, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h3, file$f, 6, 2, 163);
    			add_location(p, file$f, 8, 2, 277);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", input_placeholder_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.placeholder"));
    			add_location(input, file$f, 12, 8, 464);
    			attr_dev(div, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div, file$f, 11, 6, 403);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$f, 10, 4, 366);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$f, 9, 2, 337);
    			add_location(main, file$f, 5, 0, 152);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h3);
    			append_dev(h3, t0);
    			append_dev(main, t1);
    			append_dev(main, p);
    			append_dev(p, t2);
    			append_dev(main, t3);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div);
    			append_dev(div, input);
    			set_input_value(input, /*danger_temp_mnem*/ ctx[0]);
    			append_dev(fieldset, t4);
    			mount_component(accountfrommnemsubmit, fieldset, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.title") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$_*/ 2) && t2_value !== (t2_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.description") + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*$_*/ 2 && input_placeholder_value !== (input_placeholder_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.placeholder"))) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*danger_temp_mnem*/ 1 && input.value !== /*danger_temp_mnem*/ ctx[0]) {
    				set_input_value(input, /*danger_temp_mnem*/ ctx[0]);
    			}

    			const accountfrommnemsubmit_changes = {};
    			if (dirty & /*danger_temp_mnem*/ 1) accountfrommnemsubmit_changes.danger_temp_mnem = /*danger_temp_mnem*/ ctx[0];
    			accountfrommnemsubmit.$set(accountfrommnemsubmit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountfrommnemsubmit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountfrommnemsubmit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(accountfrommnemsubmit);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccountFromMnemForm", slots, []);
    	let danger_temp_mnem;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccountFromMnemForm> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		danger_temp_mnem = this.value;
    		$$invalidate(0, danger_temp_mnem);
    	}

    	$$self.$capture_state = () => ({
    		_: X,
    		AccountFromMnemSubmit,
    		danger_temp_mnem,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("danger_temp_mnem" in $$props) $$invalidate(0, danger_temp_mnem = $$props.danger_temp_mnem);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [danger_temp_mnem, $_, input_input_handler];
    }

    class AccountFromMnemForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountFromMnemForm",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src/components/dev/Swarm.svelte generated by Svelte v3.38.1 */

    const { console: console_1$2 } = globals;
    const file$e = "src/components/dev/Swarm.svelte";

    function create_fragment$e(ctx) {
    	let main;
    	let div2;
    	let h2;
    	let t1;
    	let div0;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let p2;
    	let t7;
    	let h4;
    	let t9;
    	let p3;
    	let t10;
    	let t11;
    	let t12;
    	let p4;
    	let t13;
    	let t14_value = /*swarm_files*/ ctx[1].path_exists + "";
    	let t14;
    	let t15;
    	let t16_value = /*swarm_files*/ ctx[1].path + "";
    	let t16;
    	let t17;
    	let p5;
    	let t18;
    	let t19_value = /*swarm_files*/ ctx[1].config_path_exists + "";
    	let t19;
    	let t20;
    	let t21_value = /*swarm_files*/ ctx[1].config_path + "";
    	let t21;
    	let t22;
    	let p6;
    	let t23;
    	let t24_value = /*swarm_files*/ ctx[1].proof_exists + "";
    	let t24;
    	let t25;
    	let t26_value = /*swarm_files*/ ctx[1].proof_path + "";
    	let t26;
    	let t27;
    	let div1;
    	let button0;
    	let t29;
    	let button1;
    	let t31;
    	let button2;
    	let t33;
    	let button3;
    	let t35;
    	let button4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div2 = element("div");
    			h2 = element("h2");
    			h2.textContent = "swarm";
    			t1 = space();
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "start swarm with:";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "NODE_ENV=test cargo run -p diem-swarm -- --diem-node\n        target/debug/diem-node -c ~/.0L/swarm_temp";
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "Carpe expects the swarm files to be in ~/.0L/swarm_temp";
    			t7 = space();
    			h4 = element("h4");
    			h4.textContent = "Swarm Diagnostics";
    			t9 = space();
    			p3 = element("p");
    			t10 = text("swarm running: ");
    			t11 = text(/*swarm_running*/ ctx[0]);
    			t12 = space();
    			p4 = element("p");
    			t13 = text("swarm path: ");
    			t14 = text(t14_value);
    			t15 = text(" - ");
    			t16 = text(t16_value);
    			t17 = space();
    			p5 = element("p");
    			t18 = text("alice config path: ");
    			t19 = text(t19_value);
    			t20 = text(" - ");
    			t21 = text(t21_value);
    			t22 = space();
    			p6 = element("p");
    			t23 = text("alice proof zero path: ");
    			t24 = text(t24_value);
    			t25 = text(" - ");
    			t26 = text(t26_value);
    			t27 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Check Swarm";
    			t29 = space();
    			button1 = element("button");
    			button1.textContent = "Init Alice Files";
    			t31 = space();
    			button2 = element("button");
    			button2.textContent = "Init Alice Keys";
    			t33 = space();
    			button3 = element("button");
    			button3.textContent = "Swarm Demo Tx";
    			t35 = space();
    			button4 = element("button");
    			button4.textContent = "Mine Once";
    			add_location(h2, file$e, 68, 4, 2673);
    			add_location(p0, file$e, 70, 6, 2704);
    			add_location(p1, file$e, 71, 6, 2735);
    			add_location(p2, file$e, 76, 6, 2869);
    			add_location(div0, file$e, 69, 4, 2692);
    			add_location(h4, file$e, 78, 4, 2947);
    			add_location(p3, file$e, 79, 4, 2978);
    			add_location(p4, file$e, 80, 4, 3020);
    			add_location(p5, file$e, 81, 4, 3090);
    			add_location(p6, file$e, 84, 4, 3193);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			add_location(button0, file$e, 89, 6, 3314);
    			attr_dev(button1, "class", "uk-button uk-button-default");
    			add_location(button1, file$e, 93, 6, 3424);
    			attr_dev(button2, "class", "uk-button uk-button-default");
    			add_location(button2, file$e, 97, 6, 3543);
    			attr_dev(button3, "class", "uk-button uk-button-default");
    			add_location(button3, file$e, 101, 6, 3660);
    			attr_dev(button4, "class", "uk-button uk-button-default");
    			add_location(button4, file$e, 105, 6, 3766);
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$e, 88, 4, 3294);
    			attr_dev(div2, "class", "uk-margin");
    			add_location(div2, file$e, 67, 2, 2645);
    			add_location(main, file$e, 66, 0, 2636);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div2);
    			append_dev(div2, h2);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(div0, t5);
    			append_dev(div0, p2);
    			append_dev(div2, t7);
    			append_dev(div2, h4);
    			append_dev(div2, t9);
    			append_dev(div2, p3);
    			append_dev(p3, t10);
    			append_dev(p3, t11);
    			append_dev(div2, t12);
    			append_dev(div2, p4);
    			append_dev(p4, t13);
    			append_dev(p4, t14);
    			append_dev(p4, t15);
    			append_dev(p4, t16);
    			append_dev(div2, t17);
    			append_dev(div2, p5);
    			append_dev(p5, t18);
    			append_dev(p5, t19);
    			append_dev(p5, t20);
    			append_dev(p5, t21);
    			append_dev(div2, t22);
    			append_dev(div2, p6);
    			append_dev(p6, t23);
    			append_dev(p6, t24);
    			append_dev(p6, t25);
    			append_dev(p6, t26);
    			append_dev(div2, t27);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t29);
    			append_dev(div1, button1);
    			append_dev(div1, t31);
    			append_dev(div1, button2);
    			append_dev(div1, t33);
    			append_dev(div1, button3);
    			append_dev(div1, t35);
    			append_dev(div1, button4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*swarmCheck*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*initAliceFiles*/ ctx[2], false, false, false),
    					listen_dev(button2, "click", /*initAliceKeys*/ ctx[6], false, false, false),
    					listen_dev(button3, "click", /*demo*/ ctx[3], false, false, false),
    					listen_dev(button4, "click", /*miner*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*swarm_running*/ 1) set_data_dev(t11, /*swarm_running*/ ctx[0]);
    			if (dirty & /*swarm_files*/ 2 && t14_value !== (t14_value = /*swarm_files*/ ctx[1].path_exists + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*swarm_files*/ 2 && t16_value !== (t16_value = /*swarm_files*/ ctx[1].path + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*swarm_files*/ 2 && t19_value !== (t19_value = /*swarm_files*/ ctx[1].config_path_exists + "")) set_data_dev(t19, t19_value);
    			if (dirty & /*swarm_files*/ 2 && t21_value !== (t21_value = /*swarm_files*/ ctx[1].config_path + "")) set_data_dev(t21, t21_value);
    			if (dirty & /*swarm_files*/ 2 && t24_value !== (t24_value = /*swarm_files*/ ctx[1].proof_exists + "")) set_data_dev(t24, t24_value);
    			if (dirty & /*swarm_files*/ 2 && t26_value !== (t26_value = /*swarm_files*/ ctx[1].proof_path + "")) set_data_dev(t26, t26_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Swarm", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let home_path = "";
    	let swarm_running = "";
    	let swarm_files = "";

    	const easySwarm = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("easy_swarm", {}).then(res => result = res).catch(e => raise_error(e, false, "easySwarm"));
    	});

    	const initAliceFiles = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("init_swarm", {}).then(res => {
    			result = res;
    			swarmCheck();
    		}).catch(e => raise_error(e));
    	});

    	const demo = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("swarm_demo_tx", {}).then(res => result = res).catch(e => raise_error(e));
    	});

    	const miner = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("swarm_miner", {
    			swarmDir: home_path.concat("swarm_temp"),
    			swarmPersona: "alice"
    		}).then(res => result = res).catch(e => raise_error(e));
    	});

    	const swarmCheck = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("swarm_process", {}).then(res => $$invalidate(0, swarm_running = res)).catch(e => raise_error(e));

    		i$1("swarm_files", {}).then(res => {
    			console.log(res);
    			$$invalidate(1, swarm_files = res);
    		}).catch(e => raise_error(e));
    	});

    	const initAliceKeys = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("init_from_mnem", { mnem: alice_mnem }).then(res => {
    			responses.set(res);
    			setAccount(res);
    		}).catch(e => {
    			raise_error(e);
    		});
    	});

    	let alice_mnem = "talent sunset lizard pill fame nuclear spy noodle basket okay critic grow sleep legend hurry pitch blanket clerk impose rough degree sock insane purse";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Swarm> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		invoke: i$1,
    		setAccount,
    		raise_error,
    		responses,
    		home_path,
    		swarm_running,
    		swarm_files,
    		easySwarm,
    		initAliceFiles,
    		demo,
    		miner,
    		swarmCheck,
    		initAliceKeys,
    		alice_mnem
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("home_path" in $$props) home_path = $$props.home_path;
    		if ("swarm_running" in $$props) $$invalidate(0, swarm_running = $$props.swarm_running);
    		if ("swarm_files" in $$props) $$invalidate(1, swarm_files = $$props.swarm_files);
    		if ("alice_mnem" in $$props) alice_mnem = $$props.alice_mnem;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		swarm_running,
    		swarm_files,
    		initAliceFiles,
    		demo,
    		miner,
    		swarmCheck,
    		initAliceKeys
    	];
    }

    class Swarm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Swarm",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/components/wallet/Keygen.svelte generated by Svelte v3.38.1 */

    const { console: console_1$1 } = globals;
    const file$d = "src/components/wallet/Keygen.svelte";

    // (92:2) {:else}
    function create_else_block$5(ctx) {
    	let div0;
    	let h3;
    	let t0_value = /*$_*/ ctx[4]("wallet.keygen.description") + "";
    	let t0;
    	let t1;
    	let div1;
    	let button;
    	let t2_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys") + "";
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			button = element("button");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-text-light uk-text-muted uk-text-center");
    			add_location(h3, file$d, 94, 6, 3299);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$d, 93, 4, 3256);
    			attr_dev(button, "class", "uk-button uk-button-secondary uk-align-right");
    			add_location(button, file$d, 100, 6, 3464);
    			attr_dev(div1, "class", "uk-position-center");
    			add_location(div1, file$d, 99, 4, 3425);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h3);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*keygen*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.keygen.description") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 16 && t2_value !== (t2_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys") + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(92:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (55:2) {#if address && !hide}
    function create_if_block$9(ctx) {
    	let div1;
    	let h50;
    	let t0_value = /*$_*/ ctx[4]("wallet.keygen.account_address") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2;
    	let t3;
    	let h51;
    	let t4_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key") + "";
    	let t4;
    	let t5;
    	let p1;
    	let t6;
    	let t7;
    	let p2;
    	let t8_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key_description") + "";
    	let t8;
    	let t9;
    	let h52;
    	let t10_value = /*$_*/ ctx[4]("wallet.keygen.securite_recovery_phrase") + "";
    	let t10;
    	let t11;
    	let p3;
    	let t12_value = /*$_*/ ctx[4]("wallet.keygen.securite_note") + "";
    	let t12;
    	let t13;
    	let div0;
    	let textarea;
    	let t14;
    	let div2;
    	let p4;
    	let t15_value = /*$_*/ ctx[4]("wallet.keygen.account_tips") + "";
    	let t15;
    	let t16;
    	let div3;
    	let accountfrommnemsubmit;
    	let t17;
    	let button;
    	let t18_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys_2") + "";
    	let t18;
    	let current;
    	let mounted;
    	let dispose;

    	accountfrommnemsubmit = new AccountFromMnemSubmit({
    			props: { danger_temp_mnem: "" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h50 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(/*address*/ ctx[1]);
    			t3 = space();
    			h51 = element("h5");
    			t4 = text(t4_value);
    			t5 = space();
    			p1 = element("p");
    			t6 = text(/*authkey*/ ctx[2]);
    			t7 = space();
    			p2 = element("p");
    			t8 = text(t8_value);
    			t9 = space();
    			h52 = element("h5");
    			t10 = text(t10_value);
    			t11 = space();
    			p3 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			div0 = element("div");
    			textarea = element("textarea");
    			t14 = space();
    			div2 = element("div");
    			p4 = element("p");
    			t15 = text(t15_value);
    			t16 = space();
    			div3 = element("div");
    			create_component(accountfrommnemsubmit.$$.fragment);
    			t17 = space();
    			button = element("button");
    			t18 = text(t18_value);
    			attr_dev(h50, "class", "uk-text-muted uk-text-uppercase");
    			add_location(h50, file$d, 57, 6, 2181);
    			attr_dev(p0, "class", "uk-text-emphasis uk-text-uppercase");
    			add_location(p0, file$d, 58, 6, 2274);
    			attr_dev(h51, "class", "uk-text-muted uk-text-uppercase");
    			add_location(h51, file$d, 59, 6, 2340);
    			attr_dev(p1, "class", "uk-text-emphasis uk-text-uppercase");
    			add_location(p1, file$d, 60, 6, 2429);
    			add_location(p2, file$d, 61, 6, 2495);
    			attr_dev(h52, "class", "uk-text-muted uk-text-uppercase uk-text-danger");
    			add_location(h52, file$d, 63, 6, 2555);
    			attr_dev(p3, "class", "uk-text-danger");
    			add_location(p3, file$d, 66, 6, 2688);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "rows", "3");
    			textarea.readOnly = true;
    			textarea.value = /*display_mnem*/ ctx[0];
    			add_location(textarea, file$d, 70, 8, 2808);
    			attr_dev(div0, "class", "uk-margin");
    			add_location(div0, file$d, 69, 6, 2776);
    			attr_dev(div1, "class", "uk-margin uk-card uk-card-default uk-card-body uk-text-muted");
    			add_location(div1, file$d, 56, 4, 2100);
    			add_location(p4, file$d, 75, 6, 2923);
    			add_location(div2, file$d, 74, 4, 2911);
    			attr_dev(button, "class", "uk-button uk-button-default uk-align-right");
    			add_location(button, file$d, 83, 6, 3064);
    			add_location(div3, file$d, 80, 4, 2997);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h50);
    			append_dev(h50, t0);
    			append_dev(div1, t1);
    			append_dev(div1, p0);
    			append_dev(p0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, h51);
    			append_dev(h51, t4);
    			append_dev(div1, t5);
    			append_dev(div1, p1);
    			append_dev(p1, t6);
    			append_dev(div1, t7);
    			append_dev(div1, p2);
    			append_dev(p2, t8);
    			append_dev(div1, t9);
    			append_dev(div1, h52);
    			append_dev(h52, t10);
    			append_dev(div1, t11);
    			append_dev(div1, p3);
    			append_dev(p3, t12);
    			append_dev(div1, t13);
    			append_dev(div1, div0);
    			append_dev(div0, textarea);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, p4);
    			append_dev(p4, t15);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(accountfrommnemsubmit, div3, null);
    			append_dev(div3, t17);
    			append_dev(div3, button);
    			append_dev(button, t18);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*keygen*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 16) && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.keygen.account_address") + "")) set_data_dev(t0, t0_value);
    			if (!current || dirty & /*address*/ 2) set_data_dev(t2, /*address*/ ctx[1]);
    			if ((!current || dirty & /*$_*/ 16) && t4_value !== (t4_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key") + "")) set_data_dev(t4, t4_value);
    			if (!current || dirty & /*authkey*/ 4) set_data_dev(t6, /*authkey*/ ctx[2]);
    			if ((!current || dirty & /*$_*/ 16) && t8_value !== (t8_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key_description") + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*$_*/ 16) && t10_value !== (t10_value = /*$_*/ ctx[4]("wallet.keygen.securite_recovery_phrase") + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*$_*/ 16) && t12_value !== (t12_value = /*$_*/ ctx[4]("wallet.keygen.securite_note") + "")) set_data_dev(t12, t12_value);

    			if (!current || dirty & /*display_mnem*/ 1) {
    				prop_dev(textarea, "value", /*display_mnem*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 16) && t15_value !== (t15_value = /*$_*/ ctx[4]("wallet.keygen.account_tips") + "")) set_data_dev(t15, t15_value);
    			if ((!current || dirty & /*$_*/ 16) && t18_value !== (t18_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys_2") + "")) set_data_dev(t18, t18_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountfrommnemsubmit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountfrommnemsubmit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div3);
    			destroy_component(accountfrommnemsubmit);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(55:2) {#if address && !hide}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let main;
    	let div;
    	let h3;
    	let t0_value = /*$_*/ ctx[4]("wallet.keygen.title") + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*address*/ ctx[1] && !/*hide*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			attr_dev(h3, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h3, file$d, 49, 4, 1957);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$d, 48, 2, 1916);
    			add_location(main, file$d, 47, 0, 1907);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h3);
    			append_dev(h3, t0);
    			append_dev(main, t1);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 16) && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.keygen.title") + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Keygen", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	let display_mnem;
    	let address;
    	let authkey;
    	let unsubsMnem;
    	let unsubsSigningAccount;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsMnem = mnem.subscribe(m => $$invalidate(0, display_mnem = m));

    		unsubsSigningAccount = signingAccount.subscribe(a => {
    			$$invalidate(1, address = a.account);
    			$$invalidate(2, authkey = a.authkey);
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubsMnem && unsubsMnem();
    		unsubsSigningAccount && unsubsSigningAccount();
    	}));

    	let hide = true;

    	const keygen = () => __awaiter(void 0, void 0, void 0, function* () {
    		i$1("keygen", {}).then(res => {
    			console.log(res);
    			responses.set(JSON.stringify(res));
    			signingAccount.set(res.entry);
    			mnem.set(res.mnem);
    			$$invalidate(3, hide = false);
    		}).catch(e => raise_error(e, true, "keygen"));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Keygen> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onDestroy,
    		onMount,
    		invoke: i$1,
    		signingAccount,
    		mnem,
    		raise_error,
    		responses,
    		AccountFromMnemSubmit,
    		display_mnem,
    		address,
    		authkey,
    		unsubsMnem,
    		unsubsSigningAccount,
    		hide,
    		keygen,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("display_mnem" in $$props) $$invalidate(0, display_mnem = $$props.display_mnem);
    		if ("address" in $$props) $$invalidate(1, address = $$props.address);
    		if ("authkey" in $$props) $$invalidate(2, authkey = $$props.authkey);
    		if ("unsubsMnem" in $$props) unsubsMnem = $$props.unsubsMnem;
    		if ("unsubsSigningAccount" in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ("hide" in $$props) $$invalidate(3, hide = $$props.hide);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display_mnem, address, authkey, hide, $_, keygen];
    }

    class Keygen extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Keygen",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/components/txs/OnboardDialog.svelte generated by Svelte v3.38.1 */
    const file$c = "src/components/txs/OnboardDialog.svelte";

    // (54:12) {#if waiting}
    function create_if_block$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "ratio: 0.8");
    			set_style(span, "margin", "0px 10px 0px 0px");
    			add_location(span, file$c, 54, 14, 1606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(54:12) {#if waiting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let main;
    	let div3;
    	let div2;
    	let h2;
    	let t0_value = /*$_*/ ctx[4]("txs.onboard.title") + "";
    	let t0;
    	let t1;
    	let form;
    	let fieldset;
    	let div0;
    	let input;
    	let t2;
    	let p;
    	let t3;
    	let t4;
    	let div1;
    	let t5;
    	let button0;
    	let t6_value = /*$_*/ ctx[4]("txs.onboard.btn_cancel") + "";
    	let t6;
    	let t7;
    	let button1;

    	let t8_value = (/*waiting*/ ctx[3]
    	? /*$_*/ ctx[4]("txs.onboard.await")
    	: /*$_*/ ctx[4]("txs.onboard.btn_onboard")) + "";

    	let t8;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block = /*waiting*/ ctx[3] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div3 = element("div");
    			div2 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div0 = element("div");
    			input = element("input");
    			t2 = space();
    			p = element("p");
    			t3 = text(/*errorMessage*/ ctx[1]);
    			t4 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t5 = space();
    			button0 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			t8 = text(t8_value);
    			attr_dev(h2, "class", "uk-modal-title");
    			add_location(h2, file$c, 39, 6, 1088);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Onboard Key");
    			add_location(input, file$c, 44, 12, 1296);
    			attr_dev(div0, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div0, file$c, 43, 10, 1231);
    			attr_dev(p, "class", "uk-text-warning");
    			add_location(p, file$c, 51, 10, 1481);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-modal-close uk-margin-right");
    			add_location(button0, file$c, 56, 12, 1701);
    			button1.disabled = button1_disabled_value = /*waiting*/ ctx[3] || !/*onboard_key*/ ctx[2] || /*account*/ ctx[0].balance < 2000000;
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			attr_dev(button1, "id", "create-acc");
    			add_location(button1, file$c, 59, 12, 1856);
    			attr_dev(div1, "class", "uk-align-right");
    			add_location(div1, file$c, 52, 10, 1537);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$c, 42, 8, 1190);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$c, 41, 6, 1157);
    			attr_dev(div2, "class", "uk-modal-dialog uk-modal-body");
    			add_location(div2, file$c, 38, 4, 1038);
    			attr_dev(div3, "id", "onboardDialog");
    			attr_dev(div3, "uk-modal", "");
    			add_location(div3, file$c, 37, 2, 1000);
    			add_location(main, file$c, 36, 0, 991);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div3);
    			append_dev(div3, div2);
    			append_dev(div2, h2);
    			append_dev(h2, t0);
    			append_dev(div2, t1);
    			append_dev(div2, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*onboard_key*/ ctx[2]);
    			append_dev(fieldset, t2);
    			append_dev(fieldset, p);
    			append_dev(p, t3);
    			append_dev(fieldset, t4);
    			append_dev(fieldset, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, button0);
    			append_dev(button0, t6);
    			append_dev(div1, t7);
    			append_dev(div1, button1);
    			append_dev(button1, t8);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button1, "click", /*createUser*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("txs.onboard.title") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*onboard_key*/ 4 && input.value !== /*onboard_key*/ ctx[2]) {
    				set_input_value(input, /*onboard_key*/ ctx[2]);
    			}

    			if (dirty & /*errorMessage*/ 2) set_data_dev(t3, /*errorMessage*/ ctx[1]);

    			if (/*waiting*/ ctx[3]) {
    				if (if_block) ; else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(div1, t5);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$_*/ 16 && t6_value !== (t6_value = /*$_*/ ctx[4]("txs.onboard.btn_cancel") + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*waiting, $_*/ 24 && t8_value !== (t8_value = (/*waiting*/ ctx[3]
    			? /*$_*/ ctx[4]("txs.onboard.await")
    			: /*$_*/ ctx[4]("txs.onboard.btn_onboard")) + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*waiting, onboard_key, account*/ 13 && button1_disabled_value !== (button1_disabled_value = /*waiting*/ ctx[3] || !/*onboard_key*/ ctx[2] || /*account*/ ctx[0].balance < 2000000)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("OnboardDialog", slots, []);
    	
    	let { account } = $$props;

    	let { onSuccess = _ => {
    		
    	} } = $$props;

    	let errorMessage = "";
    	let onboard_key;
    	let waiting = false;

    	onMount(() => {
    		$$invalidate(1, errorMessage = account && account.balance < 2000000
    		? "Insuficient balance to onboard another account."
    		: "");
    	});

    	function createUser() {
    		$$invalidate(3, waiting = true);

    		// submit
    		i$1("create_user_account", { authkey: onboard_key }).then(res => {
    			responses.set(JSON.stringify(res));
    			notify_success("Account Added");
    			$$invalidate(3, waiting = false);
    			$$invalidate(2, onboard_key = null);
    			onSuccess(account);
    			uikit.modal("#onboardDialog").hide();
    		}).catch(error => {
    			$$invalidate(1, errorMessage = error.msg);
    			$$invalidate(3, waiting = false);
    		});
    	}

    	const writable_props = ["account", "onSuccess"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OnboardDialog> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		onboard_key = this.value;
    		$$invalidate(2, onboard_key);
    	}

    	$$self.$$set = $$props => {
    		if ("account" in $$props) $$invalidate(0, account = $$props.account);
    		if ("onSuccess" in $$props) $$invalidate(6, onSuccess = $$props.onSuccess);
    	};

    	$$self.$capture_state = () => ({
    		_: X,
    		invoke: i$1,
    		responses,
    		notify_success,
    		onMount,
    		UIkit: uikit,
    		account,
    		onSuccess,
    		errorMessage,
    		onboard_key,
    		waiting,
    		createUser,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("account" in $$props) $$invalidate(0, account = $$props.account);
    		if ("onSuccess" in $$props) $$invalidate(6, onSuccess = $$props.onSuccess);
    		if ("errorMessage" in $$props) $$invalidate(1, errorMessage = $$props.errorMessage);
    		if ("onboard_key" in $$props) $$invalidate(2, onboard_key = $$props.onboard_key);
    		if ("waiting" in $$props) $$invalidate(3, waiting = $$props.waiting);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		account,
    		errorMessage,
    		onboard_key,
    		waiting,
    		$_,
    		createUser,
    		onSuccess,
    		input_input_handler
    	];
    }

    class OnboardDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { account: 0, onSuccess: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OnboardDialog",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*account*/ ctx[0] === undefined && !("account" in props)) {
    			console.warn("<OnboardDialog> was created without expected prop 'account'");
    		}
    	}

    	get account() {
    		throw new Error("<OnboardDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<OnboardDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSuccess() {
    		throw new Error("<OnboardDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSuccess(value) {
    		throw new Error("<OnboardDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/txs/TransferDialog.svelte generated by Svelte v3.38.1 */
    const file$b = "src/components/txs/TransferDialog.svelte";

    // (86:6) {:else}
    function create_else_block$4(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[3]("txs.transfer.title") + "";
    	let t0;
    	let t1;
    	let form;
    	let fieldset;
    	let div1;
    	let label0;
    	let t2_value = /*$_*/ ctx[3]("txs.transfer.sender") + "";
    	let t2;
    	let t3;
    	let div0;
    	let input0;
    	let input0_value_value;
    	let t4;
    	let div3;
    	let label1;
    	let t5_value = /*$_*/ ctx[3]("txs.transfer.balance") + "";
    	let t5;
    	let t6;
    	let div2;
    	let input1;
    	let input1_value_value;
    	let t7;
    	let div5;
    	let label2;
    	let t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "";
    	let t8;
    	let t9;
    	let div4;
    	let input2;
    	let input2_placeholder_value;
    	let t10;
    	let div7;
    	let label3;
    	let t11_value = /*$_*/ ctx[3]("txs.transfer.amount_label") + "";
    	let t11;
    	let t12;
    	let div6;
    	let input3;
    	let input3_placeholder_value;
    	let t13;
    	let p;
    	let t14_value = (/*checkMessage*/ ctx[11] || /*errorMessage*/ ctx[6]) + "";
    	let t14;
    	let t15;
    	let div9;
    	let div8;
    	let t16;
    	let button0;

    	let t17_value = (/*waitingTxs*/ ctx[7]
    	? /*$_*/ ctx[3]("txs.transfer.btn_close")
    	: /*$_*/ ctx[3]("txs.transfer.btn_cancel")) + "";

    	let t17;
    	let t18;
    	let button1;

    	let t19_value = (/*waitingTxs*/ ctx[7]
    	? /*$_*/ ctx[3]("txs.transfer.await")
    	: /*$_*/ ctx[3]("txs.transfer.btn_next")) + "";

    	let t19;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block = /*waitingTxs*/ ctx[7] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div1 = element("div");
    			label0 = element("label");
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div3 = element("div");
    			label1 = element("label");
    			t5 = text(t5_value);
    			t6 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t7 = space();
    			div5 = element("div");
    			label2 = element("label");
    			t8 = text(t8_value);
    			t9 = space();
    			div4 = element("div");
    			input2 = element("input");
    			t10 = space();
    			div7 = element("div");
    			label3 = element("label");
    			t11 = text(t11_value);
    			t12 = space();
    			div6 = element("div");
    			input3 = element("input");
    			t13 = space();
    			p = element("p");
    			t14 = text(t14_value);
    			t15 = space();
    			div9 = element("div");
    			div8 = element("div");
    			if (if_block) if_block.c();
    			t16 = space();
    			button0 = element("button");
    			t17 = text(t17_value);
    			t18 = space();
    			button1 = element("button");
    			t19 = text(t19_value);
    			attr_dev(h2, "class", "uk-modal-title uk-text-muted uk-text-uppercase");
    			add_location(h2, file$b, 86, 8, 3334);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "sender-text");
    			add_location(label0, file$b, 90, 14, 3577);
    			attr_dev(input0, "id", "sender-text");
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "type", "text");
    			input0.value = input0_value_value = /*account*/ ctx[0].account;
    			set_style(input0, "pointer-events", "none");
    			add_location(input0, file$b, 92, 16, 3721);
    			attr_dev(div0, "class", "uk-form-controls");
    			add_location(div0, file$b, 91, 14, 3674);
    			attr_dev(div1, "class", "uk-width-3-4@s");
    			add_location(div1, file$b, 89, 12, 3534);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "balance-text");
    			add_location(label1, file$b, 102, 14, 4030);
    			attr_dev(input1, "id", "balance-text");
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "type", "text");
    			input1.value = input1_value_value = printCoins(/*account*/ ctx[0].balance);
    			set_style(input1, "pointer-events", "none");
    			add_location(input1, file$b, 104, 16, 4176);
    			attr_dev(div2, "class", "uk-form-controls");
    			add_location(div2, file$b, 103, 14, 4129);
    			attr_dev(div3, "class", "uk-width-1-4@s");
    			add_location(div3, file$b, 101, 12, 3987);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "receiver-text");
    			add_location(label2, file$b, 114, 14, 4496);
    			attr_dev(input2, "id", "receiver-text");
    			input2.autofocus = true;
    			input2.disabled = /*waitingTxs*/ ctx[7];
    			attr_dev(input2, "class", "uk-input");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", input2_placeholder_value = /*$_*/ ctx[3]("txs.transfer.receiver_placeholder"));
    			add_location(input2, file$b, 116, 16, 4644);
    			attr_dev(div4, "class", "uk-form-controls");
    			add_location(div4, file$b, 115, 14, 4597);
    			attr_dev(div5, "class", "uk-width-1-1");
    			add_location(div5, file$b, 113, 12, 4455);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "amount-text");
    			add_location(label3, file$b, 128, 14, 5045);
    			attr_dev(input3, "id", "amount-text");
    			input3.disabled = /*waitingTxs*/ ctx[7];
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", input3_placeholder_value = /*$_*/ ctx[3]("txs.transfer.amount_placeholder"));
    			add_location(input3, file$b, 131, 16, 5242);
    			attr_dev(div6, "class", "uk-form-controls uk-width-1-1");
    			add_location(div6, file$b, 129, 14, 5148);
    			attr_dev(div7, "class", "uk-width-1-1");
    			add_location(div7, file$b, 127, 12, 5004);
    			attr_dev(p, "class", "uk-text-warning");
    			add_location(p, file$b, 143, 12, 5661);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-modal-close uk-margin-right");
    			add_location(button0, file$b, 149, 16, 5959);
    			button1.disabled = button1_disabled_value = /*waitingTxs*/ ctx[7] || !/*isValidAmount*/ ctx[10] || !/*isReceiverValid*/ ctx[9];
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			add_location(button1, file$b, 152, 16, 6171);
    			attr_dev(div8, "class", "uk-align-right");
    			add_location(div8, file$b, 145, 14, 5776);
    			attr_dev(div9, "class", "uk-width-1-1");
    			add_location(div9, file$b, 144, 12, 5735);
    			attr_dev(fieldset, "class", "uk-fieldset uk-grid-small");
    			attr_dev(fieldset, "uk-grid", "");
    			add_location(fieldset, file$b, 88, 10, 3469);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$b, 87, 8, 3434);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div1);
    			append_dev(div1, label0);
    			append_dev(label0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, input0);
    			append_dev(fieldset, t4);
    			append_dev(fieldset, div3);
    			append_dev(div3, label1);
    			append_dev(label1, t5);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, input1);
    			append_dev(fieldset, t7);
    			append_dev(fieldset, div5);
    			append_dev(div5, label2);
    			append_dev(label2, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*receiver*/ ctx[1]);
    			append_dev(fieldset, t10);
    			append_dev(fieldset, div7);
    			append_dev(div7, label3);
    			append_dev(label3, t11);
    			append_dev(div7, t12);
    			append_dev(div7, div6);
    			append_dev(div6, input3);
    			set_input_value(input3, /*amountFormatted*/ ctx[5]);
    			/*input3_binding*/ ctx[18](input3);
    			append_dev(fieldset, t13);
    			append_dev(fieldset, p);
    			append_dev(p, t14);
    			append_dev(fieldset, t15);
    			append_dev(fieldset, div9);
    			append_dev(div9, div8);
    			if (if_block) if_block.m(div8, null);
    			append_dev(div8, t16);
    			append_dev(div8, button0);
    			append_dev(button0, t17);
    			append_dev(div8, t18);
    			append_dev(div8, button1);
    			append_dev(button1, t19);
    			input2.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[16]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[17]),
    					listen_dev(input3, "input", /*handleChange*/ ctx[14], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("txs.transfer.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 8 && t2_value !== (t2_value = /*$_*/ ctx[3]("txs.transfer.sender") + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*account*/ 1 && input0_value_value !== (input0_value_value = /*account*/ ctx[0].account) && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*$_*/ 8 && t5_value !== (t5_value = /*$_*/ ctx[3]("txs.transfer.balance") + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*account*/ 1 && input1_value_value !== (input1_value_value = printCoins(/*account*/ ctx[0].balance)) && input1.value !== input1_value_value) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (dirty & /*$_*/ 8 && t8_value !== (t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*waitingTxs*/ 128) {
    				prop_dev(input2, "disabled", /*waitingTxs*/ ctx[7]);
    			}

    			if (dirty & /*$_*/ 8 && input2_placeholder_value !== (input2_placeholder_value = /*$_*/ ctx[3]("txs.transfer.receiver_placeholder"))) {
    				attr_dev(input2, "placeholder", input2_placeholder_value);
    			}

    			if (dirty & /*receiver*/ 2 && input2.value !== /*receiver*/ ctx[1]) {
    				set_input_value(input2, /*receiver*/ ctx[1]);
    			}

    			if (dirty & /*$_*/ 8 && t11_value !== (t11_value = /*$_*/ ctx[3]("txs.transfer.amount_label") + "")) set_data_dev(t11, t11_value);

    			if (dirty & /*waitingTxs*/ 128) {
    				prop_dev(input3, "disabled", /*waitingTxs*/ ctx[7]);
    			}

    			if (dirty & /*$_*/ 8 && input3_placeholder_value !== (input3_placeholder_value = /*$_*/ ctx[3]("txs.transfer.amount_placeholder"))) {
    				attr_dev(input3, "placeholder", input3_placeholder_value);
    			}

    			if (dirty & /*amountFormatted*/ 32 && input3.value !== /*amountFormatted*/ ctx[5]) {
    				set_input_value(input3, /*amountFormatted*/ ctx[5]);
    			}

    			if (dirty & /*checkMessage, errorMessage*/ 2112 && t14_value !== (t14_value = (/*checkMessage*/ ctx[11] || /*errorMessage*/ ctx[6]) + "")) set_data_dev(t14, t14_value);

    			if (/*waitingTxs*/ ctx[7]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					if_block.m(div8, t16);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*waitingTxs, $_*/ 136 && t17_value !== (t17_value = (/*waitingTxs*/ ctx[7]
    			? /*$_*/ ctx[3]("txs.transfer.btn_close")
    			: /*$_*/ ctx[3]("txs.transfer.btn_cancel")) + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*waitingTxs, $_*/ 136 && t19_value !== (t19_value = (/*waitingTxs*/ ctx[7]
    			? /*$_*/ ctx[3]("txs.transfer.await")
    			: /*$_*/ ctx[3]("txs.transfer.btn_next")) + "")) set_data_dev(t19, t19_value);

    			if (dirty & /*waitingTxs, isValidAmount, isReceiverValid*/ 1664 && button1_disabled_value !== (button1_disabled_value = /*waitingTxs*/ ctx[7] || !/*isValidAmount*/ ctx[10] || !/*isReceiverValid*/ ctx[9])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(form);
    			/*input3_binding*/ ctx[18](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(86:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:6) {#if waitingConfirmation}
    function create_if_block$7(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[3]("txs.transfer.confirm_title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[3]("txs.transfer.please_confirm") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[3]("txs.transfer.sender") + "";
    	let t4;
    	let t5;
    	let span0;
    	let t6_value = /*account*/ ctx[0].account + "";
    	let t6;
    	let t7;
    	let p2;
    	let t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "";
    	let t8;
    	let t9;
    	let span1;
    	let t10;
    	let t11;
    	let p3;
    	let t12_value = /*$_*/ ctx[3]("txs.transfer.amount") + "";
    	let t12;
    	let t13;
    	let span2;
    	let t14_value = printUnscaledCoins(/*amount*/ ctx[2]) + "";
    	let t14;
    	let t15;
    	let p4;
    	let button0;
    	let t16_value = /*$_*/ ctx[3]("txs.transfer.btn_cancel") + "";
    	let t16;
    	let t17;
    	let button1;
    	let t18_value = /*$_*/ ctx[3]("txs.transfer.btn_confirm") + "";
    	let t18;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = text(": ");
    			span0 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			p2 = element("p");
    			t8 = text(t8_value);
    			t9 = text(": ");
    			span1 = element("span");
    			t10 = text(/*receiver*/ ctx[1]);
    			t11 = space();
    			p3 = element("p");
    			t12 = text(t12_value);
    			t13 = text(": ");
    			span2 = element("span");
    			t14 = text(t14_value);
    			t15 = space();
    			p4 = element("p");
    			button0 = element("button");
    			t16 = text(t16_value);
    			t17 = space();
    			button1 = element("button");
    			t18 = text(t18_value);
    			attr_dev(h2, "class", "uk-modal-title uk-text-muted");
    			add_location(h2, file$b, 75, 8, 2470);
    			add_location(p0, file$b, 76, 8, 2559);
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$b, 77, 66, 2668);
    			attr_dev(p1, "class", "uk-text-uppercase");
    			add_location(p1, file$b, 77, 8, 2610);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$b, 78, 68, 2792);
    			attr_dev(p2, "class", "uk-text-uppercase");
    			add_location(p2, file$b, 78, 8, 2732);
    			attr_dev(span2, "class", "uk-text-bold");
    			add_location(span2, file$b, 79, 66, 2907);
    			attr_dev(p3, "class", "uk-text-uppercase");
    			add_location(p3, file$b, 79, 8, 2849);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-margin-right");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$b, 82, 12, 3025);
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$b, 83, 12, 3175);
    			attr_dev(p4, "class", "uk-text-right");
    			add_location(p4, file$b, 81, 8, 2987);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t4);
    			append_dev(p1, t5);
    			append_dev(p1, span0);
    			append_dev(span0, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t8);
    			append_dev(p2, t9);
    			append_dev(p2, span1);
    			append_dev(span1, t10);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p3, anchor);
    			append_dev(p3, t12);
    			append_dev(p3, t13);
    			append_dev(p3, span2);
    			append_dev(span2, t14);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, p4, anchor);
    			append_dev(p4, button0);
    			append_dev(button0, t16);
    			append_dev(p4, t17);
    			append_dev(p4, button1);
    			append_dev(button1, t18);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*cancelClick*/ ctx[12], false, false, false),
    					listen_dev(button1, "click", /*confirmClick*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("txs.transfer.confirm_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 8 && t2_value !== (t2_value = /*$_*/ ctx[3]("txs.transfer.please_confirm") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 8 && t4_value !== (t4_value = /*$_*/ ctx[3]("txs.transfer.sender") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*account*/ 1 && t6_value !== (t6_value = /*account*/ ctx[0].account + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 8 && t8_value !== (t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*receiver*/ 2) set_data_dev(t10, /*receiver*/ ctx[1]);
    			if (dirty & /*$_*/ 8 && t12_value !== (t12_value = /*$_*/ ctx[3]("txs.transfer.amount") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*amount*/ 4 && t14_value !== (t14_value = printUnscaledCoins(/*amount*/ ctx[2]) + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*$_*/ 8 && t16_value !== (t16_value = /*$_*/ ctx[3]("txs.transfer.btn_cancel") + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*$_*/ 8 && t18_value !== (t18_value = /*$_*/ ctx[3]("txs.transfer.btn_confirm") + "")) set_data_dev(t18, t18_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(p4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(75:6) {#if waitingConfirmation}",
    		ctx
    	});

    	return block;
    }

    // (147:16) {#if waitingTxs}
    function create_if_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "ratio: 0.8");
    			set_style(span, "margin", "0px 10px 0px 0px");
    			add_location(span, file$b, 147, 18, 5856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(147:16) {#if waitingTxs}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let main;
    	let div1;
    	let div0;

    	function select_block_type(ctx, dirty) {
    		if (/*waitingConfirmation*/ ctx[8]) return create_if_block$7;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "uk-modal-dialog uk-modal-body");
    			add_location(div0, file$b, 73, 4, 2386);
    			attr_dev(div1, "id", "coinTransferDialog");
    			attr_dev(div1, "uk-modal", "");
    			add_location(div1, file$b, 72, 2, 2343);
    			add_location(main, file$b, 71, 0, 2334);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			if_block.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const re = /[a-fA-F0-9]{32}/i;

    function instance$b($$self, $$props, $$invalidate) {
    	let isReceiverValid;
    	let isValidAmount;
    	let checkMessage;
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(3, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TransferDialog", slots, []);
    	let { account } = $$props;

    	let { onSuccess = () => {
    		
    	} } = $$props;

    	const errorDic = {
    		"120127": $_("txs.transfer.error_slow_wallet"),
    		"1004": $_("txs.transfer.error_account_does_not_exist")
    	};

    	let receiver;
    	let amountInput;
    	let amount = 0;
    	let amountFormatted = "";
    	let errorMessage = "";
    	let waitingTxs = false;
    	let waitingConfirmation = false;

    	const transferCoins = () => {
    		$$invalidate(7, waitingTxs = true);

    		i$1("coin_transfer", { receiver: receiver.trim(), amount }).then(res => {
    			responses.set(JSON.stringify(res));
    			notify_success($_("txs.transfer.success"));
    			$$invalidate(7, waitingTxs = false);
    			$$invalidate(2, amount = null);
    			$$invalidate(5, amountFormatted = "");
    			$$invalidate(1, receiver = null);

    			// callback
    			onSuccess();

    			// close modal
    			uikit.modal("#coinTransferDialog").hide();
    		}).catch(error => {
    			$$invalidate(6, errorMessage = errorDic[error.msg]
    			? errorDic[error.msg]
    			: $_("txs.transfer.failed", { values: { code: error.msg } }));

    			$$invalidate(7, waitingTxs = false);
    		});
    	};

    	const cancelClick = () => {
    		$$invalidate(8, waitingConfirmation = false);
    	};

    	const confirmClick = () => {
    		$$invalidate(8, waitingConfirmation = false);
    		transferCoins();
    	};

    	const handleChange = () => {
    		let cleanedInput = amountInput.value.replace(/\D*/gm, "").replace(/^0+/gm, ""); // remove non digits
    		// remove leading zeros 

    		if (cleanedInput.length === 0) {
    			$$invalidate(2, amount = 0);
    			$$invalidate(5, amountFormatted = "");
    		} else {
    			$$invalidate(2, amount = parseInt(cleanedInput));
    			$$invalidate(5, amountFormatted = printUnscaledCoins(amount, 0, 0));
    		}
    	};

    	const writable_props = ["account", "onSuccess"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TransferDialog> was created with unknown prop '${key}'`);
    	});

    	function input2_input_handler() {
    		receiver = this.value;
    		$$invalidate(1, receiver);
    	}

    	function input3_input_handler() {
    		amountFormatted = this.value;
    		$$invalidate(5, amountFormatted);
    	}

    	function input3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			amountInput = $$value;
    			$$invalidate(4, amountInput);
    		});
    	}

    	const click_handler = () => $$invalidate(8, waitingConfirmation = true);

    	$$self.$$set = $$props => {
    		if ("account" in $$props) $$invalidate(0, account = $$props.account);
    		if ("onSuccess" in $$props) $$invalidate(15, onSuccess = $$props.onSuccess);
    	};

    	$$self.$capture_state = () => ({
    		_: X,
    		responses,
    		notify_success,
    		invoke: i$1,
    		UIkit: uikit,
    		unscaledCoins,
    		printUnscaledCoins,
    		printCoins,
    		account,
    		onSuccess,
    		errorDic,
    		receiver,
    		amountInput,
    		amount,
    		amountFormatted,
    		errorMessage,
    		waitingTxs,
    		waitingConfirmation,
    		re,
    		transferCoins,
    		cancelClick,
    		confirmClick,
    		handleChange,
    		$_,
    		isReceiverValid,
    		isValidAmount,
    		checkMessage
    	});

    	$$self.$inject_state = $$props => {
    		if ("account" in $$props) $$invalidate(0, account = $$props.account);
    		if ("onSuccess" in $$props) $$invalidate(15, onSuccess = $$props.onSuccess);
    		if ("receiver" in $$props) $$invalidate(1, receiver = $$props.receiver);
    		if ("amountInput" in $$props) $$invalidate(4, amountInput = $$props.amountInput);
    		if ("amount" in $$props) $$invalidate(2, amount = $$props.amount);
    		if ("amountFormatted" in $$props) $$invalidate(5, amountFormatted = $$props.amountFormatted);
    		if ("errorMessage" in $$props) $$invalidate(6, errorMessage = $$props.errorMessage);
    		if ("waitingTxs" in $$props) $$invalidate(7, waitingTxs = $$props.waitingTxs);
    		if ("waitingConfirmation" in $$props) $$invalidate(8, waitingConfirmation = $$props.waitingConfirmation);
    		if ("isReceiverValid" in $$props) $$invalidate(9, isReceiverValid = $$props.isReceiverValid);
    		if ("isValidAmount" in $$props) $$invalidate(10, isValidAmount = $$props.isValidAmount);
    		if ("checkMessage" in $$props) $$invalidate(11, checkMessage = $$props.checkMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*receiver, account*/ 3) {
    			$$invalidate(9, isReceiverValid = receiver && re.test(receiver) && receiver != account.account);
    		}

    		if ($$self.$$.dirty & /*amount, account*/ 5) {
    			$$invalidate(10, isValidAmount = amount > 0 && amount < unscaledCoins(account.balance));
    		}

    		if ($$self.$$.dirty & /*amount, account, $_, receiver*/ 15) {
    			$$invalidate(11, checkMessage = amount > unscaledCoins(account.balance)
    			? $_("txs.transfer.error_amount_greater_than_balance")
    			: receiver && receiver.toUpperCase() == account.account.toUpperCase()
    				? $_("txs.transfer.error_receiver_equals_sender")
    				: "");
    		}
    	};

    	return [
    		account,
    		receiver,
    		amount,
    		$_,
    		amountInput,
    		amountFormatted,
    		errorMessage,
    		waitingTxs,
    		waitingConfirmation,
    		isReceiverValid,
    		isValidAmount,
    		checkMessage,
    		cancelClick,
    		confirmClick,
    		handleChange,
    		onSuccess,
    		input2_input_handler,
    		input3_input_handler,
    		input3_binding,
    		click_handler
    	];
    }

    class TransferDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { account: 0, onSuccess: 15 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TransferDialog",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*account*/ ctx[0] === undefined && !("account" in props)) {
    			console.warn("<TransferDialog> was created without expected prop 'account'");
    		}
    	}

    	get account() {
    		throw new Error("<TransferDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<TransferDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSuccess() {
    		throw new Error("<TransferDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSuccess(value) {
    		throw new Error("<TransferDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/txs/Transactions.svelte generated by Svelte v3.38.1 */
    const file$a = "src/components/txs/Transactions.svelte";

    // (55:2) {:else}
    function create_else_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(55:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:2) {#if account}
    function create_if_block$6(ctx) {
    	let div1;
    	let div0;
    	let h40;
    	let span0;
    	let t0_value = /*$_*/ ctx[1]("txs.account") + "";
    	let t0;
    	let t1;
    	let t2;
    	let span1;
    	let t3_value = /*account*/ ctx[0].account + "";
    	let t3;
    	let t4;
    	let h41;
    	let span2;
    	let t5_value = /*$_*/ ctx[1]("txs.balance") + "";
    	let t5;
    	let t6;
    	let t7;
    	let span3;
    	let t8_value = printCoins(/*account*/ ctx[0].balance) + "";
    	let t8;
    	let t9;
    	let button0;
    	let t10_value = /*$_*/ ctx[1]("txs.btn_onboard") + "";
    	let t10;
    	let t11;
    	let button1;
    	let t12_value = /*$_*/ ctx[1]("txs.btn_transfer") + "";
    	let t12;
    	let t13;
    	let onboarddialog;
    	let t14;
    	let transferdialog;
    	let current;

    	onboarddialog = new OnboardDialog({
    			props: {
    				account: /*account*/ ctx[0],
    				onSuccess: /*onSuccess*/ ctx[2]
    			},
    			$$inline: true
    		});

    	transferdialog = new TransferDialog({
    			props: {
    				account: /*account*/ ctx[0],
    				onSuccess: /*onSuccess*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h40 = element("h4");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text(":");
    			t2 = space();
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			h41 = element("h4");
    			span2 = element("span");
    			t5 = text(t5_value);
    			t6 = text(":");
    			t7 = space();
    			span3 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			button0 = element("button");
    			t10 = text(t10_value);
    			t11 = space();
    			button1 = element("button");
    			t12 = text(t12_value);
    			t13 = space();
    			create_component(onboarddialog.$$.fragment);
    			t14 = space();
    			create_component(transferdialog.$$.fragment);
    			attr_dev(span0, "class", "uk-text-uppercase");
    			add_location(span0, file$a, 39, 10, 1666);
    			attr_dev(span1, "class", "uk-text-bold uk-text-uppercase");
    			add_location(span1, file$a, 40, 10, 1738);
    			attr_dev(h40, "class", "uk-text-muted");
    			add_location(h40, file$a, 38, 8, 1629);
    			attr_dev(span2, "class", "uk-text-uppercase");
    			add_location(span2, file$a, 44, 10, 1868);
    			attr_dev(span3, "class", "uk-text-bold");
    			add_location(span3, file$a, 45, 10, 1939);
    			attr_dev(h41, "class", "uk-text-muted");
    			add_location(h41, file$a, 43, 8, 1831);
    			attr_dev(div0, "class", "uk-section");
    			add_location(div0, file$a, 37, 6, 1596);
    			attr_dev(button0, "uk-toggle", "target: #onboardDialog");
    			attr_dev(button0, "class", "uk-button uk-button-default uk-margin-right");
    			add_location(button0, file$a, 49, 6, 2041);
    			attr_dev(button1, "uk-toggle", "target: #coinTransferDialog");
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			add_location(button1, file$a, 50, 6, 2175);
    			attr_dev(div1, "class", "uk-text-center");
    			add_location(div1, file$a, 36, 4, 1561);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h40);
    			append_dev(h40, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(h40, t2);
    			append_dev(h40, span1);
    			append_dev(span1, t3);
    			append_dev(div0, t4);
    			append_dev(div0, h41);
    			append_dev(h41, span2);
    			append_dev(span2, t5);
    			append_dev(span2, t6);
    			append_dev(h41, t7);
    			append_dev(h41, span3);
    			append_dev(span3, t8);
    			append_dev(div1, t9);
    			append_dev(div1, button0);
    			append_dev(button0, t10);
    			append_dev(div1, t11);
    			append_dev(div1, button1);
    			append_dev(button1, t12);
    			insert_dev(target, t13, anchor);
    			mount_component(onboarddialog, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(transferdialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("txs.account") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*account*/ 1) && t3_value !== (t3_value = /*account*/ ctx[0].account + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*$_*/ 2) && t5_value !== (t5_value = /*$_*/ ctx[1]("txs.balance") + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*account*/ 1) && t8_value !== (t8_value = printCoins(/*account*/ ctx[0].balance) + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*$_*/ 2) && t10_value !== (t10_value = /*$_*/ ctx[1]("txs.btn_onboard") + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*$_*/ 2) && t12_value !== (t12_value = /*$_*/ ctx[1]("txs.btn_transfer") + "")) set_data_dev(t12, t12_value);
    			const onboarddialog_changes = {};
    			if (dirty & /*account*/ 1) onboarddialog_changes.account = /*account*/ ctx[0];
    			onboarddialog.$set(onboarddialog_changes);
    			const transferdialog_changes = {};
    			if (dirty & /*account*/ 1) transferdialog_changes.account = /*account*/ ctx[0];
    			transferdialog.$set(transferdialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(onboarddialog.$$.fragment, local);
    			transition_in(transferdialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(onboarddialog.$$.fragment, local);
    			transition_out(transferdialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t13);
    			destroy_component(onboarddialog, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(transferdialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(36:2) {#if account}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let main;
    	let div;
    	let h2;
    	let t0_value = /*$_*/ ctx[1]("nav.transactions") + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*account*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$a, 31, 4, 1419);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$a, 30, 2, 1378);
    			add_location(main, file$a, 29, 0, 1369);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("nav.transactions") + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Transactions", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let account;
    	let unsubs;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = signingAccount.subscribe(obj => $$invalidate(0, account = obj));
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	const onSuccess = () => {
    		checkSigningAccountBalance();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Transactions> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		_: X,
    		onDestroy,
    		onMount,
    		signingAccount,
    		OnboardDialog,
    		printCoins,
    		checkSigningAccountBalance,
    		TransferDialog,
    		account,
    		unsubs,
    		onSuccess,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("account" in $$props) $$invalidate(0, account = $$props.account);
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [account, $_, onSuccess];
    }

    class Transactions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Transactions",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/components/events/PageNumber.svelte generated by Svelte v3.38.1 */

    const file$9 = "src/components/events/PageNumber.svelte";

    function create_fragment$9(ctx) {
    	let a;
    	let div;
    	let span;
    	let t;
    	let div_class_value;
    	let a_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			div = element("div");
    			span = element("span");
    			t = text(/*number*/ ctx[1]);
    			attr_dev(span, "class", "page-index-number svelte-x6ry1i");
    			add_location(span, file$9, 6, 4, 286);

    			attr_dev(div, "class", div_class_value = "uk-text-center page-index " + (/*number*/ ctx[1] == /*index*/ ctx[0]
    			? "page-index-selected"
    			: "page-index-not-selected") + " svelte-x6ry1i");

    			add_location(div, file$9, 5, 2, 170);
    			attr_dev(a, "id", a_id_value = "pageIndex" + /*number*/ ctx[1]);
    			attr_dev(a, "class", "uk-align-left page-index-link svelte-x6ry1i");
    			add_location(a, file$9, 4, 0, 66);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div);
    			append_dev(div, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*number*/ 2) set_data_dev(t, /*number*/ ctx[1]);

    			if (dirty & /*number, index*/ 3 && div_class_value !== (div_class_value = "uk-text-center page-index " + (/*number*/ ctx[1] == /*index*/ ctx[0]
    			? "page-index-selected"
    			: "page-index-not-selected") + " svelte-x6ry1i")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*number*/ 2 && a_id_value !== (a_id_value = "pageIndex" + /*number*/ ctx[1])) {
    				attr_dev(a, "id", a_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PageNumber", slots, []);
    	let { number } = $$props;
    	let { index } = $$props;
    	const writable_props = ["number", "index"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PageNumber> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, index = number);

    	$$self.$$set = $$props => {
    		if ("number" in $$props) $$invalidate(1, number = $$props.number);
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    	};

    	$$self.$capture_state = () => ({ number, index });

    	$$self.$inject_state = $$props => {
    		if ("number" in $$props) $$invalidate(1, number = $$props.number);
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [index, number, click_handler];
    }

    class PageNumber extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { number: 1, index: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PageNumber",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*number*/ ctx[1] === undefined && !("number" in props)) {
    			console.warn("<PageNumber> was created without expected prop 'number'");
    		}

    		if (/*index*/ ctx[0] === undefined && !("index" in props)) {
    			console.warn("<PageNumber> was created without expected prop 'index'");
    		}
    	}

    	get number() {
    		throw new Error("<PageNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set number(value) {
    		throw new Error("<PageNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<PageNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<PageNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/events/EventsTable.svelte generated by Svelte v3.38.1 */

    const { Object: Object_1 } = globals;
    const file$8 = "src/components/events/EventsTable.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    // (51:6) {#each pages[pageIndex] as event}
    function create_each_block_1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*event*/ ctx[29].transaction_version + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*formatEventType*/ ctx[5](/*event*/ ctx[29].data.type) + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = printCoins(/*event*/ ctx[29].data.amount.amount) + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*event*/ ctx[29].data.sender + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*event*/ ctx[29].data.receiver + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text(t8_value);
    			t9 = space();
    			attr_dev(td0, "class", "uk-text-right");
    			add_location(td0, file$8, 52, 10, 1500);
    			attr_dev(td1, "class", "uk-text-center");
    			add_location(td1, file$8, 53, 10, 1569);
    			attr_dev(td2, "class", "uk-text-right");
    			add_location(td2, file$8, 54, 10, 1646);
    			attr_dev(td3, "class", "uk-text-center");
    			add_location(td3, file$8, 55, 10, 1726);
    			attr_dev(td4, "class", "uk-text-center");
    			add_location(td4, file$8, 56, 10, 1788);
    			add_location(tr, file$8, 51, 8, 1485);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pages, pageIndex*/ 5 && t0_value !== (t0_value = /*event*/ ctx[29].transaction_version + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*pages, pageIndex*/ 5 && t2_value !== (t2_value = /*formatEventType*/ ctx[5](/*event*/ ctx[29].data.type) + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*pages, pageIndex*/ 5 && t4_value !== (t4_value = printCoins(/*event*/ ctx[29].data.amount.amount) + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*pages, pageIndex*/ 5 && t6_value !== (t6_value = /*event*/ ctx[29].data.sender + "")) set_data_dev(t6, t6_value);
    			if (dirty[0] & /*pages, pageIndex*/ 5 && t8_value !== (t8_value = /*event*/ ctx[29].data.receiver + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(51:6) {#each pages[pageIndex] as event}",
    		ctx
    	});

    	return block;
    }

    // (78:2) {#if Object.keys(pages).length > 1}
    function create_if_block$5(ctx) {
    	let div1;
    	let a0;
    	let span0;
    	let t0;
    	let div0;
    	let show_if;
    	let show_if_1;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let a1;
    	let span1;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$2, create_if_block_2, create_if_block_3, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*pages*/ 4) show_if = !!(Object.keys(/*pages*/ ctx[2]).length <= 7);
    		if (show_if) return 0;
    		if (/*pageIndex*/ ctx[0] <= 4) return 1;
    		if (dirty[0] & /*pages, pageIndex*/ 5) show_if_1 = !!(Object.keys(/*pages*/ ctx[2]).length - /*pageIndex*/ ctx[0] < 4);
    		if (show_if_1) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx, [-1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			a0 = element("a");
    			span0 = element("span");
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			a1 = element("a");
    			span1 = element("span");
    			attr_dev(span0, "uk-icon", "chevron-left");
    			add_location(span0, file$8, 84, 8, 2317);
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "previous-page-btn uk-align-left uk-text-center svelte-1022rtd");
    			add_location(a0, file$8, 79, 6, 2176);
    			attr_dev(div0, "class", "page-numbers-container uk-align-left  svelte-1022rtd");
    			add_location(div0, file$8, 86, 6, 2371);
    			attr_dev(span1, "uk-icon", "chevron-right");
    			add_location(span1, file$8, 126, 8, 4485);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "next-page-btn uk-align-left uk-text-center svelte-1022rtd");
    			add_location(a1, file$8, 121, 6, 4354);
    			attr_dev(div1, "class", "pagination-container uk-text-center svelte-1022rtd");
    			add_location(div1, file$8, 78, 4, 2120);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a0);
    			append_dev(a0, span0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			append_dev(div1, a1);
    			append_dev(a1, span1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*previousPageClick*/ ctx[3], false, false, false),
    					listen_dev(a1, "click", /*nextPageClick*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(78:2) {#if Object.keys(pages).length > 1}",
    		ctx
    	});

    	return block;
    }

    // (112:8) {:else}
    function create_else_block$2(ctx) {
    	let pagenumber0;
    	let updating_index;
    	let t0;
    	let div0;
    	let t2;
    	let pagenumber1;
    	let updating_index_1;
    	let t3;
    	let pagenumber2;
    	let updating_index_2;
    	let t4;
    	let pagenumber3;
    	let updating_index_3;
    	let t5;
    	let div1;
    	let t7;
    	let pagenumber4;
    	let updating_index_4;
    	let current;

    	function pagenumber0_index_binding_2(value) {
    		/*pagenumber0_index_binding_2*/ ctx[20](value);
    	}

    	let pagenumber0_props = { number: 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber0_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber0 = new PageNumber({ props: pagenumber0_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber0, "index", pagenumber0_index_binding_2));

    	function pagenumber1_index_binding_2(value) {
    		/*pagenumber1_index_binding_2*/ ctx[21](value);
    	}

    	let pagenumber1_props = { number: /*pageIndex*/ ctx[0] - 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber1_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber1 = new PageNumber({ props: pagenumber1_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber1, "index", pagenumber1_index_binding_2));

    	function pagenumber2_index_binding_2(value) {
    		/*pagenumber2_index_binding_2*/ ctx[22](value);
    	}

    	let pagenumber2_props = { number: /*pageIndex*/ ctx[0] };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber2_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber2 = new PageNumber({ props: pagenumber2_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber2, "index", pagenumber2_index_binding_2));

    	function pagenumber3_index_binding_2(value) {
    		/*pagenumber3_index_binding_2*/ ctx[23](value);
    	}

    	let pagenumber3_props = { number: /*pageIndex*/ ctx[0] + 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber3_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber3 = new PageNumber({ props: pagenumber3_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber3, "index", pagenumber3_index_binding_2));

    	function pagenumber4_index_binding_2(value) {
    		/*pagenumber4_index_binding_2*/ ctx[24](value);
    	}

    	let pagenumber4_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber4_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber4 = new PageNumber({ props: pagenumber4_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber4, "index", pagenumber4_index_binding_2));

    	const block = {
    		c: function create() {
    			create_component(pagenumber0.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "...";
    			t2 = space();
    			create_component(pagenumber1.$$.fragment);
    			t3 = space();
    			create_component(pagenumber2.$$.fragment);
    			t4 = space();
    			create_component(pagenumber3.$$.fragment);
    			t5 = space();
    			div1 = element("div");
    			div1.textContent = "...";
    			t7 = space();
    			create_component(pagenumber4.$$.fragment);
    			attr_dev(div0, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div0, file$8, 113, 10, 3895);
    			attr_dev(div1, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div1, file$8, 117, 10, 4176);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pagenumber1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pagenumber2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(pagenumber3, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(pagenumber4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber0_changes = {};

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber0_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber0.$set(pagenumber0_changes);
    			const pagenumber1_changes = {};
    			if (dirty[0] & /*pageIndex*/ 1) pagenumber1_changes.number = /*pageIndex*/ ctx[0] - 1;

    			if (!updating_index_1 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_1 = true;
    				pagenumber1_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_1 = false);
    			}

    			pagenumber1.$set(pagenumber1_changes);
    			const pagenumber2_changes = {};
    			if (dirty[0] & /*pageIndex*/ 1) pagenumber2_changes.number = /*pageIndex*/ ctx[0];

    			if (!updating_index_2 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_2 = true;
    				pagenumber2_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_2 = false);
    			}

    			pagenumber2.$set(pagenumber2_changes);
    			const pagenumber3_changes = {};
    			if (dirty[0] & /*pageIndex*/ 1) pagenumber3_changes.number = /*pageIndex*/ ctx[0] + 1;

    			if (!updating_index_3 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_3 = true;
    				pagenumber3_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_3 = false);
    			}

    			pagenumber3.$set(pagenumber3_changes);
    			const pagenumber4_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber4_changes.number = Object.keys(/*pages*/ ctx[2]).length;

    			if (!updating_index_4 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_4 = true;
    				pagenumber4_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_4 = false);
    			}

    			pagenumber4.$set(pagenumber4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber0.$$.fragment, local);
    			transition_in(pagenumber1.$$.fragment, local);
    			transition_in(pagenumber2.$$.fragment, local);
    			transition_in(pagenumber3.$$.fragment, local);
    			transition_in(pagenumber4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber0.$$.fragment, local);
    			transition_out(pagenumber1.$$.fragment, local);
    			transition_out(pagenumber2.$$.fragment, local);
    			transition_out(pagenumber3.$$.fragment, local);
    			transition_out(pagenumber4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			destroy_component(pagenumber1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pagenumber2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(pagenumber3, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			destroy_component(pagenumber4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(112:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (103:60) 
    function create_if_block_3(ctx) {
    	let pagenumber0;
    	let updating_index;
    	let t0;
    	let div;
    	let t2;
    	let pagenumber1;
    	let updating_index_1;
    	let t3;
    	let pagenumber2;
    	let updating_index_2;
    	let t4;
    	let pagenumber3;
    	let updating_index_3;
    	let t5;
    	let pagenumber4;
    	let updating_index_4;
    	let t6;
    	let pagenumber5;
    	let updating_index_5;
    	let current;

    	function pagenumber0_index_binding_1(value) {
    		/*pagenumber0_index_binding_1*/ ctx[14](value);
    	}

    	let pagenumber0_props = { number: 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber0_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber0 = new PageNumber({ props: pagenumber0_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber0, "index", pagenumber0_index_binding_1));

    	function pagenumber1_index_binding_1(value) {
    		/*pagenumber1_index_binding_1*/ ctx[15](value);
    	}

    	let pagenumber1_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length - 4
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber1_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber1 = new PageNumber({ props: pagenumber1_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber1, "index", pagenumber1_index_binding_1));

    	function pagenumber2_index_binding_1(value) {
    		/*pagenumber2_index_binding_1*/ ctx[16](value);
    	}

    	let pagenumber2_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length - 3
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber2_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber2 = new PageNumber({ props: pagenumber2_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber2, "index", pagenumber2_index_binding_1));

    	function pagenumber3_index_binding_1(value) {
    		/*pagenumber3_index_binding_1*/ ctx[17](value);
    	}

    	let pagenumber3_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length - 2
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber3_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber3 = new PageNumber({ props: pagenumber3_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber3, "index", pagenumber3_index_binding_1));

    	function pagenumber4_index_binding_1(value) {
    		/*pagenumber4_index_binding_1*/ ctx[18](value);
    	}

    	let pagenumber4_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length - 1
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber4_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber4 = new PageNumber({ props: pagenumber4_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber4, "index", pagenumber4_index_binding_1));

    	function pagenumber5_index_binding_1(value) {
    		/*pagenumber5_index_binding_1*/ ctx[19](value);
    	}

    	let pagenumber5_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber5_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber5 = new PageNumber({ props: pagenumber5_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber5, "index", pagenumber5_index_binding_1));

    	const block = {
    		c: function create() {
    			create_component(pagenumber0.$$.fragment);
    			t0 = space();
    			div = element("div");
    			div.textContent = "...";
    			t2 = space();
    			create_component(pagenumber1.$$.fragment);
    			t3 = space();
    			create_component(pagenumber2.$$.fragment);
    			t4 = space();
    			create_component(pagenumber3.$$.fragment);
    			t5 = space();
    			create_component(pagenumber4.$$.fragment);
    			t6 = space();
    			create_component(pagenumber5.$$.fragment);
    			attr_dev(div, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div, file$8, 104, 10, 3293);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pagenumber1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pagenumber2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(pagenumber3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(pagenumber4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(pagenumber5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber0_changes = {};

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber0_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber0.$set(pagenumber0_changes);
    			const pagenumber1_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber1_changes.number = Object.keys(/*pages*/ ctx[2]).length - 4;

    			if (!updating_index_1 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_1 = true;
    				pagenumber1_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_1 = false);
    			}

    			pagenumber1.$set(pagenumber1_changes);
    			const pagenumber2_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber2_changes.number = Object.keys(/*pages*/ ctx[2]).length - 3;

    			if (!updating_index_2 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_2 = true;
    				pagenumber2_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_2 = false);
    			}

    			pagenumber2.$set(pagenumber2_changes);
    			const pagenumber3_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber3_changes.number = Object.keys(/*pages*/ ctx[2]).length - 2;

    			if (!updating_index_3 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_3 = true;
    				pagenumber3_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_3 = false);
    			}

    			pagenumber3.$set(pagenumber3_changes);
    			const pagenumber4_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber4_changes.number = Object.keys(/*pages*/ ctx[2]).length - 1;

    			if (!updating_index_4 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_4 = true;
    				pagenumber4_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_4 = false);
    			}

    			pagenumber4.$set(pagenumber4_changes);
    			const pagenumber5_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber5_changes.number = Object.keys(/*pages*/ ctx[2]).length;

    			if (!updating_index_5 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_5 = true;
    				pagenumber5_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_5 = false);
    			}

    			pagenumber5.$set(pagenumber5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber0.$$.fragment, local);
    			transition_in(pagenumber1.$$.fragment, local);
    			transition_in(pagenumber2.$$.fragment, local);
    			transition_in(pagenumber3.$$.fragment, local);
    			transition_in(pagenumber4.$$.fragment, local);
    			transition_in(pagenumber5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber0.$$.fragment, local);
    			transition_out(pagenumber1.$$.fragment, local);
    			transition_out(pagenumber2.$$.fragment, local);
    			transition_out(pagenumber3.$$.fragment, local);
    			transition_out(pagenumber4.$$.fragment, local);
    			transition_out(pagenumber5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);
    			destroy_component(pagenumber1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pagenumber2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(pagenumber3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(pagenumber4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(pagenumber5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(103:60) ",
    		ctx
    	});

    	return block;
    }

    // (94:33) 
    function create_if_block_2(ctx) {
    	let pagenumber0;
    	let updating_index;
    	let t0;
    	let pagenumber1;
    	let updating_index_1;
    	let t1;
    	let pagenumber2;
    	let updating_index_2;
    	let t2;
    	let pagenumber3;
    	let updating_index_3;
    	let t3;
    	let pagenumber4;
    	let updating_index_4;
    	let t4;
    	let div;
    	let t6;
    	let pagenumber5;
    	let updating_index_5;
    	let current;

    	function pagenumber0_index_binding(value) {
    		/*pagenumber0_index_binding*/ ctx[8](value);
    	}

    	let pagenumber0_props = { number: 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber0_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber0 = new PageNumber({ props: pagenumber0_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber0, "index", pagenumber0_index_binding));

    	function pagenumber1_index_binding(value) {
    		/*pagenumber1_index_binding*/ ctx[9](value);
    	}

    	let pagenumber1_props = { number: 2 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber1_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber1 = new PageNumber({ props: pagenumber1_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber1, "index", pagenumber1_index_binding));

    	function pagenumber2_index_binding(value) {
    		/*pagenumber2_index_binding*/ ctx[10](value);
    	}

    	let pagenumber2_props = { number: 3 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber2_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber2 = new PageNumber({ props: pagenumber2_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber2, "index", pagenumber2_index_binding));

    	function pagenumber3_index_binding(value) {
    		/*pagenumber3_index_binding*/ ctx[11](value);
    	}

    	let pagenumber3_props = { number: 4 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber3_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber3 = new PageNumber({ props: pagenumber3_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber3, "index", pagenumber3_index_binding));

    	function pagenumber4_index_binding(value) {
    		/*pagenumber4_index_binding*/ ctx[12](value);
    	}

    	let pagenumber4_props = { number: 5 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber4_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber4 = new PageNumber({ props: pagenumber4_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber4, "index", pagenumber4_index_binding));

    	function pagenumber5_index_binding(value) {
    		/*pagenumber5_index_binding*/ ctx[13](value);
    	}

    	let pagenumber5_props = {
    		number: Object.keys(/*pages*/ ctx[2]).length
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber5_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber5 = new PageNumber({ props: pagenumber5_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber5, "index", pagenumber5_index_binding));

    	const block = {
    		c: function create() {
    			create_component(pagenumber0.$$.fragment);
    			t0 = space();
    			create_component(pagenumber1.$$.fragment);
    			t1 = space();
    			create_component(pagenumber2.$$.fragment);
    			t2 = space();
    			create_component(pagenumber3.$$.fragment);
    			t3 = space();
    			create_component(pagenumber4.$$.fragment);
    			t4 = space();
    			div = element("div");
    			div.textContent = "...";
    			t6 = space();
    			create_component(pagenumber5.$$.fragment);
    			attr_dev(div, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div, file$8, 99, 10, 2994);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pagenumber1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pagenumber2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pagenumber3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pagenumber4, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(pagenumber5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber0_changes = {};

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber0_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber0.$set(pagenumber0_changes);
    			const pagenumber1_changes = {};

    			if (!updating_index_1 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_1 = true;
    				pagenumber1_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_1 = false);
    			}

    			pagenumber1.$set(pagenumber1_changes);
    			const pagenumber2_changes = {};

    			if (!updating_index_2 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_2 = true;
    				pagenumber2_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_2 = false);
    			}

    			pagenumber2.$set(pagenumber2_changes);
    			const pagenumber3_changes = {};

    			if (!updating_index_3 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_3 = true;
    				pagenumber3_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_3 = false);
    			}

    			pagenumber3.$set(pagenumber3_changes);
    			const pagenumber4_changes = {};

    			if (!updating_index_4 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_4 = true;
    				pagenumber4_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_4 = false);
    			}

    			pagenumber4.$set(pagenumber4_changes);
    			const pagenumber5_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber5_changes.number = Object.keys(/*pages*/ ctx[2]).length;

    			if (!updating_index_5 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_5 = true;
    				pagenumber5_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_5 = false);
    			}

    			pagenumber5.$set(pagenumber5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber0.$$.fragment, local);
    			transition_in(pagenumber1.$$.fragment, local);
    			transition_in(pagenumber2.$$.fragment, local);
    			transition_in(pagenumber3.$$.fragment, local);
    			transition_in(pagenumber4.$$.fragment, local);
    			transition_in(pagenumber5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber0.$$.fragment, local);
    			transition_out(pagenumber1.$$.fragment, local);
    			transition_out(pagenumber2.$$.fragment, local);
    			transition_out(pagenumber3.$$.fragment, local);
    			transition_out(pagenumber4.$$.fragment, local);
    			transition_out(pagenumber5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(pagenumber1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pagenumber2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(pagenumber3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pagenumber4, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t6);
    			destroy_component(pagenumber5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(94:33) ",
    		ctx
    	});

    	return block;
    }

    // (89:8) {#if Object.keys(pages).length <= 7}
    function create_if_block_1$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = Object.keys(/*pages*/ ctx[2]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pages, pageIndex*/ 5) {
    				each_value = Object.keys(/*pages*/ ctx[2]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(89:8) {#if Object.keys(pages).length <= 7}",
    		ctx
    	});

    	return block;
    }

    // (90:10) {#each Object.keys(pages) as number}
    function create_each_block$2(ctx) {
    	let pagenumber;
    	let updating_index;
    	let current;

    	function pagenumber_index_binding(value) {
    		/*pagenumber_index_binding*/ ctx[7](value);
    	}

    	let pagenumber_props = { number: Number(/*number*/ ctx[26]) };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber = new PageNumber({ props: pagenumber_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber, "index", pagenumber_index_binding));

    	const block = {
    		c: function create() {
    			create_component(pagenumber.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber_changes = {};
    			if (dirty[0] & /*pages*/ 4) pagenumber_changes.number = Number(/*number*/ ctx[26]);

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber.$set(pagenumber_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(90:10) {#each Object.keys(pages) as number}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let main;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0_value = /*$_*/ ctx[1]("events.version") + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*$_*/ ctx[1]("events.type") + "";
    	let t2;
    	let t3;
    	let th2;
    	let t4_value = /*$_*/ ctx[1]("events.amount") + "";
    	let t4;
    	let t5;
    	let th3;
    	let t6_value = /*$_*/ ctx[1]("events.sender") + "";
    	let t6;
    	let t7;
    	let th4;
    	let t8_value = /*$_*/ ctx[1]("events.receiver") + "";
    	let t8;
    	let t9;
    	let tbody;
    	let t10;
    	let show_if = Object.keys(/*pages*/ ctx[2]).length > 1;
    	let current;
    	let each_value_1 = /*pages*/ ctx[2][/*pageIndex*/ ctx[0]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block = show_if && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			t6 = text(t6_value);
    			t7 = space();
    			th4 = element("th");
    			t8 = text(t8_value);
    			t9 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t10 = space();
    			if (if_block) if_block.c();
    			attr_dev(th0, "class", "uk-text-right");
    			add_location(th0, file$8, 42, 8, 1079);
    			attr_dev(th1, "class", "uk-text-center");
    			set_style(th1, "width", "98px");
    			add_location(th1, file$8, 43, 8, 1141);
    			attr_dev(th2, "class", "uk-text-right");
    			add_location(th2, file$8, 44, 8, 1221);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$8, 45, 8, 1282);
    			attr_dev(th4, "class", "uk-text-center");
    			add_location(th4, file$8, 46, 8, 1344);
    			add_location(tr, file$8, 41, 6, 1066);
    			add_location(thead, file$8, 40, 4, 1052);
    			add_location(tbody, file$8, 49, 4, 1429);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$8, 39, 2, 1006);
    			add_location(main, file$8, 37, 0, 980);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			append_dev(table, t9);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(main, t10);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("events.version") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty[0] & /*$_*/ 2) && t2_value !== (t2_value = /*$_*/ ctx[1]("events.type") + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty[0] & /*$_*/ 2) && t4_value !== (t4_value = /*$_*/ ctx[1]("events.amount") + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty[0] & /*$_*/ 2) && t6_value !== (t6_value = /*$_*/ ctx[1]("events.sender") + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*$_*/ 2) && t8_value !== (t8_value = /*$_*/ ctx[1]("events.receiver") + "")) set_data_dev(t8, t8_value);

    			if (dirty[0] & /*pages, pageIndex, formatEventType*/ 37) {
    				each_value_1 = /*pages*/ ctx[2][/*pageIndex*/ ctx[0]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*pages*/ 4) show_if = Object.keys(/*pages*/ ctx[2]).length > 1;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*pages*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const maxPageSize = 5;

    function splitPages(items, pageSize) {
    	let ret = {};
    	let num = 1;

    	for (let i = 0; i < items.length; i = i + pageSize) {
    		let nextPage = items.slice(i, i + pageSize);
    		ret[num] = nextPage;
    		num++;
    	}

    	return ret;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let pages;
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EventsTable", slots, []);
    	let { events } = $$props;

    	const eventTypesDic = {
    		receivedpayment: $_("events.received_payment"),
    		sentpayment: $_("events.sent_payment")
    	};

    	let pageIndex = 1; // [ 1 ... pages length ]

    	function previousPageClick() {
    		if (pageIndex > 1) {
    			$$invalidate(0, pageIndex = pageIndex - 1);
    		}
    	}

    	function nextPageClick() {
    		if (pageIndex < Object.keys(pages).length) {
    			$$invalidate(0, pageIndex = pageIndex + 1);
    		}
    	}

    	function formatEventType(type) {
    		const value = eventTypesDic[type];
    		return value || type;
    	}

    	const writable_props = ["events"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EventsTable> was created with unknown prop '${key}'`);
    	});

    	function pagenumber_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber0_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber1_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber2_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber3_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber4_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber5_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber0_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber1_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber2_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber3_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber4_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber5_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber0_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber1_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber2_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber3_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber4_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	$$self.$$set = $$props => {
    		if ("events" in $$props) $$invalidate(6, events = $$props.events);
    	};

    	$$self.$capture_state = () => ({
    		_: X,
    		PageNumber,
    		printCoins,
    		events,
    		maxPageSize,
    		eventTypesDic,
    		pageIndex,
    		splitPages,
    		previousPageClick,
    		nextPageClick,
    		formatEventType,
    		$_,
    		pages
    	});

    	$$self.$inject_state = $$props => {
    		if ("events" in $$props) $$invalidate(6, events = $$props.events);
    		if ("pageIndex" in $$props) $$invalidate(0, pageIndex = $$props.pageIndex);
    		if ("pages" in $$props) $$invalidate(2, pages = $$props.pages);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*events*/ 64) {
    			$$invalidate(2, pages = splitPages(events, maxPageSize));
    		}
    	};

    	return [
    		pageIndex,
    		$_,
    		pages,
    		previousPageClick,
    		nextPageClick,
    		formatEventType,
    		events,
    		pagenumber_index_binding,
    		pagenumber0_index_binding,
    		pagenumber1_index_binding,
    		pagenumber2_index_binding,
    		pagenumber3_index_binding,
    		pagenumber4_index_binding,
    		pagenumber5_index_binding,
    		pagenumber0_index_binding_1,
    		pagenumber1_index_binding_1,
    		pagenumber2_index_binding_1,
    		pagenumber3_index_binding_1,
    		pagenumber4_index_binding_1,
    		pagenumber5_index_binding_1,
    		pagenumber0_index_binding_2,
    		pagenumber1_index_binding_2,
    		pagenumber2_index_binding_2,
    		pagenumber3_index_binding_2,
    		pagenumber4_index_binding_2
    	];
    }

    class EventsTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { events: 6 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsTable",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*events*/ ctx[6] === undefined && !("events" in props)) {
    			console.warn("<EventsTable> was created without expected prop 'events'");
    		}
    	}

    	get events() {
    		throw new Error("<EventsTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set events(value) {
    		throw new Error("<EventsTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/events/EventsTableDummy.svelte generated by Svelte v3.38.1 */
    const file$7 = "src/components/events/EventsTableDummy.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (24:6) {#each dummyEvents as event}
    function create_each_block$1(ctx) {
    	let tr;
    	let td0;
    	let span0;
    	let t0_value = /*event*/ ctx[3].version + "";
    	let t0;
    	let t1;
    	let td1;
    	let span1;
    	let t2_value = /*event*/ ctx[3].type + "";
    	let t2;
    	let t3;
    	let td2;
    	let span2;
    	let t4_value = /*event*/ ctx[3].amount + "";
    	let t4;
    	let t5;
    	let td3;
    	let span3;
    	let t6_value = /*event*/ ctx[3].sender + "";
    	let t6;
    	let t7;
    	let td4;
    	let span4;
    	let t8_value = /*event*/ ctx[3].receiver + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			td4 = element("td");
    			span4 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			attr_dev(span0, "class", "dummy-container svelte-1adt5y8");
    			add_location(span0, file$7, 25, 36, 1574);
    			attr_dev(td0, "class", "uk-text-right");
    			add_location(td0, file$7, 25, 10, 1548);
    			attr_dev(span1, "class", "dummy-container svelte-1adt5y8");
    			add_location(span1, file$7, 26, 37, 1669);
    			attr_dev(td1, "class", "uk-text-center");
    			add_location(td1, file$7, 26, 10, 1642);
    			attr_dev(span2, "class", "dummy-container svelte-1adt5y8");
    			add_location(span2, file$7, 27, 36, 1760);
    			attr_dev(td2, "class", "uk-text-right");
    			add_location(td2, file$7, 27, 10, 1734);
    			attr_dev(span3, "class", "dummy-container svelte-1adt5y8");
    			add_location(span3, file$7, 28, 37, 1854);
    			attr_dev(td3, "class", "uk-text-center");
    			add_location(td3, file$7, 28, 10, 1827);
    			attr_dev(span4, "class", "dummy-container svelte-1adt5y8");
    			add_location(span4, file$7, 29, 37, 1948);
    			attr_dev(td4, "class", "uk-text-center");
    			add_location(td4, file$7, 29, 10, 1921);
    			add_location(tr, file$7, 24, 8, 1533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, span0);
    			append_dev(span0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, span1);
    			append_dev(span1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, span2);
    			append_dev(span2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, span3);
    			append_dev(span3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, span4);
    			append_dev(span4, t8);
    			append_dev(tr, t9);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(24:6) {#each dummyEvents as event}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let main;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let span0;
    	let t0_value = /*$_*/ ctx[0]("events.version") + "";
    	let t0;
    	let t1;
    	let th1;
    	let span1;
    	let t2_value = /*$_*/ ctx[0]("events.type") + "";
    	let t2;
    	let t3;
    	let th2;
    	let span2;
    	let t4_value = /*$_*/ ctx[0]("events.amount") + "";
    	let t4;
    	let t5;
    	let th3;
    	let span3;
    	let t6_value = /*$_*/ ctx[0]("events.sender") + "";
    	let t6;
    	let t7;
    	let th4;
    	let span4;
    	let t8_value = /*$_*/ ctx[0]("events.receiver") + "";
    	let t8;
    	let t9;
    	let tbody;
    	let each_value = /*dummyEvents*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			th4 = element("th");
    			span4 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span0, "class", "dummy-container svelte-1adt5y8");
    			add_location(span0, file$7, 15, 34, 993);
    			attr_dev(th0, "class", "uk-text-right");
    			add_location(th0, file$7, 15, 8, 967);
    			attr_dev(span1, "class", "dummy-container svelte-1adt5y8");
    			add_location(span1, file$7, 16, 35, 1093);
    			attr_dev(th1, "class", "uk-text-center");
    			add_location(th1, file$7, 16, 8, 1066);
    			attr_dev(span2, "class", "dummy-container svelte-1adt5y8");
    			add_location(span2, file$7, 17, 34, 1189);
    			attr_dev(th2, "class", "uk-text-right");
    			add_location(th2, file$7, 17, 8, 1163);
    			attr_dev(span3, "class", "dummy-container svelte-1adt5y8");
    			add_location(span3, file$7, 18, 35, 1288);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$7, 18, 8, 1261);
    			attr_dev(span4, "class", "dummy-container svelte-1adt5y8");
    			add_location(span4, file$7, 19, 35, 1387);
    			attr_dev(th4, "class", "uk-text-center");
    			add_location(th4, file$7, 19, 8, 1360);
    			add_location(tr, file$7, 14, 6, 954);
    			add_location(thead, file$7, 13, 4, 940);
    			add_location(tbody, file$7, 22, 4, 1482);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$7, 12, 2, 894);
    			add_location(main, file$7, 11, 0, 885);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, span0);
    			append_dev(span0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, span1);
    			append_dev(span1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, span2);
    			append_dev(span2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, span3);
    			append_dev(span3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, span4);
    			append_dev(span4, t8);
    			append_dev(table, t9);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("events.version") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("events.type") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("events.amount") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("events.sender") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 1 && t8_value !== (t8_value = /*$_*/ ctx[0]("events.receiver") + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*dummyEvents*/ 2) {
    				each_value = /*dummyEvents*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EventsTableDummy", slots, []);
    	let received = $_("events.received_payment");

    	let dummyEvents = [
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EventsTableDummy> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, received, dummyEvents, $_ });

    	$$self.$inject_state = $$props => {
    		if ("received" in $$props) received = $$props.received;
    		if ("dummyEvents" in $$props) $$invalidate(1, dummyEvents = $$props.dummyEvents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$_, dummyEvents];
    }

    class EventsTableDummy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsTableDummy",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/components/events/EventsError.svelte generated by Svelte v3.38.1 */
    const file$6 = "src/components/events/EventsError.svelte";

    function create_fragment$6(ctx) {
    	let main;
    	let div1;
    	let h3;
    	let t0_value = /*$_*/ ctx[1]("events.loading.error") + "";
    	let t0;
    	let t1;
    	let div0;
    	let p;
    	let t2;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			p = element("p");
    			t2 = text(/*loadingError*/ ctx[0]);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-muted");
    			add_location(h3, file$6, 8, 6, 188);
    			add_location(p, file$6, 10, 8, 302);
    			add_location(div0, file$6, 9, 6, 288);
    			attr_dev(div1, "class", "uk-card uk-card-default uk-card-hover uk-card-body uk-text-muted");
    			add_location(div1, file$6, 7, 4, 103);
    			add_location(main, file$6, 6, 0, 92);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, h3);
    			append_dev(h3, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("events.loading.error") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*loadingError*/ 1) set_data_dev(t2, /*loadingError*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EventsError", slots, []);
    	let { loadingError } = $$props;
    	const writable_props = ["loadingError"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EventsError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("loadingError" in $$props) $$invalidate(0, loadingError = $$props.loadingError);
    	};

    	$$self.$capture_state = () => ({ _: X, loadingError, $_ });

    	$$self.$inject_state = $$props => {
    		if ("loadingError" in $$props) $$invalidate(0, loadingError = $$props.loadingError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadingError, $_];
    }

    class EventsError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { loadingError: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsError",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*loadingError*/ ctx[0] === undefined && !("loadingError" in props)) {
    			console.warn("<EventsError> was created without expected prop 'loadingError'");
    		}
    	}

    	get loadingError() {
    		throw new Error("<EventsError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadingError(value) {
    		throw new Error("<EventsError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/events/Events.svelte generated by Svelte v3.38.1 */
    const file$5 = "src/components/events/Events.svelte";

    // (53:4) {:else}
    function create_else_block$1(ctx) {
    	let eventstable;
    	let current;

    	eventstable = new EventsTable({
    			props: { events: /*events*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(eventstable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventstable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventstable_changes = {};
    			if (dirty & /*events*/ 1) eventstable_changes.events = /*events*/ ctx[0];
    			eventstable.$set(eventstable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventstable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventstable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventstable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(53:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (50:29) 
    function create_if_block_1$1(ctx) {
    	let span;
    	let t;
    	let eventstabledummy;
    	let current;
    	eventstabledummy = new EventsTableDummy({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = space();
    			create_component(eventstabledummy.$$.fragment);
    			attr_dev(span, "uk-spinner", "");
    			set_style(span, "position", "absolute");
    			set_style(span, "top", "0px");
    			set_style(span, "left", "0px");
    			add_location(span, file$5, 50, 6, 2253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(eventstabledummy, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventstabledummy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventstabledummy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t);
    			destroy_component(eventstabledummy, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(50:29) ",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#if loadingError}
    function create_if_block$4(ctx) {
    	let eventserror;
    	let current;

    	eventserror = new EventsError({
    			props: { loadingError: /*loadingError*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(eventserror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventserror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventserror_changes = {};
    			if (dirty & /*loadingError*/ 2) eventserror_changes.loadingError = /*loadingError*/ ctx[1];
    			eventserror.$set(eventserror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventserror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventserror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventserror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(48:4) {#if loadingError}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let main;
    	let div1;
    	let div0;
    	let h2;
    	let t0_value = /*$_*/ ctx[2]("events.account_events") + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$4, create_if_block_1$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loadingError*/ ctx[1]) return 0;
    		if (/*events*/ ctx[0] == null) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$5, 45, 6, 2052);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$5, 44, 4, 2009);
    			set_style(div1, "position", "relative");
    			add_location(div1, file$5, 43, 2, 1973);
    			add_location(main, file$5, 42, 0, 1964);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div1, t1);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 4) && t0_value !== (t0_value = /*$_*/ ctx[2]("events.account_events") + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Events", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let events = null;
    	let myAccount = null;
    	let unsubscribeAccount;
    	let unsubscribeEvents;
    	let loadingError = null;

    	const errors = {
    		"corrupted_db": $_("events.loading.corrupted_db"),
    		"account_not_on_chain": $_("events.loading.account_off_chain")
    	};

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubscribeAccount = signingAccount.subscribe(account => {
    			if (myAccount && myAccount.account == account.account) {
    				return;
    			}

    			$$invalidate(1, loadingError = null);
    			myAccount = account;
    			getAccountEvents(myAccount, error => $$invalidate(1, loadingError = errors[error] || error));

    			unsubscribeEvents = accountEvents.subscribe(all => {
    				$$invalidate(0, events = all[myAccount.account]);
    			});
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubscribeAccount && unsubscribeAccount();
    		unsubscribeEvents && unsubscribeEvents();
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Events> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		onDestroy,
    		accountEvents,
    		signingAccount,
    		getAccountEvents,
    		EventsTable,
    		EventsTableDummy,
    		_: X,
    		EventsError,
    		events,
    		myAccount,
    		unsubscribeAccount,
    		unsubscribeEvents,
    		loadingError,
    		errors,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("events" in $$props) $$invalidate(0, events = $$props.events);
    		if ("myAccount" in $$props) myAccount = $$props.myAccount;
    		if ("unsubscribeAccount" in $$props) unsubscribeAccount = $$props.unsubscribeAccount;
    		if ("unsubscribeEvents" in $$props) unsubscribeEvents = $$props.unsubscribeEvents;
    		if ("loadingError" in $$props) $$invalidate(1, loadingError = $$props.loadingError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [events, loadingError, $_];
    }

    class Events extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Events",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/components/about/About.svelte generated by Svelte v3.38.1 */
    const file$4 = "src/components/about/About.svelte";

    function create_fragment$4(ctx) {
    	let main;
    	let div0;
    	let h2;
    	let t0_value = /*$_*/ ctx[1]("about.about") + "";
    	let t0;
    	let t1;
    	let div1;
    	let h3;
    	let t2_value = /*$_*/ ctx[1]("about.release") + "";
    	let t2;
    	let t3;
    	let p0;
    	let span0;
    	let t4_value = /*$_*/ ctx[1]("about.version") + "";
    	let t4;
    	let t5;
    	let t6;
    	let t7_value = /*release*/ ctx[0].version + "";
    	let t7;
    	let t8;
    	let p1;
    	let span1;
    	let t9_value = /*$_*/ ctx[1]("about.commit") + "";
    	let t9;
    	let t10;
    	let t11_value = /*release*/ ctx[0].hash + "";
    	let t11;
    	let t12;
    	let p2;
    	let span2;
    	let t13_value = /*$_*/ ctx[1]("about.branch") + "";
    	let t13;
    	let t14;
    	let t15_value = /*release*/ ctx[0].head + "";
    	let t15;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			h3 = element("h3");
    			t2 = text(t2_value);
    			t3 = space();
    			p0 = element("p");
    			span0 = element("span");
    			t4 = text(t4_value);
    			t5 = text(": ");
    			t6 = text("v");
    			t7 = text(t7_value);
    			t8 = space();
    			p1 = element("p");
    			span1 = element("span");
    			t9 = text(t9_value);
    			t10 = text(": ");
    			t11 = text(t11_value);
    			t12 = space();
    			p2 = element("p");
    			span2 = element("span");
    			t13 = text(t13_value);
    			t14 = text(": ");
    			t15 = text(t15_value);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$4, 15, 4, 343);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$4, 14, 2, 302);
    			attr_dev(h3, "class", "uk-card-title uk-text-muted");
    			add_location(h3, file$4, 18, 4, 507);
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$4, 20, 6, 610);
    			attr_dev(p0, "class", "uk-text-muted");
    			add_location(p0, file$4, 19, 4, 578);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$4, 23, 6, 731);
    			attr_dev(p1, "class", "uk-text-muted");
    			add_location(p1, file$4, 22, 4, 699);
    			attr_dev(span2, "class", "uk-text-bold");
    			add_location(span2, file$4, 26, 6, 847);
    			attr_dev(p2, "class", "uk-text-muted");
    			add_location(p2, file$4, 25, 4, 815);
    			attr_dev(div1, "class", "uk-card uk-card-default uk-card-body uk-width-1-2@m");
    			add_location(div1, file$4, 17, 2, 437);
    			attr_dev(main, "class", "uk-height-viewport");
    			add_location(main, file$4, 13, 0, 266);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, h3);
    			append_dev(h3, t2);
    			append_dev(div1, t3);
    			append_dev(div1, p0);
    			append_dev(p0, span0);
    			append_dev(span0, t4);
    			append_dev(span0, t5);
    			append_dev(p0, t6);
    			append_dev(p0, t7);
    			append_dev(div1, t8);
    			append_dev(div1, p1);
    			append_dev(p1, span1);
    			append_dev(span1, t9);
    			append_dev(span1, t10);
    			append_dev(p1, t11);
    			append_dev(div1, t12);
    			append_dev(div1, p2);
    			append_dev(p2, span2);
    			append_dev(span2, t13);
    			append_dev(span2, t14);
    			append_dev(p2, t15);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("about.about") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("about.release") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 2 && t4_value !== (t4_value = /*$_*/ ctx[1]("about.version") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*release*/ 1 && t7_value !== (t7_value = /*release*/ ctx[0].version + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*$_*/ 2 && t9_value !== (t9_value = /*$_*/ ctx[1]("about.commit") + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*release*/ 1 && t11_value !== (t11_value = /*release*/ ctx[0].hash + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*$_*/ 2 && t13_value !== (t13_value = /*$_*/ ctx[1]("about.branch") + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*release*/ 1 && t15_value !== (t15_value = /*release*/ ctx[0].head + "")) set_data_dev(t15, t15_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("About", slots, []);
    	let release = {};

    	onMount(async () => {
    		getVersion();
    		app_version.subscribe(v => $$invalidate(0, release = v));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		getVersion,
    		app_version,
    		_: X,
    		release,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("release" in $$props) $$invalidate(0, release = $$props.release);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [release, $_];
    }

    class About extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/components/layout/SearchingFullnodes.svelte generated by Svelte v3.38.1 */
    const file$3 = "src/components/layout/SearchingFullnodes.svelte";

    // (11:2) {#if isLoaded && scanning}
    function create_if_block$3(ctx) {
    	let div1;
    	let span;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			span.textContent = "Attempting to connect to blockchain  ";
    			div0 = element("div");
    			attr_dev(span, "class", "uk-text-uppercase");
    			add_location(span, file$3, 12, 6, 426);
    			attr_dev(div0, "uk-spinner", "ratio: 0.5");
    			attr_dev(div0, "class", "uk-padding");
    			add_location(div0, file$3, 12, 83, 503);
    			attr_dev(div1, "class", "uk-background-primary uk-light uk-text-center uk-padding");
    			add_location(div1, file$3, 11, 4, 349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			append_dev(div1, div0);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(11:2) {#if isLoaded && scanning}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let main;
    	let if_block = /*isLoaded*/ ctx[1] && /*scanning*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$3, 9, 0, 309);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isLoaded*/ ctx[1] && /*scanning*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SearchingFullnodes", slots, []);
    	let scanning = true;
    	let isLoaded = false;
    	isAccountsLoaded.subscribe(boo => $$invalidate(1, isLoaded = boo));
    	scanning_fullnodes.subscribe(b => $$invalidate(0, scanning = b));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchingFullnodes> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: X,
    		scanning_fullnodes,
    		isAccountsLoaded,
    		scanning,
    		isLoaded
    	});

    	$$self.$inject_state = $$props => {
    		if ("scanning" in $$props) $$invalidate(0, scanning = $$props.scanning);
    		if ("isLoaded" in $$props) $$invalidate(1, isLoaded = $$props.isLoaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [scanning, isLoaded];
    }

    class SearchingFullnodes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchingFullnodes",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/components/layout/RecoveryMode.svelte generated by Svelte v3.38.1 */

    const { console: console_1 } = globals;
    const file$2 = "src/components/layout/RecoveryMode.svelte";

    // (19:2) {#if is_recovery}
    function create_if_block$2(ctx) {
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot],
    					title: [create_title_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardalert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardalert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_, epoch_recovery_ends*/ 14) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardalert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(19:2) {#if is_recovery}",
    		ctx
    	});

    	return block;
    }

    // (21:4) 
    function create_title_slot(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[2]("layout.recovery_mode.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$2, 20, 4, 518);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("layout.recovery_mode.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(21:4) ",
    		ctx
    	});

    	return block;
    }

    // (23:4) 
    function create_body_slot(ctx) {
    	let div;

    	let t_value = /*$_*/ ctx[2]("layout.recovery_mode.body", {
    		values: {
    			epoch_recovery_ends: /*epoch_recovery_ends*/ ctx[1],
    			epoch_recovery_ends_after: /*epoch_recovery_ends*/ ctx[1] + 1
    		}
    	}) + "";

    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$2, 22, 4, 589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, epoch_recovery_ends*/ 6 && t_value !== (t_value = /*$_*/ ctx[2]("layout.recovery_mode.body", {
    				values: {
    					epoch_recovery_ends: /*epoch_recovery_ends*/ ctx[1],
    					epoch_recovery_ends_after: /*epoch_recovery_ends*/ ctx[1] + 1
    				}
    			}) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot.name,
    		type: "slot",
    		source: "(23:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let main;
    	let current;
    	let if_block = /*is_recovery*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$2, 17, 0, 473);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*is_recovery*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*is_recovery*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("RecoveryMode", slots, []);
    	let is_recovery = false;
    	let epoch_recovery_ends = null;

    	i$1("get_recovery_mode", {}).then(ends => {
    		console.log(">>> get_recovery_mode");
    		console.log(ends);

    		if (ends > 0) {
    			($$invalidate(0, is_recovery = true), $$invalidate(1, epoch_recovery_ends = ends));
    		}
    	}).catch(e => {
    		console.log(e);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<RecoveryMode> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		_: X,
    		CardAlert,
    		is_recovery,
    		epoch_recovery_ends,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("is_recovery" in $$props) $$invalidate(0, is_recovery = $$props.is_recovery);
    		if ("epoch_recovery_ends" in $$props) $$invalidate(1, epoch_recovery_ends = $$props.epoch_recovery_ends);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [is_recovery, epoch_recovery_ends, $_];
    }

    class RecoveryMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RecoveryMode",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/make-whole/MakeWhole.svelte generated by Svelte v3.38.1 */
    const file$1 = "src/components/make-whole/MakeWhole.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (129:4) {:else}
    function create_else_block_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			set_style(span, "position", "absolute");
    			set_style(span, "top", "0px");
    			set_style(span, "left", "0px");
    			add_location(span, file$1, 129, 6, 4945);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(129:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (99:4) {#if credits}
    function create_if_block$1(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0_value = /*$_*/ ctx[4]("make_whole.table.account") + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*$_*/ ctx[4]("make_whole.table.amount") + "";
    	let t2;
    	let t3;
    	let th2;
    	let t4_value = /*$_*/ ctx[4]("make_whole.table.claim") + "";
    	let t4;
    	let t5;
    	let tbody;
    	let each_value = /*credits*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "class", "uk-text-left");
    			add_location(th0, file$1, 102, 12, 3798);
    			attr_dev(th1, "class", "uk-text-right");
    			add_location(th1, file$1, 103, 12, 3873);
    			attr_dev(th2, "class", "uk-text-center");
    			add_location(th2, file$1, 104, 12, 3948);
    			add_location(tr, file$1, 101, 10, 3781);
    			add_location(thead, file$1, 100, 8, 3763);
    			add_location(tbody, file$1, 107, 8, 4052);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$1, 99, 6, 3713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			append_dev(table, t5);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("make_whole.table.account") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 16 && t2_value !== (t2_value = /*$_*/ ctx[4]("make_whole.table.amount") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 16 && t4_value !== (t4_value = /*$_*/ ctx[4]("make_whole.table.claim") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*credits, isProcessing, claimCoins, $_, printCoins*/ 51) {
    				each_value = /*credits*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(99:4) {#if credits}",
    		ctx
    	});

    	return block;
    }

    // (116:16) {:else}
    function create_else_block(ctx) {
    	let button;

    	let t_value = (/*isProcessing*/ ctx[1]
    	? /*$_*/ ctx[4]("make_whole.claim_btn.await")
    	: /*$_*/ ctx[4]("make_whole.claim_btn.claim")) + "";

    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*credit*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			button.disabled = /*isProcessing*/ ctx[1];
    			set_style(button, "width", "180px");
    			attr_dev(button, "class", "uk-button uk-button-primary");
    			add_location(button, file$1, 116, 18, 4497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*isProcessing, $_*/ 18 && t_value !== (t_value = (/*isProcessing*/ ctx[1]
    			? /*$_*/ ctx[4]("make_whole.claim_btn.await")
    			: /*$_*/ ctx[4]("make_whole.claim_btn.claim")) + "")) set_data_dev(t, t_value);

    			if (dirty & /*isProcessing*/ 2) {
    				prop_dev(button, "disabled", /*isProcessing*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(116:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (114:16) {#if credit.claimed}
    function create_if_block_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-success");
    			attr_dev(span, "uk-icon", "icon: check; ratio: 1; color: green");
    			add_location(span, file$1, 114, 18, 4371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(114:16) {#if credit.claimed}",
    		ctx
    	});

    	return block;
    }

    // (109:10) {#each credits as credit}
    function create_each_block(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*credit*/ ctx[9].account + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = printCoins(/*credit*/ ctx[9].coins.value) + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4;

    	function select_block_type_1(ctx, dirty) {
    		if (/*credit*/ ctx[9].claimed) return create_if_block_1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			if_block.c();
    			t4 = space();
    			attr_dev(td0, "class", "uk-text-left");
    			add_location(td0, file$1, 110, 14, 4127);
    			attr_dev(td1, "class", "uk-text-right");
    			add_location(td1, file$1, 111, 14, 4188);
    			attr_dev(td2, "class", "uk-text-center");
    			set_style(td2, "width", "200px");
    			add_location(td2, file$1, 112, 14, 4266);
    			add_location(tr, file$1, 109, 12, 4108);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			if_block.m(td2, null);
    			append_dev(tr, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*credits*/ 1 && t0_value !== (t0_value = /*credit*/ ctx[9].account + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*credits*/ 1 && t2_value !== (t2_value = printCoins(/*credit*/ ctx[9].coins.value) + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(td2, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(109:10) {#each credits as credit}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let main;
    	let div2;
    	let div1;
    	let div0;
    	let h20;
    	let span;
    	let t0;
    	let p0;
    	let t1_value = /*$_*/ ctx[4]("make_whole.modal_success.title") + "";
    	let t1;
    	let t2;
    	let html_tag;

    	let raw0_value = /*$_*/ ctx[4]("make_whole.modal_success.amount_for_account", {
    		values: {
    			coins: /*selected*/ ctx[2] && printCoins(/*selected*/ ctx[2].coins.value),
    			account: /*selected*/ ctx[2] ? /*selected*/ ctx[2].account : ""
    		}
    	}) + "";

    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[4]("make_whole.modal_success.check_balance") + "";
    	let t4;
    	let t5;
    	let p2;
    	let button0;
    	let t6_value = /*$_*/ ctx[4]("make_whole.modal_success.ok_btn") + "";
    	let t6;
    	let t7;
    	let div5;
    	let div4;
    	let div3;
    	let h21;
    	let t8_value = /*$_*/ ctx[4]("make_whole.modal_error.title") + "";
    	let t8;
    	let t9;
    	let p3;
    	let t10;
    	let t11;
    	let p4;
    	let button1;
    	let t12_value = /*$_*/ ctx[4]("make_whole.modal_error.ok_btn") + "";
    	let t12;
    	let t13;
    	let div8;
    	let div6;
    	let h3;
    	let t14_value = /*$_*/ ctx[4]("make_whole.card.title") + "";
    	let t14;
    	let t15;
    	let html_tag_1;
    	let raw1_value = /*$_*/ ctx[4]("make_whole.card.body") + "";
    	let t16;
    	let div7;
    	let t17;

    	function select_block_type(ctx, dirty) {
    		if (/*credits*/ ctx[0]) return create_if_block$1;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			span = element("span");
    			t0 = space();
    			p0 = element("p");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			button0 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			h21 = element("h2");
    			t8 = text(t8_value);
    			t9 = space();
    			p3 = element("p");
    			t10 = text(/*errorMsg*/ ctx[3]);
    			t11 = space();
    			p4 = element("p");
    			button1 = element("button");
    			t12 = text(t12_value);
    			t13 = space();
    			div8 = element("div");
    			div6 = element("div");
    			h3 = element("h3");
    			t14 = text(t14_value);
    			t15 = space();
    			t16 = space();
    			div7 = element("div");
    			t17 = space();
    			if_block.c();
    			attr_dev(span, "class", "success-icon svelte-zqs745");
    			attr_dev(span, "uk-icon", "icon: check; ratio: 2");
    			add_location(span, file$1, 59, 35, 2263);
    			attr_dev(h20, "class", "uk-modal-title");
    			add_location(h20, file$1, 59, 8, 2236);
    			attr_dev(p0, "class", "uk-text-small");
    			add_location(p0, file$1, 60, 8, 2344);
    			html_tag = new HtmlTag(t3);
    			add_location(p1, file$1, 62, 8, 2598);
    			attr_dev(div0, "class", "uk-section");
    			add_location(div0, file$1, 58, 6, 2203);
    			attr_dev(button0, "class", "uk-button uk-button-large uk-button-primary uk-margin-right uk-modal-close");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$1, 66, 8, 2707);
    			attr_dev(p2, "class", "uk-text-center");
    			add_location(p2, file$1, 65, 6, 2672);
    			attr_dev(div1, "class", "uk-modal-dialog uk-modal-body uk-text-center");
    			set_style(div1, "background-image", "url('/images/confetti.gif')");
    			add_location(div1, file$1, 57, 4, 2084);
    			attr_dev(div2, "id", "claimedWithSuccess");
    			attr_dev(div2, "uk-modal", "");
    			add_location(div2, file$1, 56, 2, 2041);
    			attr_dev(h21, "class", "uk-modal-title");
    			add_location(h21, file$1, 77, 8, 3059);
    			add_location(p3, file$1, 78, 8, 3138);
    			attr_dev(div3, "class", "uk-section");
    			add_location(div3, file$1, 76, 6, 3026);
    			attr_dev(button1, "class", "uk-button uk-button-large uk-button-primary uk-margin-right uk-modal-close");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$1, 82, 8, 3211);
    			attr_dev(p4, "class", "uk-text-center");
    			add_location(p4, file$1, 81, 6, 3176);
    			attr_dev(div4, "class", "uk-modal-dialog uk-modal-body uk-text-center");
    			add_location(div4, file$1, 75, 4, 2961);
    			attr_dev(div5, "id", "claimError");
    			attr_dev(div5, "uk-modal", "");
    			add_location(div5, file$1, 74, 2, 2926);
    			attr_dev(h3, "class", "uk-card-title uk-text-muted uk-text-uppercase");
    			add_location(h3, file$1, 92, 6, 3516);
    			html_tag_1 = new HtmlTag(null);
    			attr_dev(div6, "class", "uk-card uk-card-default uk-card-body");
    			add_location(div6, file$1, 91, 4, 3459);
    			add_location(div7, file$1, 95, 4, 3665);
    			attr_dev(div8, "class", "uk-container");
    			add_location(div8, file$1, 90, 2, 3428);
    			add_location(main, file$1, 55, 0, 2032);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h20);
    			append_dev(h20, span);
    			append_dev(div0, t0);
    			append_dev(div0, p0);
    			append_dev(p0, t1);
    			append_dev(div0, t2);
    			html_tag.m(raw0_value, div0);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(p1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, p2);
    			append_dev(p2, button0);
    			append_dev(button0, t6);
    			append_dev(main, t7);
    			append_dev(main, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, h21);
    			append_dev(h21, t8);
    			append_dev(div3, t9);
    			append_dev(div3, p3);
    			append_dev(p3, t10);
    			append_dev(div4, t11);
    			append_dev(div4, p4);
    			append_dev(p4, button1);
    			append_dev(button1, t12);
    			append_dev(main, t13);
    			append_dev(main, div8);
    			append_dev(div8, div6);
    			append_dev(div6, h3);
    			append_dev(h3, t14);
    			append_dev(div6, t15);
    			html_tag_1.m(raw1_value, div6);
    			append_dev(div8, t16);
    			append_dev(div8, div7);
    			append_dev(div8, t17);
    			if_block.m(div8, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 16 && t1_value !== (t1_value = /*$_*/ ctx[4]("make_whole.modal_success.title") + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$_, selected*/ 20 && raw0_value !== (raw0_value = /*$_*/ ctx[4]("make_whole.modal_success.amount_for_account", {
    				values: {
    					coins: /*selected*/ ctx[2] && printCoins(/*selected*/ ctx[2].coins.value),
    					account: /*selected*/ ctx[2] ? /*selected*/ ctx[2].account : ""
    				}
    			}) + "")) html_tag.p(raw0_value);

    			if (dirty & /*$_*/ 16 && t4_value !== (t4_value = /*$_*/ ctx[4]("make_whole.modal_success.check_balance") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 16 && t6_value !== (t6_value = /*$_*/ ctx[4]("make_whole.modal_success.ok_btn") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 16 && t8_value !== (t8_value = /*$_*/ ctx[4]("make_whole.modal_error.title") + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*errorMsg*/ 8) set_data_dev(t10, /*errorMsg*/ ctx[3]);
    			if (dirty & /*$_*/ 16 && t12_value !== (t12_value = /*$_*/ ctx[4]("make_whole.modal_error.ok_btn") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$_*/ 16 && t14_value !== (t14_value = /*$_*/ ctx[4]("make_whole.card.title") + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*$_*/ 16 && raw1_value !== (raw1_value = /*$_*/ ctx[4]("make_whole.card.body") + "")) html_tag_1.p(raw1_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div8, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, "_");
    	component_subscribe($$self, X, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MakeWhole", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let credits;
    	let unsubs;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs = makeWhole.subscribe(mk => {
    			$$invalidate(0, credits = []);

    			for (const address in mk) {
    				let accountCredits = mk[address];

    				accountCredits.forEach(credit => {
    					credits.push({
    						account: address,
    						coins: credit.coins,
    						claimed: credit.claimed
    					});
    				});
    			}
    		});
    	}));

    	onDestroy(() => __awaiter(void 0, void 0, void 0, function* () {
    		unsubs && unsubs();
    	}));

    	let isProcessing = false;
    	let selected = null;
    	let errorMsg = "";

    	const claimCoins = credit => {
    		$$invalidate(2, selected = credit);
    		$$invalidate(1, isProcessing = true);

    		let callback = error => {
    			$$invalidate(1, isProcessing = false);

    			if (error) {
    				$$invalidate(3, errorMsg = error);
    				uikit.modal("#claimError").show();
    				return;
    			}

    			uikit.modal("#claimedWithSuccess").show();
    		};

    		callback.bind({ isProcessing });
    		claimMakeWhole(selected.account, callback);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MakeWhole> was created with unknown prop '${key}'`);
    	});

    	const click_handler = credit => claimCoins(credit);

    	$$self.$capture_state = () => ({
    		__awaiter,
    		UIkit: uikit,
    		printCoins,
    		makeWhole,
    		onDestroy,
    		onMount,
    		claimMakeWhole,
    		_: X,
    		credits,
    		unsubs,
    		isProcessing,
    		selected,
    		errorMsg,
    		claimCoins,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("credits" in $$props) $$invalidate(0, credits = $$props.credits);
    		if ("unsubs" in $$props) unsubs = $$props.unsubs;
    		if ("isProcessing" in $$props) $$invalidate(1, isProcessing = $$props.isProcessing);
    		if ("selected" in $$props) $$invalidate(2, selected = $$props.selected);
    		if ("errorMsg" in $$props) $$invalidate(3, errorMsg = $$props.errorMsg);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [credits, isProcessing, selected, errorMsg, $_, claimCoins, click_handler];
    }

    class MakeWhole extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MakeWhole",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.38.1 */
    const file = "src/App.svelte";

    // (127:8) {#if debug }
    function create_if_block(ctx) {
    	let debugcard;
    	let current;
    	debugcard = new DebugCard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(debugcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(debugcard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(debugcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(debugcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(debugcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(127:8) {#if debug }",
    		ctx
    	});

    	return block;
    }

    // (104:4) <Router>
    function create_default_slot(ctx) {
    	let nav;
    	let t0;
    	let div;
    	let route0;
    	let t1;
    	let route1;
    	let t2;
    	let route2;
    	let t3;
    	let route3;
    	let t4;
    	let route4;
    	let t5;
    	let route5;
    	let t6;
    	let route6;
    	let t7;
    	let route7;
    	let t8;
    	let route8;
    	let t9;
    	let route9;
    	let t10;
    	let route10;
    	let t11;
    	let current;
    	nav = new Nav({ $$inline: true });

    	route0 = new Route({
    			props: {
    				path: routes.home,
    				component: Wallet,
    				primary: false
    			},
    			$$inline: true
    		});

    	route1 = new Route({
    			props: {
    				path: routes.accountFromMnem,
    				component: AccountFromMnemForm,
    				primary: false
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: routes.keygen,
    				component: Keygen,
    				primary: false
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: routes.miner,
    				component: Miner,
    				primary: false
    			},
    			$$inline: true
    		});

    	route4 = new Route({
    			props: {
    				path: routes.transactions,
    				component: Transactions,
    				primary: false
    			},
    			$$inline: true
    		});

    	route5 = new Route({
    			props: {
    				path: routes.events,
    				component: Events,
    				primary: false
    			},
    			$$inline: true
    		});

    	route6 = new Route({
    			props: {
    				path: routes.settings,
    				component: Settings,
    				primary: false
    			},
    			$$inline: true
    		});

    	route7 = new Route({
    			props: {
    				path: routes.about,
    				component: About,
    				primary: false
    			},
    			$$inline: true
    		});

    	route8 = new Route({
    			props: {
    				path: routes.makeWhole,
    				component: MakeWhole,
    				primary: false
    			},
    			$$inline: true
    		});

    	route9 = new Route({
    			props: {
    				path: routes.developer,
    				component: DevMode,
    				primary: false
    			},
    			$$inline: true
    		});

    	route10 = new Route({
    			props: {
    				path: routes.swarm,
    				component: Swarm,
    				primary: false
    			},
    			$$inline: true
    		});

    	let if_block = /*debug*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			create_component(nav.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(route0.$$.fragment);
    			t1 = space();
    			create_component(route1.$$.fragment);
    			t2 = space();
    			create_component(route2.$$.fragment);
    			t3 = space();
    			create_component(route3.$$.fragment);
    			t4 = space();
    			create_component(route4.$$.fragment);
    			t5 = space();
    			create_component(route5.$$.fragment);
    			t6 = space();
    			create_component(route6.$$.fragment);
    			t7 = space();
    			create_component(route7.$$.fragment);
    			t8 = space();
    			create_component(route8.$$.fragment);
    			t9 = space();
    			create_component(route9.$$.fragment);
    			t10 = space();
    			create_component(route10.$$.fragment);
    			t11 = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "uk-background-muted uk-margin-large");
    			add_location(div, file, 105, 6, 4663);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nav, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(route0, div, null);
    			append_dev(div, t1);
    			mount_component(route1, div, null);
    			append_dev(div, t2);
    			mount_component(route2, div, null);
    			append_dev(div, t3);
    			mount_component(route3, div, null);
    			append_dev(div, t4);
    			mount_component(route4, div, null);
    			append_dev(div, t5);
    			mount_component(route5, div, null);
    			append_dev(div, t6);
    			mount_component(route6, div, null);
    			append_dev(div, t7);
    			mount_component(route7, div, null);
    			append_dev(div, t8);
    			mount_component(route8, div, null);
    			append_dev(div, t9);
    			mount_component(route9, div, null);
    			append_dev(div, t10);
    			mount_component(route10, div, null);
    			append_dev(div, t11);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*debug*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*debug*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(route6.$$.fragment, local);
    			transition_in(route7.$$.fragment, local);
    			transition_in(route8.$$.fragment, local);
    			transition_in(route9.$$.fragment, local);
    			transition_in(route10.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(route6.$$.fragment, local);
    			transition_out(route7.$$.fragment, local);
    			transition_out(route8.$$.fragment, local);
    			transition_out(route9.$$.fragment, local);
    			transition_out(route10.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nav, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(route0);
    			destroy_component(route1);
    			destroy_component(route2);
    			destroy_component(route3);
    			destroy_component(route4);
    			destroy_component(route5);
    			destroy_component(route6);
    			destroy_component(route7);
    			destroy_component(route8);
    			destroy_component(route9);
    			destroy_component(route10);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(104:4) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let searchingfullnodes;
    	let t0;
    	let recoverymode;
    	let t1;
    	let div;
    	let router;
    	let current;
    	searchingfullnodes = new SearchingFullnodes({ $$inline: true });
    	recoverymode = new RecoveryMode({ $$inline: true });

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(searchingfullnodes.$$.fragment);
    			t0 = space();
    			create_component(recoverymode.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(router.$$.fragment);
    			attr_dev(div, "class", "uk-container");
    			add_location(div, file, 102, 2, 4603);
    			attr_dev(main, "class", "uk-background-muted uk-height-viewport");
    			add_location(main, file, 98, 0, 4501);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(searchingfullnodes, main, null);
    			append_dev(main, t0);
    			mount_component(recoverymode, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			mount_component(router, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, debug*/ 129) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchingfullnodes.$$.fragment, local);
    			transition_in(recoverymode.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchingfullnodes.$$.fragment, local);
    			transition_out(recoverymode.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(searchingfullnodes);
    			destroy_component(recoverymode);
    			destroy_component(router);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	
    	init_preferences();
    	let unlistenProofStart;
    	let unlistenAck;
    	let unlistenBacklogSuccess;
    	let unlistenBacklogError;
    	let healthTick;
    	let debug = false;

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		logger(Level.Warn, "Webview is starting");
    		isCarpeInit();
    		getEnv();
    		getVersion();

    		// iterates through the list of peers in 0L.toml, and updates the statistics in preferences.json. So we don't need to test fullnodes on every transaction.
    		refreshUpstreamPeerStats().then(() => {
    			carpeTick();
    		});

    		healthTick = setInterval(carpeTick, 30000); // do a healthcheck, this is async
    		debugMode.subscribe(b => $$invalidate(0, debug = b));

    		///// Backlog /////
    		// Todo: Should this listener only be started in the miner view?
    		// submitted tower txs, which happens with backlog, requires a private key.
    		// so that the user does not need to keep authorizing the key,
    		// there is a listener service which loads the key once, and then waits for a specific
    		// event to trigger the backlog submission.
    		unlistenProofStart = yield o("proof-start", event => {
    			responses.set(event.payload);

    			//update the tower stats after we show the backlog being up to date.
    			minerEventReceived.set(true);

    			backlogInProgress.set(false);
    			backlogSubmitted.set(false);
    		});

    		unlistenAck = yield o("ack-backlog-request", event => {
    			backlogInProgress.set(true);
    		});

    		unlistenBacklogSuccess = yield o("backlog-success", event => {
    			responses.set(event.payload);

    			//update the tower stats after we show the backlog being up to date.
    			backlogInProgress.set(false);

    			backlogSubmitted.set(true);
    			carpeTick();
    		});

    		unlistenBacklogError = yield o("backlog-error", event => {
    			// TODO: show an UX in the miner view for this type of error
    			raise_error(event.payload, true, "listen(backlog-error)");

    			backlogInProgress.set(false);
    			backlogSubmitted.set(false);
    		});
    	}));

    	onDestroy(() => {
    		unlistenProofStart();
    		unlistenAck();
    		unlistenBacklogSuccess();
    		unlistenBacklogError();
    		clearInterval(healthTick);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		listen: o,
    		onDestroy,
    		onMount,
    		Router,
    		Route,
    		Nav,
    		DebugCard,
    		Wallet,
    		Miner,
    		Settings,
    		DevMode,
    		AccountFromMnemForm,
    		Swarm,
    		Keygen,
    		Transactions,
    		Events,
    		About,
    		backlogInProgress,
    		backlogSubmitted,
    		minerEventReceived,
    		raise_error,
    		getEnv,
    		responses,
    		debugMode,
    		routes,
    		isCarpeInit,
    		getVersion,
    		carpeTick,
    		init_preferences,
    		SearchingFullnodes,
    		RecoveryMode,
    		MakeWhole,
    		refreshUpstreamPeerStats,
    		Level,
    		logger,
    		unlistenProofStart,
    		unlistenAck,
    		unlistenBacklogSuccess,
    		unlistenBacklogError,
    		healthTick,
    		debug
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("unlistenProofStart" in $$props) unlistenProofStart = $$props.unlistenProofStart;
    		if ("unlistenAck" in $$props) unlistenAck = $$props.unlistenAck;
    		if ("unlistenBacklogSuccess" in $$props) unlistenBacklogSuccess = $$props.unlistenBacklogSuccess;
    		if ("unlistenBacklogError" in $$props) unlistenBacklogError = $$props.unlistenBacklogError;
    		if ("healthTick" in $$props) healthTick = $$props.healthTick;
    		if ("debug" in $$props) $$invalidate(0, debug = $$props.debug);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [debug];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
        props: {
            name: 'tauri',
        },
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
