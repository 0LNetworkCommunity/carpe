
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35731/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    /**
     * List of attributes that should always be set through the attr method,
     * because updating them through the property setter doesn't work reliably.
     * In the example of `width`/`height`, the problem is that the setter only
     * accepts numeric values, but the attribute can also be set to a string like `50%`.
     * If this list becomes too big, rethink this approach.
     */
    const always_set_through_set_attribute = ['width', 'height'];
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                /** #7364  target for <template> may be provided as #document-fragment(11) */
                else
                    this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));
                this.t = target.tagName !== 'TEMPLATE' ? target : target.content;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    /**
     * Associates an arbitrary `context` object with the current component and the specified `key`
     * and returns that object. The context is then available to children of the component
     * (including slotted content) with `getContext`.
     *
     * Like lifecycle functions, this must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-setcontext
     */
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
        return context;
    }
    /**
     * Retrieves the context that belongs to the closest parent component with the specified `key`.
     * Must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-getcontext
     */
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush$1);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush$1() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush$1();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        if (has_stop_immediate_propagation)
            modifiers.push('stopImmediatePropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function set_data_contenteditable_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function set_data_maybe_contenteditable_dev(text, data, attr_value) {
        if (~contenteditable_truthy_values.indexOf(attr_value)) {
            set_data_contenteditable_dev(text, data);
        }
        else {
            set_data_dev(text, data);
        }
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var t=function(n,e){return (t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,n){t.__proto__=n;}||function(t,n){for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e]);})(n,e)};function n$1(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=n;}t(n,e),n.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r);}var e=function(){return (e=Object.assign||function(t){for(var n,e=1,r=arguments.length;e<r;e++)for(var o in n=arguments[e])Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o]);return t}).apply(this,arguments)};function r$1(t,n,e,r){return new(e||(e=Promise))((function(o,a){function i(t){try{u(r.next(t));}catch(t){a(t);}}function c(t){try{u(r.throw(t));}catch(t){a(t);}}function u(t){var n;t.done?o(t.value):(n=t.value,n instanceof e?n:new e((function(t){t(n);}))).then(i,c);}u((r=r.apply(t,n||[])).next());}))}function o$1(t,n){var e,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:c(0),throw:c(1),return:c(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function c(a){return function(c){return function(a){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=i.trys,(o=o.length>0&&o[o.length-1])||6!==a[0]&&2!==a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=n.call(t,i);}catch(t){a=[6,t],r=0;}finally{e=o=0;}if(5&a[0])throw a[1];return {value:a[0]?a[1]:void 0,done:!0}}([a,c])}}}function a(t,n){void 0===n&&(n=!1);var e=function(){var t=new Int8Array(1);window.crypto.getRandomValues(t);var n=new Uint8Array(Math.max(16,Math.abs(t[0])));return window.crypto.getRandomValues(n),n.join("")}();return Object.defineProperty(window,e,{value:function(r){return n&&Reflect.deleteProperty(window,e),null==t?void 0:t(r)},writable:!1,configurable:!0}),e}function i$1(t,n){return void 0===n&&(n={}),r$1(this,void 0,void 0,(function(){return o$1(this,(function(r){return [2,new Promise((function(r,o){var i=a((function(t){r(t),Reflect.deleteProperty(window,c);}),!0),c=a((function(t){o(t),Reflect.deleteProperty(window,i);}),!0);window.rpc.notify(t,e({__invokeKey:__TAURI_INVOKE_KEY__,callback:i,error:c},n));}))]}))}))}function c$2(t){return navigator.userAgent.includes("Windows")?"https://asset.localhost/"+t:"asset://"+t}Object.freeze({__proto__:null,transformCallback:a,invoke:i$1,convertFileSrc:c$2});

    function n(n){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(i){return [2,i$1("tauri",n)]}))}))}

    function r(i,r,u){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){switch(t.label){case 0:return [4,n({__tauriModule:"Event",message:{cmd:"emit",event:i,windowLabel:r,payload:u}})];case 1:return t.sent(),[2]}}))}))}function u$1(i){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Event",message:{cmd:"unlisten",eventId:i}})]}))}))}function o(r,o){return r$1(this,void 0,void 0,(function(){var s=this;return o$1(this,(function(c){return [2,n({__tauriModule:"Event",message:{cmd:"listen",event:r,handler:a(o)}}).then((function(i){return function(){return r$1(s,void 0,void 0,(function(){return o$1(this,(function(t){return [2,u$1(i)]}))}))}}))]}))}))}function s$1(i,e){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,o(i,(function(t){e(t),u$1(t.id).catch((function(){}));}))]}))}))}function c$1(i,e){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,r(i,void 0,e)]}))}))}Object.freeze({__proto__:null,listen:o,once:s$1,emit:c$1});

    /*
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     */

    const isUndefined = value => typeof value === "undefined";

    const isFunction = value => typeof value === "function";

    const isNumber = value => typeof value === "number";

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
    	return (
    		!event.defaultPrevented &&
    		event.button === 0 &&
    		!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    	);
    }

    function createCounter() {
    	let i = 0;
    	/**
    	 * Returns an id and increments the internal state
    	 * @returns {number}
    	 */
    	return () => i++;
    }

    /**
     * Create a globally unique id
     *
     * @returns {string} An id
     */
    function createGlobalId() {
    	return Math.random().toString(36).substring(2);
    }

    const isSSR = typeof window === "undefined";

    function addListener(target, type, handler) {
    	target.addEventListener(type, handler);
    	return () => target.removeEventListener(type, handler);
    }

    const createInlineStyle = (disableInlineStyles, style) =>
    	disableInlineStyles ? {} : { style };
    const createMarkerProps = disableInlineStyles => ({
    	"aria-hidden": "true",
    	...createInlineStyle(disableInlineStyles, "display:none;"),
    });

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier} [start]
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=} start
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0 && stop) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let started = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (started) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            started = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
                // We need to set this to false because callbacks can still happen despite having unsubscribed:
                // Callbacks might already be placed in the queue which doesn't know it should no longer
                // invoke this derived store.
                started = false;
            };
        });
    }

    /*
     * Adapted from https://github.com/EmilTholin/svelte-routing
     *
     * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE
     */

    const createKey = ctxName => `@@svnav-ctx__${ctxName}`;

    // Use strings instead of objects, so different versions of
    // svelte-navigator can potentially still work together
    const LOCATION = createKey("LOCATION");
    const ROUTER = createKey("ROUTER");
    const ROUTE = createKey("ROUTE");
    const ROUTE_PARAMS = createKey("ROUTE_PARAMS");
    const FOCUS_ELEM = createKey("FOCUS_ELEM");

    const paramRegex = /^:(.+)/;

    const substr = (str, start, end) => str.substr(start, end);

    /**
     * Check if `string` starts with `search`
     * @param {string} string
     * @param {string} search
     * @return {boolean}
     */
    const startsWith$1 = (string, search) =>
    	substr(string, 0, search.length) === search;

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    const isRootSegment = segment => segment === "";

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    const isDynamic = segment => paramRegex.test(segment);

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    const isSplat = segment => segment[0] === "*";

    /**
     * Strip potention splat and splatname of the end of a path
     * @param {string} str
     * @return {string}
     */
    const stripSplat = str => str.replace(/\*.*$/, "");

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    const stripSlashes = str => str.replace(/(^\/+|\/+$)/g, "");

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri, filterFalsy = false) {
    	const segments = stripSlashes(uri).split("/");
    	return filterFalsy ? segments.filter(Boolean) : segments;
    }

    /**
     * Add the query to the pathname if a query is given
     * @param {string} pathname
     * @param {string} [query]
     * @return {string}
     */
    const addQuery = (pathname, query) =>
    	pathname + (query ? `?${query}` : "");

    /**
     * Normalizes a basepath
     *
     * @param {string} path
     * @returns {string}
     *
     * @example
     * normalizePath("base/path/") // -> "/base/path"
     */
    const normalizePath = path => `/${stripSlashes(path)}`;

    /**
     * Joins and normalizes multiple path fragments
     *
     * @param {...string} pathFragments
     * @returns {string}
     */
    function join(...pathFragments) {
    	const joinFragment = fragment => segmentize(fragment, true).join("/");
    	const joinedSegments = pathFragments.map(joinFragment).join("/");
    	return normalizePath(joinedSegments);
    }

    // We start from 1 here, so we can check if an origin id has been passed
    // by using `originId || <fallback>`
    const LINK_ID = 1;
    const ROUTE_ID = 2;
    const ROUTER_ID = 3;
    const USE_FOCUS_ID = 4;
    const USE_LOCATION_ID = 5;
    const USE_MATCH_ID = 6;
    const USE_NAVIGATE_ID = 7;
    const USE_PARAMS_ID = 8;
    const USE_RESOLVABLE_ID = 9;
    const USE_RESOLVE_ID = 10;
    const NAVIGATE_ID = 11;

    const labels = {
    	[LINK_ID]: "Link",
    	[ROUTE_ID]: "Route",
    	[ROUTER_ID]: "Router",
    	[USE_FOCUS_ID]: "useFocus",
    	[USE_LOCATION_ID]: "useLocation",
    	[USE_MATCH_ID]: "useMatch",
    	[USE_NAVIGATE_ID]: "useNavigate",
    	[USE_PARAMS_ID]: "useParams",
    	[USE_RESOLVABLE_ID]: "useResolvable",
    	[USE_RESOLVE_ID]: "useResolve",
    	[NAVIGATE_ID]: "navigate",
    };

    const createLabel = labelId => labels[labelId];

    function createIdentifier(labelId, props) {
    	let attr;
    	if (labelId === ROUTE_ID) {
    		attr = props.path ? `path="${props.path}"` : "default";
    	} else if (labelId === LINK_ID) {
    		attr = `to="${props.to}"`;
    	} else if (labelId === ROUTER_ID) {
    		attr = `basepath="${props.basepath || ""}"`;
    	}
    	return `<${createLabel(labelId)} ${attr || ""} />`;
    }

    function createMessage(labelId, message, props, originId) {
    	const origin = props && createIdentifier(originId || labelId, props);
    	const originMsg = origin ? `\n\nOccurred in: ${origin}` : "";
    	const label = createLabel(labelId);
    	const msg = isFunction(message) ? message(label) : message;
    	return `<${label}> ${msg}${originMsg}`;
    }

    const createMessageHandler =
    	handler =>
    	(...args) =>
    		handler(createMessage(...args));

    const fail = createMessageHandler(message => {
    	throw new Error(message);
    });

    // eslint-disable-next-line no-console
    const warn = createMessageHandler(console.warn);

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
    	const score = route.default
    		? 0
    		: segmentize(route.fullPath).reduce((acc, segment) => {
    				let nextScore = acc;
    				nextScore += SEGMENT_POINTS;

    				if (isRootSegment(segment)) {
    					nextScore += ROOT_POINTS;
    				} else if (isDynamic(segment)) {
    					nextScore += DYNAMIC_POINTS;
    				} else if (isSplat(segment)) {
    					nextScore -= SEGMENT_POINTS + SPLAT_PENALTY;
    				} else {
    					nextScore += STATIC_POINTS;
    				}

    				return nextScore;
    		  }, 0);

    	return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
    	return (
    		routes
    			.map(rankRoute)
    			// If two routes have the exact same score, we go by index instead
    			.sort((a, b) => {
    				if (a.score < b.score) {
    					return 1;
    				}
    				if (a.score > b.score) {
    					return -1;
    				}
    				return a.index - b.index;
    			})
    	);
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { fullPath, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick(routes, uri) {
    	let bestMatch;
    	let defaultMatch;

    	const [uriPathname] = uri.split("?");
    	const uriSegments = segmentize(uriPathname);
    	const isRootUri = uriSegments[0] === "";
    	const ranked = rankRoutes(routes);

    	for (let i = 0, l = ranked.length; i < l; i++) {
    		const { route } = ranked[i];
    		let missed = false;
    		const params = {};

    		// eslint-disable-next-line no-shadow
    		const createMatch = uri => ({ ...route, params, uri });

    		if (route.default) {
    			defaultMatch = createMatch(uri);
    			continue;
    		}

    		const routeSegments = segmentize(route.fullPath);
    		const max = Math.max(uriSegments.length, routeSegments.length);
    		let index = 0;

    		for (; index < max; index++) {
    			const routeSegment = routeSegments[index];
    			const uriSegment = uriSegments[index];

    			if (!isUndefined(routeSegment) && isSplat(routeSegment)) {
    				// Hit a splat, just grab the rest, and return a match
    				// uri:   /files/documents/work
    				// route: /files/* or /files/*splatname
    				const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

    				params[splatName] = uriSegments
    					.slice(index)
    					.map(decodeURIComponent)
    					.join("/");
    				break;
    			}

    			if (isUndefined(uriSegment)) {
    				// URI is shorter than the route, no match
    				// uri:   /users
    				// route: /users/:userId
    				missed = true;
    				break;
    			}

    			const dynamicMatch = paramRegex.exec(routeSegment);

    			if (dynamicMatch && !isRootUri) {
    				const value = decodeURIComponent(uriSegment);
    				params[dynamicMatch[1]] = value;
    			} else if (routeSegment !== uriSegment) {
    				// Current segments don't match, not dynamic, not splat, so no match
    				// uri:   /users/123/settings
    				// route: /users/:id/profile
    				missed = true;
    				break;
    			}
    		}

    		if (!missed) {
    			bestMatch = createMatch(join(...uriSegments.slice(0, index)));
    			break;
    		}
    	}

    	return bestMatch || defaultMatch || null;
    }

    /**
     * Check if the `route.fullPath` matches the `uri`.
     * @param {Object} route
     * @param {string} uri
     * @return {?object}
     */
    function match(route, uri) {
    	return pick([route], uri);
    }

    /**
     * Resolve URIs as though every path is a directory, no files. Relative URIs
     * in the browser can feel awkward because not only can you be "in a directory",
     * you can be "at a file", too. For example:
     *
     *  browserSpecResolve('foo', '/bar/') => /bar/foo
     *  browserSpecResolve('foo', '/bar') => /foo
     *
     * But on the command line of a file system, it's not as complicated. You can't
     * `cd` from a file, only directories. This way, links have to know less about
     * their current path. To go deeper you can do this:
     *
     *  <Link to="deeper"/>
     *  // instead of
     *  <Link to=`{${props.uri}/deeper}`/>
     *
     * Just like `cd`, if you want to go deeper from the command line, you do this:
     *
     *  cd deeper
     *  # not
     *  cd $(pwd)/deeper
     *
     * By treating every path as a directory, linking to relative paths should
     * require less contextual information and (fingers crossed) be more intuitive.
     * @param {string} to
     * @param {string} base
     * @return {string}
     */
    function resolve(to, base) {
    	// /foo/bar, /baz/qux => /foo/bar
    	if (startsWith$1(to, "/")) {
    		return to;
    	}

    	const [toPathname, toQuery] = to.split("?");
    	const [basePathname] = base.split("?");
    	const toSegments = segmentize(toPathname);
    	const baseSegments = segmentize(basePathname);

    	// ?a=b, /users?b=c => /users?a=b
    	if (toSegments[0] === "") {
    		return addQuery(basePathname, toQuery);
    	}

    	// profile, /users/789 => /users/789/profile
    	if (!startsWith$1(toSegments[0], ".")) {
    		const pathname = baseSegments.concat(toSegments).join("/");
    		return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
    	}

    	// ./       , /users/123 => /users/123
    	// ../      , /users/123 => /users
    	// ../..    , /users/123 => /
    	// ../../one, /a/b/c/d   => /a/b/one
    	// .././one , /a/b/c/d   => /a/b/c/one
    	const allSegments = baseSegments.concat(toSegments);
    	const segments = [];

    	allSegments.forEach(segment => {
    		if (segment === "..") {
    			segments.pop();
    		} else if (segment !== ".") {
    			segments.push(segment);
    		}
    	});

    	return addQuery(`/${segments.join("/")}`, toQuery);
    }

    /**
     * Normalizes a location for consumption by `Route` children and the `Router`.
     * It removes the apps basepath from the pathname
     * and sets default values for `search` and `hash` properties.
     *
     * @param {Object} location The current global location supplied by the history component
     * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)
     *
     * @returns The normalized location
     */
    function normalizeLocation(location, basepath) {
    	const { pathname, hash = "", search = "", state } = location;
    	const baseSegments = segmentize(basepath, true);
    	const pathSegments = segmentize(pathname, true);
    	while (baseSegments.length) {
    		if (baseSegments[0] !== pathSegments[0]) {
    			fail(
    				ROUTER_ID,
    				`Invalid state: All locations must begin with the basepath "${basepath}", found "${pathname}"`,
    			);
    		}
    		baseSegments.shift();
    		pathSegments.shift();
    	}
    	return {
    		pathname: join(...pathSegments),
    		hash,
    		search,
    		state,
    	};
    }

    const normalizeUrlFragment = frag => (frag.length === 1 ? "" : frag);

    /**
     * Creates a location object from an url.
     * It is used to create a location from the url prop used in SSR
     *
     * @param {string} url The url string (e.g. "/path/to/somewhere")
     * @returns {{ pathname: string; search: string; hash: string }} The location
     *
     * @example
     * ```js
     * const path = "/search?q=falafel#result-3";
     * const location = parsePath(path);
     * // -> {
     * //   pathname: "/search",
     * //   search: "?q=falafel",
     * //   hash: "#result-3",
     * // };
     * ```
     */
    const parsePath = path => {
    	const searchIndex = path.indexOf("?");
    	const hashIndex = path.indexOf("#");
    	const hasSearchIndex = searchIndex !== -1;
    	const hasHashIndex = hashIndex !== -1;
    	const hash = hasHashIndex
    		? normalizeUrlFragment(substr(path, hashIndex))
    		: "";
    	const pathnameAndSearch = hasHashIndex ? substr(path, 0, hashIndex) : path;
    	const search = hasSearchIndex
    		? normalizeUrlFragment(substr(pathnameAndSearch, searchIndex))
    		: "";
    	const pathname =
    		(hasSearchIndex
    			? substr(pathnameAndSearch, 0, searchIndex)
    			: pathnameAndSearch) || "/";
    	return { pathname, search, hash };
    };

    /**
     * Joins a location object to one path string.
     *
     * @param {{ pathname: string; search: string; hash: string }} location The location object
     * @returns {string} A path, created from the location
     *
     * @example
     * ```js
     * const location = {
     *   pathname: "/search",
     *   search: "?q=falafel",
     *   hash: "#result-3",
     * };
     * const path = stringifyPath(location);
     * // -> "/search?q=falafel#result-3"
     * ```
     */
    const stringifyPath = location => {
    	const { pathname, search, hash } = location;
    	return pathname + search + hash;
    };

    /**
     * Resolves a link relative to the parent Route and the Routers basepath.
     *
     * @param {string} path The given path, that will be resolved
     * @param {string} routeBase The current Routes base path
     * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory
     * @returns {string} The resolved path
     *
     * @example
     * resolveLink("relative", "/routeBase", "/") // -> "/routeBase/relative"
     * resolveLink("/absolute", "/routeBase", "/") // -> "/absolute"
     * resolveLink("relative", "/routeBase", "/base") // -> "/base/routeBase/relative"
     * resolveLink("/absolute", "/routeBase", "/base") // -> "/base/absolute"
     */
    function resolveLink(path, routeBase, appBase) {
    	return join(appBase, resolve(path, routeBase));
    }

    /**
     * Get the uri for a Route, by matching it against the current location.
     *
     * @param {string} routePath The Routes resolved path
     * @param {string} pathname The current locations pathname
     */
    function extractBaseUri(routePath, pathname) {
    	const fullPath = normalizePath(stripSplat(routePath));
    	const baseSegments = segmentize(fullPath, true);
    	const pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);
    	const routeMatch = match({ fullPath }, join(...pathSegments));
    	return routeMatch && routeMatch.uri;
    }

    /*
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     */

    const POP = "POP";
    const PUSH = "PUSH";
    const REPLACE = "REPLACE";

    function getLocation(source) {
    	return {
    		...source.location,
    		pathname: encodeURI(decodeURI(source.location.pathname)),
    		state: source.history.state,
    		_key: (source.history.state && source.history.state._key) || "initial",
    	};
    }

    function createHistory(source) {
    	let listeners = [];
    	let location = getLocation(source);
    	let action = POP;

    	const notifyListeners = (listenerFns = listeners) =>
    		listenerFns.forEach(listener => listener({ location, action }));

    	return {
    		get location() {
    			return location;
    		},
    		listen(listener) {
    			listeners.push(listener);

    			const popstateListener = () => {
    				location = getLocation(source);
    				action = POP;
    				notifyListeners([listener]);
    			};

    			// Call listener when it is registered
    			notifyListeners([listener]);

    			const unlisten = addListener(source, "popstate", popstateListener);
    			return () => {
    				unlisten();
    				listeners = listeners.filter(fn => fn !== listener);
    			};
    		},
    		/**
    		 * Navigate to a new absolute route.
    		 *
    		 * @param {string|number} to The path to navigate to.
    		 *
    		 * If `to` is a number we will navigate to the stack entry index + `to`
    		 * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
    		 * @param {Object} options
    		 * @param {*} [options.state] The state will be accessible through `location.state`
    		 * @param {boolean} [options.replace=false] Replace the current entry in the history
    		 * stack, instead of pushing on a new one
    		 */
    		navigate(to, options) {
    			const { state = {}, replace = false } = options || {};
    			action = replace ? REPLACE : PUSH;
    			if (isNumber(to)) {
    				if (options) {
    					warn(
    						NAVIGATE_ID,
    						"Navigation options (state or replace) are not supported, " +
    							"when passing a number as the first argument to navigate. " +
    							"They are ignored.",
    					);
    				}
    				action = POP;
    				source.history.go(to);
    			} else {
    				const keyedState = { ...state, _key: createGlobalId() };
    				// try...catch iOS Safari limits to 100 pushState calls
    				try {
    					source.history[replace ? "replaceState" : "pushState"](
    						keyedState,
    						"",
    						to,
    					);
    				} catch (e) {
    					source.location[replace ? "replace" : "assign"](to);
    				}
    			}

    			location = getLocation(source);
    			notifyListeners();
    		},
    	};
    }

    function createStackFrame(state, uri) {
    	return { ...parsePath(uri), state };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
    	let index = 0;
    	let stack = [createStackFrame(null, initialPathname)];

    	return {
    		// This is just for testing...
    		get entries() {
    			return stack;
    		},
    		get location() {
    			return stack[index];
    		},
    		addEventListener() {},
    		removeEventListener() {},
    		history: {
    			get state() {
    				return stack[index].state;
    			},
    			pushState(state, title, uri) {
    				index++;
    				// Throw away anything in the stack with an index greater than the current index.
    				// This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.
    				// If we call `go(+n)` the stack entries with an index greater than the current index can
    				// be reused.
    				// However, if we navigate to a path, instead of a number, we want to create a new branch
    				// of navigation.
    				stack = stack.slice(0, index);
    				stack.push(createStackFrame(state, uri));
    			},
    			replaceState(state, title, uri) {
    				stack[index] = createStackFrame(state, uri);
    			},
    			go(to) {
    				const newIndex = index + to;
    				if (newIndex < 0 || newIndex > stack.length - 1) {
    					return;
    				}
    				index = newIndex;
    			},
    		},
    	};
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = !!(
    	!isSSR &&
    	window.document &&
    	window.document.createElement
    );
    // Use memory history in iframes (for example in Svelte REPL)
    const isEmbeddedPage = !isSSR && window.location.origin === "null";
    const globalHistory = createHistory(
    	canUseDOM && !isEmbeddedPage ? window : createMemorySource(),
    );
    const { navigate } = globalHistory;

    // We need to keep the focus candidate in a separate file, so svelte does
    // not update, when we mutate it.
    // Also, we need a single global reference, because taking focus needs to
    // work globally, even if we have multiple top level routers
    // eslint-disable-next-line import/no-mutable-exports
    let focusCandidate = null;

    // eslint-disable-next-line import/no-mutable-exports
    let initialNavigation = true;

    /**
     * Check if RouterA is above RouterB in the document
     * @param {number} routerIdA The first Routers id
     * @param {number} routerIdB The second Routers id
     */
    function isAbove(routerIdA, routerIdB) {
    	const routerMarkers = document.querySelectorAll("[data-svnav-router]");
    	for (let i = 0; i < routerMarkers.length; i++) {
    		const node = routerMarkers[i];
    		const currentId = Number(node.dataset.svnavRouter);
    		if (currentId === routerIdA) return true;
    		if (currentId === routerIdB) return false;
    	}
    	return false;
    }

    /**
     * Check if a Route candidate is the best choice to move focus to,
     * and store the best match.
     * @param {{
         level: number;
         routerId: number;
         route: {
           id: number;
           focusElement: import("svelte/store").Readable<Promise<Element>|null>;
         }
       }} item A Route candidate, that updated and is visible after a navigation
     */
    function pushFocusCandidate(item) {
    	if (
    		// Best candidate if it's the only candidate...
    		!focusCandidate ||
    		// Route is nested deeper, than previous candidate
    		// -> Route change was triggered in the deepest affected
    		// Route, so that's were focus should move to
    		item.level > focusCandidate.level ||
    		// If the level is identical, we want to focus the first Route in the document,
    		// so we pick the first Router lookin from page top to page bottom.
    		(item.level === focusCandidate.level &&
    			isAbove(item.routerId, focusCandidate.routerId))
    	) {
    		focusCandidate = item;
    	}
    }

    /**
     * Reset the focus candidate.
     */
    function clearFocusCandidate() {
    	focusCandidate = null;
    }

    function initialNavigationOccurred() {
    	initialNavigation = false;
    }

    /*
     * `focus` Adapted from https://github.com/oaf-project/oaf-side-effects/blob/master/src/index.ts
     *
     * https://github.com/oaf-project/oaf-side-effects/blob/master/LICENSE
     */
    function focus(elem) {
    	if (!elem) return false;
    	const TABINDEX = "tabindex";
    	try {
    		if (!elem.hasAttribute(TABINDEX)) {
    			elem.setAttribute(TABINDEX, "-1");
    			let unlisten;
    			// We remove tabindex after blur to avoid weird browser behavior
    			// where a mouse click can activate elements with tabindex="-1".
    			const blurListener = () => {
    				elem.removeAttribute(TABINDEX);
    				unlisten();
    			};
    			unlisten = addListener(elem, "blur", blurListener);
    		}
    		elem.focus();
    		return document.activeElement === elem;
    	} catch (e) {
    		// Apparently trying to focus a disabled element in IE can throw.
    		// See https://stackoverflow.com/a/1600194/2476884
    		return false;
    	}
    }

    function isEndMarker(elem, id) {
    	return Number(elem.dataset.svnavRouteEnd) === id;
    }

    function isHeading(elem) {
    	return /^H[1-6]$/i.test(elem.tagName);
    }

    function query(selector, parent = document) {
    	return parent.querySelector(selector);
    }

    function queryHeading(id) {
    	const marker = query(`[data-svnav-route-start="${id}"]`);
    	let current = marker.nextElementSibling;
    	while (!isEndMarker(current, id)) {
    		if (isHeading(current)) {
    			return current;
    		}
    		const heading = query("h1,h2,h3,h4,h5,h6", current);
    		if (heading) {
    			return heading;
    		}
    		current = current.nextElementSibling;
    	}
    	return null;
    }

    function handleFocus(route) {
    	Promise.resolve(get_store_value(route.focusElement)).then(elem => {
    		const focusElement = elem || queryHeading(route.id);
    		if (!focusElement) {
    			warn(
    				ROUTER_ID,
    				"Could not find an element to focus. " +
    					"You should always render a header for accessibility reasons, " +
    					'or set a custom focus element via the "useFocus" hook. ' +
    					"If you don't want this Route or Router to manage focus, " +
    					'pass "primary={false}" to it.',
    				route,
    				ROUTE_ID,
    			);
    		}
    		const headingFocused = focus(focusElement);
    		if (headingFocused) return;
    		focus(document.documentElement);
    	});
    }

    const createTriggerFocus =
    	(a11yConfig, announcementText, location) =>
    	(manageFocus, announceNavigation) =>
    		// Wait until the dom is updated, so we can look for headings
    		tick().then(() => {
    			if (!focusCandidate || initialNavigation) {
    				initialNavigationOccurred();
    				return;
    			}
    			if (manageFocus) {
    				handleFocus(focusCandidate.route);
    			}
    			if (a11yConfig.announcements && announceNavigation) {
    				const { path, fullPath, meta, params, uri } = focusCandidate.route;
    				const announcementMessage = a11yConfig.createAnnouncement(
    					{ path, fullPath, meta, params, uri },
    					get_store_value(location),
    				);
    				Promise.resolve(announcementMessage).then(message => {
    					announcementText.set(message);
    				});
    			}
    			clearFocusCandidate();
    		});

    const visuallyHiddenStyle =
    	"position:fixed;" +
    	"top:-1px;" +
    	"left:0;" +
    	"width:1px;" +
    	"height:1px;" +
    	"padding:0;" +
    	"overflow:hidden;" +
    	"clip:rect(0,0,0,0);" +
    	"white-space:nowrap;" +
    	"border:0;";

    /* node_modules/svelte-navigator/src/Router.svelte generated by Svelte v3.59.2 */

    const file$$ = "node_modules/svelte-navigator/src/Router.svelte";

    // (204:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}
    function create_if_block$w(ctx) {
    	let div;
    	let t;

    	let div_levels = [
    		{ role: "status" },
    		{ "aria-atomic": "true" },
    		{ "aria-live": "polite" },
    		{ "data-svnav-announcer": "" },
    		createInlineStyle(/*shouldDisableInlineStyles*/ ctx[6], visuallyHiddenStyle)
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*$announcementText*/ ctx[0]);
    			set_attributes(div, div_data);
    			add_location(div, file$$, 204, 1, 6149);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$announcementText*/ 1) set_data_maybe_contenteditable_dev(t, /*$announcementText*/ ctx[0], div_data['contenteditable']);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(204:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let current;

    	let div_levels = [
    		createMarkerProps(/*shouldDisableInlineStyles*/ ctx[6]),
    		{ "data-svnav-router": /*routerId*/ ctx[3] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
    	let if_block = /*isTopLevelRouter*/ ctx[2] && /*manageFocus*/ ctx[4] && /*a11yConfig*/ ctx[1].announcements && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			set_attributes(div, div_data);
    			add_location(div, file$$, 196, 0, 5982);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[21],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*isTopLevelRouter*/ ctx[2] && /*manageFocus*/ ctx[4] && /*a11yConfig*/ ctx[1].announcements) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const createId$1 = createCounter();
    const defaultBasepath = "/";

    function instance$10($$self, $$props, $$invalidate) {
    	let $location;
    	let $activeRoute;
    	let $prevLocation;
    	let $routes;
    	let $announcementText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, ['default']);
    	let { basepath = defaultBasepath } = $$props;
    	let { url = null } = $$props;
    	let { history = globalHistory } = $$props;
    	let { primary = true } = $$props;
    	let { a11y = {} } = $$props;
    	let { disableInlineStyles = false } = $$props;

    	const a11yConfig = {
    		createAnnouncement: route => `Navigated to ${route.uri}`,
    		announcements: true,
    		...a11y
    	};

    	// Remember the initial `basepath`, so we can fire a warning
    	// when the user changes it later
    	const initialBasepath = basepath;

    	const normalizedBasepath = normalizePath(basepath);
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const isTopLevelRouter = !locationContext;
    	const routerId = createId$1();
    	const manageFocus = primary && !(routerContext && !routerContext.manageFocus);
    	const announcementText = writable("");
    	validate_store(announcementText, 'announcementText');
    	component_subscribe($$self, announcementText, value => $$invalidate(0, $announcementText = value));

    	const shouldDisableInlineStyles = routerContext
    	? routerContext.disableInlineStyles
    	: disableInlineStyles;

    	const routes = writable([]);
    	validate_store(routes, 'routes');
    	component_subscribe($$self, routes, value => $$invalidate(20, $routes = value));
    	const activeRoute = writable(null);
    	validate_store(activeRoute, 'activeRoute');
    	component_subscribe($$self, activeRoute, value => $$invalidate(18, $activeRoute = value));

    	// Used in SSR to synchronously set that a Route is active.
    	let hasActiveRoute = false;

    	// Nesting level of router.
    	// We will need this to identify sibling routers, when moving
    	// focus on navigation, so we can focus the first possible router
    	const level = isTopLevelRouter ? 0 : routerContext.level + 1;

    	// If we're running an SSR we force the location to the `url` prop
    	const getInitialLocation = () => normalizeLocation(isSSR ? parsePath(url) : history.location, normalizedBasepath);

    	const location = isTopLevelRouter
    	? writable(getInitialLocation())
    	: locationContext;

    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(17, $location = value));
    	const prevLocation = writable($location);
    	validate_store(prevLocation, 'prevLocation');
    	component_subscribe($$self, prevLocation, value => $$invalidate(19, $prevLocation = value));
    	const triggerFocus = createTriggerFocus(a11yConfig, announcementText, location);
    	const createRouteFilter = routeId => routeList => routeList.filter(routeItem => routeItem.id !== routeId);

    	function registerRoute(route) {
    		if (isSSR) {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match(route, $location.pathname);

    			if (matchingRoute) {
    				hasActiveRoute = true;

    				// Return the match in SSR mode, so the matched Route can use it immediatly.
    				// Waiting for activeRoute to update does not work, because it updates
    				// after the Route is initialized
    				return matchingRoute; // eslint-disable-line consistent-return
    			}
    		} else {
    			routes.update(prevRoutes => {
    				// Remove an old version of the updated route,
    				// before pushing the new version
    				const nextRoutes = createRouteFilter(route.id)(prevRoutes);

    				nextRoutes.push(route);
    				return nextRoutes;
    			});
    		}
    	}

    	function unregisterRoute(routeId) {
    		routes.update(createRouteFilter(routeId));
    	}

    	if (!isTopLevelRouter && basepath !== defaultBasepath) {
    		warn(ROUTER_ID, 'Only top-level Routers can have a "basepath" prop. It is ignored.', { basepath });
    	}

    	if (isTopLevelRouter) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = history.listen(changedHistory => {
    				const normalizedLocation = normalizeLocation(changedHistory.location, normalizedBasepath);
    				prevLocation.set($location);
    				location.set(normalizedLocation);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		registerRoute,
    		unregisterRoute,
    		manageFocus,
    		level,
    		id: routerId,
    		history: isTopLevelRouter ? history : routerContext.history,
    		basepath: isTopLevelRouter
    		? normalizedBasepath
    		: routerContext.basepath,
    		disableInlineStyles: shouldDisableInlineStyles
    	});

    	const writable_props = ['basepath', 'url', 'history', 'primary', 'a11y', 'disableInlineStyles'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('basepath' in $$props) $$invalidate(11, basepath = $$props.basepath);
    		if ('url' in $$props) $$invalidate(12, url = $$props.url);
    		if ('history' in $$props) $$invalidate(13, history = $$props.history);
    		if ('primary' in $$props) $$invalidate(14, primary = $$props.primary);
    		if ('a11y' in $$props) $$invalidate(15, a11y = $$props.a11y);
    		if ('disableInlineStyles' in $$props) $$invalidate(16, disableInlineStyles = $$props.disableInlineStyles);
    		if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createCounter,
    		createInlineStyle,
    		createMarkerProps,
    		createId: createId$1,
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		normalizePath,
    		pick,
    		match,
    		normalizeLocation,
    		parsePath,
    		isSSR,
    		warn,
    		ROUTER_ID,
    		pushFocusCandidate,
    		visuallyHiddenStyle,
    		createTriggerFocus,
    		defaultBasepath,
    		basepath,
    		url,
    		history,
    		primary,
    		a11y,
    		disableInlineStyles,
    		a11yConfig,
    		initialBasepath,
    		normalizedBasepath,
    		locationContext,
    		routerContext,
    		isTopLevelRouter,
    		routerId,
    		manageFocus,
    		announcementText,
    		shouldDisableInlineStyles,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		level,
    		getInitialLocation,
    		location,
    		prevLocation,
    		triggerFocus,
    		createRouteFilter,
    		registerRoute,
    		unregisterRoute,
    		$location,
    		$activeRoute,
    		$prevLocation,
    		$routes,
    		$announcementText
    	});

    	$$self.$inject_state = $$props => {
    		if ('basepath' in $$props) $$invalidate(11, basepath = $$props.basepath);
    		if ('url' in $$props) $$invalidate(12, url = $$props.url);
    		if ('history' in $$props) $$invalidate(13, history = $$props.history);
    		if ('primary' in $$props) $$invalidate(14, primary = $$props.primary);
    		if ('a11y' in $$props) $$invalidate(15, a11y = $$props.a11y);
    		if ('disableInlineStyles' in $$props) $$invalidate(16, disableInlineStyles = $$props.disableInlineStyles);
    		if ('hasActiveRoute' in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*basepath*/ 2048) {
    			if (basepath !== initialBasepath) {
    				warn(ROUTER_ID, 'You cannot change the "basepath" prop. It is ignored.');
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$routes, $location*/ 1179648) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			{
    				const bestMatch = pick($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$location, $prevLocation*/ 655360) {
    			// Manage focus and announce navigation to screen reader users
    			{
    				if (isTopLevelRouter) {
    					const hasHash = !!$location.hash;

    					// When a hash is present in the url, we skip focus management, because
    					// focusing a different element will prevent in-page jumps (See #3)
    					const shouldManageFocus = !hasHash && manageFocus;

    					// We don't want to make an announcement, when the hash changes,
    					// but the active route stays the same
    					const announceNavigation = !hasHash || $location.pathname !== $prevLocation.pathname;

    					triggerFocus(shouldManageFocus, announceNavigation);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$activeRoute*/ 262144) {
    			// Queue matched Route, so top level Router can decide which Route to focus.
    			// Non primary Routers should just be ignored
    			if (manageFocus && $activeRoute && $activeRoute.primary) {
    				pushFocusCandidate({ level, routerId, route: $activeRoute });
    			}
    		}
    	};

    	return [
    		$announcementText,
    		a11yConfig,
    		isTopLevelRouter,
    		routerId,
    		manageFocus,
    		announcementText,
    		shouldDisableInlineStyles,
    		routes,
    		activeRoute,
    		location,
    		prevLocation,
    		basepath,
    		url,
    		history,
    		primary,
    		a11y,
    		disableInlineStyles,
    		$location,
    		$activeRoute,
    		$prevLocation,
    		$routes,
    		$$scope,
    		slots
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$10,
    			create_fragment$10,
    			safe_not_equal,
    			{
    				basepath: 11,
    				url: 12,
    				history: 13,
    				primary: 14,
    				a11y: 15,
    				disableInlineStyles: 16
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get history() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set history(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primary() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primary(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get a11y() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set a11y(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disableInlineStyles() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disableInlineStyles(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Router$1 = Router;

    /**
     * Check if a component or hook have been created outside of a
     * context providing component
     * @param {number} componentId
     * @param {*} props
     * @param {string?} ctxKey
     * @param {number?} ctxProviderId
     */
    function usePreflightCheck(
    	componentId,
    	props,
    	ctxKey = ROUTER,
    	ctxProviderId = ROUTER_ID,
    ) {
    	const ctx = getContext(ctxKey);
    	if (!ctx) {
    		fail(
    			componentId,
    			label =>
    				`You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`,
    			props,
    		);
    	}
    }

    const toReadonly = ctx => {
    	const { subscribe } = getContext(ctx);
    	return { subscribe };
    };

    /**
     * Access the current location via a readable store.
     * @returns {import("svelte/store").Readable<{
        pathname: string;
        search: string;
        hash: string;
        state: {};
      }>}
     *
     * @example
      ```html
      <script>
        import { useLocation } from "svelte-navigator";

        const location = useLocation();

        $: console.log($location);
        // {
        //   pathname: "/blog",
        //   search: "?id=123",
        //   hash: "#comments",
        //   state: {}
        // }
      </script>
      ```
     */
    function useLocation() {
    	usePreflightCheck(USE_LOCATION_ID);
    	return toReadonly(LOCATION);
    }

    /**
     * @typedef {{
        path: string;
        fullPath: string;
        uri: string;
        params: {};
      }} RouteMatch
     */

    /**
     * @typedef {import("svelte/store").Readable<RouteMatch|null>} RouteMatchStore
     */

    /**
     * Access the history of top level Router.
     */
    function useHistory() {
    	const { history } = getContext(ROUTER);
    	return history;
    }

    /**
     * Access the base of the parent Route.
     */
    function useRouteBase() {
    	const route = getContext(ROUTE);
    	return route ? derived(route, _route => _route.base) : writable("/");
    }

    /**
     * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.
     * It is used under the hood in `Link` and `useNavigate`.
     * You can use it to manually resolve links, when using the `link` or `links` actions.
     *
     * @returns {(path: string) => string}
     *
     * @example
      ```html
      <script>
        import { link, useResolve } from "svelte-navigator";

        const resolve = useResolve();
        // `resolvedLink` will be resolved relative to its parent Route
        // and the Routers `basepath`
        const resolvedLink = resolve("relativePath");
      </script>

      <a href={resolvedLink} use:link>Relative link</a>
      ```
     */
    function useResolve() {
    	usePreflightCheck(USE_RESOLVE_ID);
    	const routeBase = useRouteBase();
    	const { basepath: appBase } = getContext(ROUTER);
    	/**
    	 * Resolves the path relative to the current route and basepath.
    	 *
    	 * @param {string} path The path to resolve
    	 * @returns {string} The resolved path
    	 */
    	const resolve = path => resolveLink(path, get_store_value(routeBase), appBase);
    	return resolve;
    }

    /**
     * A hook, that returns a context-aware version of `navigate`.
     * It will automatically resolve the given link relative to the current Route.
     * It will also resolve a link against the `basepath` of the Router.
     *
     * @example
      ```html
      <!-- App.svelte -->
      <script>
        import { link, Route } from "svelte-navigator";
        import RouteComponent from "./RouteComponent.svelte";
      </script>

      <Router>
        <Route path="route1">
          <RouteComponent />
        </Route>
        <!-- ... -->
      </Router>

      <!-- RouteComponent.svelte -->
      <script>
        import { useNavigate } from "svelte-navigator";

        const navigate = useNavigate();
      </script>

      <button on:click="{() => navigate('relativePath')}">
        go to /route1/relativePath
      </button>
      <button on:click="{() => navigate('/absolutePath')}">
        go to /absolutePath
      </button>
      ```
      *
      * @example
      ```html
      <!-- App.svelte -->
      <script>
        import { link, Route } from "svelte-navigator";
        import RouteComponent from "./RouteComponent.svelte";
      </script>

      <Router basepath="/base">
        <Route path="route1">
          <RouteComponent />
        </Route>
        <!-- ... -->
      </Router>

      <!-- RouteComponent.svelte -->
      <script>
        import { useNavigate } from "svelte-navigator";

        const navigate = useNavigate();
      </script>

      <button on:click="{() => navigate('relativePath')}">
        go to /base/route1/relativePath
      </button>
      <button on:click="{() => navigate('/absolutePath')}">
        go to /base/absolutePath
      </button>
      ```
     */
    function useNavigate() {
    	usePreflightCheck(USE_NAVIGATE_ID);
    	const resolve = useResolve();
    	const { navigate } = useHistory();
    	/**
    	 * Navigate to a new route.
    	 * Resolves the link relative to the current route and basepath.
    	 *
    	 * @param {string|number} to The path to navigate to.
    	 *
    	 * If `to` is a number we will navigate to the stack entry index + `to`
    	 * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
    	 * @param {Object} options
    	 * @param {*} [options.state]
    	 * @param {boolean} [options.replace=false]
    	 */
    	const navigateRelative = (to, options) => {
    		// If to is a number, we navigate to the target stack entry via `history.go`.
    		// Otherwise resolve the link
    		const target = isNumber(to) ? to : resolve(to);
    		return navigate(target, options);
    	};
    	return navigateRelative;
    }

    /* node_modules/svelte-navigator/src/Route.svelte generated by Svelte v3.59.2 */
    const file$_ = "node_modules/svelte-navigator/src/Route.svelte";

    const get_default_slot_changes = dirty => ({
    	params: dirty & /*$params*/ 16,
    	location: dirty & /*$location*/ 8
    });

    const get_default_slot_context = ctx => ({
    	params: isSSR ? get_store_value(/*params*/ ctx[10]) : /*$params*/ ctx[4],
    	location: /*$location*/ ctx[3],
    	navigate: /*navigate*/ ctx[11]
    });

    // (98:0) {#if isActive}
    function create_if_block$v(ctx) {
    	let router;
    	let current;

    	router = new Router$1({
    			props: {
    				primary: /*primary*/ ctx[1],
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const router_changes = {};
    			if (dirty & /*primary*/ 2) router_changes.primary = /*primary*/ ctx[1];

    			if (dirty & /*$$scope, component, $location, $params, $$restProps*/ 528409) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(98:0) {#if isActive}",
    		ctx
    	});

    	return block;
    }

    // (114:2) {:else}
    function create_else_block$h(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, $params, $location*/ 524312)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(114:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (106:2) {#if component !== null}
    function create_if_block_1$g(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[3] },
    		{ navigate: /*navigate*/ ctx[11] },
    		isSSR ? get_store_value(/*params*/ ctx[10]) : /*$params*/ ctx[4],
    		/*$$restProps*/ ctx[12]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, navigate, isSSR, get, params, $params, $$restProps*/ 7192)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 8 && { location: /*$location*/ ctx[3] },
    					dirty & /*navigate*/ 2048 && { navigate: /*navigate*/ ctx[11] },
    					dirty & /*isSSR, get, params, $params*/ 1040 && get_spread_object(isSSR ? get_store_value(/*params*/ ctx[10]) : /*$params*/ ctx[4]),
    					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12])
    				])
    			: {};

    			if (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(106:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    // (99:1) <Router {primary}>
    function create_default_slot$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$g, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(99:1) <Router {primary}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;

    	let div0_levels = [
    		createMarkerProps(/*disableInlineStyles*/ ctx[7]),
    		{ "data-svnav-route-start": /*id*/ ctx[5] }
    	];

    	let div_data_1 = {};

    	for (let i = 0; i < div0_levels.length; i += 1) {
    		div_data_1 = assign(div_data_1, div0_levels[i]);
    	}

    	let if_block = /*isActive*/ ctx[2] && create_if_block$v(ctx);

    	let div1_levels = [
    		createMarkerProps(/*disableInlineStyles*/ ctx[7]),
    		{ "data-svnav-route-end": /*id*/ ctx[5] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div_data = assign(div_data, div1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			set_attributes(div0, div_data_1);
    			add_location(div0, file$_, 96, 0, 2664);
    			set_attributes(div1, div_data);
    			add_location(div1, file$_, 122, 0, 3340);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isActive*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isActive*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const createId = createCounter();

    function instance$$($$self, $$props, $$invalidate) {
    	let isActive;
    	const omit_props_names = ["path","component","meta","primary"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $activeRoute;
    	let $location;
    	let $parentBase;
    	let $params;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Route', slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	let { meta = {} } = $$props;
    	let { primary = true } = $$props;
    	usePreflightCheck(ROUTE_ID, $$props);
    	const id = createId();
    	const { registerRoute, unregisterRoute, activeRoute, disableInlineStyles } = getContext(ROUTER);
    	validate_store(activeRoute, 'activeRoute');
    	component_subscribe($$self, activeRoute, value => $$invalidate(16, $activeRoute = value));
    	const parentBase = useRouteBase();
    	validate_store(parentBase, 'parentBase');
    	component_subscribe($$self, parentBase, value => $$invalidate(17, $parentBase = value));
    	const location = useLocation();
    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(3, $location = value));
    	const focusElement = writable(null);

    	// In SSR we cannot wait for $activeRoute to update,
    	// so we use the match returned from `registerRoute` instead
    	let ssrMatch;

    	const route = writable();
    	const params = writable({});
    	validate_store(params, 'params');
    	component_subscribe($$self, params, value => $$invalidate(4, $params = value));
    	setContext(ROUTE, route);
    	setContext(ROUTE_PARAMS, params);
    	setContext(FOCUS_ELEM, focusElement);

    	// We need to call useNavigate after the route is set,
    	// so we can use the routes path for link resolution
    	const navigate = useNavigate();

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway
    	if (!isSSR) {
    		onDestroy(() => unregisterRoute(id));
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('path' in $$new_props) $$invalidate(13, path = $$new_props.path);
    		if ('component' in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ('meta' in $$new_props) $$invalidate(14, meta = $$new_props.meta);
    		if ('primary' in $$new_props) $$invalidate(1, primary = $$new_props.primary);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createCounter,
    		createMarkerProps,
    		createId,
    		getContext,
    		onDestroy,
    		setContext,
    		writable,
    		get: get_store_value,
    		Router: Router$1,
    		ROUTER,
    		ROUTE,
    		ROUTE_PARAMS,
    		FOCUS_ELEM,
    		useLocation,
    		useNavigate,
    		useRouteBase,
    		usePreflightCheck,
    		isSSR,
    		extractBaseUri,
    		join,
    		ROUTE_ID,
    		path,
    		component,
    		meta,
    		primary,
    		id,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		disableInlineStyles,
    		parentBase,
    		location,
    		focusElement,
    		ssrMatch,
    		route,
    		params,
    		navigate,
    		isActive,
    		$activeRoute,
    		$location,
    		$parentBase,
    		$params
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('path' in $$props) $$invalidate(13, path = $$new_props.path);
    		if ('component' in $$props) $$invalidate(0, component = $$new_props.component);
    		if ('meta' in $$props) $$invalidate(14, meta = $$new_props.meta);
    		if ('primary' in $$props) $$invalidate(1, primary = $$new_props.primary);
    		if ('ssrMatch' in $$props) $$invalidate(15, ssrMatch = $$new_props.ssrMatch);
    		if ('isActive' in $$props) $$invalidate(2, isActive = $$new_props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*path, $parentBase, meta, $location, primary*/ 155658) {
    			{
    				// The route store will be re-computed whenever props, location or parentBase change
    				const isDefault = path === "";

    				const rawBase = join($parentBase, path);

    				const updatedRoute = {
    					id,
    					path,
    					meta,
    					// If no path prop is given, this Route will act as the default Route
    					// that is rendered if no other Route in the Router is a match
    					default: isDefault,
    					fullPath: isDefault ? "" : rawBase,
    					base: isDefault
    					? $parentBase
    					: extractBaseUri(rawBase, $location.pathname),
    					primary,
    					focusElement
    				};

    				route.set(updatedRoute);

    				// If we're in SSR mode and the Route matches,
    				// `registerRoute` will return the match
    				$$invalidate(15, ssrMatch = registerRoute(updatedRoute));
    			}
    		}

    		if ($$self.$$.dirty & /*ssrMatch, $activeRoute*/ 98304) {
    			$$invalidate(2, isActive = !!(ssrMatch || $activeRoute && $activeRoute.id === id));
    		}

    		if ($$self.$$.dirty & /*isActive, ssrMatch, $activeRoute*/ 98308) {
    			if (isActive) {
    				const { params: activeParams } = ssrMatch || $activeRoute;
    				params.set(activeParams);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		primary,
    		isActive,
    		$location,
    		$params,
    		id,
    		activeRoute,
    		disableInlineStyles,
    		parentBase,
    		location,
    		params,
    		navigate,
    		$$restProps,
    		path,
    		meta,
    		ssrMatch,
    		$activeRoute,
    		$parentBase,
    		slots,
    		$$scope
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$$, create_fragment$$, safe_not_equal, {
    			path: 13,
    			component: 0,
    			meta: 14,
    			primary: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get meta() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set meta(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primary() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primary(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Route$1 = Route;

    /* node_modules/svelte-navigator/src/Link.svelte generated by Svelte v3.59.2 */
    const file$Z = "node_modules/svelte-navigator/src/Link.svelte";

    function create_fragment$_(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	let a_levels = [{ href: /*href*/ ctx[0] }, /*ariaCurrent*/ ctx[2], /*props*/ ctx[1]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$Z, 65, 0, 1861);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onClick*/ ctx[4], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				dirty & /*ariaCurrent*/ 4 && /*ariaCurrent*/ ctx[2],
    				dirty & /*props*/ 2 && /*props*/ ctx[1]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let href;
    	let isPartiallyCurrent;
    	let isCurrent;
    	let isExactCurrent;
    	let ariaCurrent;
    	let props;
    	const omit_props_names = ["to","replace","state","getProps"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	let { to } = $$props;
    	let { replace = false } = $$props;
    	let { state = {} } = $$props;
    	let { getProps = null } = $$props;
    	usePreflightCheck(LINK_ID, $$props);
    	const location = useLocation();
    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(11, $location = value));
    	const dispatch = createEventDispatcher();
    	const resolve = useResolve();
    	const { navigate } = useHistory();

    	function onClick(event) {
    		dispatch("click", event);

    		if (shouldNavigate(event)) {
    			event.preventDefault();

    			// Don't push another entry to the history stack when the user
    			// clicks on a Link to the page they are currently on.
    			const shouldReplace = isExactCurrent || replace;

    			navigate(href, { state, replace: shouldReplace });
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (to === undefined && !('to' in $$props || $$self.$$.bound[$$self.$$.props['to']])) {
    			console.warn("<Link> was created without expected prop 'to'");
    		}
    	});

    	$$self.$$set = $$new_props => {
    		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('to' in $$new_props) $$invalidate(5, to = $$new_props.to);
    		if ('replace' in $$new_props) $$invalidate(6, replace = $$new_props.replace);
    		if ('state' in $$new_props) $$invalidate(7, state = $$new_props.state);
    		if ('getProps' in $$new_props) $$invalidate(8, getProps = $$new_props.getProps);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		useLocation,
    		useResolve,
    		useHistory,
    		usePreflightCheck,
    		shouldNavigate,
    		isFunction,
    		startsWith: startsWith$1,
    		LINK_ID,
    		parsePath,
    		stringifyPath,
    		to,
    		replace,
    		state,
    		getProps,
    		location,
    		dispatch,
    		resolve,
    		navigate,
    		onClick,
    		href,
    		isExactCurrent,
    		isCurrent,
    		isPartiallyCurrent,
    		props,
    		ariaCurrent,
    		$location
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
    		if ('to' in $$props) $$invalidate(5, to = $$new_props.to);
    		if ('replace' in $$props) $$invalidate(6, replace = $$new_props.replace);
    		if ('state' in $$props) $$invalidate(7, state = $$new_props.state);
    		if ('getProps' in $$props) $$invalidate(8, getProps = $$new_props.getProps);
    		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
    		if ('isExactCurrent' in $$props) isExactCurrent = $$new_props.isExactCurrent;
    		if ('isCurrent' in $$props) $$invalidate(9, isCurrent = $$new_props.isCurrent);
    		if ('isPartiallyCurrent' in $$props) $$invalidate(10, isPartiallyCurrent = $$new_props.isPartiallyCurrent);
    		if ('props' in $$props) $$invalidate(1, props = $$new_props.props);
    		if ('ariaCurrent' in $$props) $$invalidate(2, ariaCurrent = $$new_props.ariaCurrent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*to, $location*/ 2080) {
    			// We need to pass location here to force re-resolution of the link,
    			// when the pathname changes. Otherwise we could end up with stale path params,
    			// when for example an :id changes in the parent Routes path
    			$$invalidate(0, href = resolve(to, $location));
    		}

    		if ($$self.$$.dirty & /*$location, href*/ 2049) {
    			$$invalidate(10, isPartiallyCurrent = startsWith$1($location.pathname, href));
    		}

    		if ($$self.$$.dirty & /*href, $location*/ 2049) {
    			$$invalidate(9, isCurrent = href === $location.pathname);
    		}

    		if ($$self.$$.dirty & /*href, $location*/ 2049) {
    			isExactCurrent = parsePath(href) === stringifyPath($location);
    		}

    		if ($$self.$$.dirty & /*isCurrent*/ 512) {
    			$$invalidate(2, ariaCurrent = isCurrent ? { "aria-current": "page" } : {});
    		}

    		$$invalidate(1, props = (() => {
    			if (isFunction(getProps)) {
    				const dynamicProps = getProps({
    					location: $location,
    					href,
    					isPartiallyCurrent,
    					isCurrent
    				});

    				return { ...$$restProps, ...dynamicProps };
    			}

    			return $$restProps;
    		})());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		href,
    		props,
    		ariaCurrent,
    		location,
    		onClick,
    		to,
    		replace,
    		state,
    		getProps,
    		isCurrent,
    		isPartiallyCurrent,
    		$location,
    		$$scope,
    		slots
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$_, create_fragment$_, safe_not_equal, { to: 5, replace: 6, state: 7, getProps: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get to() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Link$1 = Link;

    const new_account = function (account, authkey, nickname) {
        return {
            account: account,
            authkey: authkey,
            nickname: nickname,
            on_chain: null,
            balance: null,
        };
    };
    const signingAccount = writable(new_account("", "", ""));
    const mnem = writable("");
    const isInit = writable(false);
    const isRefreshingAccounts = writable(false);
    const all_accounts = writable([]);
    const isAccountsLoaded = writable(false);
    const accountEvents = writable({}); // TODO define interface AccountEvent
    const makeWhole = writable({});

    // one of the Errors mapped in carpeError.ts
    // display these errors
    // the state get switeched to false whenever a new backlog submission happens.
    // todo: each error needs have its own rules for clearing
    const displayInsufficientBalance = writable({});
    const displayWrongDifficulty = writable({});
    const displayTooManyProofs = writable({});
    const displayDiscontinuity = writable({});
    const displayInvalidProof = writable({});
    const clearDisplayErrors = () => {
        displayWrongDifficulty.set({});
        displayTooManyProofs.set({});
        displayDiscontinuity.set({});
        displayInvalidProof.set({});
        displayInsufficientBalance.set({});
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*! UIkit 3.17.11 | https://www.getuikit.com | (c) 2014 - 2023 YOOtheme | MIT License */

    var uikit = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        const { hasOwnProperty, toString } = Object.prototype;
        function hasOwn(obj, key) {
          return hasOwnProperty.call(obj, key);
        }
        const hyphenateRe = /\B([A-Z])/g;
        const hyphenate = memoize((str) => str.replace(hyphenateRe, "-$1").toLowerCase());
        const camelizeRe = /-(\w)/g;
        const camelize = memoize(
          (str) => (str.charAt(0).toLowerCase() + str.slice(1)).replace(camelizeRe, (_, c) => c.toUpperCase())
        );
        const ucfirst = memoize((str) => str.charAt(0).toUpperCase() + str.slice(1));
        function startsWith(str, search) {
          var _a;
          return (_a = str == null ? void 0 : str.startsWith) == null ? void 0 : _a.call(str, search);
        }
        function endsWith(str, search) {
          var _a;
          return (_a = str == null ? void 0 : str.endsWith) == null ? void 0 : _a.call(str, search);
        }
        function includes(obj, search) {
          var _a;
          return (_a = obj == null ? void 0 : obj.includes) == null ? void 0 : _a.call(obj, search);
        }
        function findIndex(array, predicate) {
          var _a;
          return (_a = array == null ? void 0 : array.findIndex) == null ? void 0 : _a.call(array, predicate);
        }
        const { isArray, from: toArray } = Array;
        const { assign } = Object;
        function isFunction(obj) {
          return typeof obj === "function";
        }
        function isObject(obj) {
          return obj !== null && typeof obj === "object";
        }
        function isPlainObject(obj) {
          return toString.call(obj) === "[object Object]";
        }
        function isWindow(obj) {
          return isObject(obj) && obj === obj.window;
        }
        function isDocument(obj) {
          return nodeType(obj) === 9;
        }
        function isNode(obj) {
          return nodeType(obj) >= 1;
        }
        function isElement(obj) {
          return nodeType(obj) === 1;
        }
        function nodeType(obj) {
          return !isWindow(obj) && isObject(obj) && obj.nodeType;
        }
        function isBoolean(value) {
          return typeof value === "boolean";
        }
        function isString(value) {
          return typeof value === "string";
        }
        function isNumber(value) {
          return typeof value === "number";
        }
        function isNumeric(value) {
          return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
        }
        function isEmpty(obj) {
          return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);
        }
        function isUndefined(value) {
          return value === void 0;
        }
        function toBoolean(value) {
          return isBoolean(value) ? value : value === "true" || value === "1" || value === "" ? true : value === "false" || value === "0" ? false : value;
        }
        function toNumber(value) {
          const number = Number(value);
          return isNaN(number) ? false : number;
        }
        function toFloat(value) {
          return parseFloat(value) || 0;
        }
        function toNode(element) {
          return toNodes(element)[0];
        }
        function toNodes(element) {
          return isNode(element) ? [element] : Array.from(element || []).filter(isNode);
        }
        function toWindow(element) {
          if (isWindow(element)) {
            return element;
          }
          element = toNode(element);
          const document = isDocument(element) ? element : element == null ? void 0 : element.ownerDocument;
          return (document == null ? void 0 : document.defaultView) || window;
        }
        function isEqual(value, other) {
          return value === other || isObject(value) && isObject(other) && Object.keys(value).length === Object.keys(other).length && each(value, (val, key) => val === other[key]);
        }
        function swap(value, a, b) {
          return value.replace(new RegExp(`${a}|${b}`, "g"), (match) => match === a ? b : a);
        }
        function last(array) {
          return array[array.length - 1];
        }
        function each(obj, cb) {
          for (const key in obj) {
            if (false === cb(obj[key], key)) {
              return false;
            }
          }
          return true;
        }
        function sortBy(array, prop) {
          return array.slice().sort(
            ({ [prop]: propA = 0 }, { [prop]: propB = 0 }) => propA > propB ? 1 : propB > propA ? -1 : 0
          );
        }
        function sumBy(array, iteratee) {
          return array.reduce(
            (sum, item) => sum + toFloat(isFunction(iteratee) ? iteratee(item) : item[iteratee]),
            0
          );
        }
        function uniqueBy(array, prop) {
          const seen = /* @__PURE__ */ new Set();
          return array.filter(({ [prop]: check }) => seen.has(check) ? false : seen.add(check));
        }
        function pick(obj, props) {
          return props.reduce((res, prop) => ({ ...res, [prop]: obj[prop] }), {});
        }
        function clamp(number, min = 0, max = 1) {
          return Math.min(Math.max(toNumber(number) || 0, min), max);
        }
        function noop() {
        }
        function intersectRect(...rects) {
          return [
            ["bottom", "top"],
            ["right", "left"]
          ].every(
            ([minProp, maxProp]) => Math.min(...rects.map(({ [minProp]: min }) => min)) - Math.max(...rects.map(({ [maxProp]: max }) => max)) > 0
          );
        }
        function pointInRect(point, rect) {
          return point.x <= rect.right && point.x >= rect.left && point.y <= rect.bottom && point.y >= rect.top;
        }
        function ratio(dimensions, prop, value) {
          const aProp = prop === "width" ? "height" : "width";
          return {
            [aProp]: dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp],
            [prop]: value
          };
        }
        function contain(dimensions, maxDimensions) {
          dimensions = { ...dimensions };
          for (const prop in dimensions) {
            dimensions = dimensions[prop] > maxDimensions[prop] ? ratio(dimensions, prop, maxDimensions[prop]) : dimensions;
          }
          return dimensions;
        }
        function cover$1(dimensions, maxDimensions) {
          dimensions = contain(dimensions, maxDimensions);
          for (const prop in dimensions) {
            dimensions = dimensions[prop] < maxDimensions[prop] ? ratio(dimensions, prop, maxDimensions[prop]) : dimensions;
          }
          return dimensions;
        }
        const Dimensions = { ratio, contain, cover: cover$1 };
        function getIndex(i, elements, current = 0, finite = false) {
          elements = toNodes(elements);
          const { length } = elements;
          if (!length) {
            return -1;
          }
          i = isNumeric(i) ? toNumber(i) : i === "next" ? current + 1 : i === "previous" ? current - 1 : i === "last" ? length - 1 : elements.indexOf(toNode(i));
          if (finite) {
            return clamp(i, 0, length - 1);
          }
          i %= length;
          return i < 0 ? i + length : i;
        }
        function memoize(fn) {
          const cache = /* @__PURE__ */ Object.create(null);
          return (key, ...args) => cache[key] || (cache[key] = fn(key, ...args));
        }

        function attr(element, name, value) {
          var _a;
          if (isObject(name)) {
            for (const key in name) {
              attr(element, key, name[key]);
            }
            return;
          }
          if (isUndefined(value)) {
            return (_a = toNode(element)) == null ? void 0 : _a.getAttribute(name);
          } else {
            for (const el of toNodes(element)) {
              if (isFunction(value)) {
                value = value.call(el, attr(el, name));
              }
              if (value === null) {
                removeAttr(el, name);
              } else {
                el.setAttribute(name, value);
              }
            }
          }
        }
        function hasAttr(element, name) {
          return toNodes(element).some((element2) => element2.hasAttribute(name));
        }
        function removeAttr(element, name) {
          toNodes(element).forEach((element2) => element2.removeAttribute(name));
        }
        function data(element, attribute) {
          for (const name of [attribute, `data-${attribute}`]) {
            if (hasAttr(element, name)) {
              return attr(element, name);
            }
          }
        }

        function addClass(element, ...classes) {
          for (const node of toNodes(element)) {
            const add = toClasses(classes).filter((cls) => !hasClass(node, cls));
            if (add.length) {
              node.classList.add(...add);
            }
          }
        }
        function removeClass(element, ...classes) {
          for (const node of toNodes(element)) {
            const remove = toClasses(classes).filter((cls) => hasClass(node, cls));
            if (remove.length) {
              node.classList.remove(...remove);
            }
          }
        }
        function removeClasses$1(element, clsRegex) {
          clsRegex = new RegExp(clsRegex);
          for (const node of toNodes(element)) {
            node.classList.remove(...toArray(node.classList).filter((cls) => cls.match(clsRegex)));
          }
        }
        function replaceClass(element, oldClass, newClass) {
          newClass = toClasses(newClass);
          oldClass = toClasses(oldClass).filter((cls) => !includes(newClass, cls));
          removeClass(element, oldClass);
          addClass(element, newClass);
        }
        function hasClass(element, cls) {
          [cls] = toClasses(cls);
          return toNodes(element).some((node) => node.classList.contains(cls));
        }
        function toggleClass(element, cls, force) {
          const classes = toClasses(cls);
          if (!isUndefined(force)) {
            force = !!force;
          }
          for (const node of toNodes(element)) {
            for (const cls2 of classes) {
              node.classList.toggle(cls2, force);
            }
          }
        }
        function toClasses(str) {
          return str ? isArray(str) ? str.map(toClasses).flat() : String(str).split(/[ ,]/).filter(Boolean) : [];
        }

        const voidElements = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        function isVoidElement(element) {
          return toNodes(element).some((element2) => voidElements[element2.tagName.toLowerCase()]);
        }
        function isVisible(element) {
          return toNodes(element).some(
            (element2) => element2.offsetWidth || element2.offsetHeight || element2.getClientRects().length
          );
        }
        const selInput = "input,select,textarea,button";
        function isInput(element) {
          return toNodes(element).some((element2) => matches(element2, selInput));
        }
        const selFocusable = `${selInput},a[href],[tabindex]`;
        function isFocusable(element) {
          return matches(element, selFocusable);
        }
        function parent(element) {
          var _a;
          return (_a = toNode(element)) == null ? void 0 : _a.parentElement;
        }
        function filter$1(element, selector) {
          return toNodes(element).filter((element2) => matches(element2, selector));
        }
        function matches(element, selector) {
          return toNodes(element).some((element2) => element2.matches(selector));
        }
        function closest(element, selector) {
          var _a;
          return (_a = toNode(element)) == null ? void 0 : _a.closest(startsWith(selector, ">") ? selector.slice(1) : selector);
        }
        function within(element, selector) {
          return isString(selector) ? !!closest(element, selector) : toNode(selector).contains(toNode(element));
        }
        function parents(element, selector) {
          const elements = [];
          while (element = parent(element)) {
            if (!selector || matches(element, selector)) {
              elements.push(element);
            }
          }
          return elements;
        }
        function children(element, selector) {
          element = toNode(element);
          const children2 = element ? toArray(element.children) : [];
          return selector ? filter$1(children2, selector) : children2;
        }
        function index(element, ref) {
          return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);
        }
        function isSameSiteAnchor(el) {
          el = toNode(el);
          return el && ["origin", "pathname", "search"].every((part) => el[part] === location[part]);
        }
        function getTargetedElement(el) {
          if (isSameSiteAnchor(el)) {
            el = toNode(el);
            const id = decodeURIComponent(el.hash).substring(1);
            return document.getElementById(id) || document.getElementsByName(id)[0];
          }
        }

        function query(selector, context) {
          return find(selector, getContext(selector, context));
        }
        function queryAll(selector, context) {
          return findAll(selector, getContext(selector, context));
        }
        function find(selector, context) {
          return toNode(_query(selector, toNode(context), "querySelector"));
        }
        function findAll(selector, context) {
          return toNodes(_query(selector, toNode(context), "querySelectorAll"));
        }
        const contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
        const isContextSelector = memoize((selector) => selector.match(contextSelectorRe));
        function getContext(selector, context = document) {
          return isString(selector) && isContextSelector(selector) || isDocument(context) ? context : context.ownerDocument;
        }
        const contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;
        const sanatize = memoize((selector) => selector.replace(contextSanitizeRe, "$1 *"));
        function _query(selector, context = document, queryFn) {
          if (!selector || !isString(selector)) {
            return selector;
          }
          selector = sanatize(selector);
          if (isContextSelector(selector)) {
            const split = splitSelector(selector);
            selector = "";
            for (let sel of split) {
              let ctx = context;
              if (sel[0] === "!") {
                const selectors = sel.substr(1).trim().split(" ");
                ctx = parent(context).closest(selectors[0]);
                sel = selectors.slice(1).join(" ").trim();
                if (!sel.length && split.length === 1) {
                  return ctx;
                }
              }
              if (sel[0] === "-") {
                const selectors = sel.substr(1).trim().split(" ");
                const prev = (ctx || context).previousElementSibling;
                ctx = matches(prev, sel.substr(1)) ? prev : null;
                sel = selectors.slice(1).join(" ");
              }
              if (ctx) {
                selector += `${selector ? "," : ""}${domPath(ctx)} ${sel}`;
              }
            }
            context = document;
          }
          try {
            return context[queryFn](selector);
          } catch (e) {
            return null;
          }
        }
        const selectorRe = /.*?[^\\](?:,|$)/g;
        const splitSelector = memoize(
          (selector) => selector.match(selectorRe).map((selector2) => selector2.replace(/,$/, "").trim())
        );
        function domPath(element) {
          const names = [];
          while (element.parentNode) {
            const id = attr(element, "id");
            if (id) {
              names.unshift(`#${escape(id)}`);
              break;
            } else {
              let { tagName } = element;
              if (tagName !== "HTML") {
                tagName += `:nth-child(${index(element) + 1})`;
              }
              names.unshift(tagName);
              element = element.parentNode;
            }
          }
          return names.join(" > ");
        }
        function escape(css) {
          return isString(css) ? CSS.escape(css) : "";
        }

        function on(...args) {
          let [targets, types, selector, listener, useCapture = false] = getArgs(args);
          if (listener.length > 1) {
            listener = detail(listener);
          }
          if (useCapture == null ? void 0 : useCapture.self) {
            listener = selfFilter(listener);
          }
          if (selector) {
            listener = delegate(selector, listener);
          }
          for (const type of types) {
            for (const target of targets) {
              target.addEventListener(type, listener, useCapture);
            }
          }
          return () => off(targets, types, listener, useCapture);
        }
        function off(...args) {
          let [targets, types, , listener, useCapture = false] = getArgs(args);
          for (const type of types) {
            for (const target of targets) {
              target.removeEventListener(type, listener, useCapture);
            }
          }
        }
        function once(...args) {
          const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);
          const off2 = on(
            element,
            types,
            selector,
            (e) => {
              const result = !condition || condition(e);
              if (result) {
                off2();
                listener(e, result);
              }
            },
            useCapture
          );
          return off2;
        }
        function trigger(targets, event, detail2) {
          return toEventTargets(targets).every(
            (target) => target.dispatchEvent(createEvent(event, true, true, detail2))
          );
        }
        function createEvent(e, bubbles = true, cancelable = false, detail2) {
          if (isString(e)) {
            e = new CustomEvent(e, { bubbles, cancelable, detail: detail2 });
          }
          return e;
        }
        function getArgs(args) {
          args[0] = toEventTargets(args[0]);
          if (isString(args[1])) {
            args[1] = args[1].split(" ");
          }
          if (isFunction(args[2])) {
            args.splice(2, 0, false);
          }
          return args;
        }
        function delegate(selector, listener) {
          return (e) => {
            const current = selector[0] === ">" ? findAll(selector, e.currentTarget).reverse().find((element) => element.contains(e.target)) : e.target.closest(selector);
            if (current) {
              e.current = current;
              listener.call(this, e);
              delete e.current;
            }
          };
        }
        function detail(listener) {
          return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);
        }
        function selfFilter(listener) {
          return function(e) {
            if (e.target === e.currentTarget || e.target === e.current) {
              return listener.call(null, e);
            }
          };
        }
        function isEventTarget(target) {
          return target && "addEventListener" in target;
        }
        function toEventTarget(target) {
          return isEventTarget(target) ? target : toNode(target);
        }
        function toEventTargets(target) {
          return isArray(target) ? target.map(toEventTarget).filter(Boolean) : isString(target) ? findAll(target) : isEventTarget(target) ? [target] : toNodes(target);
        }
        function isTouch(e) {
          return e.pointerType === "touch" || !!e.touches;
        }
        function getEventPos(e) {
          var _a, _b;
          const { clientX: x, clientY: y } = ((_a = e.touches) == null ? void 0 : _a[0]) || ((_b = e.changedTouches) == null ? void 0 : _b[0]) || e;
          return { x, y };
        }

        const cssNumber = {
          "animation-iteration-count": true,
          "column-count": true,
          "fill-opacity": true,
          "flex-grow": true,
          "flex-shrink": true,
          "font-weight": true,
          "line-height": true,
          opacity: true,
          order: true,
          orphans: true,
          "stroke-dasharray": true,
          "stroke-dashoffset": true,
          widows: true,
          "z-index": true,
          zoom: true
        };
        function css(element, property, value, priority) {
          const elements = toNodes(element);
          for (const element2 of elements) {
            if (isString(property)) {
              property = propName(property);
              if (isUndefined(value)) {
                return getComputedStyle(element2).getPropertyValue(property);
              } else {
                element2.style.setProperty(
                  property,
                  isNumeric(value) && !cssNumber[property] ? `${value}px` : value || isNumber(value) ? value : "",
                  priority
                );
              }
            } else if (isArray(property)) {
              const props = {};
              for (const prop of property) {
                props[prop] = css(element2, prop);
              }
              return props;
            } else if (isObject(property)) {
              priority = value;
              each(property, (value2, property2) => css(element2, property2, value2, priority));
            }
          }
          return elements[0];
        }
        const propName = memoize((name) => vendorPropName(name));
        function vendorPropName(name) {
          if (startsWith(name, "--")) {
            return name;
          }
          name = hyphenate(name);
          const { style } = document.documentElement;
          if (name in style) {
            return name;
          }
          for (const prefix of ["webkit", "moz"]) {
            const prefixedName = `-${prefix}-${name}`;
            if (prefixedName in style) {
              return prefixedName;
            }
          }
        }

        const clsTransition = "uk-transition";
        const clsTransitionEnd = "transitionend";
        const clsTransitionCanceled = "transitioncanceled";
        function transition$1(element, props, duration = 400, timing = "linear") {
          duration = Math.round(duration);
          return Promise.all(
            toNodes(element).map(
              (element2) => new Promise((resolve, reject) => {
                for (const name in props) {
                  const value = css(element2, name);
                  if (value === "") {
                    css(element2, name, value);
                  }
                }
                const timer = setTimeout(() => trigger(element2, clsTransitionEnd), duration);
                once(
                  element2,
                  [clsTransitionEnd, clsTransitionCanceled],
                  ({ type }) => {
                    clearTimeout(timer);
                    removeClass(element2, clsTransition);
                    css(element2, {
                      transitionProperty: "",
                      transitionDuration: "",
                      transitionTimingFunction: ""
                    });
                    type === clsTransitionCanceled ? reject() : resolve(element2);
                  },
                  { self: true }
                );
                addClass(element2, clsTransition);
                css(element2, {
                  transitionProperty: Object.keys(props).map(propName).join(","),
                  transitionDuration: `${duration}ms`,
                  transitionTimingFunction: timing,
                  ...props
                });
              })
            )
          );
        }
        const Transition = {
          start: transition$1,
          async stop(element) {
            trigger(element, clsTransitionEnd);
            await Promise.resolve();
          },
          async cancel(element) {
            trigger(element, clsTransitionCanceled);
            await Promise.resolve();
          },
          inProgress(element) {
            return hasClass(element, clsTransition);
          }
        };
        const animationPrefix = "uk-animation-";
        const clsAnimationEnd = "animationend";
        const clsAnimationCanceled = "animationcanceled";
        function animate$2(element, animation, duration = 200, origin, out) {
          return Promise.all(
            toNodes(element).map(
              (element2) => new Promise((resolve, reject) => {
                trigger(element2, clsAnimationCanceled);
                const timer = setTimeout(() => trigger(element2, clsAnimationEnd), duration);
                once(
                  element2,
                  [clsAnimationEnd, clsAnimationCanceled],
                  ({ type }) => {
                    clearTimeout(timer);
                    type === clsAnimationCanceled ? reject() : resolve(element2);
                    css(element2, "animationDuration", "");
                    removeClasses$1(element2, `${animationPrefix}\\S*`);
                  },
                  { self: true }
                );
                css(element2, "animationDuration", `${duration}ms`);
                addClass(element2, animation, animationPrefix + (out ? "leave" : "enter"));
                if (startsWith(animation, animationPrefix)) {
                  origin && addClass(element2, `uk-transform-origin-${origin}`);
                  out && addClass(element2, `${animationPrefix}reverse`);
                }
              })
            )
          );
        }
        const inProgressRe = new RegExp(`${animationPrefix}(enter|leave)`);
        const Animation = {
          in: animate$2,
          out(element, animation, duration, origin) {
            return animate$2(element, animation, duration, origin, true);
          },
          inProgress(element) {
            return inProgressRe.test(attr(element, "class"));
          },
          cancel(element) {
            trigger(element, clsAnimationCanceled);
          }
        };

        function ready(fn) {
          if (document.readyState !== "loading") {
            fn();
            return;
          }
          once(document, "DOMContentLoaded", fn);
        }
        function isTag(element, ...tagNames) {
          return tagNames.some((tagName) => {
            var _a;
            return ((_a = element == null ? void 0 : element.tagName) == null ? void 0 : _a.toLowerCase()) === tagName.toLowerCase();
          });
        }
        function empty(element) {
          element = $(element);
          element.innerHTML = "";
          return element;
        }
        function html(parent2, html2) {
          return isUndefined(html2) ? $(parent2).innerHTML : append(empty(parent2), html2);
        }
        const prepend = applyFn("prepend");
        const append = applyFn("append");
        const before = applyFn("before");
        const after = applyFn("after");
        function applyFn(fn) {
          return function(ref, element) {
            var _a;
            const nodes = toNodes(isString(element) ? fragment(element) : element);
            (_a = $(ref)) == null ? void 0 : _a[fn](...nodes);
            return unwrapSingle(nodes);
          };
        }
        function remove$1(element) {
          toNodes(element).forEach((element2) => element2.remove());
        }
        function wrapAll(element, structure) {
          structure = toNode(before(element, structure));
          while (structure.firstChild) {
            structure = structure.firstChild;
          }
          append(structure, element);
          return structure;
        }
        function wrapInner(element, structure) {
          return toNodes(
            toNodes(element).map(
              (element2) => element2.hasChildNodes() ? wrapAll(toArray(element2.childNodes), structure) : append(element2, structure)
            )
          );
        }
        function unwrap(element) {
          toNodes(element).map(parent).filter((value, index, self) => self.indexOf(value) === index).forEach((parent2) => parent2.replaceWith(...parent2.childNodes));
        }
        const singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;
        function fragment(html2) {
          const matches = singleTagRe.exec(html2);
          if (matches) {
            return document.createElement(matches[1]);
          }
          const container = document.createElement("template");
          container.innerHTML = html2.trim();
          return unwrapSingle(container.content.childNodes);
        }
        function unwrapSingle(nodes) {
          return nodes.length > 1 ? nodes : nodes[0];
        }
        function apply(node, fn) {
          if (!isElement(node)) {
            return;
          }
          fn(node);
          node = node.firstElementChild;
          while (node) {
            const next = node.nextElementSibling;
            apply(node, fn);
            node = next;
          }
        }
        function $(selector, context) {
          return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);
        }
        function $$(selector, context) {
          return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);
        }
        function isHtml(str) {
          return isString(str) && startsWith(str.trim(), "<");
        }

        const dirs$1 = {
          width: ["left", "right"],
          height: ["top", "bottom"]
        };
        function dimensions$1(element) {
          const rect = isElement(element) ? toNode(element).getBoundingClientRect() : { height: height(element), width: width(element), top: 0, left: 0 };
          return {
            height: rect.height,
            width: rect.width,
            top: rect.top,
            left: rect.left,
            bottom: rect.top + rect.height,
            right: rect.left + rect.width
          };
        }
        function offset(element, coordinates) {
          if (coordinates) {
            css(element, { left: 0, top: 0 });
          }
          const currentOffset = dimensions$1(element);
          if (element) {
            const { scrollY, scrollX } = toWindow(element);
            const offsetBy = { height: scrollY, width: scrollX };
            for (const dir in dirs$1) {
              for (const prop of dirs$1[dir]) {
                currentOffset[prop] += offsetBy[dir];
              }
            }
          }
          if (!coordinates) {
            return currentOffset;
          }
          for (const prop of ["left", "top"]) {
            css(element, prop, coordinates[prop] - currentOffset[prop]);
          }
        }
        function position(element) {
          let { top, left } = offset(element);
          const {
            ownerDocument: { body, documentElement },
            offsetParent
          } = toNode(element);
          let parent = offsetParent || documentElement;
          while (parent && (parent === body || parent === documentElement) && css(parent, "position") === "static") {
            parent = parent.parentNode;
          }
          if (isElement(parent)) {
            const parentOffset = offset(parent);
            top -= parentOffset.top + toFloat(css(parent, "borderTopWidth"));
            left -= parentOffset.left + toFloat(css(parent, "borderLeftWidth"));
          }
          return {
            top: top - toFloat(css(element, "marginTop")),
            left: left - toFloat(css(element, "marginLeft"))
          };
        }
        function offsetPosition(element) {
          element = toNode(element);
          const offset2 = [element.offsetTop, element.offsetLeft];
          while (element = element.offsetParent) {
            offset2[0] += element.offsetTop + toFloat(css(element, `borderTopWidth`));
            offset2[1] += element.offsetLeft + toFloat(css(element, `borderLeftWidth`));
            if (css(element, "position") === "fixed") {
              const win = toWindow(element);
              offset2[0] += win.scrollY;
              offset2[1] += win.scrollX;
              return offset2;
            }
          }
          return offset2;
        }
        const height = dimension("height");
        const width = dimension("width");
        function dimension(prop) {
          const propName = ucfirst(prop);
          return (element, value) => {
            if (isUndefined(value)) {
              if (isWindow(element)) {
                return element[`inner${propName}`];
              }
              if (isDocument(element)) {
                const doc = element.documentElement;
                return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);
              }
              element = toNode(element);
              value = css(element, prop);
              value = value === "auto" ? element[`offset${propName}`] : toFloat(value) || 0;
              return value - boxModelAdjust(element, prop);
            } else {
              return css(
                element,
                prop,
                !value && value !== 0 ? "" : +value + boxModelAdjust(element, prop) + "px"
              );
            }
          };
        }
        function boxModelAdjust(element, prop, sizing = "border-box") {
          return css(element, "boxSizing") === sizing ? sumBy(
            dirs$1[prop].map(ucfirst),
            (prop2) => toFloat(css(element, `padding${prop2}`)) + toFloat(css(element, `border${prop2}Width`))
          ) : 0;
        }
        function flipPosition(pos) {
          for (const dir in dirs$1) {
            for (const i in dirs$1[dir]) {
              if (dirs$1[dir][i] === pos) {
                return dirs$1[dir][1 - i];
              }
            }
          }
          return pos;
        }
        function toPx(value, property = "width", element = window, offsetDim = false) {
          if (!isString(value)) {
            return toFloat(value);
          }
          return sumBy(parseCalc(value), (value2) => {
            const unit = parseUnit(value2);
            return unit ? percent(
              unit === "vh" ? getViewportHeight() : unit === "vw" ? width(toWindow(element)) : offsetDim ? element[`offset${ucfirst(property)}`] : dimensions$1(element)[property],
              value2
            ) : value2;
          });
        }
        const calcRe = /-?\d+(?:\.\d+)?(?:v[wh]|%|px)?/g;
        const parseCalc = memoize((calc) => calc.toString().replace(/\s/g, "").match(calcRe) || []);
        const unitRe$1 = /(?:v[hw]|%)$/;
        const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);
        function percent(base, value) {
          return base * toFloat(value) / 100;
        }
        let vh;
        let vhEl;
        function getViewportHeight() {
          if (vh) {
            return vh;
          }
          if (!vhEl) {
            vhEl = $("<div>");
            css(vhEl, {
              height: "100vh",
              position: "fixed"
            });
            on(window, "resize", () => vh = null);
          }
          append(document.body, vhEl);
          vh = vhEl.clientHeight;
          remove$1(vhEl);
          return vh;
        }

        const inBrowser = typeof window !== "undefined";
        const isRtl = inBrowser && document.dir === "rtl";
        const hasTouch = inBrowser && "ontouchstart" in window;
        const hasPointerEvents = inBrowser && window.PointerEvent;
        const pointerDown$1 = hasPointerEvents ? "pointerdown" : hasTouch ? "touchstart" : "mousedown";
        const pointerMove$1 = hasPointerEvents ? "pointermove" : hasTouch ? "touchmove" : "mousemove";
        const pointerUp$1 = hasPointerEvents ? "pointerup" : hasTouch ? "touchend" : "mouseup";
        const pointerEnter = hasPointerEvents ? "pointerenter" : hasTouch ? "" : "mouseenter";
        const pointerLeave = hasPointerEvents ? "pointerleave" : hasTouch ? "" : "mouseleave";
        const pointerCancel = hasPointerEvents ? "pointercancel" : "touchcancel";

        const fastdom = {
          reads: [],
          writes: [],
          read(task) {
            this.reads.push(task);
            scheduleFlush();
            return task;
          },
          write(task) {
            this.writes.push(task);
            scheduleFlush();
            return task;
          },
          clear(task) {
            remove(this.reads, task);
            remove(this.writes, task);
          },
          flush
        };
        function flush(recursion) {
          runTasks(fastdom.reads);
          runTasks(fastdom.writes.splice(0));
          fastdom.scheduled = false;
          if (fastdom.reads.length || fastdom.writes.length) {
            scheduleFlush(recursion + 1);
          }
        }
        const RECURSION_LIMIT = 4;
        function scheduleFlush(recursion) {
          if (fastdom.scheduled) {
            return;
          }
          fastdom.scheduled = true;
          if (recursion && recursion < RECURSION_LIMIT) {
            Promise.resolve().then(() => flush(recursion));
          } else {
            requestAnimationFrame(() => flush(1));
          }
        }
        function runTasks(tasks) {
          let task;
          while (task = tasks.shift()) {
            try {
              task();
            } catch (e) {
              console.error(e);
            }
          }
        }
        function remove(array, item) {
          const index = array.indexOf(item);
          return ~index && array.splice(index, 1);
        }

        function MouseTracker() {
        }
        MouseTracker.prototype = {
          positions: [],
          init() {
            this.positions = [];
            let position;
            this.unbind = on(document, "mousemove", (e) => position = getEventPos(e));
            this.interval = setInterval(() => {
              if (!position) {
                return;
              }
              this.positions.push(position);
              if (this.positions.length > 5) {
                this.positions.shift();
              }
            }, 50);
          },
          cancel() {
            var _a;
            (_a = this.unbind) == null ? void 0 : _a.call(this);
            clearInterval(this.interval);
          },
          movesTo(target) {
            if (this.positions.length < 2) {
              return false;
            }
            const p = target.getBoundingClientRect();
            const { left, right, top, bottom } = p;
            const [prevPosition] = this.positions;
            const position = last(this.positions);
            const path = [prevPosition, position];
            if (pointInRect(position, p)) {
              return false;
            }
            const diagonals = [
              [
                { x: left, y: top },
                { x: right, y: bottom }
              ],
              [
                { x: left, y: bottom },
                { x: right, y: top }
              ]
            ];
            return diagonals.some((diagonal) => {
              const intersection = intersect(path, diagonal);
              return intersection && pointInRect(intersection, p);
            });
          }
        };
        function intersect([{ x: x1, y: y1 }, { x: x2, y: y2 }], [{ x: x3, y: y3 }, { x: x4, y: y4 }]) {
          const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
          if (denominator === 0) {
            return false;
          }
          const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
          if (ua < 0) {
            return false;
          }
          return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
        }

        function observeIntersection(targets, cb, options = {}, { intersecting = true } = {}) {
          const observer = new IntersectionObserver(
            intersecting ? (entries, observer2) => {
              if (entries.some((entry) => entry.isIntersecting)) {
                cb(entries, observer2);
              }
            } : cb,
            options
          );
          for (const el of toNodes(targets)) {
            observer.observe(el);
          }
          return observer;
        }
        const hasResizeObserver = inBrowser && window.ResizeObserver;
        function observeResize(targets, cb, options = { box: "border-box" }) {
          if (hasResizeObserver) {
            return observe$1(ResizeObserver, targets, cb, options);
          }
          const off = [on(window, "load resize", cb), on(document, "loadedmetadata load", cb, true)];
          return { disconnect: () => off.map((cb2) => cb2()) };
        }
        function observeViewportResize(cb) {
          return { disconnect: on([window, window.visualViewport], "resize", cb) };
        }
        function observeMutation(targets, cb, options) {
          return observe$1(MutationObserver, targets, cb, options);
        }
        function observe$1(Observer, targets, cb, options) {
          const observer = new Observer(cb);
          for (const el of toNodes(targets)) {
            observer.observe(el, options);
          }
          return observer;
        }

        function play(el) {
          if (isIFrame(el)) {
            call(el, { func: "playVideo", method: "play" });
          }
          if (isHTML5(el)) {
            el.play();
          }
        }
        function pause(el) {
          if (isIFrame(el)) {
            call(el, { func: "pauseVideo", method: "pause" });
          }
          if (isHTML5(el)) {
            el.pause();
          }
        }
        function mute(el) {
          if (isIFrame(el)) {
            call(el, { func: "mute", method: "setVolume", value: 0 });
          }
          if (isHTML5(el)) {
            el.muted = true;
          }
        }
        function isVideo(el) {
          return isHTML5(el) || isIFrame(el);
        }
        function isHTML5(el) {
          return isTag(el, "video");
        }
        function isIFrame(el) {
          return isTag(el, "iframe") && (isYoutube(el) || isVimeo(el));
        }
        function isYoutube(el) {
          return !!el.src.match(
            /\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/
          );
        }
        function isVimeo(el) {
          return !!el.src.match(/vimeo\.com\/video\/.*/);
        }
        async function call(el, cmd) {
          await enableApi(el);
          post(el, cmd);
        }
        function post(el, cmd) {
          el.contentWindow.postMessage(JSON.stringify({ event: "command", ...cmd }), "*");
        }
        const stateKey = "_ukPlayer";
        let counter = 0;
        function enableApi(el) {
          if (el[stateKey]) {
            return el[stateKey];
          }
          const youtube = isYoutube(el);
          const vimeo = isVimeo(el);
          const id = ++counter;
          let poller;
          return el[stateKey] = new Promise((resolve) => {
            youtube && once(el, "load", () => {
              const listener = () => post(el, { event: "listening", id });
              poller = setInterval(listener, 100);
              listener();
            });
            once(window, "message", resolve, false, ({ data }) => {
              try {
                data = JSON.parse(data);
                return youtube && (data == null ? void 0 : data.id) === id && data.event === "onReady" || vimeo && Number(data == null ? void 0 : data.player_id) === id;
              } catch (e) {
              }
            });
            el.src = `${el.src}${includes(el.src, "?") ? "&" : "?"}${youtube ? "enablejsapi=1" : `api=1&player_id=${id}`}`;
          }).then(() => clearInterval(poller));
        }

        function isInView(element, offsetTop = 0, offsetLeft = 0) {
          if (!isVisible(element)) {
            return false;
          }
          return intersectRect(
            ...overflowParents(element).map((parent2) => {
              const { top, left, bottom, right } = offsetViewport(parent2);
              return {
                top: top - offsetTop,
                left: left - offsetLeft,
                bottom: bottom + offsetTop,
                right: right + offsetLeft
              };
            }).concat(offset(element))
          );
        }
        function scrollIntoView(element, { offset: offsetBy = 0 } = {}) {
          const parents2 = isVisible(element) ? scrollParents(element, false, ["hidden"]) : [];
          return parents2.reduce(
            (fn, scrollElement, i) => {
              const { scrollTop, scrollHeight, offsetHeight } = scrollElement;
              const viewport = offsetViewport(scrollElement);
              const maxScroll = scrollHeight - viewport.height;
              const { height: elHeight, top: elTop } = parents2[i - 1] ? offsetViewport(parents2[i - 1]) : offset(element);
              let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop);
              if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {
                top += offsetBy;
              } else {
                offsetBy = 0;
              }
              if (top > maxScroll) {
                offsetBy -= top - maxScroll;
                top = maxScroll;
              } else if (top < 0) {
                offsetBy -= top;
                top = 0;
              }
              return () => scrollTo(scrollElement, top - scrollTop, element, maxScroll).then(fn);
            },
            () => Promise.resolve()
          )();
          function scrollTo(element2, top, targetEl, maxScroll) {
            return new Promise((resolve) => {
              const scroll = element2.scrollTop;
              const duration = getDuration(Math.abs(top));
              const start = Date.now();
              const isScrollingElement = scrollingElement(element2) === element2;
              const targetTop = offset(targetEl).top + (isScrollingElement ? 0 : scroll);
              let prev = 0;
              let frames = 15;
              (function step() {
                const percent = ease(clamp((Date.now() - start) / duration));
                let diff = 0;
                if (parents2[0] === element2 && scroll + top < maxScroll) {
                  diff = offset(targetEl).top + (isScrollingElement ? 0 : element2.scrollTop) - targetTop;
                  const coverEl = getCoveringElement(targetEl);
                  diff -= coverEl ? offset(coverEl).height : 0;
                }
                element2.scrollTop = Math[top + diff > 0 ? "max" : "min"](
                  element2.scrollTop,
                  scroll + (top + diff) * percent
                );
                if (percent === 1 && (prev === diff || !frames--)) {
                  resolve();
                } else {
                  prev = diff;
                  requestAnimationFrame(step);
                }
              })();
            });
          }
          function getDuration(dist) {
            return 40 * Math.pow(dist, 0.375);
          }
          function ease(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
          }
        }
        function scrolledOver(element, startOffset = 0, endOffset = 0) {
          if (!isVisible(element)) {
            return 0;
          }
          const scrollElement = scrollParent(element, true);
          const { scrollHeight, scrollTop } = scrollElement;
          const { height: viewportHeight } = offsetViewport(scrollElement);
          const maxScroll = scrollHeight - viewportHeight;
          const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];
          const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);
          const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);
          return clamp((scrollTop - start) / (end - start));
        }
        function scrollParents(element, scrollable = false, props = []) {
          const scrollEl = scrollingElement(element);
          let ancestors = parents(element).reverse();
          ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);
          const fixedIndex = findIndex(ancestors, (el) => css(el, "position") === "fixed");
          if (~fixedIndex) {
            ancestors = ancestors.slice(fixedIndex);
          }
          return [scrollEl].concat(
            ancestors.filter(
              (parent2) => css(parent2, "overflow").split(" ").some((prop) => includes(["auto", "scroll", ...props], prop)) && (!scrollable || parent2.scrollHeight > offsetViewport(parent2).height)
            )
          ).reverse();
        }
        function scrollParent(...args) {
          return scrollParents(...args)[0];
        }
        function overflowParents(element) {
          return scrollParents(element, false, ["hidden", "clip"]);
        }
        function offsetViewport(scrollElement) {
          const window = toWindow(scrollElement);
          const {
            visualViewport,
            document: { documentElement }
          } = window;
          let viewportElement = scrollElement === scrollingElement(scrollElement) ? window : scrollElement;
          if (isWindow(viewportElement) && visualViewport) {
            let { height, width, scale, pageTop: top, pageLeft: left } = visualViewport;
            height = Math.round(height * scale);
            width = Math.round(width * scale);
            return { height, width, top, left, bottom: top + height, right: left + width };
          }
          let rect = offset(viewportElement);
          if (css(viewportElement, "display") === "inline") {
            return rect;
          }
          for (let [prop, dir, start, end] of [
            ["width", "x", "left", "right"],
            ["height", "y", "top", "bottom"]
          ]) {
            if (isWindow(viewportElement)) {
              viewportElement = documentElement;
            } else {
              rect[start] += toFloat(css(viewportElement, `border-${start}-width`));
            }
            const subpixel = rect[prop] % 1;
            rect[prop] = rect[dir] = viewportElement[`client${ucfirst(prop)}`] - (subpixel ? subpixel < 0.5 ? -subpixel : 1 - subpixel : 0);
            rect[end] = rect[prop] + rect[start];
          }
          return rect;
        }
        function getCoveringElement(target) {
          return target.ownerDocument.elementsFromPoint(offset(target).left, 0).find(
            (el) => !el.contains(target) && (hasPosition(el, "fixed") && zIndex(
              parents(target).reverse().find((parent2) => !parent2.contains(el) && !hasPosition(parent2, "static"))
            ) < zIndex(el) || hasPosition(el, "sticky") && parent(el).contains(target))
          );
        }
        function zIndex(element) {
          return toFloat(css(element, "zIndex"));
        }
        function hasPosition(element, position) {
          return css(element, "position") === position;
        }
        function scrollingElement(element) {
          return toWindow(element).document.scrollingElement;
        }

        const dirs = [
          ["width", "x", "left", "right"],
          ["height", "y", "top", "bottom"]
        ];
        function positionAt(element, target, options) {
          options = {
            attach: {
              element: ["left", "top"],
              target: ["left", "top"],
              ...options.attach
            },
            offset: [0, 0],
            placement: [],
            ...options
          };
          if (!isArray(target)) {
            target = [target, target];
          }
          offset(element, getPosition(element, target, options));
        }
        function getPosition(element, target, options) {
          const position = attachTo(element, target, options);
          const { boundary, viewportOffset = 0, placement } = options;
          let offsetPosition = position;
          for (const [i, [prop, , start, end]] of Object.entries(dirs)) {
            const viewport = getViewport$2(element, target[i], viewportOffset, boundary, i);
            if (isWithin(position, viewport, i)) {
              continue;
            }
            let offsetBy = 0;
            if (placement[i] === "flip") {
              const attach = options.attach.target[i];
              if (attach === end && position[end] <= viewport[end] || attach === start && position[start] >= viewport[start]) {
                continue;
              }
              offsetBy = flip(element, target, options, i)[start] - position[start];
              const scrollArea = getScrollArea(element, target[i], viewportOffset, i);
              if (!isWithin(applyOffset(position, offsetBy, i), scrollArea, i)) {
                if (isWithin(position, scrollArea, i)) {
                  continue;
                }
                if (options.recursion) {
                  return false;
                }
                const newPos = flipAxis(element, target, options);
                if (newPos && isWithin(newPos, scrollArea, 1 - i)) {
                  return newPos;
                }
                continue;
              }
            } else if (placement[i] === "shift") {
              const targetDim = offset(target[i]);
              const { offset: elOffset } = options;
              offsetBy = clamp(
                clamp(position[start], viewport[start], viewport[end] - position[prop]),
                targetDim[start] - position[prop] + elOffset[i],
                targetDim[end] - elOffset[i]
              ) - position[start];
            }
            offsetPosition = applyOffset(offsetPosition, offsetBy, i);
          }
          return offsetPosition;
        }
        function attachTo(element, target, options) {
          let { attach, offset: offsetBy } = {
            attach: {
              element: ["left", "top"],
              target: ["left", "top"],
              ...options.attach
            },
            offset: [0, 0],
            ...options
          };
          let elOffset = offset(element);
          for (const [i, [prop, , start, end]] of Object.entries(dirs)) {
            const targetOffset = attach.target[i] === attach.element[i] ? offsetViewport(target[i]) : offset(target[i]);
            elOffset = applyOffset(
              elOffset,
              targetOffset[start] - elOffset[start] + moveBy(attach.target[i], end, targetOffset[prop]) - moveBy(attach.element[i], end, elOffset[prop]) + +offsetBy[i],
              i
            );
          }
          return elOffset;
        }
        function applyOffset(position, offset2, i) {
          const [, dir, start, end] = dirs[i];
          const newPos = { ...position };
          newPos[start] = position[dir] = position[start] + offset2;
          newPos[end] += offset2;
          return newPos;
        }
        function moveBy(attach, end, dim) {
          return attach === "center" ? dim / 2 : attach === end ? dim : 0;
        }
        function getViewport$2(element, target, viewportOffset, boundary, i) {
          let viewport = getIntersectionArea(...commonScrollParents(element, target).map(offsetViewport));
          if (viewportOffset) {
            viewport[dirs[i][2]] += viewportOffset;
            viewport[dirs[i][3]] -= viewportOffset;
          }
          if (boundary) {
            viewport = getIntersectionArea(
              viewport,
              offset(isArray(boundary) ? boundary[i] : boundary)
            );
          }
          return viewport;
        }
        function getScrollArea(element, target, viewportOffset, i) {
          const [prop, axis, start, end] = dirs[i];
          const [scrollElement] = commonScrollParents(element, target);
          const viewport = offsetViewport(scrollElement);
          if (["auto", "scroll"].includes(css(scrollElement, `overflow-${axis}`))) {
            viewport[start] -= scrollElement[`scroll${ucfirst(start)}`];
            viewport[end] = viewport[start] + scrollElement[`scroll${ucfirst(prop)}`];
          }
          viewport[start] += viewportOffset;
          viewport[end] -= viewportOffset;
          return viewport;
        }
        function commonScrollParents(element, target) {
          return overflowParents(target).filter((parent) => parent.contains(element));
        }
        function getIntersectionArea(...rects) {
          let area = {};
          for (const rect of rects) {
            for (const [, , start, end] of dirs) {
              area[start] = Math.max(area[start] || 0, rect[start]);
              area[end] = Math.min(...[area[end], rect[end]].filter(Boolean));
            }
          }
          return area;
        }
        function isWithin(positionA, positionB, i) {
          const [, , start, end] = dirs[i];
          return positionA[start] >= positionB[start] && positionA[end] <= positionB[end];
        }
        function flip(element, target, { offset: offset2, attach }, i) {
          return attachTo(element, target, {
            attach: {
              element: flipAttach(attach.element, i),
              target: flipAttach(attach.target, i)
            },
            offset: flipOffset(offset2, i)
          });
        }
        function flipAxis(element, target, options) {
          return getPosition(element, target, {
            ...options,
            attach: {
              element: options.attach.element.map(flipAttachAxis).reverse(),
              target: options.attach.target.map(flipAttachAxis).reverse()
            },
            offset: options.offset.reverse(),
            placement: options.placement.reverse(),
            recursion: true
          });
        }
        function flipAttach(attach, i) {
          const newAttach = [...attach];
          const index = dirs[i].indexOf(attach[i]);
          if (~index) {
            newAttach[i] = dirs[i][1 - index % 2 + 2];
          }
          return newAttach;
        }
        function flipAttachAxis(prop) {
          for (let i = 0; i < dirs.length; i++) {
            const index = dirs[i].indexOf(prop);
            if (~index) {
              return dirs[1 - i][index % 2 + 2];
            }
          }
        }
        function flipOffset(offset2, i) {
          offset2 = [...offset2];
          offset2[i] *= -1;
          return offset2;
        }

        var util = /*#__PURE__*/Object.freeze({
            __proto__: null,
            $: $,
            $$: $$,
            Animation: Animation,
            Dimensions: Dimensions,
            MouseTracker: MouseTracker,
            Transition: Transition,
            addClass: addClass,
            after: after,
            append: append,
            apply: apply,
            assign: assign,
            attr: attr,
            before: before,
            boxModelAdjust: boxModelAdjust,
            camelize: camelize,
            children: children,
            clamp: clamp,
            closest: closest,
            createEvent: createEvent,
            css: css,
            data: data,
            dimensions: dimensions$1,
            each: each,
            empty: empty,
            endsWith: endsWith,
            escape: escape,
            fastdom: fastdom,
            filter: filter$1,
            find: find,
            findAll: findAll,
            findIndex: findIndex,
            flipPosition: flipPosition,
            fragment: fragment,
            getCoveringElement: getCoveringElement,
            getEventPos: getEventPos,
            getIndex: getIndex,
            getTargetedElement: getTargetedElement,
            hasAttr: hasAttr,
            hasClass: hasClass,
            hasOwn: hasOwn,
            hasTouch: hasTouch,
            height: height,
            html: html,
            hyphenate: hyphenate,
            inBrowser: inBrowser,
            includes: includes,
            index: index,
            intersectRect: intersectRect,
            isArray: isArray,
            isBoolean: isBoolean,
            isDocument: isDocument,
            isElement: isElement,
            isEmpty: isEmpty,
            isEqual: isEqual,
            isFocusable: isFocusable,
            isFunction: isFunction,
            isInView: isInView,
            isInput: isInput,
            isNode: isNode,
            isNumber: isNumber,
            isNumeric: isNumeric,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isRtl: isRtl,
            isSameSiteAnchor: isSameSiteAnchor,
            isString: isString,
            isTag: isTag,
            isTouch: isTouch,
            isUndefined: isUndefined,
            isVideo: isVideo,
            isVisible: isVisible,
            isVoidElement: isVoidElement,
            isWindow: isWindow,
            last: last,
            matches: matches,
            memoize: memoize,
            mute: mute,
            noop: noop,
            observeIntersection: observeIntersection,
            observeMutation: observeMutation,
            observeResize: observeResize,
            observeViewportResize: observeViewportResize,
            off: off,
            offset: offset,
            offsetPosition: offsetPosition,
            offsetViewport: offsetViewport,
            on: on,
            once: once,
            overflowParents: overflowParents,
            parent: parent,
            parents: parents,
            pause: pause,
            pick: pick,
            play: play,
            pointInRect: pointInRect,
            pointerCancel: pointerCancel,
            pointerDown: pointerDown$1,
            pointerEnter: pointerEnter,
            pointerLeave: pointerLeave,
            pointerMove: pointerMove$1,
            pointerUp: pointerUp$1,
            position: position,
            positionAt: positionAt,
            prepend: prepend,
            propName: propName,
            query: query,
            queryAll: queryAll,
            ready: ready,
            remove: remove$1,
            removeAttr: removeAttr,
            removeClass: removeClass,
            removeClasses: removeClasses$1,
            replaceClass: replaceClass,
            scrollIntoView: scrollIntoView,
            scrollParent: scrollParent,
            scrollParents: scrollParents,
            scrolledOver: scrolledOver,
            selFocusable: selFocusable,
            selInput: selInput,
            sortBy: sortBy,
            startsWith: startsWith,
            sumBy: sumBy,
            swap: swap,
            toArray: toArray,
            toBoolean: toBoolean,
            toEventTargets: toEventTargets,
            toFloat: toFloat,
            toNode: toNode,
            toNodes: toNodes,
            toNumber: toNumber,
            toPx: toPx,
            toWindow: toWindow,
            toggleClass: toggleClass,
            trigger: trigger,
            ucfirst: ucfirst,
            uniqueBy: uniqueBy,
            unwrap: unwrap,
            width: width,
            within: within,
            wrapAll: wrapAll,
            wrapInner: wrapInner
        });

        var Class = {
          connected() {
            addClass(this.$el, this.$options.id);
          }
        };

        const units = ["days", "hours", "minutes", "seconds"];
        var countdown = {
          mixins: [Class],
          props: {
            date: String,
            clsWrapper: String,
            role: String
          },
          data: {
            date: "",
            clsWrapper: ".uk-countdown-%unit%",
            role: "timer"
          },
          connected() {
            attr(this.$el, "role", this.role);
            this.date = toFloat(Date.parse(this.$props.date));
            this.end = false;
            this.start();
          },
          disconnected() {
            this.stop();
          },
          events: {
            name: "visibilitychange",
            el() {
              return document;
            },
            handler() {
              if (document.hidden) {
                this.stop();
              } else {
                this.start();
              }
            }
          },
          methods: {
            start() {
              this.stop();
              this.update();
              if (!this.timer) {
                trigger(this.$el, "countdownstart");
                this.timer = setInterval(this.update, 1e3);
              }
            },
            stop() {
              if (this.timer) {
                clearInterval(this.timer);
                trigger(this.$el, "countdownstop");
                this.timer = null;
              }
            },
            update() {
              const timespan = getTimeSpan(this.date);
              if (!timespan.total) {
                this.stop();
                if (!this.end) {
                  trigger(this.$el, "countdownend");
                  this.end = true;
                }
              }
              for (const unit of units) {
                const el = $(this.clsWrapper.replace("%unit%", unit), this.$el);
                if (!el) {
                  continue;
                }
                let digits = String(Math.trunc(timespan[unit]));
                digits = digits.length < 2 ? `0${digits}` : digits;
                if (el.textContent !== digits) {
                  digits = digits.split("");
                  if (digits.length !== el.children.length) {
                    html(el, digits.map(() => "<span></span>").join(""));
                  }
                  digits.forEach((digit, i) => el.children[i].textContent = digit);
                }
              }
            }
          }
        };
        function getTimeSpan(date) {
          const total = Math.max(0, date - Date.now()) / 1e3;
          return {
            total,
            seconds: total % 60,
            minutes: total / 60 % 60,
            hours: total / 60 / 60 % 24,
            days: total / 60 / 60 / 24
          };
        }

        const strats = {};
        strats.events = strats.watch = strats.observe = strats.created = strats.beforeConnect = strats.connected = strats.beforeDisconnect = strats.disconnected = strats.destroy = concatStrat;
        strats.args = function(parentVal, childVal) {
          return childVal !== false && concatStrat(childVal || parentVal);
        };
        strats.update = function(parentVal, childVal) {
          return sortBy(
            concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),
            "order"
          );
        };
        strats.props = function(parentVal, childVal) {
          if (isArray(childVal)) {
            const value = {};
            for (const key of childVal) {
              value[key] = String;
            }
            childVal = value;
          }
          return strats.methods(parentVal, childVal);
        };
        strats.computed = strats.methods = function(parentVal, childVal) {
          return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;
        };
        strats.i18n = strats.data = function(parentVal, childVal, vm) {
          if (!vm) {
            if (!childVal) {
              return parentVal;
            }
            if (!parentVal) {
              return childVal;
            }
            return function(vm2) {
              return mergeFnData(parentVal, childVal, vm2);
            };
          }
          return mergeFnData(parentVal, childVal, vm);
        };
        function mergeFnData(parentVal, childVal, vm) {
          return strats.computed(
            isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,
            isFunction(childVal) ? childVal.call(vm, vm) : childVal
          );
        }
        function concatStrat(parentVal, childVal) {
          parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;
          return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
        }
        function defaultStrat(parentVal, childVal) {
          return isUndefined(childVal) ? parentVal : childVal;
        }
        function mergeOptions(parent, child, vm) {
          const options = {};
          if (isFunction(child)) {
            child = child.options;
          }
          if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
          }
          if (child.mixins) {
            for (const mixin of child.mixins) {
              parent = mergeOptions(parent, mixin, vm);
            }
          }
          for (const key in parent) {
            mergeKey(key);
          }
          for (const key in child) {
            if (!hasOwn(parent, key)) {
              mergeKey(key);
            }
          }
          function mergeKey(key) {
            options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
          }
          return options;
        }
        function parseOptions(options, args = []) {
          try {
            return options ? startsWith(options, "{") ? JSON.parse(options) : args.length && !includes(options, ":") ? { [args[0]]: options } : options.split(";").reduce((options2, option) => {
              const [key, value] = option.split(/:(.*)/);
              if (key && !isUndefined(value)) {
                options2[key.trim()] = value.trim();
              }
              return options2;
            }, {}) : {};
          } catch (e) {
            return {};
          }
        }
        function coerce$1(type, value) {
          if (type === Boolean) {
            return toBoolean(value);
          } else if (type === Number) {
            return toNumber(value);
          } else if (type === "list") {
            return toList(value);
          } else if (type === Object && isString(value)) {
            return parseOptions(value);
          }
          return type ? type(value) : value;
        }
        const listRe = /,(?![^(]*\))/;
        function toList(value) {
          return isArray(value) ? value : isString(value) ? value.split(listRe).map((value2) => isNumeric(value2) ? toNumber(value2) : toBoolean(value2.trim())) : [value];
        }

        function initUpdates(instance) {
          instance._data = {};
          instance._updates = [...instance.$options.update || []];
        }
        function prependUpdate(instance, update) {
          instance._updates.unshift(update);
        }
        function clearUpdateData(instance) {
          delete instance._data;
        }
        function callUpdate(instance, e = "update") {
          if (!instance._connected) {
            return;
          }
          if (!instance._updates.length) {
            return;
          }
          if (!instance._queued) {
            instance._queued = /* @__PURE__ */ new Set();
            fastdom.read(() => {
              if (instance._connected) {
                runUpdates(instance, instance._queued);
              }
              delete instance._queued;
            });
          }
          instance._queued.add(e.type || e);
        }
        function runUpdates(instance, types) {
          for (const { read, write, events = [] } of instance._updates) {
            if (!types.has("update") && !events.some((type) => types.has(type))) {
              continue;
            }
            let result;
            if (read) {
              result = read.call(instance, instance._data, types);
              if (result && isPlainObject(result)) {
                assign(instance._data, result);
              }
            }
            if (write && result !== false) {
              fastdom.write(() => {
                if (instance._connected) {
                  write.call(instance, instance._data, types);
                }
              });
            }
          }
        }

        function resize(options) {
          return observe(observeResize, options, "resize");
        }
        function intersection(options) {
          return observe(observeIntersection, options);
        }
        function mutation(options) {
          return observe(observeMutation, options);
        }
        function lazyload(options = {}) {
          return intersection({
            handler: function(entries, observer) {
              const { targets = this.$el, preload = 5 } = options;
              for (const el of toNodes(isFunction(targets) ? targets(this) : targets)) {
                $$('[loading="lazy"]', el).slice(0, preload - 1).forEach((el2) => removeAttr(el2, "loading"));
              }
              for (const el of entries.filter(({ isIntersecting }) => isIntersecting).map(({ target }) => target)) {
                observer.unobserve(el);
              }
            },
            ...options
          });
        }
        function viewport(options) {
          return observe((target, handler) => observeViewportResize(handler), options);
        }
        function scroll$1(options) {
          return observe(
            (target, handler) => ({
              disconnect: on(toScrollTargets(target), "scroll", handler, { passive: true })
            }),
            options,
            "scroll"
          );
        }
        function swipe(options) {
          return {
            observe(target, handler) {
              return {
                observe: noop,
                unobserve: noop,
                disconnect: on(target, pointerDown$1, handler, { passive: true })
              };
            },
            handler(e) {
              if (!isTouch(e)) {
                return;
              }
              const pos = getEventPos(e);
              const target = "tagName" in e.target ? e.target : parent(e.target);
              once(document, `${pointerUp$1} ${pointerCancel} scroll`, (e2) => {
                const { x, y } = getEventPos(e2);
                if (e2.type !== "scroll" && target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {
                  setTimeout(() => {
                    trigger(target, "swipe");
                    trigger(target, `swipe${swipeDirection(pos.x, pos.y, x, y)}`);
                  });
                }
              });
            },
            ...options
          };
        }
        function observe(observe2, options, emit) {
          return {
            observe: observe2,
            handler() {
              callUpdate(this, emit);
            },
            ...options
          };
        }
        function swipeDirection(x1, y1, x2, y2) {
          return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? "Left" : "Right" : y1 - y2 > 0 ? "Up" : "Down";
        }
        function toScrollTargets(elements) {
          return toNodes(elements).map((node) => {
            const { ownerDocument } = node;
            const parent2 = scrollParent(node, true);
            return parent2 === ownerDocument.scrollingElement ? ownerDocument : parent2;
          });
        }

        var Margin = {
          props: {
            margin: String,
            firstColumn: Boolean
          },
          data: {
            margin: "uk-margin-small-top",
            firstColumn: "uk-first-column"
          },
          observe: [
            mutation({
              options: {
                childList: true,
                attributes: true,
                attributeFilter: ["style"]
              }
            }),
            resize({
              target: ({ $el }) => [$el, ...children($el)]
            })
          ],
          update: {
            read() {
              return {
                rows: getRows(toArray(this.$el.children))
              };
            },
            write({ rows }) {
              for (const row of rows) {
                for (const el of row) {
                  toggleClass(el, this.margin, rows[0] !== row);
                  toggleClass(el, this.firstColumn, row[isRtl ? row.length - 1 : 0] === el);
                }
              }
            },
            events: ["resize"]
          }
        };
        function getRows(elements) {
          const sorted = [[]];
          const withOffset = elements.some(
            (el, i) => i && elements[i - 1].offsetParent !== el.offsetParent
          );
          for (const el of elements) {
            if (!isVisible(el)) {
              continue;
            }
            const offset = getOffset(el, withOffset);
            for (let i = sorted.length - 1; i >= 0; i--) {
              const current = sorted[i];
              if (!current[0]) {
                current.push(el);
                break;
              }
              const offsetCurrent = getOffset(current[0], withOffset);
              if (offset.top >= offsetCurrent.bottom - 1 && offset.top !== offsetCurrent.top) {
                sorted.push([el]);
                break;
              }
              if (offset.bottom - 1 > offsetCurrent.top || offset.top === offsetCurrent.top) {
                let j = current.length - 1;
                for (; j >= 0; j--) {
                  const offsetCurrent2 = getOffset(current[j], withOffset);
                  if (offset.left >= offsetCurrent2.left) {
                    break;
                  }
                }
                current.splice(j + 1, 0, el);
                break;
              }
              if (i === 0) {
                sorted.unshift([el]);
                break;
              }
            }
          }
          return sorted;
        }
        function getOffset(element, offset = false) {
          let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;
          if (offset) {
            [offsetTop, offsetLeft] = offsetPosition(element);
          }
          return {
            top: offsetTop,
            left: offsetLeft,
            bottom: offsetTop + offsetHeight,
            right: offsetLeft + offsetWidth
          };
        }

        const clsLeave = "uk-transition-leave";
        const clsEnter = "uk-transition-enter";
        function fade(action, target, duration, stagger = 0) {
          const index = transitionIndex(target, true);
          const propsIn = { opacity: 1 };
          const propsOut = { opacity: 0 };
          const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();
          const leaveFn = wrapIndexFn(async () => {
            addClass(target, clsLeave);
            await Promise.all(
              getTransitionNodes(target).map(
                (child, i) => new Promise(
                  (resolve) => setTimeout(
                    () => Transition.start(child, propsOut, duration / 2, "ease").then(
                      resolve
                    ),
                    i * stagger
                  )
                )
              )
            );
            removeClass(target, clsLeave);
          });
          const enterFn = wrapIndexFn(async () => {
            const oldHeight = height(target);
            addClass(target, clsEnter);
            action();
            css(children(target), { opacity: 0 });
            await awaitFrame$1();
            const nodes = children(target);
            const newHeight = height(target);
            css(target, "alignContent", "flex-start");
            height(target, oldHeight);
            const transitionNodes = getTransitionNodes(target);
            css(nodes, propsOut);
            const transitions = transitionNodes.map(async (child, i) => {
              await awaitTimeout(i * stagger);
              await Transition.start(child, propsIn, duration / 2, "ease");
            });
            if (oldHeight !== newHeight) {
              transitions.push(
                Transition.start(
                  target,
                  { height: newHeight },
                  duration / 2 + transitionNodes.length * stagger,
                  "ease"
                )
              );
            }
            await Promise.all(transitions).then(() => {
              removeClass(target, clsEnter);
              if (index === transitionIndex(target)) {
                css(target, { height: "", alignContent: "" });
                css(nodes, { opacity: "" });
                delete target.dataset.transition;
              }
            });
          });
          return hasClass(target, clsLeave) ? waitTransitionend(target).then(enterFn) : hasClass(target, clsEnter) ? waitTransitionend(target).then(leaveFn).then(enterFn) : leaveFn().then(enterFn);
        }
        function transitionIndex(target, next) {
          if (next) {
            target.dataset.transition = 1 + transitionIndex(target);
          }
          return toNumber(target.dataset.transition) || 0;
        }
        function waitTransitionend(target) {
          return Promise.all(
            children(target).filter(Transition.inProgress).map(
              (el) => new Promise((resolve) => once(el, "transitionend transitioncanceled", resolve))
            )
          );
        }
        function getTransitionNodes(target) {
          return getRows(children(target)).flat().filter((node) => isVisible(node));
        }
        function awaitFrame$1() {
          return new Promise((resolve) => requestAnimationFrame(resolve));
        }
        function awaitTimeout(timeout) {
          return new Promise((resolve) => setTimeout(resolve, timeout));
        }

        async function slide(action, target, duration) {
          await awaitFrame();
          let nodes = children(target);
          const currentProps = nodes.map((el) => getProps$1(el, true));
          const targetProps = { ...css(target, ["height", "padding"]), display: "block" };
          await Promise.all(nodes.concat(target).map(Transition.cancel));
          action();
          nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));
          await Promise.resolve();
          fastdom.flush();
          const targetStyle = attr(target, "style");
          const targetPropsTo = css(target, ["height", "padding"]);
          const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);
          const attrsTo = nodes.map((el) => ({ style: attr(el, "style") }));
          nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));
          css(target, targetProps);
          trigger(target, "scroll");
          fastdom.flush();
          await awaitFrame();
          const transitions = nodes.map((el, i) => parent(el) === target && Transition.start(el, propsTo[i], duration, "ease")).concat(Transition.start(target, targetPropsTo, duration, "ease"));
          try {
            await Promise.all(transitions);
            nodes.forEach((el, i) => {
              attr(el, attrsTo[i]);
              if (parent(el) === target) {
                css(el, "display", propsTo[i].opacity === 0 ? "none" : "");
              }
            });
            attr(target, "style", targetStyle);
          } catch (e) {
            attr(nodes, "style", "");
            resetProps(target, targetProps);
          }
        }
        function getProps$1(el, opacity) {
          const zIndex = css(el, "zIndex");
          return isVisible(el) ? {
            display: "",
            opacity: opacity ? css(el, "opacity") : "0",
            pointerEvents: "none",
            position: "absolute",
            zIndex: zIndex === "auto" ? index(el) : zIndex,
            ...getPositionWithMargin(el)
          } : false;
        }
        function getTransitionProps(target, nodes, currentProps) {
          const propsTo = nodes.map(
            (el, i) => parent(el) && i in currentProps ? currentProps[i] ? isVisible(el) ? getPositionWithMargin(el) : { opacity: 0 } : { opacity: isVisible(el) ? 1 : 0 } : false
          );
          const propsFrom = propsTo.map((props, i) => {
            const from = parent(nodes[i]) === target && (currentProps[i] || getProps$1(nodes[i]));
            if (!from) {
              return false;
            }
            if (!props) {
              delete from.opacity;
            } else if (!("opacity" in props)) {
              const { opacity } = from;
              if (opacity % 1) {
                props.opacity = 1;
              } else {
                delete from.opacity;
              }
            }
            return from;
          });
          return [propsTo, propsFrom];
        }
        function resetProps(el, props) {
          for (const prop in props) {
            css(el, prop, "");
          }
        }
        function getPositionWithMargin(el) {
          const { height, width } = offset(el);
          return {
            height,
            width,
            transform: "",
            ...position(el),
            ...css(el, ["marginTop", "marginLeft"])
          };
        }
        function awaitFrame() {
          return new Promise((resolve) => requestAnimationFrame(resolve));
        }

        var Animate = {
          props: {
            duration: Number,
            animation: Boolean
          },
          data: {
            duration: 150,
            animation: "slide"
          },
          methods: {
            animate(action, target = this.$el) {
              const name = this.animation;
              const animationFn = name === "fade" ? fade : name === "delayed-fade" ? (...args) => fade(...args, 40) : name ? slide : () => {
                action();
                return Promise.resolve();
              };
              return animationFn(action, target, this.duration).catch(noop);
            }
          }
        };

        const keyMap = {
          TAB: 9,
          ESC: 27,
          SPACE: 32,
          END: 35,
          HOME: 36,
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40
        };

        var filter = {
          mixins: [Animate],
          args: "target",
          props: {
            target: String,
            selActive: Boolean
          },
          data: {
            target: "",
            selActive: false,
            attrItem: "uk-filter-control",
            cls: "uk-active",
            duration: 250
          },
          computed: {
            children: ({ target }, $el) => $$(`${target} > *`, $el),
            toggles: ({ attrItem }, $el) => $$(`[${attrItem}],[data-${attrItem}]`, $el)
          },
          watch: {
            toggles(toggles) {
              this.updateState();
              const actives = $$(this.selActive, this.$el);
              for (const toggle of toggles) {
                if (this.selActive !== false) {
                  toggleClass(toggle, this.cls, includes(actives, toggle));
                }
                const button = findButton(toggle);
                if (isTag(button, "a")) {
                  attr(button, "role", "button");
                }
              }
            },
            children(list, prev) {
              if (prev) {
                this.updateState();
              }
            }
          },
          events: {
            name: "click keydown",
            delegate() {
              return `[${this.attrItem}],[data-${this.attrItem}]`;
            },
            handler(e) {
              if (e.type === "keydown" && e.keyCode !== keyMap.SPACE) {
                return;
              }
              if (e.target.closest("a,button")) {
                e.preventDefault();
                this.apply(e.current);
              }
            }
          },
          methods: {
            apply(el) {
              const prevState = this.getState();
              const newState = mergeState(el, this.attrItem, this.getState());
              if (!isEqualState(prevState, newState)) {
                this.setState(newState);
              }
            },
            getState() {
              return this.toggles.filter((item) => hasClass(item, this.cls)).reduce((state, el) => mergeState(el, this.attrItem, state), {
                filter: { "": "" },
                sort: []
              });
            },
            async setState(state, animate = true) {
              state = { filter: { "": "" }, sort: [], ...state };
              trigger(this.$el, "beforeFilter", [this, state]);
              for (const toggle of this.toggles) {
                toggleClass(toggle, this.cls, matchFilter(toggle, this.attrItem, state));
              }
              await Promise.all(
                $$(this.target, this.$el).map((target) => {
                  const filterFn = () => {
                    applyState(state, target, children(target));
                    this.$update(this.$el);
                  };
                  return animate ? this.animate(filterFn, target) : filterFn();
                })
              );
              trigger(this.$el, "afterFilter", [this]);
            },
            updateState() {
              fastdom.write(() => this.setState(this.getState(), false));
            }
          }
        };
        function getFilter(el, attr2) {
          return parseOptions(data(el, attr2), ["filter"]);
        }
        function isEqualState(stateA, stateB) {
          return ["filter", "sort"].every((prop) => isEqual(stateA[prop], stateB[prop]));
        }
        function applyState(state, target, children) {
          const selector = getSelector(state);
          children.forEach((el) => css(el, "display", selector && !matches(el, selector) ? "none" : ""));
          const [sort, order] = state.sort;
          if (sort) {
            const sorted = sortItems(children, sort, order);
            if (!isEqual(sorted, children)) {
              append(target, sorted);
            }
          }
        }
        function mergeState(el, attr2, state) {
          const { filter, group, sort, order = "asc" } = getFilter(el, attr2);
          if (filter || isUndefined(sort)) {
            if (group) {
              if (filter) {
                delete state.filter[""];
                state.filter[group] = filter;
              } else {
                delete state.filter[group];
                if (isEmpty(state.filter) || "" in state.filter) {
                  state.filter = { "": filter || "" };
                }
              }
            } else {
              state.filter = { "": filter || "" };
            }
          }
          if (!isUndefined(sort)) {
            state.sort = [sort, order];
          }
          return state;
        }
        function matchFilter(el, attr2, { filter: stateFilter = { "": "" }, sort: [stateSort, stateOrder] }) {
          const { filter = "", group = "", sort, order = "asc" } = getFilter(el, attr2);
          return isUndefined(sort) ? group in stateFilter && filter === stateFilter[group] || !filter && group && !(group in stateFilter) && !stateFilter[""] : stateSort === sort && stateOrder === order;
        }
        function getSelector({ filter }) {
          let selector = "";
          each(filter, (value) => selector += value || "");
          return selector;
        }
        function sortItems(nodes, sort, order) {
          return [...nodes].sort(
            (a, b) => data(a, sort).localeCompare(data(b, sort), void 0, { numeric: true }) * (order === "asc" || -1)
          );
        }
        function findButton(el) {
          return $("a,button", el) || el;
        }

        var Container = {
          props: {
            container: Boolean
          },
          data: {
            container: true
          },
          computed: {
            container({ container }) {
              return container === true && this.$container || container && $(container);
            }
          }
        };

        let prevented;
        function preventBackgroundScroll(el) {
          const off = on(
            el,
            "touchmove",
            (e) => {
              if (e.targetTouches.length !== 1 || matches(e.target, 'input[type="range"')) {
                return;
              }
              let { scrollHeight, clientHeight } = scrollParent(e.target);
              if (clientHeight >= scrollHeight && e.cancelable) {
                e.preventDefault();
              }
            },
            { passive: false }
          );
          if (prevented) {
            return off;
          }
          prevented = true;
          const { scrollingElement } = document;
          css(scrollingElement, {
            overflowY: CSS.supports("overflow", "clip") ? "clip" : "hidden",
            touchAction: "none",
            paddingRight: width(window) - scrollingElement.clientWidth || ""
          });
          return () => {
            prevented = false;
            off();
            css(scrollingElement, { overflowY: "", touchAction: "", paddingRight: "" });
          };
        }

        var Togglable = {
          props: {
            cls: Boolean,
            animation: "list",
            duration: Number,
            velocity: Number,
            origin: String,
            transition: String
          },
          data: {
            cls: false,
            animation: [false],
            duration: 200,
            velocity: 0.2,
            origin: false,
            transition: "ease",
            clsEnter: "uk-togglabe-enter",
            clsLeave: "uk-togglabe-leave"
          },
          computed: {
            hasAnimation: ({ animation }) => !!animation[0],
            hasTransition: ({ animation }) => ["slide", "reveal"].some((transition) => startsWith(animation[0], transition))
          },
          methods: {
            async toggleElement(targets, toggle, animate) {
              try {
                await Promise.all(
                  toNodes(targets).map((el) => {
                    const show = isBoolean(toggle) ? toggle : !this.isToggled(el);
                    if (!trigger(el, `before${show ? "show" : "hide"}`, [this])) {
                      return Promise.reject();
                    }
                    const promise = (isFunction(animate) ? animate : animate === false || !this.hasAnimation ? toggleInstant : this.hasTransition ? toggleTransition : toggleAnimation)(el, show, this);
                    const cls = show ? this.clsEnter : this.clsLeave;
                    addClass(el, cls);
                    trigger(el, show ? "show" : "hide", [this]);
                    const done = () => {
                      removeClass(el, cls);
                      trigger(el, show ? "shown" : "hidden", [this]);
                    };
                    return promise ? promise.then(done, () => {
                      removeClass(el, cls);
                      return Promise.reject();
                    }) : done();
                  })
                );
                return true;
              } catch (e) {
                return false;
              }
            },
            isToggled(el = this.$el) {
              el = toNode(el);
              return hasClass(el, this.clsEnter) ? true : hasClass(el, this.clsLeave) ? false : this.cls ? hasClass(el, this.cls.split(" ")[0]) : isVisible(el);
            },
            _toggle(el, toggled) {
              if (!el) {
                return;
              }
              toggled = Boolean(toggled);
              let changed;
              if (this.cls) {
                changed = includes(this.cls, " ") || toggled !== hasClass(el, this.cls);
                changed && toggleClass(el, this.cls, includes(this.cls, " ") ? void 0 : toggled);
              } else {
                changed = toggled === el.hidden;
                changed && (el.hidden = !toggled);
              }
              $$("[autofocus]", el).some((el2) => isVisible(el2) ? el2.focus() || true : el2.blur());
              if (changed) {
                trigger(el, "toggled", [toggled, this]);
              }
            }
          }
        };
        function toggleInstant(el, show, { _toggle }) {
          Animation.cancel(el);
          Transition.cancel(el);
          return _toggle(el, show);
        }
        async function toggleTransition(el, show, { animation, duration, velocity, transition, _toggle }) {
          var _a;
          const [mode = "reveal", startProp = "top"] = ((_a = animation[0]) == null ? void 0 : _a.split("-")) || [];
          const dirs = [
            ["left", "right"],
            ["top", "bottom"]
          ];
          const dir = dirs[includes(dirs[0], startProp) ? 0 : 1];
          const end = dir[1] === startProp;
          const props = ["width", "height"];
          const dimProp = props[dirs.indexOf(dir)];
          const marginProp = `margin-${dir[0]}`;
          const marginStartProp = `margin-${startProp}`;
          let currentDim = dimensions$1(el)[dimProp];
          const inProgress = Transition.inProgress(el);
          await Transition.cancel(el);
          if (show) {
            _toggle(el, true);
          }
          const prevProps = Object.fromEntries(
            [
              "padding",
              "border",
              "width",
              "height",
              "minWidth",
              "minHeight",
              "overflowY",
              "overflowX",
              marginProp,
              marginStartProp
            ].map((key) => [key, el.style[key]])
          );
          const dim = dimensions$1(el);
          const currentMargin = toFloat(css(el, marginProp));
          const marginStart = toFloat(css(el, marginStartProp));
          const endDim = dim[dimProp] + marginStart;
          if (!inProgress && !show) {
            currentDim += marginStart;
          }
          const [wrapper] = wrapInner(el, "<div>");
          css(wrapper, {
            boxSizing: "border-box",
            height: dim.height,
            width: dim.width,
            ...css(el, [
              "overflow",
              "padding",
              "borderTop",
              "borderRight",
              "borderBottom",
              "borderLeft",
              "borderImage",
              marginStartProp
            ])
          });
          css(el, {
            padding: 0,
            border: 0,
            minWidth: 0,
            minHeight: 0,
            [marginStartProp]: 0,
            width: dim.width,
            height: dim.height,
            overflow: "hidden",
            [dimProp]: currentDim
          });
          const percent = currentDim / endDim;
          duration = (velocity * endDim + duration) * (show ? 1 - percent : percent);
          const endProps = { [dimProp]: show ? endDim : 0 };
          if (end) {
            css(el, marginProp, endDim - currentDim + currentMargin);
            endProps[marginProp] = show ? currentMargin : endDim + currentMargin;
          }
          if (!end ^ mode === "reveal") {
            css(wrapper, marginProp, -endDim + currentDim);
            Transition.start(wrapper, { [marginProp]: show ? 0 : -endDim }, duration, transition);
          }
          try {
            await Transition.start(el, endProps, duration, transition);
          } finally {
            css(el, prevProps);
            unwrap(wrapper.firstChild);
            if (!show) {
              _toggle(el, false);
            }
          }
        }
        function toggleAnimation(el, show, cmp) {
          const { animation, duration, _toggle } = cmp;
          if (show) {
            _toggle(el, true);
            return Animation.in(el, animation[0], duration, cmp.origin);
          }
          return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(
            () => _toggle(el, false)
          );
        }

        const active$1 = [];
        var Modal = {
          mixins: [Class, Container, Togglable],
          props: {
            selPanel: String,
            selClose: String,
            escClose: Boolean,
            bgClose: Boolean,
            stack: Boolean,
            role: String
          },
          data: {
            cls: "uk-open",
            escClose: true,
            bgClose: true,
            overlay: true,
            stack: false,
            role: "dialog"
          },
          computed: {
            panel: ({ selPanel }, $el) => $(selPanel, $el),
            transitionElement() {
              return this.panel;
            },
            bgClose({ bgClose }) {
              return bgClose && this.panel;
            }
          },
          connected() {
            attr(this.panel || this.$el, "role", this.role);
            if (this.overlay) {
              attr(this.panel || this.$el, "aria-modal", true);
            }
          },
          beforeDisconnect() {
            if (includes(active$1, this)) {
              this.toggleElement(this.$el, false, false);
            }
          },
          events: [
            {
              name: "click",
              delegate() {
                return `${this.selClose},a[href*="#"]`;
              },
              handler(e) {
                const { current, defaultPrevented } = e;
                const { hash } = current;
                if (!defaultPrevented && hash && isSameSiteAnchor(current) && !this.$el.contains($(hash))) {
                  this.hide();
                } else if (matches(current, this.selClose)) {
                  e.preventDefault();
                  this.hide();
                }
              }
            },
            {
              name: "toggle",
              self: true,
              handler(e) {
                if (e.defaultPrevented) {
                  return;
                }
                e.preventDefault();
                if (this.isToggled() === includes(active$1, this)) {
                  this.toggle();
                }
              }
            },
            {
              name: "beforeshow",
              self: true,
              handler(e) {
                if (includes(active$1, this)) {
                  return false;
                }
                if (!this.stack && active$1.length) {
                  Promise.all(active$1.map((modal) => modal.hide())).then(this.show);
                  e.preventDefault();
                } else {
                  active$1.push(this);
                }
              }
            },
            {
              name: "show",
              self: true,
              handler() {
                if (this.stack) {
                  css(this.$el, "zIndex", toFloat(css(this.$el, "zIndex")) + active$1.length);
                }
                const handlers = [
                  this.overlay && preventBackgroundFocus(this),
                  this.overlay && preventBackgroundScroll(this.$el),
                  this.bgClose && listenForBackgroundClose$1(this),
                  this.escClose && listenForEscClose$1(this)
                ];
                once(
                  this.$el,
                  "hidden",
                  () => handlers.forEach((handler) => handler && handler()),
                  { self: true }
                );
                addClass(document.documentElement, this.clsPage);
              }
            },
            {
              name: "shown",
              self: true,
              handler() {
                if (!isFocusable(this.$el)) {
                  attr(this.$el, "tabindex", "-1");
                }
                if (!matches(this.$el, ":focus-within")) {
                  this.$el.focus();
                }
              }
            },
            {
              name: "hidden",
              self: true,
              handler() {
                if (includes(active$1, this)) {
                  active$1.splice(active$1.indexOf(this), 1);
                }
                css(this.$el, "zIndex", "");
                if (!active$1.some((modal) => modal.clsPage === this.clsPage)) {
                  removeClass(document.documentElement, this.clsPage);
                }
              }
            }
          ],
          methods: {
            toggle() {
              return this.isToggled() ? this.hide() : this.show();
            },
            show() {
              if (this.container && parent(this.$el) !== this.container) {
                append(this.container, this.$el);
                return new Promise(
                  (resolve) => requestAnimationFrame(() => this.show().then(resolve))
                );
              }
              return this.toggleElement(this.$el, true, animate$1);
            },
            hide() {
              return this.toggleElement(this.$el, false, animate$1);
            }
          }
        };
        function animate$1(el, show, { transitionElement, _toggle }) {
          return new Promise(
            (resolve, reject) => once(el, "show hide", () => {
              var _a;
              (_a = el._reject) == null ? void 0 : _a.call(el);
              el._reject = reject;
              _toggle(el, show);
              const off = once(
                transitionElement,
                "transitionstart",
                () => {
                  once(transitionElement, "transitionend transitioncancel", resolve, {
                    self: true
                  });
                  clearTimeout(timer);
                },
                { self: true }
              );
              const timer = setTimeout(
                () => {
                  off();
                  resolve();
                },
                toMs(css(transitionElement, "transitionDuration"))
              );
            })
          ).then(() => delete el._reject);
        }
        function toMs(time) {
          return time ? endsWith(time, "ms") ? toFloat(time) : toFloat(time) * 1e3 : 0;
        }
        function preventBackgroundFocus(modal) {
          return on(document, "focusin", (e) => {
            if (last(active$1) === modal && !modal.$el.contains(e.target)) {
              modal.$el.focus();
            }
          });
        }
        function listenForBackgroundClose$1(modal) {
          return on(document, pointerDown$1, ({ target }) => {
            if (last(active$1) !== modal || modal.overlay && !modal.$el.contains(target) || modal.panel.contains(target)) {
              return;
            }
            once(
              document,
              `${pointerUp$1} ${pointerCancel} scroll`,
              ({ defaultPrevented, type, target: newTarget }) => {
                if (!defaultPrevented && type === pointerUp$1 && target === newTarget) {
                  modal.hide();
                }
              },
              true
            );
          });
        }
        function listenForEscClose$1(modal) {
          return on(document, "keydown", (e) => {
            if (e.keyCode === 27 && last(active$1) === modal) {
              modal.hide();
            }
          });
        }

        var Animations$2 = {
          slide: {
            show(dir) {
              return [{ transform: translate(dir * -100) }, { transform: translate() }];
            },
            percent(current) {
              return translated(current);
            },
            translate(percent, dir) {
              return [
                { transform: translate(dir * -100 * percent) },
                { transform: translate(dir * 100 * (1 - percent)) }
              ];
            }
          }
        };
        function translated(el) {
          return Math.abs(css(el, "transform").split(",")[4] / el.offsetWidth);
        }
        function translate(value = 0, unit = "%") {
          value += value ? unit : "";
          return `translate3d(${value}, 0, 0)`;
        }
        function scale3d(value) {
          return `scale3d(${value}, ${value}, 1)`;
        }

        function Transitioner$1(prev, next, dir, { animation, easing }) {
          const { percent, translate, show = noop } = animation;
          const props = show(dir);
          let resolve;
          return {
            dir,
            show(duration, percent2 = 0, linear) {
              const timing = linear ? "linear" : easing;
              duration -= Math.round(duration * clamp(percent2, -1, 1));
              this.translate(percent2);
              triggerUpdate$1(next, "itemin", { percent: percent2, duration, timing, dir });
              triggerUpdate$1(prev, "itemout", { percent: 1 - percent2, duration, timing, dir });
              return new Promise((res) => {
                resolve || (resolve = res);
                Promise.all([
                  Transition.start(next, props[1], duration, timing),
                  Transition.start(prev, props[0], duration, timing)
                ]).then(() => {
                  this.reset();
                  resolve();
                }, noop);
              });
            },
            cancel() {
              return Transition.cancel([next, prev]);
            },
            reset() {
              for (const prop in props[0]) {
                css([next, prev], prop, "");
              }
            },
            async forward(duration, percent2 = this.percent()) {
              await this.cancel();
              return this.show(duration, percent2, true);
            },
            translate(percent2) {
              this.reset();
              const props2 = translate(percent2, dir);
              css(next, props2[1]);
              css(prev, props2[0]);
              triggerUpdate$1(next, "itemtranslatein", { percent: percent2, dir });
              triggerUpdate$1(prev, "itemtranslateout", { percent: 1 - percent2, dir });
            },
            percent() {
              return percent(prev || next, next, dir);
            },
            getDistance() {
              return prev == null ? void 0 : prev.offsetWidth;
            }
          };
        }
        function triggerUpdate$1(el, type, data) {
          trigger(el, createEvent(type, false, false, data));
        }

        var I18n = {
          props: {
            i18n: Object
          },
          data: {
            i18n: null
          },
          methods: {
            t(key, ...params) {
              var _a, _b, _c;
              let i = 0;
              return ((_c = ((_a = this.i18n) == null ? void 0 : _a[key]) || ((_b = this.$options.i18n) == null ? void 0 : _b[key])) == null ? void 0 : _c.replace(
                /%s/g,
                () => params[i++] || ""
              )) || "";
            }
          }
        };

        var SliderAutoplay = {
          props: {
            autoplay: Boolean,
            autoplayInterval: Number,
            pauseOnHover: Boolean
          },
          data: {
            autoplay: false,
            autoplayInterval: 7e3,
            pauseOnHover: true
          },
          connected() {
            attr(this.list, "aria-live", this.autoplay ? "off" : "polite");
            this.autoplay && this.startAutoplay();
          },
          disconnected() {
            this.stopAutoplay();
          },
          update() {
            attr(this.slides, "tabindex", "-1");
          },
          events: [
            {
              name: "visibilitychange",
              el() {
                return document;
              },
              filter() {
                return this.autoplay;
              },
              handler() {
                if (document.hidden) {
                  this.stopAutoplay();
                } else {
                  this.startAutoplay();
                }
              }
            }
          ],
          methods: {
            startAutoplay() {
              this.stopAutoplay();
              this.interval = setInterval(() => {
                if (!(this.stack.length || this.draggable && matches(this.$el, ":focus-within") || this.pauseOnHover && matches(this.$el, ":hover"))) {
                  this.show("next");
                }
              }, this.autoplayInterval);
            },
            stopAutoplay() {
              clearInterval(this.interval);
            }
          }
        };

        const pointerOptions = { passive: false, capture: true };
        const pointerUpOptions = { passive: true, capture: true };
        const pointerDown = "touchstart mousedown";
        const pointerMove = "touchmove mousemove";
        const pointerUp = "touchend touchcancel mouseup click input scroll";
        var SliderDrag = {
          props: {
            draggable: Boolean
          },
          data: {
            draggable: true,
            threshold: 10
          },
          created() {
            for (const key of ["start", "move", "end"]) {
              const fn = this[key];
              this[key] = (e) => {
                const pos = getEventPos(e).x * (isRtl ? -1 : 1);
                this.prevPos = pos === this.pos ? this.prevPos : this.pos;
                this.pos = pos;
                fn(e);
              };
            }
          },
          events: [
            {
              name: pointerDown,
              passive: true,
              delegate() {
                return `${this.selList} > *`;
              },
              handler(e) {
                if (!this.draggable || !isTouch(e) && hasSelectableText(e.target) || e.target.closest(selInput) || e.button > 0 || this.length < 2) {
                  return;
                }
                this.start(e);
              }
            },
            {
              name: "dragstart",
              handler(e) {
                e.preventDefault();
              }
            },
            {
              // iOS workaround for slider stopping if swiping fast
              name: pointerMove,
              el() {
                return this.list;
              },
              handler: noop,
              ...pointerOptions
            }
          ],
          methods: {
            start() {
              this.drag = this.pos;
              if (this._transitioner) {
                this.percent = this._transitioner.percent();
                this.drag += this._transitioner.getDistance() * this.percent * this.dir;
                this._transitioner.cancel();
                this._transitioner.translate(this.percent);
                this.dragging = true;
                this.stack = [];
              } else {
                this.prevIndex = this.index;
              }
              on(document, pointerMove, this.move, pointerOptions);
              on(document, pointerUp, this.end, pointerUpOptions);
              css(this.list, "userSelect", "none");
            },
            move(e) {
              const distance = this.pos - this.drag;
              if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {
                return;
              }
              css(this.list, "pointerEvents", "none");
              e.cancelable && e.preventDefault();
              this.dragging = true;
              this.dir = distance < 0 ? 1 : -1;
              let { slides, prevIndex } = this;
              let dis = Math.abs(distance);
              let nextIndex = this.getIndex(prevIndex + this.dir);
              let width = this._getDistance(prevIndex, nextIndex);
              while (nextIndex !== prevIndex && dis > width) {
                this.drag -= width * this.dir;
                prevIndex = nextIndex;
                dis -= width;
                nextIndex = this.getIndex(prevIndex + this.dir);
                width = this._getDistance(prevIndex, nextIndex);
              }
              this.percent = dis / width;
              const prev = slides[prevIndex];
              const next = slides[nextIndex];
              const changed = this.index !== nextIndex;
              const edge = prevIndex === nextIndex;
              let itemShown;
              for (const i of [this.index, this.prevIndex]) {
                if (!includes([nextIndex, prevIndex], i)) {
                  trigger(slides[i], "itemhidden", [this]);
                  if (edge) {
                    itemShown = true;
                    this.prevIndex = prevIndex;
                  }
                }
              }
              if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
                trigger(slides[this.index], "itemshown", [this]);
              }
              if (changed) {
                this.prevIndex = prevIndex;
                this.index = nextIndex;
                !edge && trigger(prev, "beforeitemhide", [this]);
                trigger(next, "beforeitemshow", [this]);
              }
              this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);
              if (changed) {
                !edge && trigger(prev, "itemhide", [this]);
                trigger(next, "itemshow", [this]);
              }
            },
            end() {
              off(document, pointerMove, this.move, pointerOptions);
              off(document, pointerUp, this.end, pointerUpOptions);
              if (this.dragging) {
                this.dragging = null;
                if (this.index === this.prevIndex) {
                  this.percent = 1 - this.percent;
                  this.dir *= -1;
                  this._show(false, this.index, true);
                  this._transitioner = null;
                } else {
                  const dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;
                  this.index = dirChange ? this.index : this.prevIndex;
                  if (dirChange) {
                    this.percent = 1 - this.percent;
                  }
                  this.show(
                    this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? "next" : "previous",
                    true
                  );
                }
              }
              css(this.list, { userSelect: "", pointerEvents: "" });
              this.drag = this.percent = null;
            },
            _getDistance(prev, next) {
              return this._getTransitioner(prev, prev !== next && next).getDistance() || this.slides[prev].offsetWidth;
            }
          }
        };
        function hasSelectableText(el) {
          return css(el, "userSelect") !== "none" && toArray(el.childNodes).some((el2) => el2.nodeType === 3 && el2.textContent.trim());
        }

        function initWatches(instance) {
          instance._watches = [];
          for (const watches of instance.$options.watch || []) {
            for (const [name, watch] of Object.entries(watches)) {
              registerWatch(instance, watch, name);
            }
          }
          instance._initial = true;
        }
        function registerWatch(instance, watch, name) {
          instance._watches.push({
            name,
            ...isPlainObject(watch) ? watch : { handler: watch }
          });
        }
        function runWatches(instance, values) {
          for (const { name, handler, immediate = true } of instance._watches) {
            if (instance._initial && immediate || hasOwn(values, name) && !isEqual(values[name], instance[name])) {
              handler.call(instance, instance[name], values[name]);
            }
          }
          instance._initial = false;
        }

        function initComputed(instance) {
          const { computed } = instance.$options;
          instance._computed = {};
          if (computed) {
            for (const key in computed) {
              registerComputed(instance, key, computed[key]);
            }
          }
        }
        function registerComputed(instance, key, cb) {
          instance._hasComputed = true;
          Object.defineProperty(instance, key, {
            enumerable: true,
            get() {
              const { _computed, $props, $el } = instance;
              if (!hasOwn(_computed, key)) {
                _computed[key] = (cb.get || cb).call(instance, $props, $el);
              }
              return _computed[key];
            },
            set(value) {
              const { _computed } = instance;
              _computed[key] = cb.set ? cb.set.call(instance, value) : value;
              if (isUndefined(_computed[key])) {
                delete _computed[key];
              }
            }
          });
        }
        function initComputedUpdates(instance) {
          if (!instance._hasComputed) {
            return;
          }
          prependUpdate(instance, {
            read: () => runWatches(instance, resetComputed(instance)),
            events: ["resize", "computed"]
          });
          registerComputedObserver();
          instances$1.add(instance);
        }
        function disconnectComputedUpdates(instance) {
          instances$1 == null ? void 0 : instances$1.delete(instance);
          resetComputed(instance);
        }
        function resetComputed(instance) {
          const values = { ...instance._computed };
          instance._computed = {};
          return values;
        }
        let observer;
        let instances$1;
        function registerComputedObserver() {
          if (observer) {
            return;
          }
          instances$1 = /* @__PURE__ */ new Set();
          observer = new MutationObserver(() => {
            for (const instance of instances$1) {
              callUpdate(instance, "computed");
            }
          });
          observer.observe(document, {
            subtree: true,
            childList: true
          });
        }

        function initEvents(instance) {
          instance._events = [];
          for (const event of instance.$options.events || []) {
            if (hasOwn(event, "handler")) {
              registerEvent(instance, event);
            } else {
              for (const key in event) {
                registerEvent(instance, event[key], key);
              }
            }
          }
        }
        function unbindEvents(instance) {
          instance._events.forEach((unbind) => unbind());
          delete instance._events;
        }
        function registerEvent(instance, event, key) {
          let { name, el, handler, capture, passive, delegate, filter, self } = isPlainObject(event) ? event : { name: key, handler: event };
          el = isFunction(el) ? el.call(instance, instance) : el || instance.$el;
          if (!el || isArray(el) && !el.length || filter && !filter.call(instance)) {
            return;
          }
          instance._events.push(
            on(
              el,
              name,
              delegate ? isString(delegate) ? delegate : delegate.call(instance, instance) : null,
              isString(handler) ? instance[handler] : handler.bind(instance),
              { passive, capture, self }
            )
          );
        }

        function initObservers(instance) {
          instance._observers = [];
          for (const observer of instance.$options.observe || []) {
            if (hasOwn(observer, "handler")) {
              registerObservable(instance, observer);
            } else {
              for (const observable of observer) {
                registerObservable(instance, observable);
              }
            }
          }
        }
        function registerObserver(instance, ...observer) {
          instance._observers.push(...observer);
        }
        function disconnectObservers(instance) {
          for (const observer of instance._observers) {
            observer.disconnect();
          }
        }
        function registerObservable(instance, observable) {
          let { observe, target = instance.$el, handler, options, filter, args } = observable;
          if (filter && !filter.call(instance, instance)) {
            return;
          }
          const key = `_observe${instance._observers.length}`;
          if (isFunction(target) && !hasOwn(instance, key)) {
            registerComputed(instance, key, () => target.call(instance, instance));
          }
          handler = isString(handler) ? instance[handler] : handler.bind(instance);
          if (isFunction(options)) {
            options = options.call(instance, instance);
          }
          const targets = hasOwn(instance, key) ? instance[key] : target;
          const observer = observe(targets, handler, options, args);
          if (isFunction(target) && isArray(instance[key]) && observer.unobserve) {
            registerWatch(instance, { handler: updateTargets(observer), immediate: false }, key);
          }
          registerObserver(instance, observer);
        }
        function updateTargets(observer) {
          return (targets, prev) => {
            for (const target of prev) {
              !includes(targets, target) && observer.unobserve(target);
            }
            for (const target of targets) {
              !includes(prev, target) && observer.observe(target);
            }
          };
        }

        function initProps(instance) {
          const { $options, $props } = instance;
          const props = getProps($options);
          assign($props, props);
          const { computed, methods } = $options;
          for (let key in $props) {
            if (key in props && (!computed || !hasOwn(computed, key)) && (!methods || !hasOwn(methods, key))) {
              instance[key] = $props[key];
            }
          }
        }
        function getProps(opts) {
          const data$1 = {};
          const { args = [], props = {}, el, id } = opts;
          if (!props) {
            return data$1;
          }
          for (const key in props) {
            const prop = hyphenate(key);
            let value = data(el, prop);
            if (isUndefined(value)) {
              continue;
            }
            value = props[key] === Boolean && value === "" ? true : coerce$1(props[key], value);
            if (prop === "target" && startsWith(value, "_")) {
              continue;
            }
            data$1[key] = value;
          }
          const options = parseOptions(data(el, id), args);
          for (const key in options) {
            const prop = camelize(key);
            if (!isUndefined(props[prop])) {
              data$1[prop] = coerce$1(props[prop], options[key]);
            }
          }
          return data$1;
        }
        const getAttributes = memoize((id, props) => {
          const attributes = Object.keys(props);
          const filter = attributes.concat(id).map((key) => [hyphenate(key), `data-${hyphenate(key)}`]).flat();
          return { attributes, filter };
        });
        function initPropsObserver(instance) {
          const { $options, $props } = instance;
          const { id, props, el } = $options;
          if (!props) {
            return;
          }
          const { attributes, filter } = getAttributes(id, props);
          const observer = new MutationObserver((records) => {
            const data = getProps($options);
            if (records.some(({ attributeName }) => {
              const prop = attributeName.replace("data-", "");
              return (prop === id ? attributes : [camelize(prop), camelize(attributeName)]).some(
                (prop2) => !isUndefined(data[prop2]) && data[prop2] !== $props[prop2]
              );
            })) {
              instance.$reset();
            }
          });
          observer.observe(el, {
            attributes: true,
            attributeFilter: filter
          });
          registerObserver(instance, observer);
        }

        function callHook(instance, hook) {
          var _a;
          (_a = instance.$options[hook]) == null ? void 0 : _a.forEach((handler) => handler.call(instance));
        }
        function callConnected(instance) {
          if (instance._connected) {
            return;
          }
          initProps(instance);
          callHook(instance, "beforeConnect");
          instance._connected = true;
          initEvents(instance);
          initUpdates(instance);
          initWatches(instance);
          initObservers(instance);
          initPropsObserver(instance);
          initComputedUpdates(instance);
          callHook(instance, "connected");
          callUpdate(instance);
        }
        function callDisconnected(instance) {
          if (!instance._connected) {
            return;
          }
          callHook(instance, "beforeDisconnect");
          unbindEvents(instance);
          clearUpdateData(instance);
          disconnectObservers(instance);
          disconnectComputedUpdates(instance);
          callHook(instance, "disconnected");
          instance._connected = false;
        }

        let uid = 0;
        function init$1(instance, options = {}) {
          options.data = normalizeData(options, instance.constructor.options);
          instance.$options = mergeOptions(instance.constructor.options, options, instance);
          instance.$props = {};
          instance._uid = uid++;
          initData(instance);
          initMethods(instance);
          initComputed(instance);
          callHook(instance, "created");
          if (options.el) {
            instance.$mount(options.el);
          }
        }
        function initData(instance) {
          const { data = {} } = instance.$options;
          for (const key in data) {
            instance.$props[key] = instance[key] = data[key];
          }
        }
        function initMethods(instance) {
          const { methods } = instance.$options;
          if (methods) {
            for (const key in methods) {
              instance[key] = methods[key].bind(instance);
            }
          }
        }
        function normalizeData({ data = {} }, { args = [], props = {} }) {
          if (isArray(data)) {
            data = data.slice(0, args.length).reduce((data2, value, index) => {
              if (isPlainObject(value)) {
                assign(data2, value);
              } else {
                data2[args[index]] = value;
              }
              return data2;
            }, {});
          }
          for (const key in data) {
            if (isUndefined(data[key])) {
              delete data[key];
            } else if (props[key]) {
              data[key] = coerce$1(props[key], data[key]);
            }
          }
          return data;
        }

        const App = function(options) {
          init$1(this, options);
        };
        App.util = util;
        App.options = {};
        App.version = "3.17.11";

        const PREFIX = "uk-";
        const DATA = "__uikit__";
        const components$2 = {};
        function component(name, options) {
          var _a;
          const id = PREFIX + hyphenate(name);
          if (!options) {
            if (isPlainObject(components$2[id])) {
              components$2[id] = App.extend(components$2[id]);
            }
            return components$2[id];
          }
          name = camelize(name);
          App[name] = (element, data) => createComponent(name, element, data);
          const opt = isPlainObject(options) ? { ...options } : options.options;
          opt.id = id;
          opt.name = name;
          (_a = opt.install) == null ? void 0 : _a.call(opt, App, opt, name);
          if (App._initialized && !opt.functional) {
            requestAnimationFrame(() => createComponent(name, `[${id}],[data-${id}]`));
          }
          return components$2[id] = opt;
        }
        function createComponent(name, element, data, ...args) {
          const Component = component(name);
          return Component.options.functional ? new Component({ data: isPlainObject(element) ? element : [element, data, ...args] }) : element ? $$(element).map(init)[0] : init();
          function init(element2) {
            const instance = getComponent(element2, name);
            if (instance) {
              if (data) {
                instance.$destroy();
              } else {
                return instance;
              }
            }
            return new Component({ el: element2, data });
          }
        }
        function getComponents(element) {
          return (element == null ? void 0 : element[DATA]) || {};
        }
        function getComponent(element, name) {
          return getComponents(element)[name];
        }
        function attachToElement(element, instance) {
          if (!element[DATA]) {
            element[DATA] = {};
          }
          element[DATA][instance.$options.name] = instance;
        }
        function detachFromElement(element, instance) {
          var _a;
          (_a = element[DATA]) == null ? true : delete _a[instance.$options.name];
          if (!isEmpty(element[DATA])) {
            delete element[DATA];
          }
        }

        function globalApi(App) {
          App.component = component;
          App.getComponents = getComponents;
          App.getComponent = getComponent;
          App.update = update;
          App.use = function(plugin) {
            if (plugin.installed) {
              return;
            }
            plugin.call(null, this);
            plugin.installed = true;
            return this;
          };
          App.mixin = function(mixin, component2) {
            component2 = (isString(component2) ? this.component(component2) : component2) || this;
            component2.options = mergeOptions(component2.options, mixin);
          };
          App.extend = function(options) {
            options || (options = {});
            const Super = this;
            const Sub = function UIkitComponent(options2) {
              init$1(this, options2);
            };
            Sub.prototype = Object.create(Super.prototype);
            Sub.prototype.constructor = Sub;
            Sub.options = mergeOptions(Super.options, options);
            Sub.super = Super;
            Sub.extend = Super.extend;
            return Sub;
          };
          let container;
          Object.defineProperty(App, "container", {
            get() {
              return container || document.body;
            },
            set(element) {
              container = $(element);
            }
          });
        }
        function update(element, e) {
          element = element ? toNode(element) : document.body;
          for (const parentEl of parents(element).reverse()) {
            updateElement(parentEl, e);
          }
          apply(element, (element2) => updateElement(element2, e));
        }
        function updateElement(element, e) {
          const components = getComponents(element);
          for (const name in components) {
            callUpdate(components[name], e);
          }
        }

        function instanceApi(App) {
          App.prototype.$mount = function(el) {
            const instance = this;
            attachToElement(el, instance);
            instance.$options.el = el;
            if (document.contains(el)) {
              callConnected(instance);
            }
          };
          App.prototype.$destroy = function(removeEl = false) {
            const instance = this;
            const { el } = instance.$options;
            if (el) {
              callDisconnected(instance);
            }
            callHook(instance, "destroy");
            detachFromElement(el, instance);
            if (removeEl) {
              remove$1(instance.$el);
            }
          };
          App.prototype.$create = createComponent;
          App.prototype.$emit = function(e) {
            callUpdate(this, e);
          };
          App.prototype.$update = function(element = this.$el, e) {
            update(element, e);
          };
          App.prototype.$reset = function() {
            callDisconnected(this);
            callConnected(this);
          };
          App.prototype.$getComponent = getComponent;
          Object.defineProperties(App.prototype, {
            $el: {
              get() {
                return this.$options.el;
              }
            },
            $container: Object.getOwnPropertyDescriptor(App, "container")
          });
        }
        let id = 1;
        function generateId(instance, el = null) {
          return (el == null ? void 0 : el.id) || `${instance.$options.id}-${id++}`;
        }

        var SliderNav = {
          i18n: {
            next: "Next slide",
            previous: "Previous slide",
            slideX: "Slide %s",
            slideLabel: "%s of %s",
            role: "String"
          },
          data: {
            selNav: false,
            role: "region"
          },
          computed: {
            nav: ({ selNav }, $el) => $(selNav, $el),
            navChildren() {
              return children(this.nav);
            },
            selNavItem: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`,
            navItems(_, $el) {
              return $$(this.selNavItem, $el);
            }
          },
          watch: {
            nav(nav, prev) {
              attr(nav, "role", "tablist");
              if (prev) {
                this.$emit();
              }
            },
            list(list) {
              attr(list, "role", "presentation");
            },
            navChildren(children2) {
              attr(children2, "role", "presentation");
            },
            navItems(items) {
              for (const el of items) {
                const cmd = data(el, this.attrItem);
                const button = $("a,button", el) || el;
                let ariaLabel;
                let ariaControls = null;
                if (isNumeric(cmd)) {
                  const item = toNumber(cmd);
                  const slide = this.slides[item];
                  if (slide) {
                    if (!slide.id) {
                      slide.id = generateId(this, slide);
                    }
                    ariaControls = slide.id;
                  }
                  ariaLabel = this.t("slideX", toFloat(cmd) + 1);
                  attr(button, "role", "tab");
                } else {
                  if (this.list) {
                    if (!this.list.id) {
                      this.list.id = generateId(this, this.list);
                    }
                    ariaControls = this.list.id;
                  }
                  ariaLabel = this.t(cmd);
                }
                attr(button, {
                  "aria-controls": ariaControls,
                  "aria-label": attr(button, "aria-label") || ariaLabel
                });
              }
            },
            slides(slides) {
              slides.forEach(
                (slide, i) => attr(slide, {
                  role: this.nav ? "tabpanel" : "group",
                  "aria-label": this.t("slideLabel", i + 1, this.length),
                  "aria-roledescription": this.nav ? null : "slide"
                })
              );
            },
            length(length) {
              const navLength = this.navChildren.length;
              if (this.nav && length !== navLength) {
                empty(this.nav);
                for (let i = 0; i < length; i++) {
                  append(this.nav, `<li ${this.attrItem}="${i}"><a href></a></li>`);
                }
              }
            }
          },
          connected() {
            attr(this.$el, {
              role: this.role,
              "aria-roledescription": "carousel"
            });
          },
          update: [
            {
              write() {
                this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));
                this.updateNav();
              },
              events: ["resize"]
            }
          ],
          events: [
            {
              name: "click keydown",
              delegate() {
                return this.selNavItem;
              },
              handler(e) {
                if (e.target.closest("a,button") && (e.type === "click" || e.keyCode === keyMap.SPACE)) {
                  e.preventDefault();
                  this.show(data(e.current, this.attrItem));
                }
              }
            },
            {
              name: "itemshow",
              handler: "updateNav"
            },
            {
              name: "keydown",
              delegate() {
                return this.selNavItem;
              },
              handler(e) {
                const { current, keyCode } = e;
                const cmd = data(current, this.attrItem);
                if (!isNumeric(cmd)) {
                  return;
                }
                let i = keyCode === keyMap.HOME ? 0 : keyCode === keyMap.END ? "last" : keyCode === keyMap.LEFT ? "previous" : keyCode === keyMap.RIGHT ? "next" : -1;
                if (~i) {
                  e.preventDefault();
                  this.show(i);
                }
              }
            }
          ],
          methods: {
            updateNav() {
              const index = this.getValidIndex();
              for (const el of this.navItems) {
                const cmd = data(el, this.attrItem);
                const button = $("a,button", el) || el;
                if (isNumeric(cmd)) {
                  const item = toNumber(cmd);
                  const active = item === index;
                  toggleClass(el, this.clsActive, active);
                  attr(button, {
                    "aria-selected": active,
                    tabindex: active ? null : -1
                  });
                  if (active && button && matches(parent(el), ":focus-within")) {
                    button.focus();
                  }
                } else {
                  toggleClass(
                    el,
                    "uk-invisible",
                    this.finite && (cmd === "previous" && index === 0 || cmd === "next" && index >= this.maxIndex)
                  );
                }
              }
            }
          }
        };

        var Slider = {
          mixins: [SliderAutoplay, SliderDrag, SliderNav, I18n],
          props: {
            clsActivated: Boolean,
            easing: String,
            index: Number,
            finite: Boolean,
            velocity: Number
          },
          data: () => ({
            easing: "ease",
            finite: false,
            velocity: 1,
            index: 0,
            prevIndex: -1,
            stack: [],
            percent: 0,
            clsActive: "uk-active",
            clsActivated: false,
            Transitioner: false,
            transitionOptions: {}
          }),
          connected() {
            this.prevIndex = -1;
            this.index = this.getValidIndex(this.$props.index);
            this.stack = [];
          },
          disconnected() {
            removeClass(this.slides, this.clsActive);
          },
          computed: {
            duration: ({ velocity }, $el) => speedUp($el.offsetWidth / velocity),
            list: ({ selList }, $el) => $(selList, $el),
            maxIndex() {
              return this.length - 1;
            },
            slides() {
              return children(this.list);
            },
            length() {
              return this.slides.length;
            }
          },
          watch: {
            slides(slides, prev) {
              if (prev) {
                this.$emit();
              }
            }
          },
          observe: resize(),
          methods: {
            show(index, force = false) {
              var _a;
              if (this.dragging || !this.length) {
                return;
              }
              const { stack } = this;
              const queueIndex = force ? 0 : stack.length;
              const reset = () => {
                stack.splice(queueIndex, 1);
                if (stack.length) {
                  this.show(stack.shift(), true);
                }
              };
              stack[force ? "unshift" : "push"](index);
              if (!force && stack.length > 1) {
                if (stack.length === 2) {
                  (_a = this._transitioner) == null ? void 0 : _a.forward(Math.min(this.duration, 200));
                }
                return;
              }
              const prevIndex = this.getIndex(this.index);
              const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
              const nextIndex = this.getIndex(index, this.index);
              const next = this.slides[nextIndex];
              if (prev === next) {
                reset();
                return;
              }
              this.dir = getDirection(index, prevIndex);
              this.prevIndex = prevIndex;
              this.index = nextIndex;
              if (prev && !trigger(prev, "beforeitemhide", [this]) || !trigger(next, "beforeitemshow", [this, prev])) {
                this.index = this.prevIndex;
                reset();
                return;
              }
              const promise = this._show(prev, next, force).then(() => {
                prev && trigger(prev, "itemhidden", [this]);
                trigger(next, "itemshown", [this]);
                stack.shift();
                this._transitioner = null;
                requestAnimationFrame(() => stack.length && this.show(stack.shift(), true));
              });
              prev && trigger(prev, "itemhide", [this]);
              trigger(next, "itemshow", [this]);
              return promise;
            },
            getIndex(index = this.index, prev = this.index) {
              return clamp(
                getIndex(index, this.slides, prev, this.finite),
                0,
                Math.max(0, this.maxIndex)
              );
            },
            getValidIndex(index = this.index, prevIndex = this.prevIndex) {
              return this.getIndex(index, prevIndex);
            },
            _show(prev, next, force) {
              this._transitioner = this._getTransitioner(prev, next, this.dir, {
                easing: force ? next.offsetWidth < 600 ? "cubic-bezier(0.25, 0.46, 0.45, 0.94)" : "cubic-bezier(0.165, 0.84, 0.44, 1)" : this.easing,
                ...this.transitionOptions
              });
              if (!force && !prev) {
                this._translate(1);
                return Promise.resolve();
              }
              const { length } = this.stack;
              return this._transitioner[length > 1 ? "forward" : "show"](
                length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,
                this.percent
              );
            },
            _translate(percent, prev = this.prevIndex, next = this.index) {
              const transitioner = this._getTransitioner(prev === next ? false : prev, next);
              transitioner.translate(percent);
              return transitioner;
            },
            _getTransitioner(prev = this.prevIndex, next = this.index, dir = this.dir || 1, options = this.transitionOptions) {
              return new this.Transitioner(
                isNumber(prev) ? this.slides[prev] : prev,
                isNumber(next) ? this.slides[next] : next,
                dir * (isRtl ? -1 : 1),
                options
              );
            }
          }
        };
        function getDirection(index, prevIndex) {
          return index === "next" ? 1 : index === "previous" ? -1 : index < prevIndex ? -1 : 1;
        }
        function speedUp(x) {
          return 0.5 * x + 300;
        }

        var Slideshow = {
          mixins: [Slider],
          props: {
            animation: String
          },
          data: {
            animation: "slide",
            clsActivated: "uk-transition-active",
            Animations: Animations$2,
            Transitioner: Transitioner$1
          },
          computed: {
            animation({ animation, Animations: Animations2 }) {
              return { ...Animations2[animation] || Animations2.slide, name: animation };
            },
            transitionOptions() {
              return { animation: this.animation };
            }
          },
          events: {
            beforeitemshow({ target }) {
              addClass(target, this.clsActive);
            },
            itemshown({ target }) {
              addClass(target, this.clsActivated);
            },
            itemhidden({ target }) {
              removeClass(target, this.clsActive, this.clsActivated);
            }
          }
        };

        var Animations$1 = {
          ...Animations$2,
          fade: {
            show() {
              return [{ opacity: 0 }, { opacity: 1 }];
            },
            percent(current) {
              return 1 - css(current, "opacity");
            },
            translate(percent) {
              return [{ opacity: 1 - percent }, { opacity: percent }];
            }
          },
          scale: {
            show() {
              return [
                { opacity: 0, transform: scale3d(1 - 0.2) },
                { opacity: 1, transform: scale3d(1) }
              ];
            },
            percent(current) {
              return 1 - css(current, "opacity");
            },
            translate(percent) {
              return [
                { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },
                { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }
              ];
            }
          }
        };

        var LightboxPanel = {
          mixins: [Modal, Slideshow],
          functional: true,
          props: {
            delayControls: Number,
            preload: Number,
            videoAutoplay: Boolean,
            template: String
          },
          data: () => ({
            preload: 1,
            videoAutoplay: false,
            delayControls: 3e3,
            items: [],
            cls: "uk-open",
            clsPage: "uk-lightbox-page",
            selList: ".uk-lightbox-items",
            attrItem: "uk-lightbox-item",
            selClose: ".uk-close-large",
            selCaption: ".uk-lightbox-caption",
            pauseOnHover: false,
            velocity: 2,
            Animations: Animations$1,
            template: `<div class="uk-lightbox uk-overflow-hidden"> <ul class="uk-lightbox-items"></ul> <div class="uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque"> <button class="uk-lightbox-toolbar-icon uk-close-large" type="button" uk-close></button> </div> <a class="uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade" href uk-slidenav-previous uk-lightbox-item="previous"></a> <a class="uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade" href uk-slidenav-next uk-lightbox-item="next"></a> <div class="uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque"></div> </div>`
          }),
          created() {
            const $el = $(this.template);
            const list = $(this.selList, $el);
            this.items.forEach(() => append(list, "<li>"));
            const close = $("[uk-close]", $el);
            const closeLabel = this.t("close");
            if (close && closeLabel) {
              close.dataset.i18n = JSON.stringify({ label: closeLabel });
            }
            this.$mount(append(this.container, $el));
          },
          computed: {
            caption: ({ selCaption }, $el) => $(selCaption, $el)
          },
          events: [
            {
              name: `${pointerMove$1} ${pointerDown$1} keydown`,
              handler: "showControls"
            },
            {
              name: "click",
              self: true,
              delegate() {
                return `${this.selList} > *`;
              },
              handler(e) {
                if (!e.defaultPrevented) {
                  this.hide();
                }
              }
            },
            {
              name: "shown",
              self: true,
              handler() {
                this.showControls();
              }
            },
            {
              name: "hide",
              self: true,
              handler() {
                this.hideControls();
                removeClass(this.slides, this.clsActive);
                Transition.stop(this.slides);
              }
            },
            {
              name: "hidden",
              self: true,
              handler() {
                this.$destroy(true);
              }
            },
            {
              name: "keyup",
              el() {
                return document;
              },
              handler({ keyCode }) {
                if (!this.isToggled(this.$el) || !this.draggable) {
                  return;
                }
                let i = -1;
                if (keyCode === keyMap.LEFT) {
                  i = "previous";
                } else if (keyCode === keyMap.RIGHT) {
                  i = "next";
                } else if (keyCode === keyMap.HOME) {
                  i = 0;
                } else if (keyCode === keyMap.END) {
                  i = "last";
                }
                if (~i) {
                  this.show(i);
                }
              }
            },
            {
              name: "beforeitemshow",
              handler(e) {
                if (this.isToggled()) {
                  return;
                }
                this.draggable = false;
                e.preventDefault();
                this.toggleElement(this.$el, true, false);
                this.animation = Animations$1["scale"];
                removeClass(e.target, this.clsActive);
                this.stack.splice(1, 0, this.index);
              }
            },
            {
              name: "itemshow",
              handler() {
                html(this.caption, this.getItem().caption || "");
                for (let j = -this.preload; j <= this.preload; j++) {
                  this.loadItem(this.index + j);
                }
              }
            },
            {
              name: "itemshown",
              handler() {
                this.draggable = this.$props.draggable;
              }
            },
            {
              name: "itemload",
              async handler(_, item) {
                const { source: src, type, alt = "", poster, attrs = {} } = item;
                this.setItem(item, "<span uk-spinner></span>");
                if (!src) {
                  return;
                }
                let matches;
                const iframeAttrs = {
                  allowfullscreen: "",
                  style: "max-width: 100%; box-sizing: border-box;",
                  "uk-responsive": "",
                  "uk-video": `${this.videoAutoplay}`
                };
                if (type === "image" || src.match(/\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\?)/i)) {
                  const img = createEl("img", { src, alt, ...attrs });
                  on(img, "load", () => this.setItem(item, img));
                  on(img, "error", () => this.setError(item));
                } else if (type === "video" || src.match(/\.(mp4|webm|ogv)($|\?)/i)) {
                  const video = createEl("video", {
                    src,
                    poster,
                    controls: "",
                    playsinline: "",
                    "uk-video": `${this.videoAutoplay}`,
                    ...attrs
                  });
                  on(video, "loadedmetadata", () => this.setItem(item, video));
                  on(video, "error", () => this.setError(item));
                } else if (type === "iframe" || src.match(/\.(html|php)($|\?)/i)) {
                  this.setItem(
                    item,
                    createEl("iframe", {
                      src,
                      allowfullscreen: "",
                      class: "uk-lightbox-iframe",
                      ...attrs
                    })
                  );
                } else if (matches = src.match(
                  /\/\/(?:.*?youtube(-nocookie)?\..*?(?:[?&]v=|\/shorts\/)|youtu\.be\/)([\w-]{11})[&?]?(.*)?/
                )) {
                  this.setItem(
                    item,
                    createEl("iframe", {
                      src: `https://www.youtube${matches[1] || ""}.com/embed/${matches[2]}${matches[3] ? `?${matches[3]}` : ""}`,
                      width: 1920,
                      height: 1080,
                      ...iframeAttrs,
                      ...attrs
                    })
                  );
                } else if (matches = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/)) {
                  try {
                    const { height, width } = await (await fetch(
                      `https://vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI(
                src
              )}`,
                      { credentials: "omit" }
                    )).json();
                    this.setItem(
                      item,
                      createEl("iframe", {
                        src: `https://player.vimeo.com/video/${matches[1]}${matches[2] ? `?${matches[2]}` : ""}`,
                        width,
                        height,
                        ...iframeAttrs,
                        ...attrs
                      })
                    );
                  } catch (e) {
                    this.setError(item);
                  }
                }
              }
            }
          ],
          methods: {
            loadItem(index = this.index) {
              const item = this.getItem(index);
              if (!this.getSlide(item).childElementCount) {
                trigger(this.$el, "itemload", [item]);
              }
            },
            getItem(index = this.index) {
              return this.items[getIndex(index, this.slides)];
            },
            setItem(item, content) {
              trigger(this.$el, "itemloaded", [this, html(this.getSlide(item), content)]);
            },
            getSlide(item) {
              return this.slides[this.items.indexOf(item)];
            },
            setError(item) {
              this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
            },
            showControls() {
              clearTimeout(this.controlsTimer);
              this.controlsTimer = setTimeout(this.hideControls, this.delayControls);
              addClass(this.$el, "uk-active", "uk-transition-active");
            },
            hideControls() {
              removeClass(this.$el, "uk-active", "uk-transition-active");
            }
          }
        };
        function createEl(tag, attrs) {
          const el = fragment(`<${tag}>`);
          attr(el, attrs);
          return el;
        }

        var lightbox = {
          install: install$3,
          props: { toggle: String },
          data: { toggle: "a" },
          computed: {
            toggles: ({ toggle }, $el) => $$(toggle, $el)
          },
          watch: {
            toggles(toggles) {
              this.hide();
              for (const toggle of toggles) {
                if (isTag(toggle, "a")) {
                  attr(toggle, "role", "button");
                }
              }
            }
          },
          disconnected() {
            this.hide();
          },
          events: {
            name: "click",
            delegate() {
              return `${this.toggle}:not(.uk-disabled)`;
            },
            handler(e) {
              e.preventDefault();
              this.show(e.current);
            }
          },
          methods: {
            show(index) {
              const items = uniqueBy(this.toggles.map(toItem), "source");
              if (isElement(index)) {
                const { source } = toItem(index);
                index = findIndex(items, ({ source: src }) => source === src);
              }
              this.panel = this.panel || this.$create("lightboxPanel", { ...this.$props, items });
              on(this.panel.$el, "hidden", () => this.panel = null);
              return this.panel.show(index);
            },
            hide() {
              var _a;
              return (_a = this.panel) == null ? void 0 : _a.hide();
            }
          }
        };
        function install$3(UIkit, Lightbox) {
          if (!UIkit.lightboxPanel) {
            UIkit.component("lightboxPanel", LightboxPanel);
          }
          assign(Lightbox.props, UIkit.component("lightboxPanel").options.props);
        }
        function toItem(el) {
          const item = {};
          for (const attr2 of ["href", "caption", "type", "poster", "alt", "attrs"]) {
            item[attr2 === "href" ? "source" : attr2] = data(el, attr2);
          }
          item.attrs = parseOptions(item.attrs);
          return item;
        }

        var notification = {
          mixins: [Container],
          functional: true,
          args: ["message", "status"],
          data: {
            message: "",
            status: "",
            timeout: 5e3,
            group: "",
            pos: "top-center",
            clsContainer: "uk-notification",
            clsClose: "uk-notification-close",
            clsMsg: "uk-notification-message"
          },
          install: install$2,
          computed: {
            marginProp: ({ pos }) => `margin-${pos.match(/[a-z]+(?=-)/)[0]}`,
            startProps() {
              return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };
            }
          },
          created() {
            const posClass = `${this.clsContainer}-${this.pos}`;
            let container = $(`.${posClass}`, this.container);
            if (!container || !isVisible(container)) {
              container = append(
                this.container,
                `<div class="${this.clsContainer} ${posClass}"></div>`
              );
            }
            this.$mount(
              append(
                container,
                `<div class="${this.clsMsg}${this.status ? ` ${this.clsMsg}-${this.status}` : ""}" role="alert"> <a href class="${this.clsClose}" data-uk-close></a> <div>${this.message}</div> </div>`
              )
            );
          },
          async connected() {
            const margin = toFloat(css(this.$el, this.marginProp));
            await Transition.start(css(this.$el, this.startProps), {
              opacity: 1,
              [this.marginProp]: margin
            });
            if (this.timeout) {
              this.timer = setTimeout(this.close, this.timeout);
            }
          },
          events: {
            click(e) {
              if (e.target.closest('a[href="#"],a[href=""]')) {
                e.preventDefault();
              }
              this.close();
            },
            [pointerEnter]() {
              if (this.timer) {
                clearTimeout(this.timer);
              }
            },
            [pointerLeave]() {
              if (this.timeout) {
                this.timer = setTimeout(this.close, this.timeout);
              }
            }
          },
          methods: {
            async close(immediate) {
              const removeFn = (el) => {
                const container = parent(el);
                trigger(el, "close", [this]);
                remove$1(el);
                if (!(container == null ? void 0 : container.hasChildNodes())) {
                  remove$1(container);
                }
              };
              if (this.timer) {
                clearTimeout(this.timer);
              }
              if (!immediate) {
                await Transition.start(this.$el, this.startProps);
              }
              removeFn(this.$el);
            }
          }
        };
        function install$2(UIkit) {
          UIkit.notification.closeAll = function(group, immediate) {
            apply(document.body, (el) => {
              const notification = UIkit.getComponent(el, "notification");
              if (notification && (!group || group === notification.group)) {
                notification.close(immediate);
              }
            });
          };
        }

        var Media = {
          props: {
            media: Boolean
          },
          data: {
            media: false
          },
          connected() {
            const media = toMedia(this.media, this.$el);
            this.matchMedia = true;
            if (media) {
              this.mediaObj = window.matchMedia(media);
              const handler = () => {
                this.matchMedia = this.mediaObj.matches;
                trigger(this.$el, createEvent("mediachange", false, true, [this.mediaObj]));
              };
              this.offMediaObj = on(this.mediaObj, "change", () => {
                handler();
                this.$emit("resize");
              });
              handler();
            }
          },
          disconnected() {
            var _a;
            (_a = this.offMediaObj) == null ? void 0 : _a.call(this);
          }
        };
        function toMedia(value, element) {
          if (isString(value)) {
            if (startsWith(value, "@")) {
              value = toFloat(css(element, `--uk-breakpoint-${value.substr(1)}`));
            } else if (isNaN(value)) {
              return value;
            }
          }
          return value && isNumeric(value) ? `(min-width: ${value}px)` : "";
        }

        function getMaxPathLength(el) {
          return Math.ceil(
            Math.max(
              0,
              ...$$("[stroke]", el).map((stroke) => {
                try {
                  return stroke.getTotalLength();
                } catch (e) {
                  return 0;
                }
              })
            )
          );
        }

        const props = {
          x: transformFn,
          y: transformFn,
          rotate: transformFn,
          scale: transformFn,
          color: colorFn,
          backgroundColor: colorFn,
          borderColor: colorFn,
          blur: filterFn,
          hue: filterFn,
          fopacity: filterFn,
          grayscale: filterFn,
          invert: filterFn,
          saturate: filterFn,
          sepia: filterFn,
          opacity: cssPropFn,
          stroke: strokeFn,
          bgx: backgroundFn,
          bgy: backgroundFn
        };
        const { keys } = Object;
        var Parallax = {
          mixins: [Media],
          props: fillObject(keys(props), "list"),
          data: fillObject(keys(props), void 0),
          computed: {
            props(properties, $el) {
              const stops = {};
              for (const prop in properties) {
                if (prop in props && !isUndefined(properties[prop])) {
                  stops[prop] = properties[prop].slice();
                }
              }
              const result = {};
              for (const prop in stops) {
                result[prop] = props[prop](prop, $el, stops[prop], stops);
              }
              return result;
            }
          },
          events: {
            load() {
              this.$emit();
            }
          },
          methods: {
            reset() {
              for (const prop in this.getCss(0)) {
                css(this.$el, prop, "");
              }
            },
            getCss(percent) {
              const css2 = {};
              for (const prop in this.props) {
                this.props[prop](css2, clamp(percent));
              }
              css2.willChange = Object.keys(css2).map(propName).join(",");
              return css2;
            }
          }
        };
        function transformFn(prop, el, stops) {
          let unit = getUnit(stops) || { x: "px", y: "px", rotate: "deg" }[prop] || "";
          let transformFn2;
          if (prop === "x" || prop === "y") {
            prop = `translate${ucfirst(prop)}`;
            transformFn2 = (stop) => toFloat(toFloat(stop).toFixed(unit === "px" ? 0 : 6));
          } else if (prop === "scale") {
            unit = "";
            transformFn2 = (stop) => {
              var _a;
              return getUnit([stop]) ? toPx(stop, "width", el, true) / el[`offset${((_a = stop.endsWith) == null ? void 0 : _a.call(stop, "vh")) ? "Height" : "Width"}`] : toFloat(stop);
            };
          }
          if (stops.length === 1) {
            stops.unshift(prop === "scale" ? 1 : 0);
          }
          stops = parseStops(stops, transformFn2);
          return (css2, percent) => {
            css2.transform = `${css2.transform || ""} ${prop}(${getValue(stops, percent)}${unit})`;
          };
        }
        function colorFn(prop, el, stops) {
          if (stops.length === 1) {
            stops.unshift(getCssValue(el, prop, ""));
          }
          stops = parseStops(stops, (stop) => parseColor(el, stop));
          return (css2, percent) => {
            const [start, end, p] = getStop(stops, percent);
            const value = start.map((value2, i) => {
              value2 += p * (end[i] - value2);
              return i === 3 ? toFloat(value2) : parseInt(value2, 10);
            }).join(",");
            css2[prop] = `rgba(${value})`;
          };
        }
        function parseColor(el, color) {
          return getCssValue(el, "color", color).split(/[(),]/g).slice(1, -1).concat(1).slice(0, 4).map(toFloat);
        }
        function filterFn(prop, el, stops) {
          if (stops.length === 1) {
            stops.unshift(0);
          }
          const unit = getUnit(stops) || { blur: "px", hue: "deg" }[prop] || "%";
          prop = { fopacity: "opacity", hue: "hue-rotate" }[prop] || prop;
          stops = parseStops(stops);
          return (css2, percent) => {
            const value = getValue(stops, percent);
            css2.filter = `${css2.filter || ""} ${prop}(${value + unit})`;
          };
        }
        function cssPropFn(prop, el, stops) {
          if (stops.length === 1) {
            stops.unshift(getCssValue(el, prop, ""));
          }
          stops = parseStops(stops);
          return (css2, percent) => {
            css2[prop] = getValue(stops, percent);
          };
        }
        function strokeFn(prop, el, stops) {
          if (stops.length === 1) {
            stops.unshift(0);
          }
          const unit = getUnit(stops);
          const length = getMaxPathLength(el);
          stops = parseStops(stops.reverse(), (stop) => {
            stop = toFloat(stop);
            return unit === "%" ? stop * length / 100 : stop;
          });
          if (!stops.some(([value]) => value)) {
            return noop;
          }
          css(el, "strokeDasharray", length);
          return (css2, percent) => {
            css2.strokeDashoffset = getValue(stops, percent);
          };
        }
        function backgroundFn(prop, el, stops, props2) {
          if (stops.length === 1) {
            stops.unshift(0);
          }
          const attr = prop === "bgy" ? "height" : "width";
          props2[prop] = parseStops(stops, (stop) => toPx(stop, attr, el));
          const bgProps = ["bgx", "bgy"].filter((prop2) => prop2 in props2);
          if (bgProps.length === 2 && prop === "bgx") {
            return noop;
          }
          if (getCssValue(el, "backgroundSize", "") === "cover") {
            return backgroundCoverFn(prop, el, stops, props2);
          }
          const positions = {};
          for (const prop2 of bgProps) {
            positions[prop2] = getBackgroundPos(el, prop2);
          }
          return setBackgroundPosFn(bgProps, positions, props2);
        }
        function backgroundCoverFn(prop, el, stops, props2) {
          const dimImage = getBackgroundImageDimensions(el);
          if (!dimImage.width) {
            return noop;
          }
          const dimEl = {
            width: el.offsetWidth,
            height: el.offsetHeight
          };
          const bgProps = ["bgx", "bgy"].filter((prop2) => prop2 in props2);
          const positions = {};
          for (const prop2 of bgProps) {
            const values = props2[prop2].map(([value]) => value);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const down = values.indexOf(min) < values.indexOf(max);
            const diff = max - min;
            positions[prop2] = `${(down ? -diff : 0) - (down ? min : max)}px`;
            dimEl[prop2 === "bgy" ? "height" : "width"] += diff;
          }
          const dim = Dimensions.cover(dimImage, dimEl);
          for (const prop2 of bgProps) {
            const attr = prop2 === "bgy" ? "height" : "width";
            const overflow = dim[attr] - dimEl[attr];
            positions[prop2] = `max(${getBackgroundPos(el, prop2)},-${overflow}px) + ${positions[prop2]}`;
          }
          const fn = setBackgroundPosFn(bgProps, positions, props2);
          return (css2, percent) => {
            fn(css2, percent);
            css2.backgroundSize = `${dim.width}px ${dim.height}px`;
            css2.backgroundRepeat = "no-repeat";
          };
        }
        function getBackgroundPos(el, prop) {
          return getCssValue(el, `background-position-${prop.substr(-1)}`, "");
        }
        function setBackgroundPosFn(bgProps, positions, props2) {
          return function(css2, percent) {
            for (const prop of bgProps) {
              const value = getValue(props2[prop], percent);
              css2[`background-position-${prop.substr(-1)}`] = `calc(${positions[prop]} + ${value}px)`;
            }
          };
        }
        const dimensions = {};
        function getBackgroundImageDimensions(el) {
          const src = css(el, "backgroundImage").replace(/^none|url\(["']?(.+?)["']?\)$/, "$1");
          if (dimensions[src]) {
            return dimensions[src];
          }
          const image = new Image();
          if (src) {
            image.src = src;
            if (!image.naturalWidth) {
              image.onload = () => {
                dimensions[src] = toDimensions(image);
                trigger(el, createEvent("load", false));
              };
              return toDimensions(image);
            }
          }
          return dimensions[src] = toDimensions(image);
        }
        function toDimensions(image) {
          return {
            width: image.naturalWidth,
            height: image.naturalHeight
          };
        }
        function parseStops(stops, fn = toFloat) {
          const result = [];
          const { length } = stops;
          let nullIndex = 0;
          for (let i = 0; i < length; i++) {
            let [value, percent] = isString(stops[i]) ? stops[i].trim().split(/ (?![^(]*\))/) : [stops[i]];
            value = fn(value);
            percent = percent ? toFloat(percent) / 100 : null;
            if (i === 0) {
              if (percent === null) {
                percent = 0;
              } else if (percent) {
                result.push([value, 0]);
              }
            } else if (i === length - 1) {
              if (percent === null) {
                percent = 1;
              } else if (percent !== 1) {
                result.push([value, percent]);
                percent = 1;
              }
            }
            result.push([value, percent]);
            if (percent === null) {
              nullIndex++;
            } else if (nullIndex) {
              const leftPercent = result[i - nullIndex - 1][1];
              const p = (percent - leftPercent) / (nullIndex + 1);
              for (let j = nullIndex; j > 0; j--) {
                result[i - j][1] = leftPercent + p * (nullIndex - j + 1);
              }
              nullIndex = 0;
            }
          }
          return result;
        }
        function getStop(stops, percent) {
          const index = findIndex(stops.slice(1), ([, targetPercent]) => percent <= targetPercent) + 1;
          return [
            stops[index - 1][0],
            stops[index][0],
            (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])
          ];
        }
        function getValue(stops, percent) {
          const [start, end, p] = getStop(stops, percent);
          return start + Math.abs(start - end) * p * (start < end ? 1 : -1);
        }
        const unitRe = /^-?\d+(?:\.\d+)?(\S+)?/;
        function getUnit(stops, defaultUnit) {
          var _a;
          for (const stop of stops) {
            const match = (_a = stop.match) == null ? void 0 : _a.call(stop, unitRe);
            if (match) {
              return match[1];
            }
          }
          return defaultUnit;
        }
        function getCssValue(el, prop, value) {
          const prev = el.style[prop];
          const val = css(css(el, prop, value), prop);
          el.style[prop] = prev;
          return val;
        }
        function fillObject(keys2, value) {
          return keys2.reduce((data, prop) => {
            data[prop] = value;
            return data;
          }, {});
        }

        var parallax = {
          mixins: [Parallax],
          props: {
            target: String,
            viewport: Number,
            // Deprecated
            easing: Number,
            start: String,
            end: String
          },
          data: {
            target: false,
            viewport: 1,
            easing: 1,
            start: 0,
            end: 0
          },
          computed: {
            target: ({ target }, $el) => getOffsetElement(target && query(target, $el) || $el),
            start({ start }) {
              return toPx(start, "height", this.target, true);
            },
            end({ end, viewport: viewport2 }) {
              return toPx(
                end || (viewport2 = (1 - viewport2) * 100) && `${viewport2}vh+${viewport2}%`,
                "height",
                this.target,
                true
              );
            }
          },
          observe: [
            viewport(),
            scroll$1({ target: ({ target }) => target }),
            resize({ target: ({ $el, target }) => [$el, target, scrollParent(target, true)] })
          ],
          update: {
            read({ percent }, types) {
              if (!types.has("scroll")) {
                percent = false;
              }
              if (!isVisible(this.$el)) {
                return false;
              }
              if (!this.matchMedia) {
                return;
              }
              const prev = percent;
              percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);
              return {
                percent,
                style: prev === percent ? false : this.getCss(percent)
              };
            },
            write({ style }) {
              if (!this.matchMedia) {
                this.reset();
                return;
              }
              style && css(this.$el, style);
            },
            events: ["scroll", "resize"]
          }
        };
        function ease(percent, easing) {
          return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, 1 - easing);
        }
        function getOffsetElement(el) {
          return el ? "offsetTop" in el ? el : getOffsetElement(parent(el)) : document.documentElement;
        }

        var SliderReactive = {
          update: {
            write() {
              if (this.stack.length || this.dragging) {
                return;
              }
              const index = this.getValidIndex();
              if (!~this.prevIndex || this.index !== index) {
                this.show(index);
              } else {
                this._translate(1, this.prevIndex, this.index);
              }
            },
            events: ["resize"]
          }
        };

        var SliderPreload = {
          observe: lazyload({
            target: ({ slides }) => slides,
            targets: (instance) => instance.getAdjacentSlides()
          })
        };

        function Transitioner(prev, next, dir, { center, easing, list }) {
          const from = prev ? getLeft(prev, list, center) : getLeft(next, list, center) + dimensions$1(next).width * dir;
          const to = next ? getLeft(next, list, center) : from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);
          let resolve;
          return {
            dir,
            show(duration, percent = 0, linear) {
              const timing = linear ? "linear" : easing;
              duration -= Math.round(duration * clamp(percent, -1, 1));
              this.translate(percent);
              percent = prev ? percent : clamp(percent, 0, 1);
              triggerUpdate(this.getItemIn(), "itemin", { percent, duration, timing, dir });
              prev && triggerUpdate(this.getItemIn(true), "itemout", {
                percent: 1 - percent,
                duration,
                timing,
                dir
              });
              return new Promise((res) => {
                resolve || (resolve = res);
                Transition.start(
                  list,
                  { transform: translate(-to * (isRtl ? -1 : 1), "px") },
                  duration,
                  timing
                ).then(resolve, noop);
              });
            },
            cancel() {
              return Transition.cancel(list);
            },
            reset() {
              css(list, "transform", "");
            },
            async forward(duration, percent = this.percent()) {
              await this.cancel();
              return this.show(duration, percent, true);
            },
            translate(percent) {
              const distance = this.getDistance() * dir * (isRtl ? -1 : 1);
              css(
                list,
                "transform",
                translate(
                  clamp(
                    -to + (distance - distance * percent),
                    -getWidth(list),
                    dimensions$1(list).width
                  ) * (isRtl ? -1 : 1),
                  "px"
                )
              );
              const actives = this.getActives();
              const itemIn = this.getItemIn();
              const itemOut = this.getItemIn(true);
              percent = prev ? clamp(percent, -1, 1) : 0;
              for (const slide of children(list)) {
                const isActive = includes(actives, slide);
                const isIn = slide === itemIn;
                const isOut = slide === itemOut;
                const translateIn = isIn || !isOut && (isActive || dir * (isRtl ? -1 : 1) === -1 ^ getElLeft(slide, list) > getElLeft(prev || next));
                triggerUpdate(slide, `itemtranslate${translateIn ? "in" : "out"}`, {
                  dir,
                  percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0
                });
              }
            },
            percent() {
              return Math.abs(
                (css(list, "transform").split(",")[4] * (isRtl ? -1 : 1) + from) / (to - from)
              );
            },
            getDistance() {
              return Math.abs(to - from);
            },
            getItemIn(out = false) {
              let actives = this.getActives();
              let nextActives = inView(list, getLeft(next || prev, list, center));
              if (out) {
                const temp = actives;
                actives = nextActives;
                nextActives = temp;
              }
              return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];
            },
            getActives() {
              return inView(list, getLeft(prev || next, list, center));
            }
          };
        }
        function getLeft(el, list, center) {
          const left = getElLeft(el, list);
          return center ? left - centerEl(el, list) : Math.min(left, getMax(list));
        }
        function getMax(list) {
          return Math.max(0, getWidth(list) - dimensions$1(list).width);
        }
        function getWidth(list) {
          return sumBy(children(list), (el) => dimensions$1(el).width);
        }
        function centerEl(el, list) {
          return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;
        }
        function getElLeft(el, list) {
          return el && (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (isRtl ? -1 : 1) || 0;
        }
        function inView(list, listLeft) {
          listLeft -= 1;
          const listWidth = dimensions$1(list).width;
          const listRight = listLeft + listWidth + 2;
          return children(list).filter((slide) => {
            const slideLeft = getElLeft(slide, list);
            const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);
            return slideLeft >= listLeft && slideRight <= listRight;
          });
        }
        function triggerUpdate(el, type, data) {
          trigger(el, createEvent(type, false, false, data));
        }

        var slider = {
          mixins: [Class, Slider, SliderReactive, SliderPreload],
          props: {
            center: Boolean,
            sets: Boolean
          },
          data: {
            center: false,
            sets: false,
            attrItem: "uk-slider-item",
            selList: ".uk-slider-items",
            selNav: ".uk-slider-nav",
            clsContainer: "uk-slider-container",
            Transitioner
          },
          computed: {
            avgWidth() {
              return getWidth(this.list) / this.length;
            },
            finite({ finite }) {
              return finite || isFinite(this.list, this.center);
            },
            maxIndex() {
              if (!this.finite || this.center && !this.sets) {
                return this.length - 1;
              }
              if (this.center) {
                return last(this.sets);
              }
              let lft = 0;
              const max = getMax(this.list);
              const index = findIndex(this.slides, (el) => {
                if (lft >= max) {
                  return true;
                }
                lft += dimensions$1(el).width;
              });
              return ~index ? index : this.length - 1;
            },
            sets({ sets: enabled }) {
              if (!enabled) {
                return;
              }
              let left = 0;
              const sets = [];
              const width = dimensions$1(this.list).width;
              for (let i = 0; i < this.length; i++) {
                const slideWidth = dimensions$1(this.slides[i]).width;
                if (left + slideWidth > width) {
                  left = 0;
                }
                if (this.center) {
                  if (left < width / 2 && left + slideWidth + dimensions$1(getIndex(+i + 1, this.slides)).width / 2 > width / 2) {
                    sets.push(+i);
                    left = width / 2 - slideWidth / 2;
                  }
                } else if (left === 0) {
                  sets.push(Math.min(+i, this.maxIndex));
                }
                left += slideWidth;
              }
              if (sets.length) {
                return sets;
              }
            },
            transitionOptions() {
              return {
                center: this.center,
                list: this.list
              };
            },
            slides() {
              return children(this.list).filter(isVisible);
            }
          },
          connected() {
            toggleClass(this.$el, this.clsContainer, !$(`.${this.clsContainer}`, this.$el));
          },
          observe: resize({
            target: ({ slides }) => slides
          }),
          update: {
            write() {
              for (const el of this.navItems) {
                const index = toNumber(data(el, this.attrItem));
                if (index !== false) {
                  el.hidden = !this.maxIndex || index > this.maxIndex || this.sets && !includes(this.sets, index);
                }
              }
              if (this.length && !this.dragging && !this.stack.length) {
                this.reorder();
                this._translate(1);
              }
              this.updateActiveClasses();
            },
            events: ["resize"]
          },
          events: {
            beforeitemshow(e) {
              if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) {
                this.index = this.getValidIndex();
              }
              const diff = Math.abs(
                this.index - this.prevIndex + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)
              );
              if (!this.dragging && diff > 1) {
                for (let i = 0; i < diff; i++) {
                  this.stack.splice(1, 0, this.dir > 0 ? "next" : "previous");
                }
                e.preventDefault();
                return;
              }
              const index = this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;
              this.duration = speedUp(this.avgWidth / this.velocity) * (dimensions$1(this.slides[index]).width / this.avgWidth);
              this.reorder();
            },
            itemshow() {
              if (~this.prevIndex) {
                addClass(this._getTransitioner().getItemIn(), this.clsActive);
              }
            },
            itemshown() {
              this.updateActiveClasses();
            }
          },
          methods: {
            reorder() {
              if (this.finite) {
                css(this.slides, "order", "");
                return;
              }
              const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;
              this.slides.forEach(
                (slide, i) => css(
                  slide,
                  "order",
                  this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ""
                )
              );
              if (!this.center) {
                return;
              }
              const next = this.slides[index];
              let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;
              let j = 0;
              while (width > 0) {
                const slideIndex = this.getIndex(--j + index, index);
                const slide = this.slides[slideIndex];
                css(slide, "order", slideIndex > index ? -2 : -1);
                width -= dimensions$1(slide).width;
              }
            },
            updateActiveClasses() {
              const actives = this._getTransitioner(this.index).getActives();
              const activeClasses = [
                this.clsActive,
                (!this.sets || includes(this.sets, toFloat(this.index))) && this.clsActivated || ""
              ];
              for (const slide of this.slides) {
                const active = includes(actives, slide);
                toggleClass(slide, activeClasses, active);
                attr(slide, "aria-hidden", !active);
                for (const focusable of $$(selFocusable, slide)) {
                  if (!hasOwn(focusable, "_tabindex")) {
                    focusable._tabindex = attr(focusable, "tabindex");
                  }
                  attr(focusable, "tabindex", active ? focusable._tabindex : -1);
                }
              }
            },
            getValidIndex(index = this.index, prevIndex = this.prevIndex) {
              index = this.getIndex(index, prevIndex);
              if (!this.sets) {
                return index;
              }
              let prev;
              do {
                if (includes(this.sets, index)) {
                  return index;
                }
                prev = index;
                index = this.getIndex(index + this.dir, prevIndex);
              } while (index !== prev);
              return index;
            },
            getAdjacentSlides() {
              const { width } = dimensions$1(this.list);
              const left = -width;
              const right = width * 2;
              const slideWidth = dimensions$1(this.slides[this.index]).width;
              const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;
              const slides = /* @__PURE__ */ new Set();
              for (const i of [-1, 1]) {
                let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);
                let j = 0;
                do {
                  const slide = this.slides[this.getIndex(this.index + i + j++ * i)];
                  currentLeft += dimensions$1(slide).width * i;
                  slides.add(slide);
                } while (this.length > j && currentLeft > left && currentLeft < right);
              }
              return Array.from(slides);
            }
          }
        };
        function isFinite(list, center) {
          if (!list || list.length < 2) {
            return true;
          }
          const { width: listWidth } = dimensions$1(list);
          if (!center) {
            return Math.ceil(getWidth(list)) < Math.trunc(listWidth + getMaxElWidth(list));
          }
          const slides = children(list);
          const listHalf = Math.trunc(listWidth / 2);
          for (const index in slides) {
            const slide = slides[index];
            const slideWidth = dimensions$1(slide).width;
            const slidesInView = /* @__PURE__ */ new Set([slide]);
            let diff = 0;
            for (const i of [-1, 1]) {
              let left = slideWidth / 2;
              let j = 0;
              while (left < listHalf) {
                const nextSlide = slides[getIndex(+index + i + j++ * i, slides)];
                if (slidesInView.has(nextSlide)) {
                  return true;
                }
                left += dimensions$1(nextSlide).width;
                slidesInView.add(nextSlide);
              }
              diff = Math.max(
                diff,
                slideWidth / 2 + dimensions$1(slides[getIndex(+index + i, slides)]).width / 2 - (left - listHalf)
              );
            }
            if (diff > sumBy(
              slides.filter((slide2) => !slidesInView.has(slide2)),
              (slide2) => dimensions$1(slide2).width
            )) {
              return true;
            }
          }
          return false;
        }
        function getMaxElWidth(list) {
          return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));
        }

        var sliderParallax = {
          mixins: [Parallax],
          data: {
            selItem: "!li"
          },
          beforeConnect() {
            this.item = query(this.selItem, this.$el);
          },
          disconnected() {
            this.item = null;
          },
          events: [
            {
              name: "itemin itemout",
              self: true,
              el() {
                return this.item;
              },
              handler({ type, detail: { percent, duration, timing, dir } }) {
                fastdom.read(() => {
                  if (!this.matchMedia) {
                    return;
                  }
                  const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));
                  const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);
                  fastdom.write(() => {
                    css(this.$el, propsFrom);
                    Transition.start(this.$el, propsTo, duration, timing).catch(noop);
                  });
                });
              }
            },
            {
              name: "transitioncanceled transitionend",
              self: true,
              el() {
                return this.item;
              },
              handler() {
                Transition.cancel(this.$el);
              }
            },
            {
              name: "itemtranslatein itemtranslateout",
              self: true,
              el() {
                return this.item;
              },
              handler({ type, detail: { percent, dir } }) {
                fastdom.read(() => {
                  if (!this.matchMedia) {
                    this.reset();
                    return;
                  }
                  const props = this.getCss(getCurrentPercent(type, dir, percent));
                  fastdom.write(() => css(this.$el, props));
                });
              }
            }
          ]
        };
        function isIn(type) {
          return endsWith(type, "in");
        }
        function getCurrentPercent(type, dir, percent) {
          percent /= 2;
          return isIn(type) ^ dir < 0 ? percent : 1 - percent;
        }

        var Animations = {
          ...Animations$2,
          fade: {
            show() {
              return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];
            },
            percent(current) {
              return 1 - css(current, "opacity");
            },
            translate(percent) {
              return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];
            }
          },
          scale: {
            show() {
              return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];
            },
            percent(current) {
              return 1 - css(current, "opacity");
            },
            translate(percent) {
              return [
                { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },
                { zIndex: -1 }
              ];
            }
          },
          pull: {
            show(dir) {
              return dir < 0 ? [
                { transform: translate(30), zIndex: -1 },
                { transform: translate(), zIndex: 0 }
              ] : [
                { transform: translate(-100), zIndex: 0 },
                { transform: translate(), zIndex: -1 }
              ];
            },
            percent(current, next, dir) {
              return dir < 0 ? 1 - translated(next) : translated(current);
            },
            translate(percent, dir) {
              return dir < 0 ? [
                { transform: translate(30 * percent), zIndex: -1 },
                { transform: translate(-100 * (1 - percent)), zIndex: 0 }
              ] : [
                { transform: translate(-percent * 100), zIndex: 0 },
                { transform: translate(30 * (1 - percent)), zIndex: -1 }
              ];
            }
          },
          push: {
            show(dir) {
              return dir < 0 ? [
                { transform: translate(100), zIndex: 0 },
                { transform: translate(), zIndex: -1 }
              ] : [
                { transform: translate(-30), zIndex: -1 },
                { transform: translate(), zIndex: 0 }
              ];
            },
            percent(current, next, dir) {
              return dir > 0 ? 1 - translated(next) : translated(current);
            },
            translate(percent, dir) {
              return dir < 0 ? [
                { transform: translate(percent * 100), zIndex: 0 },
                { transform: translate(-30 * (1 - percent)), zIndex: -1 }
              ] : [
                { transform: translate(-30 * percent), zIndex: -1 },
                { transform: translate(100 * (1 - percent)), zIndex: 0 }
              ];
            }
          }
        };

        const supportsAspectRatio = inBrowser && CSS.supports("aspect-ratio", "1/1");
        var slideshow = {
          mixins: [Class, Slideshow, SliderReactive, SliderPreload],
          props: {
            ratio: String,
            minHeight: Number,
            maxHeight: Number
          },
          data: {
            ratio: "16:9",
            minHeight: false,
            maxHeight: false,
            selList: ".uk-slideshow-items",
            attrItem: "uk-slideshow-item",
            selNav: ".uk-slideshow-nav",
            Animations
          },
          watch: {
            list(list) {
              if (list && supportsAspectRatio) {
                css(list, {
                  aspectRatio: this.ratio.replace(":", "/"),
                  minHeight: this.minHeight || "",
                  maxHeight: this.maxHeight || "",
                  minWidth: "100%",
                  maxWidth: "100%"
                });
              }
            }
          },
          update: {
            // deprecated: Remove with iOS 17
            read() {
              if (!this.list || supportsAspectRatio) {
                return false;
              }
              let [width, height] = this.ratio.split(":").map(Number);
              height = height * this.list.offsetWidth / width || 0;
              if (this.minHeight) {
                height = Math.max(this.minHeight, height);
              }
              if (this.maxHeight) {
                height = Math.min(this.maxHeight, height);
              }
              return { height: height - boxModelAdjust(this.list, "height", "content-box") };
            },
            write({ height }) {
              height > 0 && css(this.list, "minHeight", height);
            },
            events: ["resize"]
          },
          methods: {
            getAdjacentSlides() {
              return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);
            }
          }
        };

        var sortable = {
          mixins: [Class, Animate],
          props: {
            group: String,
            threshold: Number,
            clsItem: String,
            clsPlaceholder: String,
            clsDrag: String,
            clsDragState: String,
            clsBase: String,
            clsNoDrag: String,
            clsEmpty: String,
            clsCustom: String,
            handle: String
          },
          data: {
            group: false,
            threshold: 5,
            clsItem: "uk-sortable-item",
            clsPlaceholder: "uk-sortable-placeholder",
            clsDrag: "uk-sortable-drag",
            clsDragState: "uk-drag",
            clsBase: "uk-sortable",
            clsNoDrag: "uk-sortable-nodrag",
            clsEmpty: "uk-sortable-empty",
            clsCustom: "",
            handle: false,
            pos: {}
          },
          created() {
            for (const key of ["init", "start", "move", "end"]) {
              const fn = this[key];
              this[key] = (e) => {
                assign(this.pos, getEventPos(e));
                fn(e);
              };
            }
          },
          events: {
            name: pointerDown$1,
            passive: false,
            handler: "init"
          },
          computed: {
            target: (_, $el) => ($el.tBodies || [$el])[0],
            items() {
              return children(this.target);
            },
            isEmpty() {
              return isEmpty(this.items);
            },
            handles({ handle }, $el) {
              return handle ? $$(handle, $el) : this.items;
            }
          },
          watch: {
            isEmpty(empty) {
              toggleClass(this.target, this.clsEmpty, empty);
            },
            handles(handles, prev) {
              css(prev, { touchAction: "", userSelect: "" });
              css(handles, { touchAction: hasTouch ? "none" : "", userSelect: "none" });
            }
          },
          update: {
            write(data) {
              if (!this.drag || !parent(this.placeholder)) {
                return;
              }
              const {
                pos: { x, y },
                origin: { offsetTop, offsetLeft },
                placeholder
              } = this;
              css(this.drag, {
                top: y - offsetTop,
                left: x - offsetLeft
              });
              const sortable = this.getSortable(document.elementFromPoint(x, y));
              if (!sortable) {
                return;
              }
              const { items } = sortable;
              if (items.some(Transition.inProgress)) {
                return;
              }
              const target = findTarget(items, { x, y });
              if (items.length && (!target || target === placeholder)) {
                return;
              }
              const previous = this.getSortable(placeholder);
              const insertTarget = findInsertTarget(
                sortable.target,
                target,
                placeholder,
                x,
                y,
                sortable === previous && data.moved !== target
              );
              if (insertTarget === false) {
                return;
              }
              if (insertTarget && placeholder === insertTarget) {
                return;
              }
              if (sortable !== previous) {
                previous.remove(placeholder);
                data.moved = target;
              } else {
                delete data.moved;
              }
              sortable.insert(placeholder, insertTarget);
              this.touched.add(sortable);
            },
            events: ["move"]
          },
          methods: {
            init(e) {
              const { target, button, defaultPrevented } = e;
              const [placeholder] = this.items.filter((el) => el.contains(target));
              if (!placeholder || defaultPrevented || button > 0 || isInput(target) || target.closest(`.${this.clsNoDrag}`) || this.handle && !target.closest(this.handle)) {
                return;
              }
              e.preventDefault();
              this.touched = /* @__PURE__ */ new Set([this]);
              this.placeholder = placeholder;
              this.origin = { target, index: index(placeholder), ...this.pos };
              on(document, pointerMove$1, this.move);
              on(document, pointerUp$1, this.end);
              if (!this.threshold) {
                this.start(e);
              }
            },
            start(e) {
              this.drag = appendDrag(this.$container, this.placeholder);
              const { left, top } = this.placeholder.getBoundingClientRect();
              assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });
              addClass(this.drag, this.clsDrag, this.clsCustom);
              addClass(this.placeholder, this.clsPlaceholder);
              addClass(this.items, this.clsItem);
              addClass(document.documentElement, this.clsDragState);
              trigger(this.$el, "start", [this, this.placeholder]);
              trackScroll(this.pos);
              this.move(e);
            },
            move(e) {
              if (this.drag) {
                this.$emit("move");
              } else if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {
                this.start(e);
              }
            },
            end() {
              off(document, pointerMove$1, this.move);
              off(document, pointerUp$1, this.end);
              if (!this.drag) {
                return;
              }
              untrackScroll();
              const sortable = this.getSortable(this.placeholder);
              if (this === sortable) {
                if (this.origin.index !== index(this.placeholder)) {
                  trigger(this.$el, "moved", [this, this.placeholder]);
                }
              } else {
                trigger(sortable.$el, "added", [sortable, this.placeholder]);
                trigger(this.$el, "removed", [this, this.placeholder]);
              }
              trigger(this.$el, "stop", [this, this.placeholder]);
              remove$1(this.drag);
              this.drag = null;
              for (const { clsPlaceholder, clsItem } of this.touched) {
                for (const sortable2 of this.touched) {
                  removeClass(sortable2.items, clsPlaceholder, clsItem);
                }
              }
              this.touched = null;
              removeClass(document.documentElement, this.clsDragState);
            },
            insert(element, target) {
              addClass(this.items, this.clsItem);
              const insert = () => target ? before(target, element) : append(this.target, element);
              this.animate(insert);
            },
            remove(element) {
              if (!this.target.contains(element)) {
                return;
              }
              this.animate(() => remove$1(element));
            },
            getSortable(element) {
              do {
                const sortable = this.$getComponent(element, "sortable");
                if (sortable && (sortable === this || this.group !== false && sortable.group === this.group)) {
                  return sortable;
                }
              } while (element = parent(element));
            }
          }
        };
        let trackTimer;
        function trackScroll(pos) {
          let last = Date.now();
          trackTimer = setInterval(() => {
            let { x, y } = pos;
            y += document.scrollingElement.scrollTop;
            const dist = (Date.now() - last) * 0.3;
            last = Date.now();
            scrollParents(document.elementFromPoint(x, pos.y)).reverse().some((scrollEl) => {
              let { scrollTop: scroll, scrollHeight } = scrollEl;
              const { top, bottom, height: height2 } = offsetViewport(scrollEl);
              if (top < y && top + 35 > y) {
                scroll -= dist;
              } else if (bottom > y && bottom - 35 < y) {
                scroll += dist;
              } else {
                return;
              }
              if (scroll > 0 && scroll < scrollHeight - height2) {
                scrollEl.scrollTop = scroll;
                return true;
              }
            });
          }, 15);
        }
        function untrackScroll() {
          clearInterval(trackTimer);
        }
        function appendDrag(container, element) {
          let clone;
          if (isTag(element, "li", "tr")) {
            clone = $("<div>");
            append(clone, element.cloneNode(true).children);
            for (const attribute of element.getAttributeNames()) {
              attr(clone, attribute, element.getAttribute(attribute));
            }
          } else {
            clone = element.cloneNode(true);
          }
          append(container, clone);
          css(clone, "margin", "0", "important");
          css(clone, {
            boxSizing: "border-box",
            width: element.offsetWidth,
            height: element.offsetHeight,
            padding: css(element, "padding")
          });
          height(clone.firstElementChild, height(element.firstElementChild));
          return clone;
        }
        function findTarget(items, point) {
          return items[findIndex(items, (item) => pointInRect(point, item.getBoundingClientRect()))];
        }
        function findInsertTarget(list, target, placeholder, x, y, sameList) {
          if (!children(list).length) {
            return;
          }
          const rect = target.getBoundingClientRect();
          if (!sameList) {
            if (!isHorizontal(list, placeholder)) {
              return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;
            }
            return target;
          }
          const placeholderRect = placeholder.getBoundingClientRect();
          const sameRow = linesIntersect(
            [rect.top, rect.bottom],
            [placeholderRect.top, placeholderRect.bottom]
          );
          const [pointerPos, lengthProp, startProp, endProp] = sameRow ? [x, "width", "left", "right"] : [y, "height", "top", "bottom"];
          const diff = placeholderRect[lengthProp] < rect[lengthProp] ? rect[lengthProp] - placeholderRect[lengthProp] : 0;
          if (placeholderRect[startProp] < rect[startProp]) {
            if (diff && pointerPos < rect[startProp] + diff) {
              return false;
            }
            return target.nextElementSibling;
          }
          if (diff && pointerPos > rect[endProp] - diff) {
            return false;
          }
          return target;
        }
        function isHorizontal(list, placeholder) {
          const single = children(list).length === 1;
          if (single) {
            append(list, placeholder);
          }
          const items = children(list);
          const isHorizontal2 = items.some((el, i) => {
            const rectA = el.getBoundingClientRect();
            return items.slice(i + 1).some((el2) => {
              const rectB = el2.getBoundingClientRect();
              return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);
            });
          });
          if (single) {
            remove$1(placeholder);
          }
          return isHorizontal2;
        }
        function linesIntersect(lineA, lineB) {
          return lineA[1] > lineB[0] && lineB[1] > lineA[0];
        }

        var Position = {
          props: {
            pos: String,
            offset: null,
            flip: Boolean,
            shift: Boolean,
            inset: Boolean
          },
          data: {
            pos: `bottom-${isRtl ? "right" : "left"}`,
            offset: false,
            flip: true,
            shift: true,
            inset: false
          },
          connected() {
            this.pos = this.$props.pos.split("-").concat("center").slice(0, 2);
            [this.dir, this.align] = this.pos;
            this.axis = includes(["top", "bottom"], this.dir) ? "y" : "x";
          },
          methods: {
            positionAt(element, target, boundary) {
              let offset = [this.getPositionOffset(element), this.getShiftOffset(element)];
              const placement = [this.flip && "flip", this.shift && "shift"];
              const attach = {
                element: [this.inset ? this.dir : flipPosition(this.dir), this.align],
                target: [this.dir, this.align]
              };
              if (this.axis === "y") {
                for (const prop in attach) {
                  attach[prop].reverse();
                }
                offset.reverse();
                placement.reverse();
              }
              const restoreScrollPosition = storeScrollPosition(element);
              const elDim = dimensions$1(element);
              css(element, { top: -elDim.height, left: -elDim.width });
              positionAt(element, target, {
                attach,
                offset,
                boundary,
                placement,
                viewportOffset: this.getViewportOffset(element)
              });
              restoreScrollPosition();
            },
            getPositionOffset(element) {
              return toPx(
                this.offset === false ? css(element, "--uk-position-offset") : this.offset,
                this.axis === "x" ? "width" : "height",
                element
              ) * (includes(["left", "top"], this.dir) ? -1 : 1) * (this.inset ? -1 : 1);
            },
            getShiftOffset(element) {
              return this.align === "center" ? 0 : toPx(
                css(element, "--uk-position-shift-offset"),
                this.axis === "y" ? "width" : "height",
                element
              ) * (includes(["left", "top"], this.align) ? 1 : -1);
            },
            getViewportOffset(element) {
              return toPx(css(element, "--uk-position-viewport-offset"));
            }
          }
        };
        function storeScrollPosition(element) {
          const scrollElement = scrollParent(element);
          const { scrollTop } = scrollElement;
          return () => {
            if (scrollTop !== scrollElement.scrollTop) {
              scrollElement.scrollTop = scrollTop;
            }
          };
        }

        var tooltip = {
          mixins: [Container, Togglable, Position],
          data: {
            pos: "top",
            animation: ["uk-animation-scale-up"],
            duration: 100,
            cls: "uk-active"
          },
          connected() {
            makeFocusable(this.$el);
          },
          disconnected() {
            this.hide();
          },
          methods: {
            show() {
              if (this.isToggled(this.tooltip || null)) {
                return;
              }
              const { delay = 0, title } = parseProps(this.$options);
              if (!title) {
                return;
              }
              const titleAttr = attr(this.$el, "title");
              const off = on(this.$el, ["blur", pointerLeave], (e) => !isTouch(e) && this.hide());
              this.reset = () => {
                attr(this.$el, { title: titleAttr, "aria-describedby": null });
                off();
              };
              const id = generateId(this);
              attr(this.$el, { title: null, "aria-describedby": id });
              clearTimeout(this.showTimer);
              this.showTimer = setTimeout(() => this._show(title, id), delay);
            },
            async hide() {
              var _a;
              if (matches(this.$el, "input:focus")) {
                return;
              }
              clearTimeout(this.showTimer);
              if (this.isToggled(this.tooltip || null)) {
                await this.toggleElement(this.tooltip, false, false);
              }
              (_a = this.reset) == null ? void 0 : _a.call(this);
              remove$1(this.tooltip);
              this.tooltip = null;
            },
            async _show(title, id) {
              this.tooltip = append(
                this.container,
                `<div id="${id}" class="uk-${this.$options.name}" role="tooltip"> <div class="uk-${this.$options.name}-inner">${title}</div> </div>`
              );
              on(this.tooltip, "toggled", (e, toggled) => {
                if (!toggled) {
                  return;
                }
                const update = () => this.positionAt(this.tooltip, this.$el);
                update();
                const [dir, align] = getAlignment(this.tooltip, this.$el, this.pos);
                this.origin = this.axis === "y" ? `${flipPosition(dir)}-${align}` : `${align}-${flipPosition(dir)}`;
                const handlers = [
                  once(
                    document,
                    `keydown ${pointerDown$1}`,
                    this.hide,
                    false,
                    (e2) => e2.type === pointerDown$1 && !this.$el.contains(e2.target) || e2.type === "keydown" && e2.keyCode === keyMap.ESC
                  ),
                  on([document, ...overflowParents(this.$el)], "scroll", update, {
                    passive: true
                  })
                ];
                once(this.tooltip, "hide", () => handlers.forEach((handler) => handler()), {
                  self: true
                });
              });
              if (!await this.toggleElement(this.tooltip, true)) {
                this.hide();
              }
            }
          },
          events: {
            // Clicking a button does not give it focus on all browsers and platforms
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
            [`focus ${pointerEnter} ${pointerDown$1}`](e) {
              if (!isTouch(e)) {
                this.show();
              }
            }
          }
        };
        function makeFocusable(el) {
          if (!isFocusable(el)) {
            attr(el, "tabindex", "0");
          }
        }
        function getAlignment(el, target, [dir, align]) {
          const elOffset = offset(el);
          const targetOffset = offset(target);
          const properties = [
            ["left", "right"],
            ["top", "bottom"]
          ];
          for (const props2 of properties) {
            if (elOffset[props2[0]] >= targetOffset[props2[1]]) {
              dir = props2[1];
              break;
            }
            if (elOffset[props2[1]] <= targetOffset[props2[0]]) {
              dir = props2[0];
              break;
            }
          }
          const props = includes(properties[0], dir) ? properties[1] : properties[0];
          if (elOffset[props[0]] === targetOffset[props[0]]) {
            align = props[0];
          } else if (elOffset[props[1]] === targetOffset[props[1]]) {
            align = props[1];
          } else {
            align = "center";
          }
          return [dir, align];
        }
        function parseProps(options) {
          const { el, id, data: data$1 } = options;
          return ["delay", "title"].reduce((obj, key) => ({ [key]: data(el, key), ...obj }), {
            ...parseOptions(data(el, id), ["title"]),
            ...data$1
          });
        }

        var upload = {
          mixins: [I18n],
          i18n: {
            invalidMime: "Invalid File Type: %s",
            invalidName: "Invalid File Name: %s",
            invalidSize: "Invalid File Size: %s Kilobytes Max"
          },
          props: {
            allow: String,
            clsDragover: String,
            concurrent: Number,
            maxSize: Number,
            method: String,
            mime: String,
            multiple: Boolean,
            name: String,
            params: Object,
            type: String,
            url: String
          },
          data: {
            allow: false,
            clsDragover: "uk-dragover",
            concurrent: 1,
            maxSize: 0,
            method: "POST",
            mime: false,
            multiple: false,
            name: "files[]",
            params: {},
            type: "",
            url: "",
            abort: noop,
            beforeAll: noop,
            beforeSend: noop,
            complete: noop,
            completeAll: noop,
            error: noop,
            fail: noop,
            load: noop,
            loadEnd: noop,
            loadStart: noop,
            progress: noop
          },
          events: {
            change(e) {
              if (!matches(e.target, 'input[type="file"]')) {
                return;
              }
              e.preventDefault();
              if (e.target.files) {
                this.upload(e.target.files);
              }
              e.target.value = "";
            },
            drop(e) {
              stop(e);
              const transfer = e.dataTransfer;
              if (!(transfer == null ? void 0 : transfer.files)) {
                return;
              }
              removeClass(this.$el, this.clsDragover);
              this.upload(transfer.files);
            },
            dragenter(e) {
              stop(e);
            },
            dragover(e) {
              stop(e);
              addClass(this.$el, this.clsDragover);
            },
            dragleave(e) {
              stop(e);
              removeClass(this.$el, this.clsDragover);
            }
          },
          methods: {
            async upload(files) {
              files = toArray(files);
              if (!files.length) {
                return;
              }
              trigger(this.$el, "upload", [files]);
              for (const file of files) {
                if (this.maxSize && this.maxSize * 1e3 < file.size) {
                  this.fail(this.t("invalidSize", this.maxSize));
                  return;
                }
                if (this.allow && !match$1(this.allow, file.name)) {
                  this.fail(this.t("invalidName", this.allow));
                  return;
                }
                if (this.mime && !match$1(this.mime, file.type)) {
                  this.fail(this.t("invalidMime", this.mime));
                  return;
                }
              }
              if (!this.multiple) {
                files = files.slice(0, 1);
              }
              this.beforeAll(this, files);
              const chunks = chunk(files, this.concurrent);
              const upload = async (files2) => {
                const data = new FormData();
                files2.forEach((file) => data.append(this.name, file));
                for (const key in this.params) {
                  data.append(key, this.params[key]);
                }
                try {
                  const xhr = await ajax(this.url, {
                    data,
                    method: this.method,
                    responseType: this.type,
                    beforeSend: (env) => {
                      const { xhr: xhr2 } = env;
                      on(xhr2.upload, "progress", this.progress);
                      for (const type of ["loadStart", "load", "loadEnd", "abort"]) {
                        on(xhr2, type.toLowerCase(), this[type]);
                      }
                      return this.beforeSend(env);
                    }
                  });
                  this.complete(xhr);
                  if (chunks.length) {
                    await upload(chunks.shift());
                  } else {
                    this.completeAll(xhr);
                  }
                } catch (e) {
                  this.error(e);
                }
              };
              await upload(chunks.shift());
            }
          }
        };
        function match$1(pattern, path) {
          return path.match(
            new RegExp(
              `^${pattern.replace(/\//g, "\\/").replace(/\*\*/g, "(\\/[^\\/]+)*").replace(/\*/g, "[^\\/]+").replace(/((?!\\))\?/g, "$1.")}$`,
              "i"
            )
          );
        }
        function chunk(files, size) {
          const chunks = [];
          for (let i = 0; i < files.length; i += size) {
            chunks.push(files.slice(i, i + size));
          }
          return chunks;
        }
        function stop(e) {
          e.preventDefault();
          e.stopPropagation();
        }
        function ajax(url, options) {
          const env = {
            data: null,
            method: "GET",
            headers: {},
            xhr: new XMLHttpRequest(),
            beforeSend: noop,
            responseType: "",
            ...options
          };
          return Promise.resolve().then(() => env.beforeSend(env)).then(() => send(url, env));
        }
        function send(url, env) {
          return new Promise((resolve, reject) => {
            const { xhr } = env;
            for (const prop in env) {
              if (prop in xhr) {
                try {
                  xhr[prop] = env[prop];
                } catch (e) {
                }
              }
            }
            xhr.open(env.method.toUpperCase(), url);
            for (const header in env.headers) {
              xhr.setRequestHeader(header, env.headers[header]);
            }
            on(xhr, "load", () => {
              if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                resolve(xhr);
              } else {
                reject(
                  assign(Error(xhr.statusText), {
                    xhr,
                    status: xhr.status
                  })
                );
              }
            });
            on(xhr, "error", () => reject(assign(Error("Network Error"), { xhr })));
            on(xhr, "timeout", () => reject(assign(Error("Network Timeout"), { xhr })));
            xhr.send(env.data);
          });
        }

        var components$1 = /*#__PURE__*/Object.freeze({
            __proto__: null,
            Countdown: countdown,
            Filter: filter,
            Lightbox: lightbox,
            LightboxPanel: LightboxPanel,
            Notification: notification,
            Parallax: parallax,
            Slider: slider,
            SliderParallax: sliderParallax,
            Slideshow: slideshow,
            SlideshowParallax: sliderParallax,
            Sortable: sortable,
            Tooltip: tooltip,
            Upload: upload
        });

        function boot(App) {
          if (inBrowser && window.MutationObserver) {
            if (document.body) {
              requestAnimationFrame(() => init(App));
            } else {
              new MutationObserver((records, observer) => {
                if (document.body) {
                  init(App);
                  observer.disconnect();
                }
              }).observe(document.documentElement, { childList: true });
            }
          }
        }
        function init(App) {
          trigger(document, "uikit:init", App);
          if (document.body) {
            apply(document.body, connect);
          }
          new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(document, {
            subtree: true,
            childList: true
          });
          new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(document, {
            subtree: true,
            attributes: true
          });
          App._initialized = true;
        }
        function applyChildListMutation({ addedNodes, removedNodes }) {
          for (const node of addedNodes) {
            apply(node, connect);
          }
          for (const node of removedNodes) {
            apply(node, disconnect);
          }
        }
        function applyAttributeMutation({ target, attributeName }) {
          var _a;
          const name = getComponentName(attributeName);
          if (name) {
            if (hasAttr(target, attributeName)) {
              createComponent(name, target);
              return;
            }
            (_a = getComponent(target, name)) == null ? void 0 : _a.$destroy();
          }
        }
        function connect(node) {
          const components2 = getComponents(node);
          for (const name in getComponents(node)) {
            callConnected(components2[name]);
          }
          for (const attributeName of node.getAttributeNames()) {
            const name = getComponentName(attributeName);
            name && createComponent(name, node);
          }
        }
        function disconnect(node) {
          const components2 = getComponents(node);
          for (const name in getComponents(node)) {
            callDisconnected(components2[name]);
          }
        }
        function getComponentName(attribute) {
          if (startsWith(attribute, "data-")) {
            attribute = attribute.slice(5);
          }
          const cmp = components$2[attribute];
          return cmp && (isPlainObject(cmp) ? cmp : cmp.options).name;
        }

        globalApi(App);
        instanceApi(App);

        var Accordion = {
          mixins: [Class, Togglable],
          props: {
            animation: Boolean,
            targets: String,
            active: null,
            collapsible: Boolean,
            multiple: Boolean,
            toggle: String,
            content: String,
            offset: Number
          },
          data: {
            targets: "> *",
            active: false,
            animation: true,
            collapsible: true,
            multiple: false,
            clsOpen: "uk-open",
            toggle: "> .uk-accordion-title",
            content: "> .uk-accordion-content",
            offset: 0
          },
          computed: {
            items: ({ targets }, $el) => $$(targets, $el),
            toggles({ toggle }) {
              return this.items.map((item) => $(toggle, item));
            },
            contents({ content }) {
              return this.items.map((item) => {
                var _a;
                return ((_a = item._wrapper) == null ? void 0 : _a.firstElementChild) || $(content, item);
              });
            }
          },
          watch: {
            items(items, prev) {
              if (prev || hasClass(items, this.clsOpen)) {
                return;
              }
              const active = this.active !== false && items[Number(this.active)] || !this.collapsible && items[0];
              if (active) {
                this.toggle(active, false);
              }
            },
            toggles() {
              this.$emit();
            },
            contents(items) {
              for (const el of items) {
                const isOpen = hasClass(
                  this.items.find((item) => item.contains(el)),
                  this.clsOpen
                );
                hide(el, !isOpen);
              }
              this.$emit();
            }
          },
          observe: lazyload(),
          events: [
            {
              name: "click keydown",
              delegate() {
                return `${this.targets} ${this.$props.toggle}`;
              },
              async handler(e) {
                var _a;
                if (e.type === "keydown" && e.keyCode !== keyMap.SPACE) {
                  return;
                }
                e.preventDefault();
                (_a = this._off) == null ? void 0 : _a.call(this);
                this._off = keepScrollPosition(e.target);
                await this.toggle(index(this.toggles, e.current));
                this._off();
              }
            },
            {
              name: "shown hidden",
              self: true,
              delegate() {
                return this.targets;
              },
              handler() {
                this.$emit();
              }
            }
          ],
          update() {
            const activeItems = filter$1(this.items, `.${this.clsOpen}`);
            for (const index2 in this.items) {
              const toggle = this.toggles[index2];
              const content = this.contents[index2];
              if (!toggle || !content) {
                continue;
              }
              toggle.id = generateId(this, toggle);
              content.id = generateId(this, content);
              const active = includes(activeItems, this.items[index2]);
              attr(toggle, {
                role: isTag(toggle, "a") ? "button" : null,
                "aria-controls": content.id,
                "aria-expanded": active,
                "aria-disabled": !this.collapsible && activeItems.length < 2 && active
              });
              attr(content, { role: "region", "aria-labelledby": toggle.id });
              if (isTag(content, "ul")) {
                attr(children(content), "role", "presentation");
              }
            }
          },
          methods: {
            toggle(item, animate) {
              item = this.items[getIndex(item, this.items)];
              let items = [item];
              const activeItems = filter$1(this.items, `.${this.clsOpen}`);
              if (!this.multiple && !includes(activeItems, items[0])) {
                items = items.concat(activeItems);
              }
              if (!this.collapsible && activeItems.length < 2 && includes(activeItems, item)) {
                return;
              }
              return Promise.all(
                items.map(
                  (el) => this.toggleElement(el, !includes(activeItems, el), (el2, show) => {
                    toggleClass(el2, this.clsOpen, show);
                    if (animate === false || !this.animation) {
                      hide($(this.content, el2), !show);
                      return;
                    }
                    return transition(el2, show, this);
                  })
                )
              );
            }
          }
        };
        function hide(el, hide2) {
          el && (el.hidden = hide2);
        }
        async function transition(el, show, { content, duration, velocity, transition: transition2 }) {
          var _a;
          content = ((_a = el._wrapper) == null ? void 0 : _a.firstElementChild) || $(content, el);
          if (!el._wrapper) {
            el._wrapper = wrapAll(content, "<div>");
          }
          const wrapper = el._wrapper;
          css(wrapper, "overflow", "hidden");
          const currentHeight = toFloat(css(wrapper, "height"));
          await Transition.cancel(wrapper);
          hide(content, false);
          const endHeight = sumBy(["marginTop", "marginBottom"], (prop) => css(content, prop)) + dimensions$1(content).height;
          const percent = currentHeight / endHeight;
          duration = (velocity * endHeight + duration) * (show ? 1 - percent : percent);
          css(wrapper, "height", currentHeight);
          await Transition.start(wrapper, { height: show ? endHeight : 0 }, duration, transition2);
          unwrap(content);
          delete el._wrapper;
          if (!show) {
            hide(content, true);
          }
        }
        function keepScrollPosition(el) {
          const scrollElement = scrollParent(el, true);
          let frame;
          (function scroll() {
            frame = requestAnimationFrame(() => {
              const { top } = el.getBoundingClientRect();
              if (top < 0) {
                scrollElement.scrollTop += top;
              }
              scroll();
            });
          })();
          return () => requestAnimationFrame(() => cancelAnimationFrame(frame));
        }

        var alert = {
          mixins: [Class, Togglable],
          args: "animation",
          props: {
            animation: Boolean,
            close: String
          },
          data: {
            animation: true,
            selClose: ".uk-alert-close",
            duration: 150
          },
          events: {
            name: "click",
            delegate() {
              return this.selClose;
            },
            handler(e) {
              e.preventDefault();
              this.close();
            }
          },
          methods: {
            async close() {
              await this.toggleElement(this.$el, false, animate);
              this.$destroy(true);
            }
          }
        };
        function animate(el, show, { duration, transition, velocity }) {
          const height = toFloat(css(el, "height"));
          css(el, "height", height);
          return Transition.start(
            el,
            {
              height: 0,
              marginTop: 0,
              marginBottom: 0,
              paddingTop: 0,
              paddingBottom: 0,
              borderTop: 0,
              borderBottom: 0,
              opacity: 0
            },
            velocity * height + duration,
            transition
          );
        }

        var Video = {
          args: "autoplay",
          props: {
            automute: Boolean,
            autoplay: Boolean
          },
          data: {
            automute: false,
            autoplay: true
          },
          connected() {
            if (this.autoplay === "inview" && !hasAttr(this.$el, "preload")) {
              this.$el.preload = "none";
            }
            if (isTag(this.$el, "iframe") && !hasAttr(this.$el, "allow")) {
              this.$el.allow = "autoplay";
            }
            if (this.automute) {
              mute(this.$el);
            }
          },
          observe: [
            intersection({
              filter: ({ $el, autoplay }) => autoplay && isVideo($el),
              handler([{ isIntersecting }]) {
                if (isIntersecting) {
                  play(this.$el);
                } else {
                  pause(this.$el);
                }
              },
              args: { intersecting: false },
              options: ({ $el, autoplay }) => ({ root: autoplay === "inview" ? null : parent($el) })
            })
          ]
        };

        var cover = {
          mixins: [Video],
          props: {
            width: Number,
            height: Number
          },
          data: {
            automute: true
          },
          events: {
            "load loadedmetadata"() {
              this.$emit("resize");
            }
          },
          observe: resize({
            target: ({ $el }) => [getPositionedParent($el) || parent($el)],
            filter: ({ $el }) => !useObjectFit($el)
          }),
          update: {
            read() {
              if (useObjectFit(this.$el)) {
                return;
              }
              const { ratio, cover } = Dimensions;
              const { $el, width, height } = this;
              let dim = { width, height };
              if (!width || !height) {
                const intrinsic = {
                  width: $el.naturalWidth || $el.videoWidth || $el.clientWidth,
                  height: $el.naturalHeight || $el.videoHeight || $el.clientHeight
                };
                if (width) {
                  dim = ratio(intrinsic, "width", width);
                } else if (height) {
                  dim = ratio(intrinsic, "height", height);
                } else {
                  dim = intrinsic;
                }
              }
              const { offsetHeight: coverHeight, offsetWidth: coverWidth } = getPositionedParent($el) || parent($el);
              const coverDim = cover(dim, {
                width: coverWidth + (coverWidth % 2 ? 1 : 0),
                height: coverHeight + (coverHeight % 2 ? 1 : 0)
              });
              if (!coverDim.width || !coverDim.height) {
                return false;
              }
              return coverDim;
            },
            write({ height, width }) {
              css(this.$el, { height, width });
            },
            events: ["resize"]
          }
        };
        function getPositionedParent(el) {
          while (el = parent(el)) {
            if (css(el, "position") !== "static") {
              return el;
            }
          }
        }
        function useObjectFit(el) {
          return isTag(el, "img", "video");
        }

        let active;
        var drop = {
          mixins: [Container, Position, Togglable],
          args: "pos",
          props: {
            mode: "list",
            toggle: Boolean,
            boundary: Boolean,
            boundaryX: Boolean,
            boundaryY: Boolean,
            target: Boolean,
            targetX: Boolean,
            targetY: Boolean,
            stretch: Boolean,
            delayShow: Number,
            delayHide: Number,
            autoUpdate: Boolean,
            clsDrop: String,
            animateOut: Boolean,
            bgScroll: Boolean,
            closeOnScroll: Boolean
          },
          data: {
            mode: ["click", "hover"],
            toggle: "- *",
            boundary: false,
            boundaryX: false,
            boundaryY: false,
            target: false,
            targetX: false,
            targetY: false,
            stretch: false,
            delayShow: 0,
            delayHide: 800,
            autoUpdate: true,
            clsDrop: false,
            animateOut: false,
            bgScroll: true,
            animation: ["uk-animation-fade"],
            cls: "uk-open",
            container: false,
            closeOnScroll: false
          },
          computed: {
            boundary({ boundary, boundaryX, boundaryY }, $el) {
              return [
                query(boundaryX || boundary, $el) || window,
                query(boundaryY || boundary, $el) || window
              ];
            },
            target({ target, targetX, targetY }, $el) {
              targetX || (targetX = target || this.targetEl);
              targetY || (targetY = target || this.targetEl);
              return [
                targetX === true ? window : query(targetX, $el),
                targetY === true ? window : query(targetY, $el)
              ];
            }
          },
          created() {
            this.tracker = new MouseTracker();
          },
          beforeConnect() {
            this.clsDrop = this.$props.clsDrop || `uk-${this.$options.name}`;
          },
          connected() {
            addClass(this.$el, "uk-drop", this.clsDrop);
            if (this.toggle && !this.targetEl) {
              this.targetEl = createToggleComponent(this);
            }
            this._style = pick(this.$el.style, ["width", "height"]);
          },
          disconnected() {
            if (this.isActive()) {
              this.hide(false);
              active = null;
            }
            css(this.$el, this._style);
          },
          observe: lazyload({
            target: ({ toggle, $el }) => query(toggle, $el),
            targets: ({ $el }) => $el
          }),
          events: [
            {
              name: "click",
              delegate() {
                return ".uk-drop-close";
              },
              handler(e) {
                e.preventDefault();
                this.hide(false);
              }
            },
            {
              name: "click",
              delegate() {
                return 'a[href*="#"]';
              },
              handler({ defaultPrevented, current }) {
                const { hash } = current;
                if (!defaultPrevented && hash && isSameSiteAnchor(current) && !this.$el.contains($(hash))) {
                  this.hide(false);
                }
              }
            },
            {
              name: "beforescroll",
              handler() {
                this.hide(false);
              }
            },
            {
              name: "toggle",
              self: true,
              handler(e, toggle) {
                e.preventDefault();
                if (this.isToggled()) {
                  this.hide(false);
                } else {
                  this.show(toggle == null ? void 0 : toggle.$el, false);
                }
              }
            },
            {
              name: "toggleshow",
              self: true,
              handler(e, toggle) {
                e.preventDefault();
                this.show(toggle == null ? void 0 : toggle.$el);
              }
            },
            {
              name: "togglehide",
              self: true,
              handler(e) {
                e.preventDefault();
                if (!matches(this.$el, ":focus,:hover")) {
                  this.hide();
                }
              }
            },
            {
              name: `${pointerEnter} focusin`,
              filter() {
                return includes(this.mode, "hover");
              },
              handler(e) {
                if (!isTouch(e)) {
                  this.clearTimers();
                }
              }
            },
            {
              name: `${pointerLeave} focusout`,
              filter() {
                return includes(this.mode, "hover");
              },
              handler(e) {
                if (!isTouch(e) && e.relatedTarget) {
                  this.hide();
                }
              }
            },
            {
              name: "toggled",
              self: true,
              handler(e, toggled) {
                if (toggled) {
                  this.clearTimers();
                  this.position();
                }
              }
            },
            {
              name: "show",
              self: true,
              handler() {
                active = this;
                this.tracker.init();
                attr(this.targetEl, "aria-expanded", true);
                const handlers = [
                  listenForResize(this),
                  listenForEscClose(this),
                  listenForBackgroundClose(this),
                  this.autoUpdate && listenForScroll(this),
                  this.closeOnScroll && listenForScrollClose(this),
                  !this.bgScroll && preventBackgroundScroll(this.$el)
                ];
                once(this.$el, "hide", () => handlers.forEach((handler) => handler && handler()), {
                  self: true
                });
              }
            },
            {
              name: "beforehide",
              self: true,
              handler() {
                this.clearTimers();
              }
            },
            {
              name: "hide",
              handler({ target }) {
                if (this.$el !== target) {
                  active = active === null && this.$el.contains(target) && this.isToggled() ? this : active;
                  return;
                }
                active = this.isActive() ? null : active;
                this.tracker.cancel();
                attr(this.targetEl, "aria-expanded", null);
              }
            }
          ],
          update: {
            write() {
              if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {
                this.position();
              }
            }
          },
          methods: {
            show(target = this.targetEl, delay = true) {
              if (this.isToggled() && target && this.targetEl && target !== this.targetEl) {
                this.hide(false, false);
              }
              this.targetEl = target;
              this.clearTimers();
              if (this.isActive()) {
                return;
              }
              if (active) {
                if (delay && active.isDelaying) {
                  this.showTimer = setTimeout(() => matches(target, ":hover") && this.show(), 10);
                  return;
                }
                let prev;
                while (active && prev !== active && !active.$el.contains(this.$el)) {
                  prev = active;
                  active.hide(false, false);
                }
              }
              if (this.container && parent(this.$el) !== this.container) {
                append(this.container, this.$el);
              }
              this.showTimer = setTimeout(
                () => this.toggleElement(this.$el, true),
                delay && this.delayShow || 0
              );
            },
            hide(delay = true, animate = true) {
              const hide = () => this.toggleElement(this.$el, false, this.animateOut && animate);
              this.clearTimers();
              this.isDelayedHide = delay;
              this.isDelaying = getPositionedElements(this.$el).some(
                (el) => this.tracker.movesTo(el)
              );
              if (delay && this.isDelaying) {
                this.hideTimer = setTimeout(this.hide, 50);
              } else if (delay && this.delayHide) {
                this.hideTimer = setTimeout(hide, this.delayHide);
              } else {
                hide();
              }
            },
            clearTimers() {
              clearTimeout(this.showTimer);
              clearTimeout(this.hideTimer);
              this.showTimer = null;
              this.hideTimer = null;
              this.isDelaying = false;
            },
            isActive() {
              return active === this;
            },
            position() {
              removeClass(this.$el, "uk-drop-stack");
              css(this.$el, this._style);
              this.$el.hidden = true;
              const viewports = this.target.map((target) => getViewport$1(this.$el, target));
              const viewportOffset = this.getViewportOffset(this.$el);
              const dirs = [
                [0, ["x", "width", "left", "right"]],
                [1, ["y", "height", "top", "bottom"]]
              ];
              for (const [i, [axis, prop]] of dirs) {
                if (this.axis !== axis && includes([axis, true], this.stretch)) {
                  css(this.$el, {
                    [prop]: Math.min(
                      offset(this.boundary[i])[prop],
                      viewports[i][prop] - 2 * viewportOffset
                    ),
                    [`overflow-${axis}`]: "auto"
                  });
                }
              }
              const maxWidth = viewports[0].width - 2 * viewportOffset;
              this.$el.hidden = false;
              css(this.$el, "maxWidth", "");
              if (this.$el.offsetWidth > maxWidth) {
                addClass(this.$el, "uk-drop-stack");
              }
              css(this.$el, "maxWidth", maxWidth);
              this.positionAt(this.$el, this.target, this.boundary);
              for (const [i, [axis, prop, start, end]] of dirs) {
                if (this.axis === axis && includes([axis, true], this.stretch)) {
                  const positionOffset = Math.abs(this.getPositionOffset(this.$el));
                  const targetOffset = offset(this.target[i]);
                  const elOffset = offset(this.$el);
                  css(this.$el, {
                    [prop]: (targetOffset[start] > elOffset[start] ? targetOffset[this.inset ? end : start] - Math.max(
                      offset(this.boundary[i])[start],
                      viewports[i][start] + viewportOffset
                    ) : Math.min(
                      offset(this.boundary[i])[end],
                      viewports[i][end] - viewportOffset
                    ) - targetOffset[this.inset ? start : end]) - positionOffset,
                    [`overflow-${axis}`]: "auto"
                  });
                  this.positionAt(this.$el, this.target, this.boundary);
                }
              }
            }
          }
        };
        function getPositionedElements(el) {
          const result = [];
          apply(el, (el2) => css(el2, "position") !== "static" && result.push(el2));
          return result;
        }
        function getViewport$1(el, target) {
          return offsetViewport(overflowParents(target).find((parent2) => parent2.contains(el)));
        }
        function createToggleComponent(drop) {
          const { $el } = drop.$create("toggle", query(drop.toggle, drop.$el), {
            target: drop.$el,
            mode: drop.mode
          });
          attr($el, "aria-haspopup", true);
          return $el;
        }
        function listenForResize(drop) {
          const update = () => drop.$emit();
          const off = [
            observeViewportResize(update),
            observeResize(overflowParents(drop.$el).concat(drop.target), update)
          ];
          return () => off.map((observer) => observer.disconnect());
        }
        function listenForScroll(drop, fn = () => drop.$emit()) {
          return on([document, ...overflowParents(drop.$el)], "scroll", fn, {
            passive: true
          });
        }
        function listenForEscClose(drop) {
          return on(document, "keydown", (e) => {
            if (e.keyCode === keyMap.ESC) {
              drop.hide(false);
            }
          });
        }
        function listenForScrollClose(drop) {
          return listenForScroll(drop, () => drop.hide(false));
        }
        function listenForBackgroundClose(drop) {
          return on(document, pointerDown$1, ({ target }) => {
            if (drop.$el.contains(target)) {
              return;
            }
            once(
              document,
              `${pointerUp$1} ${pointerCancel} scroll`,
              ({ defaultPrevented, type, target: newTarget }) => {
                if (!defaultPrevented && type === pointerUp$1 && target === newTarget && !(drop.targetEl && within(target, drop.targetEl))) {
                  drop.hide(false);
                }
              },
              true
            );
          });
        }

        var Dropnav = {
          mixins: [Class, Container],
          props: {
            align: String,
            clsDrop: String,
            boundary: Boolean,
            dropbar: Boolean,
            dropbarAnchor: Boolean,
            duration: Number,
            mode: Boolean,
            offset: Boolean,
            stretch: Boolean,
            delayShow: Boolean,
            delayHide: Boolean,
            target: Boolean,
            targetX: Boolean,
            targetY: Boolean,
            animation: Boolean,
            animateOut: Boolean,
            closeOnScroll: Boolean
          },
          data: {
            align: isRtl ? "right" : "left",
            clsDrop: "uk-dropdown",
            clsDropbar: "uk-dropnav-dropbar",
            boundary: true,
            dropbar: false,
            dropbarAnchor: false,
            duration: 200,
            container: false,
            selNavItem: "> li > a, > ul > li > a"
          },
          computed: {
            dropbarAnchor: ({ dropbarAnchor }, $el) => query(dropbarAnchor, $el) || $el,
            dropbar({ dropbar }) {
              if (!dropbar) {
                return null;
              }
              dropbar = this._dropbar || query(dropbar, this.$el) || $(`+ .${this.clsDropbar}`, this.$el);
              return dropbar ? dropbar : this._dropbar = $("<div></div>");
            },
            dropbarOffset() {
              return 0;
            },
            dropContainer(_, $el) {
              return this.container || $el;
            },
            dropdowns({ clsDrop }, $el) {
              var _a;
              const dropdowns = $$(`.${clsDrop}`, $el);
              if (this.dropContainer !== $el) {
                for (const el of $$(`.${clsDrop}`, this.dropContainer)) {
                  const target = (_a = this.getDropdown(el)) == null ? void 0 : _a.targetEl;
                  if (!includes(dropdowns, el) && target && this.$el.contains(target)) {
                    dropdowns.push(el);
                  }
                }
              }
              return dropdowns;
            },
            items({ selNavItem }, $el) {
              return $$(selNavItem, $el);
            }
          },
          watch: {
            dropbar(dropbar) {
              addClass(
                dropbar,
                "uk-dropbar",
                "uk-dropbar-top",
                this.clsDropbar,
                `uk-${this.$options.name}-dropbar`
              );
            },
            dropdowns() {
              this.initializeDropdowns();
            }
          },
          connected() {
            this.initializeDropdowns();
          },
          disconnected() {
            remove$1(this._dropbar);
            delete this._dropbar;
          },
          events: [
            {
              name: "mouseover focusin",
              delegate() {
                return this.selNavItem;
              },
              handler({ current }) {
                const active2 = this.getActive();
                if (active2 && includes(active2.mode, "hover") && active2.targetEl && !current.contains(active2.targetEl) && !active2.isDelaying) {
                  active2.hide(false);
                }
              }
            },
            {
              name: "keydown",
              self: true,
              delegate() {
                return this.selNavItem;
              },
              handler(e) {
                var _a;
                const { current, keyCode } = e;
                const active2 = this.getActive();
                if (keyCode === keyMap.DOWN && (active2 == null ? void 0 : active2.targetEl) === current) {
                  e.preventDefault();
                  (_a = $(selFocusable, active2.$el)) == null ? void 0 : _a.focus();
                }
                handleNavItemNavigation(e, this.items, active2);
              }
            },
            {
              name: "keydown",
              el() {
                return this.dropContainer;
              },
              delegate() {
                return `.${this.clsDrop}`;
              },
              handler(e) {
                var _a;
                const { current, keyCode } = e;
                if (!includes(this.dropdowns, current)) {
                  return;
                }
                const active2 = this.getActive();
                let next = -1;
                if (keyCode === keyMap.HOME) {
                  next = 0;
                } else if (keyCode === keyMap.END) {
                  next = "last";
                } else if (keyCode === keyMap.UP) {
                  next = "previous";
                } else if (keyCode === keyMap.DOWN) {
                  next = "next";
                } else if (keyCode === keyMap.ESC) {
                  (_a = active2.targetEl) == null ? void 0 : _a.focus();
                }
                if (~next) {
                  e.preventDefault();
                  const elements = $$(selFocusable, current);
                  elements[getIndex(
                    next,
                    elements,
                    findIndex(elements, (el) => matches(el, ":focus"))
                  )].focus();
                }
                handleNavItemNavigation(e, this.items, active2);
              }
            },
            {
              name: "mouseleave",
              el() {
                return this.dropbar;
              },
              filter() {
                return this.dropbar;
              },
              handler() {
                const active2 = this.getActive();
                if (active2 && includes(active2.mode, "hover") && !this.dropdowns.some((el) => matches(el, ":hover"))) {
                  active2.hide();
                }
              }
            },
            {
              name: "beforeshow",
              el() {
                return this.dropContainer;
              },
              filter() {
                return this.dropbar;
              },
              handler({ target }) {
                if (!this.isDropbarDrop(target)) {
                  return;
                }
                if (this.dropbar.previousElementSibling !== this.dropbarAnchor) {
                  after(this.dropbarAnchor, this.dropbar);
                }
                addClass(target, `${this.clsDrop}-dropbar`);
              }
            },
            {
              name: "show",
              el() {
                return this.dropContainer;
              },
              filter() {
                return this.dropbar;
              },
              handler({ target }) {
                if (!this.isDropbarDrop(target)) {
                  return;
                }
                const drop = this.getDropdown(target);
                const adjustHeight = () => {
                  const targetOffsets = parents(target, `.${this.clsDrop}`).concat(target).map((el) => offset(el));
                  const minTop = Math.min(...targetOffsets.map(({ top }) => top));
                  const maxBottom = Math.max(...targetOffsets.map(({ bottom }) => bottom));
                  const dropbarOffset = offset(this.dropbar);
                  css(
                    this.dropbar,
                    "top",
                    this.dropbar.offsetTop - (dropbarOffset.top - minTop) - this.dropbarOffset
                  );
                  this.transitionTo(
                    maxBottom - minTop + toFloat(css(target, "marginBottom")) + this.dropbarOffset,
                    target
                  );
                };
                this._observer = observeResize([drop.$el, ...drop.target], adjustHeight);
                adjustHeight();
              }
            },
            {
              name: "beforehide",
              el() {
                return this.dropContainer;
              },
              filter() {
                return this.dropbar;
              },
              handler(e) {
                const active2 = this.getActive();
                if (matches(this.dropbar, ":hover") && active2.$el === e.target && includes(active2.mode, "hover") && active2.isDelayedHide && !this.items.some((el) => active2.targetEl !== el && matches(el, ":focus"))) {
                  e.preventDefault();
                }
              }
            },
            {
              name: "hide",
              el() {
                return this.dropContainer;
              },
              filter() {
                return this.dropbar;
              },
              handler({ target }) {
                var _a;
                if (!this.isDropbarDrop(target)) {
                  return;
                }
                (_a = this._observer) == null ? void 0 : _a.disconnect();
                const active2 = this.getActive();
                if (!active2 || active2.$el === target) {
                  this.transitionTo(0);
                }
              }
            }
          ],
          methods: {
            getActive() {
              var _a;
              return includes(this.dropdowns, (_a = active) == null ? void 0 : _a.$el) && active;
            },
            async transitionTo(newHeight, el) {
              const { dropbar } = this;
              const oldHeight = height(dropbar);
              el = oldHeight < newHeight && el;
              await Transition.cancel([el, dropbar]);
              css(el, "clipPath", `polygon(0 0,100% 0,100% ${oldHeight}px,0 ${oldHeight}px)`);
              height(dropbar, oldHeight);
              await Promise.all([
                Transition.start(dropbar, { height: newHeight }, this.duration),
                Transition.start(
                  el,
                  {
                    clipPath: `polygon(0 0,100% 0,100% ${newHeight}px,0 ${newHeight}px)`
                  },
                  this.duration
                ).finally(() => css(el, { clipPath: "" }))
              ]).catch(noop);
            },
            getDropdown(el) {
              return this.$getComponent(el, "drop") || this.$getComponent(el, "dropdown");
            },
            isDropbarDrop(el) {
              return this.getDropdown(el) && hasClass(el, this.clsDrop);
            },
            initializeDropdowns() {
              this.$create(
                "drop",
                this.dropdowns.filter((el) => !this.getDropdown(el)),
                {
                  ...this.$props,
                  flip: false,
                  shift: true,
                  pos: `bottom-${this.align}`,
                  boundary: this.boundary === true ? this.$el : this.boundary
                }
              );
            }
          }
        };
        function handleNavItemNavigation(e, toggles, active2) {
          var _a, _b, _c;
          const { current, keyCode } = e;
          let next = -1;
          if (keyCode === keyMap.HOME) {
            next = 0;
          } else if (keyCode === keyMap.END) {
            next = "last";
          } else if (keyCode === keyMap.LEFT) {
            next = "previous";
          } else if (keyCode === keyMap.RIGHT) {
            next = "next";
          } else if (keyCode === keyMap.TAB) {
            (_a = active2.targetEl) == null ? void 0 : _a.focus();
            (_b = active2.hide) == null ? void 0 : _b.call(active2, false);
          }
          if (~next) {
            e.preventDefault();
            (_c = active2.hide) == null ? void 0 : _c.call(active2, false);
            toggles[getIndex(next, toggles, toggles.indexOf(active2.targetEl || current))].focus();
          }
        }

        var formCustom = {
          mixins: [Class],
          args: "target",
          props: {
            target: Boolean
          },
          data: {
            target: false
          },
          computed: {
            input: (_, $el) => $(selInput, $el),
            state() {
              return this.input.nextElementSibling;
            },
            target({ target }, $el) {
              return target && (target === true && parent(this.input) === $el && this.input.nextElementSibling || $(target, $el));
            }
          },
          update() {
            var _a;
            const { target, input } = this;
            if (!target) {
              return;
            }
            let option;
            const prop = isInput(target) ? "value" : "textContent";
            const prev = target[prop];
            const value = ((_a = input.files) == null ? void 0 : _a[0]) ? input.files[0].name : matches(input, "select") && (option = $$("option", input).filter((el) => el.selected)[0]) ? option.textContent : input.value;
            if (prev !== value) {
              target[prop] = value;
            }
          },
          events: [
            {
              name: "change",
              handler() {
                this.$emit();
              }
            },
            {
              name: "reset",
              el() {
                return this.$el.closest("form");
              },
              handler() {
                this.$emit();
              }
            }
          ]
        };

        var grid = {
          extends: Margin,
          mixins: [Class],
          name: "grid",
          props: {
            masonry: Boolean,
            parallax: String,
            parallaxStart: String,
            parallaxEnd: String,
            parallaxJustify: Boolean
          },
          data: {
            margin: "uk-grid-margin",
            clsStack: "uk-grid-stack",
            masonry: false,
            parallax: 0,
            parallaxStart: 0,
            parallaxEnd: 0,
            parallaxJustify: false
          },
          connected() {
            this.masonry && addClass(this.$el, "uk-flex-top", "uk-flex-wrap-top");
          },
          observe: scroll$1({ filter: ({ parallax, parallaxJustify }) => parallax || parallaxJustify }),
          update: [
            {
              write({ rows }) {
                toggleClass(this.$el, this.clsStack, !rows.some((row) => row.length > 1));
              },
              events: ["resize"]
            },
            {
              read(data) {
                const { rows } = data;
                let { masonry, parallax, parallaxJustify, margin } = this;
                parallax = Math.max(0, toPx(parallax));
                if (!(masonry || parallax || parallaxJustify) || positionedAbsolute(rows) || rows[0].some(
                  (el, i) => rows.some((row) => row[i] && row[i].offsetWidth !== el.offsetWidth)
                )) {
                  return data.translates = data.scrollColumns = false;
                }
                let gutter = getGutter(rows, margin);
                let columns;
                let translates;
                if (masonry) {
                  [columns, translates] = applyMasonry(rows, gutter, masonry === "next");
                } else {
                  columns = transpose(rows);
                }
                const columnHeights = columns.map(
                  (column) => sumBy(column, "offsetHeight") + gutter * (column.length - 1)
                );
                const height = Math.max(0, ...columnHeights);
                let scrollColumns;
                let parallaxStart;
                let parallaxEnd;
                if (parallax || parallaxJustify) {
                  scrollColumns = columnHeights.map(
                    (hgt, i) => parallaxJustify ? height - hgt + parallax : parallax / (i % 2 || 8)
                  );
                  if (!parallaxJustify) {
                    parallax = Math.max(
                      ...columnHeights.map((hgt, i) => hgt + scrollColumns[i] - height)
                    );
                  }
                  parallaxStart = toPx(this.parallaxStart, "height", this.$el, true);
                  parallaxEnd = toPx(this.parallaxEnd, "height", this.$el, true);
                }
                return {
                  columns,
                  translates,
                  scrollColumns,
                  parallaxStart,
                  parallaxEnd,
                  padding: parallax,
                  height: translates ? height : ""
                };
              },
              write({ height, padding }) {
                css(this.$el, "paddingBottom", padding || "");
                height !== false && css(this.$el, "height", height);
              },
              events: ["resize"]
            },
            {
              read({ rows, scrollColumns, parallaxStart, parallaxEnd }) {
                if (scrollColumns && positionedAbsolute(rows)) {
                  return false;
                }
                return {
                  scrolled: scrollColumns ? scrolledOver(this.$el, parallaxStart, parallaxEnd) : false
                };
              },
              write({ columns, scrolled, scrollColumns, translates }) {
                if (!scrolled && !translates) {
                  return;
                }
                columns.forEach(
                  (column, i) => column.forEach((el, j) => {
                    let [x, y] = translates && translates[i][j] || [0, 0];
                    if (scrolled) {
                      y += scrolled * scrollColumns[i];
                    }
                    css(el, "transform", `translate(${x}px, ${y}px)`);
                  })
                );
              },
              events: ["scroll", "resize"]
            }
          ]
        };
        function positionedAbsolute(rows) {
          return rows.flat().some((el) => css(el, "position") === "absolute");
        }
        function applyMasonry(rows, gutter, next) {
          const columns = [];
          const translates = [];
          const columnHeights = Array(rows[0].length).fill(0);
          let rowHeights = 0;
          for (let row of rows) {
            if (isRtl) {
              row = row.reverse();
            }
            let height = 0;
            for (const j in row) {
              const { offsetWidth, offsetHeight } = row[j];
              const index = next ? j : columnHeights.indexOf(Math.min(...columnHeights));
              push(columns, index, row[j]);
              push(translates, index, [
                (index - j) * offsetWidth * (isRtl ? -1 : 1),
                columnHeights[index] - rowHeights
              ]);
              columnHeights[index] += offsetHeight + gutter;
              height = Math.max(height, offsetHeight);
            }
            rowHeights += height + gutter;
          }
          return [columns, translates];
        }
        function getGutter(rows, cls) {
          const node = rows.flat().find((el) => hasClass(el, cls));
          return toFloat(node ? css(node, "marginTop") : css(rows[0][0], "paddingLeft"));
        }
        function transpose(rows) {
          const columns = [];
          for (const row of rows) {
            for (const i in row) {
              push(columns, i, row[i]);
            }
          }
          return columns;
        }
        function push(array, index, value) {
          if (!array[index]) {
            array[index] = [];
          }
          array[index].push(value);
        }

        var heightMatch = {
          args: "target",
          props: {
            target: String,
            row: Boolean
          },
          data: {
            target: "> *",
            row: true
          },
          computed: {
            elements: ({ target }, $el) => $$(target, $el)
          },
          observe: resize({
            target: ({ $el, elements }) => elements.reduce((elements2, el) => elements2.concat(el, ...el.children), [$el])
          }),
          update: {
            read() {
              return {
                rows: (this.row ? getRows(this.elements) : [this.elements]).map(match)
              };
            },
            write({ rows }) {
              for (const { heights, elements } of rows) {
                elements.forEach((el, i) => css(el, "minHeight", heights[i]));
              }
            },
            events: ["resize"]
          }
        };
        function match(elements) {
          if (elements.length < 2) {
            return { heights: [""], elements };
          }
          let heights = elements.map(getHeight);
          const max = Math.max(...heights);
          return {
            heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? "" : max),
            elements
          };
        }
        function getHeight(element) {
          const style = pick(element.style, ["display", "minHeight"]);
          if (!isVisible(element)) {
            css(element, "display", "block", "important");
          }
          css(element, "minHeight", "");
          const height = dimensions$1(element).height - boxModelAdjust(element, "height", "content-box");
          css(element, style);
          return height;
        }

        var heightViewport = {
          props: {
            expand: Boolean,
            offsetTop: Boolean,
            offsetBottom: Boolean,
            minHeight: Number
          },
          data: {
            expand: false,
            offsetTop: false,
            offsetBottom: false,
            minHeight: 0
          },
          // check for offsetTop change
          observe: [
            viewport({ filter: ({ expand }) => expand }),
            resize({ target: ({ $el }) => scrollParents($el) })
          ],
          update: {
            read() {
              if (!isVisible(this.$el)) {
                return false;
              }
              let minHeight = "";
              const box = boxModelAdjust(this.$el, "height", "content-box");
              const { body, scrollingElement } = document;
              const scrollElement = scrollParent(this.$el);
              const { height: viewportHeight } = offsetViewport(
                scrollElement === body ? scrollingElement : scrollElement
              );
              const isScrollingElement = scrollingElement === scrollElement || body === scrollElement;
              minHeight = `calc(${isScrollingElement ? "100vh" : `${viewportHeight}px`}`;
              if (this.expand) {
                const diff = dimensions$1(scrollElement).height - dimensions$1(this.$el).height;
                minHeight += ` - ${diff}px`;
              } else {
                if (this.offsetTop) {
                  if (isScrollingElement) {
                    const offsetTopEl = this.offsetTop === true ? this.$el : query(this.offsetTop, this.$el);
                    const top = offsetPosition(offsetTopEl)[0] - offsetPosition(scrollElement)[0];
                    minHeight += top > 0 && top < viewportHeight / 2 ? ` - ${top}px` : "";
                  } else {
                    minHeight += ` - ${css(scrollElement, "paddingTop")}`;
                  }
                }
                if (this.offsetBottom === true) {
                  minHeight += ` - ${dimensions$1(this.$el.nextElementSibling).height}px`;
                } else if (isNumeric(this.offsetBottom)) {
                  minHeight += ` - ${this.offsetBottom}vh`;
                } else if (this.offsetBottom && endsWith(this.offsetBottom, "px")) {
                  minHeight += ` - ${toFloat(this.offsetBottom)}px`;
                } else if (isString(this.offsetBottom)) {
                  minHeight += ` - ${dimensions$1(query(this.offsetBottom, this.$el)).height}px`;
                }
              }
              minHeight += `${box ? ` - ${box}px` : ""})`;
              return { minHeight };
            },
            write({ minHeight }) {
              css(this.$el, "minHeight", `max(${this.minHeight || 0}px, ${minHeight})`);
            },
            events: ["resize"]
          }
        };

        var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

        var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

        var dropParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>";

        var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";

        var navParentIconLarge = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 4 7 10 13 4\"/></svg>";

        var navParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>";

        var navbarParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>";

        var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><style>.uk-navbar-toggle-animate svg&gt;[class*=&quot;line-&quot;]{transition:0.2s ease-in-out;transition-property:transform, opacity;transform-origin:center;opacity:1}.uk-navbar-toggle svg&gt;.line-3{opacity:0}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-3{opacity:1}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-2{transform:rotate(45deg)}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-3{transform:rotate(-45deg)}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-1,.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-4{opacity:0}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-1{transform:translateY(6px) scaleX(0)}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-4{transform:translateY(-6px) scaleX(0)}</style><rect class=\"line-1\" y=\"3\" width=\"20\" height=\"2\"/><rect class=\"line-2\" y=\"9\" width=\"20\" height=\"2\"/><rect class=\"line-3\" y=\"9\" width=\"20\" height=\"2\"/><rect class=\"line-4\" y=\"15\" width=\"20\" height=\"2\"/></svg>";

        var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";

        var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

        var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

        var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

        var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

        var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

        var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5\"/></svg>";

        var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1\"/></svg>";

        var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547\"/></svg>";

        var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23\"/></svg>";

        var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

        var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9\"/></svg>";

        var Svg = {
          args: "src",
          props: {
            width: Number,
            height: Number,
            ratio: Number
          },
          data: {
            ratio: 1
          },
          connected() {
            this.svg = this.getSvg().then((el) => {
              if (!this._connected) {
                return;
              }
              const svg = insertSVG(el, this.$el);
              if (this.svgEl && svg !== this.svgEl) {
                remove$1(this.svgEl);
              }
              applyWidthAndHeight.call(this, svg, el);
              return this.svgEl = svg;
            }, noop);
          },
          disconnected() {
            this.svg.then((svg) => {
              if (this._connected) {
                return;
              }
              if (isVoidElement(this.$el)) {
                this.$el.hidden = false;
              }
              remove$1(svg);
              this.svgEl = null;
            });
            this.svg = null;
          },
          methods: {
            async getSvg() {
            }
          }
        };
        function insertSVG(el, root) {
          if (isVoidElement(root) || isTag(root, "canvas")) {
            root.hidden = true;
            const next = root.nextElementSibling;
            return equals(el, next) ? next : after(root, el);
          }
          const last = root.lastElementChild;
          return equals(el, last) ? last : append(root, el);
        }
        function equals(el, other) {
          return isTag(el, "svg") && isTag(other, "svg") && el.innerHTML === other.innerHTML;
        }
        function applyWidthAndHeight(el, ref) {
          const props = ["width", "height"];
          let dimensions = props.map((prop) => this[prop]);
          if (!dimensions.some((val) => val)) {
            dimensions = props.map((prop) => attr(ref, prop));
          }
          const viewBox = attr(ref, "viewBox");
          if (viewBox && !dimensions.some((val) => val)) {
            dimensions = viewBox.split(" ").slice(2);
          }
          dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));
        }

        const icons = {
          spinner,
          totop,
          marker,
          "close-icon": closeIcon,
          "close-large": closeLarge,
          "drop-parent-icon": dropParentIcon,
          "nav-parent-icon": navParentIcon,
          "nav-parent-icon-large": navParentIconLarge,
          "navbar-parent-icon": navbarParentIcon,
          "navbar-toggle-icon": navbarToggleIcon,
          "overlay-icon": overlayIcon,
          "pagination-next": paginationNext,
          "pagination-previous": paginationPrevious,
          "search-icon": searchIcon,
          "search-large": searchLarge,
          "search-navbar": searchNavbar,
          "slidenav-next": slidenavNext,
          "slidenav-next-large": slidenavNextLarge,
          "slidenav-previous": slidenavPrevious,
          "slidenav-previous-large": slidenavPreviousLarge
        };
        const Icon = {
          install: install$1,
          mixins: [Svg],
          args: "icon",
          props: { icon: String },
          isIcon: true,
          beforeConnect() {
            addClass(this.$el, "uk-icon");
          },
          methods: {
            async getSvg() {
              const icon = getIcon(this.icon);
              if (!icon) {
                throw "Icon not found.";
              }
              return icon;
            }
          }
        };
        const IconComponent = {
          args: false,
          extends: Icon,
          data: (vm) => ({
            icon: hyphenate(vm.constructor.options.name)
          }),
          beforeConnect() {
            addClass(this.$el, this.$options.id);
          }
        };
        const NavParentIcon = {
          extends: IconComponent,
          beforeConnect() {
            const icon = this.$props.icon;
            this.icon = this.$el.closest(".uk-nav-primary") ? `${icon}-large` : icon;
          }
        };
        const Search = {
          extends: IconComponent,
          mixins: [I18n],
          i18n: { toggle: "Open Search", submit: "Submit Search" },
          beforeConnect() {
            this.icon = hasClass(this.$el, "uk-search-icon") && parents(this.$el, ".uk-search-large").length ? "search-large" : parents(this.$el, ".uk-search-navbar").length ? "search-navbar" : this.$props.icon;
            if (hasAttr(this.$el, "aria-label")) {
              return;
            }
            if (hasClass(this.$el, "uk-search-toggle") || hasClass(this.$el, "uk-navbar-toggle")) {
              const label = this.t("toggle");
              attr(this.$el, "aria-label", label);
            } else {
              const button = this.$el.closest("a,button");
              if (button) {
                const label = this.t("submit");
                attr(button, "aria-label", label);
              }
            }
          }
        };
        const Spinner = {
          extends: IconComponent,
          beforeConnect() {
            attr(this.$el, "role", "status");
          },
          methods: {
            async getSvg() {
              const icon = await Icon.methods.getSvg.call(this);
              if (this.ratio !== 1) {
                css($("circle", icon), "strokeWidth", 1 / this.ratio);
              }
              return icon;
            }
          }
        };
        const ButtonComponent = {
          extends: IconComponent,
          mixins: [I18n],
          beforeConnect() {
            const button = this.$el.closest("a,button");
            attr(button, "role", this.role !== null && isTag(button, "a") ? "button" : this.role);
            const label = this.t("label");
            if (label && !hasAttr(button, "aria-label")) {
              attr(button, "aria-label", label);
            }
          }
        };
        const Slidenav = {
          extends: ButtonComponent,
          beforeConnect() {
            addClass(this.$el, "uk-slidenav");
            const icon = this.$props.icon;
            this.icon = hasClass(this.$el, "uk-slidenav-large") ? `${icon}-large` : icon;
          }
        };
        const NavbarToggleIcon = {
          extends: ButtonComponent,
          i18n: { label: "Open menu" }
        };
        const Close = {
          extends: ButtonComponent,
          i18n: { label: "Close" },
          beforeConnect() {
            this.icon = `close-${hasClass(this.$el, "uk-close-large") ? "large" : "icon"}`;
          }
        };
        const Marker = {
          extends: ButtonComponent,
          i18n: { label: "Open" }
        };
        const Totop = {
          extends: ButtonComponent,
          i18n: { label: "Back to top" }
        };
        const PaginationNext = {
          extends: ButtonComponent,
          i18n: { label: "Next page" },
          data: { role: null }
        };
        const PaginationPrevious = {
          extends: ButtonComponent,
          i18n: { label: "Previous page" },
          data: { role: null }
        };
        const parsed = {};
        function install$1(UIkit) {
          UIkit.icon.add = (name, svg) => {
            const added = isString(name) ? { [name]: svg } : name;
            each(added, (svg2, name2) => {
              icons[name2] = svg2;
              delete parsed[name2];
            });
            if (UIkit._initialized) {
              apply(
                document.body,
                (el) => each(UIkit.getComponents(el), (cmp) => {
                  cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
                })
              );
            }
          };
        }
        function getIcon(icon) {
          if (!icons[icon]) {
            return null;
          }
          if (!parsed[icon]) {
            parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());
          }
          return parsed[icon].cloneNode(true);
        }
        function applyRtl(icon) {
          return isRtl ? swap(swap(icon, "left", "right"), "previous", "next") : icon;
        }

        const nativeLazyLoad = inBrowser && "loading" in HTMLImageElement.prototype;
        var img = {
          args: "dataSrc",
          props: {
            dataSrc: String,
            sources: String,
            margin: String,
            target: String,
            loading: String
          },
          data: {
            dataSrc: "",
            sources: false,
            margin: "50%",
            target: false,
            loading: "lazy"
          },
          connected() {
            if (this.loading !== "lazy") {
              this.load();
              return;
            }
            if (nativeLazyLoad && isImg(this.$el)) {
              this.$el.loading = "lazy";
              setSrcAttrs(this.$el);
            }
            ensureSrcAttribute(this.$el);
          },
          disconnected() {
            if (this.img) {
              this.img.onload = "";
            }
            delete this.img;
          },
          observe: intersection({
            target: ({ $el, $props }) => [$el, ...queryAll($props.target, $el)],
            handler(entries, observer) {
              this.load();
              observer.disconnect();
            },
            options: ({ margin }) => ({ rootMargin: margin }),
            filter: ({ loading }) => loading === "lazy"
          }),
          methods: {
            load() {
              if (this.img) {
                return this.img;
              }
              const image = isImg(this.$el) ? this.$el : getImageFromElement(this.$el, this.dataSrc, this.sources);
              removeAttr(image, "loading");
              setSrcAttrs(this.$el, image.currentSrc);
              return this.img = image;
            }
          }
        };
        function setSrcAttrs(el, src) {
          if (isImg(el)) {
            const parentNode = parent(el);
            const elements = isTag(parentNode, "picture") ? children(parentNode) : [el];
            elements.forEach((el2) => setSourceProps(el2, el2));
          } else if (src) {
            const change = !includes(el.style.backgroundImage, src);
            if (change) {
              css(el, "backgroundImage", `url(${escape(src)})`);
              trigger(el, createEvent("load", false));
            }
          }
        }
        const srcProps = ["data-src", "data-srcset", "sizes"];
        function setSourceProps(sourceEl, targetEl) {
          for (const prop of srcProps) {
            const value = data(sourceEl, prop);
            if (value) {
              attr(targetEl, prop.replace(/^(data-)+/, ""), value);
            }
          }
        }
        function getImageFromElement(el, src, sources) {
          const img = new Image();
          wrapInPicture(img, sources);
          setSourceProps(el, img);
          img.onload = () => {
            setSrcAttrs(el, img.currentSrc);
          };
          attr(img, "src", src);
          return img;
        }
        function wrapInPicture(img, sources) {
          sources = parseSources(sources);
          if (sources.length) {
            const picture = fragment("<picture>");
            for (const attrs of sources) {
              const source = fragment("<source>");
              attr(source, attrs);
              append(picture, source);
            }
            append(picture, img);
          }
        }
        function parseSources(sources) {
          if (!sources) {
            return [];
          }
          if (startsWith(sources, "[")) {
            try {
              sources = JSON.parse(sources);
            } catch (e) {
              sources = [];
            }
          } else {
            sources = parseOptions(sources);
          }
          if (!isArray(sources)) {
            sources = [sources];
          }
          return sources.filter((source) => !isEmpty(source));
        }
        function ensureSrcAttribute(el) {
          if (isImg(el) && !hasAttr(el, "src")) {
            attr(el, "src", 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg"></svg>');
          }
        }
        function isImg(el) {
          return isTag(el, "img");
        }

        var leader = {
          mixins: [Class, Media],
          props: {
            fill: String
          },
          data: {
            fill: "",
            clsWrapper: "uk-leader-fill",
            clsHide: "uk-leader-hide",
            attrFill: "data-fill"
          },
          computed: {
            fill: ({ fill }, $el) => fill || css($el, "--uk-leader-fill-content")
          },
          connected() {
            [this.wrapper] = wrapInner(this.$el, `<span class="${this.clsWrapper}">`);
          },
          disconnected() {
            unwrap(this.wrapper.childNodes);
          },
          observe: resize(),
          update: {
            read() {
              const width = Math.trunc(this.$el.offsetWidth / 2);
              return {
                width,
                fill: this.fill,
                hide: !this.matchMedia
              };
            },
            write({ width, fill, hide }) {
              toggleClass(this.wrapper, this.clsHide, hide);
              attr(this.wrapper, this.attrFill, new Array(width).join(fill));
            },
            events: ["resize"]
          }
        };

        var modal = {
          install,
          mixins: [Modal],
          data: {
            clsPage: "uk-modal-page",
            selPanel: ".uk-modal-dialog",
            selClose: ".uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full"
          },
          events: [
            {
              name: "show",
              self: true,
              handler() {
                if (hasClass(this.panel, "uk-margin-auto-vertical")) {
                  addClass(this.$el, "uk-flex");
                } else {
                  css(this.$el, "display", "block");
                }
                height(this.$el);
              }
            },
            {
              name: "hidden",
              self: true,
              handler() {
                css(this.$el, "display", "");
                removeClass(this.$el, "uk-flex");
              }
            }
          ]
        };
        function install({ modal }) {
          modal.dialog = function(content, options) {
            const dialog = modal(
              `<div class="uk-modal"> <div class="uk-modal-dialog">${content}</div> </div>`,
              { stack: true, role: "alertdialog", ...options }
            );
            dialog.show();
            on(
              dialog.$el,
              "hidden",
              async () => {
                await Promise.resolve();
                dialog.$destroy(true);
              },
              { self: true }
            );
            return dialog;
          };
          modal.alert = function(message, options) {
            return openDialog(
              ({ i18n }) => `<div class="uk-modal-body">${isString(message) ? message : html(message)}</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-primary uk-modal-close" autofocus>${i18n.ok}</button> </div>`,
              options
            );
          };
          modal.confirm = function(message, options) {
            return openDialog(
              ({ i18n }) => `<form> <div class="uk-modal-body">${isString(message) ? message : html(message)}</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-default uk-modal-close" type="button">${i18n.cancel}</button> <button class="uk-button uk-button-primary" autofocus>${i18n.ok}</button> </div> </form>`,
              options,
              () => Promise.reject()
            );
          };
          modal.prompt = function(message, value, options) {
            const promise = openDialog(
              ({ i18n }) => `<form class="uk-form-stacked"> <div class="uk-modal-body"> <label>${isString(message) ? message : html(message)}</label> <input class="uk-input" value="${value || ""}" autofocus> </div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-default uk-modal-close" type="button">${i18n.cancel}</button> <button class="uk-button uk-button-primary">${i18n.ok}</button> </div> </form>`,
              options,
              () => null,
              () => input.value
            );
            const { $el } = promise.dialog;
            const input = $("input", $el);
            on($el, "show", () => input.select());
            return promise;
          };
          modal.i18n = {
            ok: "Ok",
            cancel: "Cancel"
          };
          function openDialog(tmpl, options, hideFn = noop, submitFn = noop) {
            options = {
              bgClose: false,
              escClose: true,
              ...options,
              i18n: { ...modal.i18n, ...options == null ? void 0 : options.i18n }
            };
            const dialog = modal.dialog(tmpl(options), options);
            return assign(
              new Promise((resolve) => {
                const off = on(dialog.$el, "hide", () => resolve(hideFn()));
                on(dialog.$el, "submit", "form", (e) => {
                  e.preventDefault();
                  resolve(submitFn(dialog));
                  off();
                  dialog.hide();
                });
              }),
              { dialog }
            );
          }
        }

        var nav = {
          extends: Accordion,
          data: {
            targets: "> .uk-parent",
            toggle: "> a",
            content: "> ul"
          }
        };

        var navbar = {
          extends: Dropnav,
          props: {
            dropbarTransparentMode: Boolean
          },
          data: {
            clsDrop: "uk-navbar-dropdown",
            selNavItem: ".uk-navbar-nav > li > a,a.uk-navbar-item,button.uk-navbar-item,.uk-navbar-item a,.uk-navbar-item button,.uk-navbar-toggle",
            // Simplify with :where() selector once browser target is Safari 14+
            selTransparentTarget: '[class*="uk-section"]',
            dropbarTransparentMode: false
          },
          computed: {
            navbarContainer: (_, $el) => $el.closest(".uk-navbar-container"),
            dropbarOffset: ({ dropbarTransparentMode }, $el) => dropbarTransparentMode === "behind" ? $el.offsetHeight : 0
          },
          watch: {
            items() {
              const justify = hasClass(this.$el, "uk-navbar-justify");
              for (const container of $$(
                ".uk-navbar-nav, .uk-navbar-left, .uk-navbar-right",
                this.$el
              )) {
                css(
                  container,
                  "flexGrow",
                  justify ? $$(
                    ".uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle",
                    container
                  ).length : ""
                );
              }
            }
          },
          disconnect() {
            var _a;
            (_a = this._colorListener) == null ? void 0 : _a.call(this);
          },
          observe: [
            mutation({
              target: ({ navbarContainer }) => navbarContainer,
              handler: "registerColorListener",
              options: { attributes: true, attributeFilter: ["class"], attributeOldValue: true }
            }),
            intersection({
              handler(records) {
                this._isIntersecting = records[0].isIntersecting;
                this.registerColorListener();
              },
              args: { intersecting: false }
            })
          ],
          events: [
            {
              name: "show",
              el() {
                return this.dropContainer;
              },
              handler({ target }) {
                const transparentMode = this.getTransparentMode(target);
                if (!transparentMode || this._mode) {
                  return;
                }
                const storePrevColor = () => this._mode = removeClasses(this.navbarContainer, "uk-light", "uk-dark");
                if (transparentMode === "behind") {
                  const mode = getDropbarBehindColor(this.$el);
                  if (mode) {
                    storePrevColor();
                    addClass(this.navbarContainer, `uk-${mode}`);
                  }
                }
                if (transparentMode === "remove") {
                  storePrevColor();
                  removeClass(this.navbarContainer, "uk-navbar-transparent");
                }
              }
            },
            {
              name: "hide",
              el() {
                return this.dropContainer;
              },
              async handler({ target }) {
                const transparentMode = this.getTransparentMode(target);
                if (!transparentMode || !this._mode) {
                  return;
                }
                await awaitMacroTask();
                if (this.getActive()) {
                  return;
                }
                if (transparentMode === "behind") {
                  const mode = getDropbarBehindColor(this.$el);
                  if (mode) {
                    removeClass(this.navbarContainer, `uk-${mode}`);
                  }
                }
                addClass(this.navbarContainer, this._mode);
                if (transparentMode === "remove") {
                  addClass(this.navbarContainer, "uk-navbar-transparent");
                }
                this._mode = null;
              }
            }
          ],
          methods: {
            getTransparentMode(el) {
              if (!this.navbarContainer) {
                return;
              }
              if (this.dropbar && this.isDropbarDrop(el)) {
                return this.dropbarTransparentMode;
              }
              const drop = this.getDropdown(el);
              if (!drop || !hasClass(el, "uk-dropbar")) {
                return;
              }
              return drop.inset ? "behind" : "remove";
            },
            registerColorListener() {
              const active = this._isIntersecting && hasClass(this.navbarContainer, "uk-navbar-transparent") && !isWithinMixBlendMode(this.navbarContainer) && !$$(".uk-drop", this.dropContainer).map(this.getDropdown).some(
                (drop) => drop.isToggled() && (drop.inset || this.getTransparentMode(drop.$el) === "behind")
              );
              if (this._colorListener) {
                if (!active) {
                  this._colorListener();
                  this._colorListener = null;
                }
                return;
              }
              if (!active) {
                return;
              }
              this._colorListener = listenForPositionChange(this.navbarContainer, () => {
                const { left, top, height } = offset(this.navbarContainer);
                const startPoint = { x: left, y: Math.max(0, top) + height / 2 };
                const target = $$(this.selTransparentTarget).find(
                  (target2) => pointInRect(startPoint, offset(target2))
                );
                const color = css(target, "--uk-navbar-color");
                if (color) {
                  replaceClass(this.navbarContainer, "uk-light,uk-dark", `uk-${color}`);
                }
              });
            }
          }
        };
        function removeClasses(el, ...classes) {
          for (const cls of classes) {
            if (hasClass(el, cls)) {
              removeClass(el, cls);
              return cls;
            }
          }
        }
        async function awaitMacroTask() {
          return new Promise((resolve) => setTimeout(resolve));
        }
        function getDropbarBehindColor(el) {
          return css(el, "--uk-navbar-dropbar-behind-color");
        }
        function listenForPositionChange(el, handler) {
          const parent2 = scrollParent(el, true);
          const scrollEl = parent2 === document.documentElement ? document : parent2;
          const off = on(scrollEl, "scroll", handler, { passive: true });
          const observer = observeResize([el, parent2], handler);
          return () => {
            off();
            observer.disconnect();
          };
        }
        function isWithinMixBlendMode(el) {
          do {
            if (css(el, "mixBlendMode") !== "normal") {
              return true;
            }
          } while (el = parent(el));
        }

        var offcanvas = {
          mixins: [Modal],
          args: "mode",
          props: {
            mode: String,
            flip: Boolean,
            overlay: Boolean,
            swiping: Boolean
          },
          data: {
            mode: "slide",
            flip: false,
            overlay: false,
            clsPage: "uk-offcanvas-page",
            clsContainer: "uk-offcanvas-container",
            selPanel: ".uk-offcanvas-bar",
            clsFlip: "uk-offcanvas-flip",
            clsContainerAnimation: "uk-offcanvas-container-animation",
            clsSidebarAnimation: "uk-offcanvas-bar-animation",
            clsMode: "uk-offcanvas",
            clsOverlay: "uk-offcanvas-overlay",
            selClose: ".uk-offcanvas-close",
            container: false,
            swiping: true
          },
          computed: {
            clsFlip: ({ flip, clsFlip }) => flip ? clsFlip : "",
            clsOverlay: ({ overlay, clsOverlay }) => overlay ? clsOverlay : "",
            clsMode: ({ mode, clsMode }) => `${clsMode}-${mode}`,
            clsSidebarAnimation: ({ mode, clsSidebarAnimation }) => mode === "none" || mode === "reveal" ? "" : clsSidebarAnimation,
            clsContainerAnimation: ({ mode, clsContainerAnimation }) => mode !== "push" && mode !== "reveal" ? "" : clsContainerAnimation,
            transitionElement({ mode }) {
              return mode === "reveal" ? parent(this.panel) : this.panel;
            }
          },
          observe: swipe({ filter: ({ swiping }) => swiping }),
          update: {
            read() {
              if (this.isToggled() && !isVisible(this.$el)) {
                this.hide();
              }
            },
            events: ["resize"]
          },
          events: [
            {
              name: "touchmove",
              self: true,
              passive: false,
              filter() {
                return this.overlay;
              },
              handler(e) {
                e.cancelable && e.preventDefault();
              }
            },
            {
              name: "show",
              self: true,
              handler() {
                if (this.mode === "reveal" && !hasClass(parent(this.panel), this.clsMode)) {
                  wrapAll(this.panel, "<div>");
                  addClass(parent(this.panel), this.clsMode);
                }
                const { body, scrollingElement } = document;
                addClass(body, this.clsContainer, this.clsFlip);
                css(body, "touch-action", "pan-y pinch-zoom");
                css(this.$el, "display", "block");
                css(this.panel, "maxWidth", scrollingElement.clientWidth);
                addClass(this.$el, this.clsOverlay);
                addClass(
                  this.panel,
                  this.clsSidebarAnimation,
                  this.mode === "reveal" ? "" : this.clsMode
                );
                height(body);
                addClass(body, this.clsContainerAnimation);
                this.clsContainerAnimation && suppressUserScale();
              }
            },
            {
              name: "hide",
              self: true,
              handler() {
                removeClass(document.body, this.clsContainerAnimation);
                css(document.body, "touch-action", "");
              }
            },
            {
              name: "hidden",
              self: true,
              handler() {
                this.clsContainerAnimation && resumeUserScale();
                if (this.mode === "reveal") {
                  unwrap(this.panel);
                }
                removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
                removeClass(this.$el, this.clsOverlay);
                css(this.$el, "display", "");
                css(this.panel, "maxWidth", "");
                removeClass(document.body, this.clsContainer, this.clsFlip);
              }
            },
            {
              name: "swipeLeft swipeRight",
              handler(e) {
                if (this.isToggled() && endsWith(e.type, "Left") ^ this.flip) {
                  this.hide();
                }
              }
            }
          ]
        };
        function suppressUserScale() {
          getViewport().content += ",user-scalable=0";
        }
        function resumeUserScale() {
          const viewport = getViewport();
          viewport.content = viewport.content.replace(/,user-scalable=0$/, "");
        }
        function getViewport() {
          return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">');
        }

        var overflowAuto = {
          mixins: [Class],
          props: {
            selContainer: String,
            selContent: String,
            minHeight: Number
          },
          data: {
            selContainer: ".uk-modal",
            selContent: ".uk-modal-dialog",
            minHeight: 150
          },
          computed: {
            container: ({ selContainer }, $el) => $el.closest(selContainer),
            content: ({ selContent }, $el) => $el.closest(selContent)
          },
          observe: resize({
            target: ({ container, content }) => [container, content]
          }),
          update: {
            read() {
              if (!this.content || !this.container || !isVisible(this.$el)) {
                return false;
              }
              return {
                max: Math.max(
                  this.minHeight,
                  height(this.container) - (dimensions$1(this.content).height - height(this.$el))
                )
              };
            },
            write({ max }) {
              css(this.$el, { minHeight: this.minHeight, maxHeight: max });
            },
            events: ["resize"]
          }
        };

        var responsive = {
          props: ["width", "height"],
          connected() {
            addClass(this.$el, "uk-responsive-width");
          },
          observe: resize({
            target: ({ $el }) => [$el, parent($el)]
          }),
          update: {
            read() {
              return isVisible(this.$el) && this.width && this.height ? { width: width(parent(this.$el)), height: this.height } : false;
            },
            write(dim) {
              height(
                this.$el,
                Dimensions.contain(
                  {
                    height: this.height,
                    width: this.width
                  },
                  dim
                ).height
              );
            },
            events: ["resize"]
          }
        };

        var scroll = {
          props: {
            offset: Number
          },
          data: {
            offset: 0
          },
          connected() {
            registerClick(this);
          },
          disconnected() {
            unregisterClick(this);
          },
          methods: {
            async scrollTo(el) {
              el = el && $(el) || document.body;
              if (trigger(this.$el, "beforescroll", [this, el])) {
                await scrollIntoView(el, { offset: this.offset });
                trigger(this.$el, "scrolled", [this, el]);
              }
            }
          }
        };
        const instances = /* @__PURE__ */ new Set();
        function registerClick(cmp) {
          if (!instances.size) {
            on(document, "click", clickHandler);
          }
          instances.add(cmp);
        }
        function unregisterClick(cmp) {
          instances.delete(cmp);
          if (!instances.size) {
            off(document, "click", clickHandler);
          }
        }
        function clickHandler(e) {
          if (e.defaultPrevented) {
            return;
          }
          for (const instance of instances) {
            if (instance.$el.contains(e.target) && isSameSiteAnchor(instance.$el)) {
              e.preventDefault();
              if (window.location.href !== instance.$el.href) {
                window.history.pushState({}, "", instance.$el.href);
              }
              instance.scrollTo(getTargetedElement(instance.$el));
            }
          }
        }

        var scrollspy = {
          args: "cls",
          props: {
            cls: String,
            target: String,
            hidden: Boolean,
            margin: String,
            repeat: Boolean,
            delay: Number
          },
          data: () => ({
            cls: "",
            target: false,
            hidden: true,
            margin: "-1px",
            repeat: false,
            delay: 0,
            inViewClass: "uk-scrollspy-inview"
          }),
          computed: {
            elements: ({ target }, $el) => target ? $$(target, $el) : [$el]
          },
          watch: {
            elements(elements) {
              if (this.hidden) {
                css(filter$1(elements, `:not(.${this.inViewClass})`), "opacity", 0);
              }
            }
          },
          connected() {
            this.elementData = /* @__PURE__ */ new Map();
          },
          disconnected() {
            for (const [el, state] of this.elementData.entries()) {
              removeClass(el, this.inViewClass, (state == null ? void 0 : state.cls) || "");
            }
            delete this.elementData;
          },
          observe: intersection({
            target: ({ elements }) => elements,
            handler(records) {
              const elements = this.elementData;
              for (const { target: el, isIntersecting } of records) {
                if (!elements.has(el)) {
                  elements.set(el, {
                    cls: data(el, "uk-scrollspy-class") || this.cls
                  });
                }
                const state = elements.get(el);
                if (!this.repeat && state.show) {
                  continue;
                }
                state.show = isIntersecting;
              }
              this.$emit();
            },
            options: ({ margin }) => ({ rootMargin: margin }),
            args: { intersecting: false }
          }),
          update: [
            {
              write(data) {
                for (const [el, state] of this.elementData.entries()) {
                  if (state.show && !state.inview && !state.queued) {
                    state.queued = true;
                    data.promise = (data.promise || Promise.resolve()).then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).then(() => {
                      this.toggle(el, true);
                      setTimeout(() => {
                        state.queued = false;
                        this.$emit();
                      }, 300);
                    });
                  } else if (!state.show && state.inview && !state.queued && this.repeat) {
                    this.toggle(el, false);
                  }
                }
              }
            }
          ],
          methods: {
            toggle(el, inview) {
              var _a;
              const state = this.elementData.get(el);
              if (!state) {
                return;
              }
              (_a = state.off) == null ? void 0 : _a.call(state);
              css(el, "opacity", !inview && this.hidden ? 0 : "");
              toggleClass(el, this.inViewClass, inview);
              toggleClass(el, state.cls);
              if (/\buk-animation-/.test(state.cls)) {
                const removeAnimationClasses = () => removeClasses$1(el, "uk-animation-[\\w-]+");
                if (inview) {
                  state.off = once(el, "animationcancel animationend", removeAnimationClasses);
                } else {
                  removeAnimationClasses();
                }
              }
              trigger(el, inview ? "inview" : "outview");
              state.inview = inview;
              this.$update(el);
            }
          }
        };

        var scrollspyNav = {
          props: {
            cls: String,
            closest: Boolean,
            scroll: Boolean,
            overflow: Boolean,
            offset: Number
          },
          data: {
            cls: "uk-active",
            closest: false,
            scroll: false,
            overflow: true,
            offset: 0
          },
          computed: {
            links: (_, $el) => $$('a[href*="#"]', $el).filter((el) => el.hash && isSameSiteAnchor(el)),
            elements({ closest: selector }) {
              return this.links.map((el) => el.closest(selector || "*"));
            }
          },
          watch: {
            links(links) {
              if (this.scroll) {
                this.$create("scroll", links, { offset: this.offset });
              }
            }
          },
          observe: [intersection(), scroll$1()],
          update: [
            {
              read() {
                const targets = this.links.map(getTargetedElement).filter(Boolean);
                const { length } = targets;
                if (!length || !isVisible(this.$el)) {
                  return false;
                }
                const scrollElement = scrollParent(targets, true);
                const { scrollTop, scrollHeight } = scrollElement;
                const viewport = offsetViewport(scrollElement);
                const max = scrollHeight - viewport.height;
                let active = false;
                if (scrollTop === max) {
                  active = length - 1;
                } else {
                  for (let i = 0; i < targets.length; i++) {
                    const fixedEl = getCoveringElement(targets[i]);
                    const offsetBy = this.offset + (fixedEl ? offset(fixedEl).height : 0);
                    if (offset(targets[i]).top - viewport.top - offsetBy > 0) {
                      break;
                    }
                    active = +i;
                  }
                  if (active === false && this.overflow) {
                    active = 0;
                  }
                }
                return { active };
              },
              write({ active }) {
                const changed = active !== false && !hasClass(this.elements[active], this.cls);
                this.links.forEach((el) => el.blur());
                for (let i = 0; i < this.elements.length; i++) {
                  toggleClass(this.elements[i], this.cls, +i === active);
                }
                if (changed) {
                  trigger(this.$el, "active", [active, this.elements[active]]);
                }
              },
              events: ["scroll", "resize"]
            }
          ]
        };

        var sticky = {
          mixins: [Class, Media],
          props: {
            position: String,
            top: null,
            bottom: null,
            start: null,
            end: null,
            offset: String,
            overflowFlip: Boolean,
            animation: String,
            clsActive: String,
            clsInactive: String,
            clsFixed: String,
            clsBelow: String,
            selTarget: String,
            showOnUp: Boolean,
            targetOffset: Number
          },
          data: {
            position: "top",
            top: false,
            bottom: false,
            start: false,
            end: false,
            offset: 0,
            overflowFlip: false,
            animation: "",
            clsActive: "uk-active",
            clsInactive: "",
            clsFixed: "uk-sticky-fixed",
            clsBelow: "uk-sticky-below",
            selTarget: "",
            showOnUp: false,
            targetOffset: false
          },
          computed: {
            selTarget: ({ selTarget }, $el) => selTarget && $(selTarget, $el) || $el
          },
          connected() {
            this.start = coerce(this.start || this.top);
            this.end = coerce(this.end || this.bottom);
            this.placeholder = $("+ .uk-sticky-placeholder", this.$el) || $('<div class="uk-sticky-placeholder"></div>');
            this.isFixed = false;
            this.setActive(false);
          },
          beforeDisconnect() {
            if (this.isFixed) {
              this.hide();
              removeClass(this.selTarget, this.clsInactive);
            }
            reset(this.$el);
            remove$1(this.placeholder);
            this.placeholder = null;
          },
          observe: [
            viewport(),
            scroll$1({ target: () => document.scrollingElement }),
            resize({ target: ({ $el }) => [$el, document.scrollingElement] })
          ],
          events: [
            {
              name: "load hashchange popstate",
              el() {
                return window;
              },
              filter() {
                return this.targetOffset !== false;
              },
              handler() {
                const { scrollingElement } = document;
                if (!location.hash || scrollingElement.scrollTop === 0) {
                  return;
                }
                setTimeout(() => {
                  const targetOffset = offset($(location.hash));
                  const elOffset = offset(this.$el);
                  if (this.isFixed && intersectRect(targetOffset, elOffset)) {
                    scrollingElement.scrollTop = targetOffset.top - elOffset.height - toPx(this.targetOffset, "height", this.placeholder) - toPx(this.offset, "height", this.placeholder);
                  }
                });
              }
            },
            {
              name: "transitionstart",
              handler() {
                this.transitionInProgress = once(
                  this.$el,
                  "transitionend transitioncancel",
                  () => this.transitionInProgress = null
                );
              }
            }
          ],
          update: [
            {
              read({ height: height$1, width, margin, sticky }) {
                this.inactive = !this.matchMedia || !isVisible(this.$el);
                if (this.inactive) {
                  return;
                }
                const hide = this.isFixed && !this.transitionInProgress;
                if (hide) {
                  preventTransition(this.$el);
                  this.hide();
                }
                if (!this.active) {
                  ({ height: height$1, width } = offset(this.$el));
                  margin = css(this.$el, "margin");
                }
                if (hide) {
                  this.show();
                }
                const viewport2 = toPx("100vh", "height");
                const dynamicViewport = height(window);
                const maxScrollHeight = Math.max(
                  0,
                  document.scrollingElement.scrollHeight - viewport2
                );
                let position = this.position;
                if (this.overflowFlip && height$1 > viewport2) {
                  position = position === "top" ? "bottom" : "top";
                }
                const referenceElement = this.isFixed ? this.placeholder : this.$el;
                let offset$1 = toPx(this.offset, "height", sticky ? this.$el : referenceElement);
                if (position === "bottom" && (height$1 < dynamicViewport || this.overflowFlip)) {
                  offset$1 += dynamicViewport - height$1;
                }
                const overflow = this.overflowFlip ? 0 : Math.max(0, height$1 + offset$1 - viewport2);
                const topOffset = offset(referenceElement).top;
                const elHeight = offset(this.$el).height;
                const start = (this.start === false ? topOffset : parseProp(this.start, this.$el, topOffset)) - offset$1;
                const end = this.end === false ? maxScrollHeight : Math.min(
                  maxScrollHeight,
                  parseProp(this.end, this.$el, topOffset + height$1, true) - elHeight - offset$1 + overflow
                );
                sticky = maxScrollHeight && !this.showOnUp && start + offset$1 === topOffset && end === Math.min(
                  maxScrollHeight,
                  parseProp("!*", this.$el, 0, true) - elHeight - offset$1 + overflow
                ) && css(parent(this.$el), "overflowY") === "visible";
                return {
                  start,
                  end,
                  offset: offset$1,
                  overflow,
                  topOffset,
                  height: height$1,
                  elHeight,
                  width,
                  margin,
                  top: offsetPosition(referenceElement)[0],
                  sticky
                };
              },
              write({ height, width, margin, offset, sticky }) {
                if (this.inactive || sticky || !this.isFixed) {
                  reset(this.$el);
                }
                if (this.inactive) {
                  return;
                }
                if (sticky) {
                  height = width = margin = 0;
                  css(this.$el, { position: "sticky", top: offset });
                }
                const { placeholder } = this;
                css(placeholder, { height, width, margin });
                if (!document.contains(placeholder)) {
                  placeholder.hidden = true;
                }
                (sticky ? before : after)(this.$el, placeholder);
              },
              events: ["resize"]
            },
            {
              read({
                scroll: prevScroll = 0,
                dir: prevDir = "down",
                overflow,
                overflowScroll = 0,
                start,
                end
              }) {
                const scroll2 = document.scrollingElement.scrollTop;
                const dir = prevScroll <= scroll2 ? "down" : "up";
                return {
                  dir,
                  prevDir,
                  scroll: scroll2,
                  prevScroll,
                  offsetParentTop: offset(
                    (this.isFixed ? this.placeholder : this.$el).offsetParent
                  ).top,
                  overflowScroll: clamp(
                    overflowScroll + clamp(scroll2, start, end) - clamp(prevScroll, start, end),
                    0,
                    overflow
                  )
                };
              },
              write(data, types) {
                const isScrollUpdate = types.has("scroll");
                const {
                  initTimestamp = 0,
                  dir,
                  prevDir,
                  scroll: scroll2,
                  prevScroll = 0,
                  top,
                  start,
                  topOffset,
                  height
                } = data;
                if (scroll2 < 0 || scroll2 === prevScroll && isScrollUpdate || this.showOnUp && !isScrollUpdate && !this.isFixed) {
                  return;
                }
                const now = Date.now();
                if (now - initTimestamp > 300 || dir !== prevDir) {
                  data.initScroll = scroll2;
                  data.initTimestamp = now;
                }
                if (this.showOnUp && !this.isFixed && Math.abs(data.initScroll - scroll2) <= 30 && Math.abs(prevScroll - scroll2) <= 10) {
                  return;
                }
                if (this.inactive || scroll2 < start || this.showOnUp && (scroll2 <= start || dir === "down" && isScrollUpdate || dir === "up" && !this.isFixed && scroll2 <= topOffset + height)) {
                  if (!this.isFixed) {
                    if (Animation.inProgress(this.$el) && top > scroll2) {
                      Animation.cancel(this.$el);
                      this.hide();
                    }
                    return;
                  }
                  if (this.animation && scroll2 > topOffset) {
                    if (hasClass(this.$el, "uk-animation-leave")) {
                      return;
                    }
                    Animation.out(this.$el, this.animation).then(() => this.hide(), noop);
                  } else {
                    this.hide();
                  }
                } else if (this.isFixed) {
                  this.update();
                } else if (this.animation && scroll2 > topOffset) {
                  this.show();
                  Animation.in(this.$el, this.animation).catch(noop);
                } else {
                  preventTransition(this.selTarget);
                  this.show();
                }
              },
              events: ["resize", "resizeViewport", "scroll"]
            }
          ],
          methods: {
            show() {
              this.isFixed = true;
              this.update();
              this.placeholder.hidden = false;
            },
            hide() {
              const { offset, sticky } = this._data;
              this.setActive(false);
              removeClass(this.$el, this.clsFixed, this.clsBelow);
              if (sticky) {
                css(this.$el, "top", offset);
              } else {
                css(this.$el, {
                  position: "",
                  top: "",
                  width: "",
                  marginTop: ""
                });
              }
              this.placeholder.hidden = true;
              this.isFixed = false;
            },
            update() {
              let {
                width,
                scroll: scroll2 = 0,
                overflow,
                overflowScroll = 0,
                start,
                end,
                offset,
                topOffset,
                height,
                elHeight,
                offsetParentTop,
                sticky
              } = this._data;
              const active = start !== 0 || scroll2 > start;
              if (!sticky) {
                let position = "fixed";
                if (scroll2 > end) {
                  offset += end - offsetParentTop + overflowScroll - overflow;
                  position = "absolute";
                }
                css(this.$el, { position, width, marginTop: 0 }, "important");
              }
              css(this.$el, "top", offset - overflowScroll);
              this.setActive(active);
              toggleClass(
                this.$el,
                this.clsBelow,
                scroll2 > topOffset + (sticky ? Math.min(height, elHeight) : height)
              );
              addClass(this.$el, this.clsFixed);
            },
            setActive(active) {
              const prev = this.active;
              this.active = active;
              if (active) {
                replaceClass(this.selTarget, this.clsInactive, this.clsActive);
                prev !== active && trigger(this.$el, "active");
              } else {
                replaceClass(this.selTarget, this.clsActive, this.clsInactive);
                prev !== active && trigger(this.$el, "inactive");
              }
            }
          }
        };
        function parseProp(value, el, propOffset, padding) {
          if (!value) {
            return 0;
          }
          if (isNumeric(value) || isString(value) && value.match(/^-?\d/)) {
            return propOffset + toPx(value, "height", el, true);
          } else {
            const refElement = value === true ? parent(el) : query(value, el);
            return offset(refElement).bottom - (padding && (refElement == null ? void 0 : refElement.contains(el)) ? toFloat(css(refElement, "paddingBottom")) : 0);
          }
        }
        function coerce(value) {
          if (value === "true") {
            return true;
          } else if (value === "false") {
            return false;
          }
          return value;
        }
        function reset(el) {
          css(el, { position: "", top: "", marginTop: "", width: "" });
        }
        function preventTransition(el) {
          addClass(el, "uk-transition-disable");
          requestAnimationFrame(() => removeClass(el, "uk-transition-disable"));
        }

        var svg = {
          mixins: [Svg],
          args: "src",
          props: {
            src: String,
            icon: String,
            attributes: "list",
            strokeAnimation: Boolean
          },
          data: {
            strokeAnimation: false
          },
          observe: [
            mutation({
              async handler() {
                const svg = await this.svg;
                if (svg) {
                  applyAttributes.call(this, svg);
                }
              },
              options: {
                attributes: true,
                attributeFilter: ["id", "class", "style"]
              }
            })
          ],
          async connected() {
            if (includes(this.src, "#")) {
              [this.src, this.icon] = this.src.split("#");
            }
            const svg = await this.svg;
            if (svg) {
              applyAttributes.call(this, svg);
              if (this.strokeAnimation) {
                applyAnimation(svg);
              }
            }
          },
          methods: {
            async getSvg() {
              if (isTag(this.$el, "img") && !this.$el.complete && this.$el.loading === "lazy") {
                return new Promise(
                  (resolve) => once(this.$el, "load", () => resolve(this.getSvg()))
                );
              }
              return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject("SVG not found.");
            }
          }
        };
        function applyAttributes(el) {
          const { $el } = this;
          addClass(el, attr($el, "class"), "uk-svg");
          for (let i = 0; i < $el.style.length; i++) {
            const prop = $el.style[i];
            css(el, prop, css($el, prop));
          }
          for (const attribute in this.attributes) {
            const [prop, value] = this.attributes[attribute].split(":", 2);
            attr(el, prop, value);
          }
          if (!this.$el.id) {
            removeAttr(el, "id");
          }
        }
        const loadSVG = memoize(async (src) => {
          if (src) {
            if (startsWith(src, "data:")) {
              return decodeURIComponent(src.split(",")[1]);
            } else {
              return (await fetch(src)).text();
            }
          } else {
            return Promise.reject();
          }
        });
        function parseSVG(svg, icon) {
          if (icon && includes(svg, "<symbol")) {
            svg = parseSymbols(svg)[icon] || svg;
          }
          svg = $(svg.substr(svg.indexOf("<svg")));
          return (svg == null ? void 0 : svg.hasChildNodes()) && svg;
        }
        const symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
        const parseSymbols = memoize(function(svg) {
          const symbols = {};
          symbolRe.lastIndex = 0;
          let match;
          while (match = symbolRe.exec(svg)) {
            symbols[match[3]] = `<svg ${match[1]}svg>`;
          }
          return symbols;
        });
        function applyAnimation(el) {
          const length = getMaxPathLength(el);
          if (length) {
            css(el, "--uk-animation-stroke", length);
          }
        }

        const selDisabled = ".uk-disabled *, .uk-disabled, [disabled]";
        var Switcher = {
          mixins: [Togglable],
          args: "connect",
          props: {
            connect: String,
            toggle: String,
            itemNav: String,
            active: Number,
            followFocus: Boolean,
            swiping: Boolean
          },
          data: {
            connect: "~.uk-switcher",
            toggle: "> * > :first-child",
            itemNav: false,
            active: 0,
            cls: "uk-active",
            attrItem: "uk-switcher-item",
            selVertical: ".uk-nav",
            followFocus: false,
            swiping: true
          },
          computed: {
            connects: ({ connect }, $el) => queryAll(connect, $el),
            connectChildren() {
              return this.connects.map((el) => children(el)).flat();
            },
            toggles: ({ toggle }, $el) => $$(toggle, $el),
            children(_, $el) {
              return children($el).filter(
                (child) => this.toggles.some((toggle) => child.contains(toggle))
              );
            }
          },
          watch: {
            connects(connects) {
              if (this.swiping) {
                css(connects, "touchAction", "pan-y pinch-zoom");
              }
              this.$emit();
            },
            connectChildren() {
              let index = Math.max(0, this.index());
              for (const el of this.connects) {
                children(el).forEach((child, i) => toggleClass(child, this.cls, i === index));
              }
              this.$emit();
            },
            toggles(toggles) {
              this.$emit();
              const active = this.index();
              this.show(~active ? active : toggles[this.active] || toggles[0]);
            }
          },
          connected() {
            attr(this.$el, "role", "tablist");
          },
          observe: [
            lazyload({ targets: ({ connectChildren }) => connectChildren }),
            swipe({ target: ({ connects }) => connects, filter: ({ swiping }) => swiping })
          ],
          events: [
            {
              name: "click keydown",
              delegate() {
                return this.toggle;
              },
              handler(e) {
                if (!matches(e.current, selDisabled) && (e.type === "click" || e.keyCode === keyMap.SPACE)) {
                  e.preventDefault();
                  this.show(e.current);
                }
              }
            },
            {
              name: "keydown",
              delegate() {
                return this.toggle;
              },
              handler(e) {
                const { current, keyCode } = e;
                const isVertical = matches(this.$el, this.selVertical);
                let i = keyCode === keyMap.HOME ? 0 : keyCode === keyMap.END ? "last" : keyCode === keyMap.LEFT && !isVertical || keyCode === keyMap.UP && isVertical ? "previous" : keyCode === keyMap.RIGHT && !isVertical || keyCode === keyMap.DOWN && isVertical ? "next" : -1;
                if (~i) {
                  e.preventDefault();
                  const toggles = this.toggles.filter((el) => !matches(el, selDisabled));
                  const next = toggles[getIndex(i, toggles, toggles.indexOf(current))];
                  next.focus();
                  if (this.followFocus) {
                    this.show(next);
                  }
                }
              }
            },
            {
              name: "click",
              el() {
                return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);
              },
              delegate() {
                return `[${this.attrItem}],[data-${this.attrItem}]`;
              },
              handler(e) {
                if (e.target.closest("a,button")) {
                  e.preventDefault();
                  this.show(data(e.current, this.attrItem));
                }
              }
            },
            {
              name: "swipeRight swipeLeft",
              filter() {
                return this.swiping;
              },
              el() {
                return this.connects;
              },
              handler({ type }) {
                this.show(endsWith(type, "Left") ? "next" : "previous");
              }
            }
          ],
          update() {
            var _a;
            attr(this.connects, "role", "presentation");
            attr(children(this.$el), "role", "presentation");
            for (const index in this.toggles) {
              const toggle = this.toggles[index];
              const item = (_a = this.connects[0]) == null ? void 0 : _a.children[index];
              attr(toggle, "role", "tab");
              if (!item) {
                continue;
              }
              toggle.id = generateId(this, toggle);
              item.id = generateId(this, item);
              attr(toggle, "aria-controls", item.id);
              attr(item, { role: "tabpanel", "aria-labelledby": toggle.id });
            }
            attr(this.$el, "aria-orientation", matches(this.$el, this.selVertical) ? "vertical" : null);
          },
          methods: {
            index() {
              return findIndex(this.children, (el) => hasClass(el, this.cls));
            },
            show(item) {
              const toggles = this.toggles.filter((el) => !matches(el, selDisabled));
              const prev = this.index();
              const next = getIndex(
                !isNode(item) || includes(toggles, item) ? item : 0,
                toggles,
                getIndex(this.toggles[prev], toggles)
              );
              const active = getIndex(toggles[next], this.toggles);
              this.children.forEach((child, i) => {
                toggleClass(child, this.cls, active === i);
                attr(this.toggles[i], {
                  "aria-selected": active === i,
                  tabindex: active === i ? null : -1
                });
              });
              const animate = prev >= 0 && prev !== next;
              this.connects.forEach(async ({ children: children2 }) => {
                const actives = toArray(children2).filter(
                  (child, i) => i !== active && hasClass(child, this.cls)
                );
                await this.toggleElement(actives, false, animate);
                await this.toggleElement(children2[active], true, animate);
              });
            }
          }
        };

        var tab = {
          mixins: [Class],
          extends: Switcher,
          props: {
            media: Boolean
          },
          data: {
            media: 960,
            attrItem: "uk-tab-item",
            selVertical: ".uk-tab-left,.uk-tab-right"
          },
          connected() {
            const cls = hasClass(this.$el, "uk-tab-left") ? "uk-tab-left" : hasClass(this.$el, "uk-tab-right") ? "uk-tab-right" : false;
            if (cls) {
              this.$create("toggle", this.$el, { cls, mode: "media", media: this.media });
            }
          }
        };

        const KEY_SPACE = 32;
        var toggle = {
          mixins: [Media, Togglable],
          args: "target",
          props: {
            href: String,
            target: null,
            mode: "list",
            queued: Boolean
          },
          data: {
            href: false,
            target: false,
            mode: "click",
            queued: true
          },
          computed: {
            target({ target }, $el) {
              target = queryAll(target || $el.hash, $el);
              return target.length ? target : [$el];
            }
          },
          connected() {
            if (!includes(this.mode, "media")) {
              if (!isFocusable(this.$el)) {
                attr(this.$el, "tabindex", "0");
              }
              if (!this.cls && isTag(this.$el, "a")) {
                attr(this.$el, "role", "button");
              }
            }
          },
          observe: lazyload({ target: ({ target }) => target }),
          events: [
            {
              name: pointerDown$1,
              filter() {
                return includes(this.mode, "hover");
              },
              handler(e) {
                this._preventClick = null;
                if (!isTouch(e) || isBoolean(this._showState) || this.$el.disabled) {
                  return;
                }
                trigger(this.$el, "focus");
                once(
                  document,
                  pointerDown$1,
                  () => trigger(this.$el, "blur"),
                  true,
                  (e2) => !this.$el.contains(e2.target)
                );
                if (includes(this.mode, "click")) {
                  this._preventClick = true;
                }
              }
            },
            {
              // mouseenter mouseleave are added because of Firefox bug,
              // where pointerleave is triggered immediately after pointerenter on scroll
              name: `mouseenter mouseleave ${pointerEnter} ${pointerLeave} focus blur`,
              filter() {
                return includes(this.mode, "hover");
              },
              handler(e) {
                if (isTouch(e) || this.$el.disabled) {
                  return;
                }
                const show = includes(["mouseenter", pointerEnter, "focus"], e.type);
                const expanded = this.isToggled(this.target);
                if (!show && (!isBoolean(this._showState) || e.type !== "blur" && matches(this.$el, ":focus") || e.type === "blur" && matches(this.$el, ":hover"))) {
                  if (expanded === this._showState) {
                    this._showState = null;
                  }
                  return;
                }
                if (show && isBoolean(this._showState) && expanded !== this._showState) {
                  return;
                }
                this._showState = show ? expanded : null;
                this.toggle(`toggle${show ? "show" : "hide"}`);
              }
            },
            {
              name: "keydown",
              filter() {
                return includes(this.mode, "click") && !isTag(this.$el, "input");
              },
              handler(e) {
                if (e.keyCode === KEY_SPACE) {
                  e.preventDefault();
                  this.$el.click();
                }
              }
            },
            {
              name: "click",
              filter() {
                return ["click", "hover"].some((mode) => includes(this.mode, mode));
              },
              handler(e) {
                let link;
                if (this._preventClick || e.target.closest('a[href="#"], a[href=""]') || (link = e.target.closest("a[href]")) && (!this.isToggled(this.target) || link.hash && matches(this.target, link.hash))) {
                  e.preventDefault();
                }
                if (!this._preventClick && includes(this.mode, "click")) {
                  this.toggle();
                }
              }
            },
            {
              name: "mediachange",
              filter() {
                return includes(this.mode, "media");
              },
              el() {
                return this.target;
              },
              handler(e, mediaObj) {
                if (mediaObj.matches ^ this.isToggled(this.target)) {
                  this.toggle();
                }
              }
            }
          ],
          methods: {
            async toggle(type) {
              if (!trigger(this.target, type || "toggle", [this])) {
                return;
              }
              if (hasAttr(this.$el, "aria-expanded")) {
                attr(this.$el, "aria-expanded", !this.isToggled(this.target));
              }
              if (!this.queued) {
                return this.toggleElement(this.target);
              }
              const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));
              if (leaving.length) {
                for (const el of this.target) {
                  const isLeaving = includes(leaving, el);
                  this.toggleElement(el, isLeaving, isLeaving);
                }
                return;
              }
              const toggled = this.target.filter(this.isToggled);
              if (await this.toggleElement(toggled, false)) {
                await this.toggleElement(
                  this.target.filter((el) => !includes(toggled, el)),
                  true
                );
              }
            }
          }
        };

        var components = /*#__PURE__*/Object.freeze({
            __proto__: null,
            Accordion: Accordion,
            Alert: alert,
            Close: Close,
            Cover: cover,
            Drop: drop,
            DropParentIcon: IconComponent,
            Dropdown: drop,
            Dropnav: Dropnav,
            FormCustom: formCustom,
            Grid: grid,
            HeightMatch: heightMatch,
            HeightViewport: heightViewport,
            Icon: Icon,
            Img: img,
            Leader: leader,
            Margin: Margin,
            Marker: Marker,
            Modal: modal,
            Nav: nav,
            NavParentIcon: NavParentIcon,
            Navbar: navbar,
            NavbarParentIcon: IconComponent,
            NavbarToggleIcon: NavbarToggleIcon,
            Offcanvas: offcanvas,
            OverflowAuto: overflowAuto,
            OverlayIcon: IconComponent,
            PaginationNext: PaginationNext,
            PaginationPrevious: PaginationPrevious,
            Responsive: responsive,
            Scroll: scroll,
            Scrollspy: scrollspy,
            ScrollspyNav: scrollspyNav,
            SearchIcon: Search,
            SlidenavNext: Slidenav,
            SlidenavPrevious: Slidenav,
            Spinner: Spinner,
            Sticky: sticky,
            Svg: svg,
            Switcher: Switcher,
            Tab: tab,
            Toggle: toggle,
            Totop: Totop,
            Video: Video
        });

        each(components, (component, name) => App.component(name, component));
        boot(App);

        each(components$1, (component, name) => App.component(name, component));

        return App;

    }));
    });

    function notify_success(s) {
        uikit.notification({
            message: `<span uk-icon=\'icon: check\'></span> ${s}`,
            pos: 'bottom-center',
            status: 'success',
            timeout: 3000
        });
    }
    function notify_error(s) {
        uikit.notification({
            message: `<span uk-icon=\'icon: warning\'></span> ${s}`,
            pos: 'bottom-center',
            status: 'error',
            timeout: 10000
        });
    }

    var Level;
    (function (Level) {
        Level["Warn"] = "Warn";
        Level["Error"] = "Error";
    })(Level || (Level = {}));
    // error logging to terminal and text file
    const logger = async (level, msg) => {
        i$1("log_this", {
            level,
            msg,
        });
    };

    var ErrMap;
    (function (ErrMap) {
        ErrMap[ErrMap["NoClientCx"] = 404] = "NoClientCx";
        ErrMap[ErrMap["AccountDNE"] = 1004] = "AccountDNE";
        ErrMap[ErrMap["InsufficientBalance"] = 12015] = "InsufficientBalance";
        ErrMap[ErrMap["WrongDifficulty"] = 130102] = "WrongDifficulty";
        ErrMap[ErrMap["TooManyProofs"] = 130108] = "TooManyProofs";
        ErrMap[ErrMap["Discontinuity"] = 130109] = "Discontinuity";
        ErrMap[ErrMap["InvalidProof"] = 130110] = "InvalidProof";
    })(ErrMap || (ErrMap = {}));
    // let list_errors: CarpeError;
    const carpeErrorLog = writable([]);
    function raise_error(err, quiet = false, caller) {
        let hasCustomErrorDisplay = false;
        // maybe we need to take an action on this error type
        if (err.category) { // check this is the expected type
            // errAction(event.paylod);
            hasCustomErrorDisplay = errAction(err);
            err.msg = `${caller}: ${err.msg}`;
            console.log(err);
        }
        else {
            console.log(`WARN: ${caller}: error type returned is not a CarpeError. Payload: ${err}`);
        }
        let list = get_store_value(carpeErrorLog);
        list.push(err);
        carpeErrorLog.set(list);
        console.log(list);
        let display = `Error (${err.uid}): ${err.msg}`;
        if (!quiet && !hasCustomErrorDisplay) {
            notify_error(display);
        }
        logger(Level.Error, err.msg);
    }
    function clearErrors() {
        carpeErrorLog.set([]);
    }
    // returns true if there is a UI for the error, so we know to display generic error notification.
    const errAction = (err) => {
        switch (err.uid) {
            case ErrMap.NoClientCx:
                // window.alert("no client connection");
                return false; // todo
            case ErrMap.AccountDNE:
                // window.alert("account does not exist");
                return false; //todo
            case ErrMap.WrongDifficulty:
                // window.alert("wrong difficulty");
                displayWrongDifficulty.set(err);
                break;
            case ErrMap.TooManyProofs:
                displayTooManyProofs.set(err);
                // window.alert("too many proofs submitted in epoch");
                break;
            case ErrMap.Discontinuity:
                displayDiscontinuity.set(err);
                // window.alert("your proofs are not chained. Perhaps some proofs have not been sent?");
                break;
            // TODO: this last one may never/rarely occur. 
            case ErrMap.InvalidProof:
                // window.alert("proof does not verify");
                displayInvalidProof.set(err);
                break;
            case ErrMap.InsufficientBalance:
                // window.alert("insufficient balance");
                displayInsufficientBalance.set(err);
                break;
            default:
                return false;
        }
        return true;
    };

    const responses = writable("");
    const debugMode = writable(false);
    // set the Environment to debug or test
    function setDebugProdTest(env) {
        i$1("set_env", { env: env })
            .then((res) => {
            notify_success(`switched to ${res} mode`);
            nodeEnv.set(res);
        })
            .catch((error) => raise_error(error, false, "setDebugProdTest"));
    }
    const nodeEnv = writable("");
    const nodeEnvIsTest = writable(false);
    // helper to figure out what environment we are in TEST/PROD
    function getEnv() {
        console.log("getEnv");
        i$1("get_env", {})
            .then((res) => {
            console.log("get env");
            console.log(res);
            nodeEnv.set(res);
            if (res == "test") {
                nodeEnvIsTest.set(true);
            }
        })
            .catch((error) => raise_error(error, false, "getEnv"));
    }
    function debugModeToggle() {
        debugMode.set(!get_store_value(debugMode));
    }

    const tower = writable({});
    // is set to true if when the app starts and Rust emits the backlog-listener-ready event.
    const backlogListenerReady = writable(false);
    // is set to true when the user toggles the miner-toggle
    // is set to false when the user manually sets to off, or the mineOnce async invocation returns error.
    const minerLoopEnabled = writable(false);
    // is set to true when the window.emit event is received
    // is set to false when a new proof starts
    const minerEventReceived = writable(false);
    // is set to true when the asyc MineOnce returns a proof
    // is set to false when a new proof starts 
    const minerProofComplete = writable(false);
    // is set to true when a backlog event is emmitted, or invoking the async backlog command
    // is set to false when a backlog-success or -fail event is received 
    const backlogInProgress = writable(false);
    // is set to true when a backlog-success event is emmitted from rust, or when the async invoked command returns
    // is set to false when a backlog-fail event is received 
    const backlogSubmitted = writable(false);
    // TODO:
    const isTowerNewbie = writable(false);

    const loadAccounts = async () => {
        // fetch data from local DB
        return i$1('get_all_accounts')
            .then((result) => {
            all_accounts.set(result.accounts);
            if (get_store_value(signingAccount).account == "" && result.accounts.length > 0) {
                // set initial signingAccount
                let first = result.accounts[0];
                setAccount(first.account, false);
            }
            if (!get_store_value(isAccountsLoaded)) {
                isAccountsLoaded.set(true);
            }
            updateMakeWhole(result.accounts);
            // fetch data from the chain
            return refreshAccounts();
        })
            .catch((error) => raise_error(error, false, "loadAccounts"));
    };
    const refreshAccounts = async () => {
        isRefreshingAccounts.set(true);
        return i$1('refresh_accounts')
            .then((result) => {
            all_accounts.set(result.accounts);
            result.accounts.forEach(el => {
                tryRefreshSignerAccount(el);
            });
            isRefreshingAccounts.set(false);
        })
            .catch(_ => {
            isRefreshingAccounts.set(false);
        });
    };
    function tryRefreshSignerAccount(newData) {
        let a = get_store_value(signingAccount).account;
        if (newData.account == a) {
            signingAccount.set(newData);
        }
    }
    const isCarpeInit = async () => {
        i$1("is_init", {})
            .then((res) => {
            responses.set(res.toString());
            isInit.set(res);
        })
            .catch((e) => raise_error(e, false, "isCarpeInit"));
    };
    function findOneAccount(account) {
        let list = get_store_value(all_accounts);
        let found = list.find((i) => i.account == account);
        return found;
    }
    const setAccount = async (an_address, notifySucess = true) => {
        if (get_store_value(signingAccount).account == an_address) {
            return;
        }
        // cannot switch profile with miner running
        if (get_store_value(minerLoopEnabled)) {
            notify_error("To switch accounts you need to turn miner off first.");
            return;
        }
        let a = findOneAccount(an_address);
        // optimistic switch
        let previous = get_store_value(signingAccount);
        signingAccount.set(a);
        // reset user data
        tower.set({});
        mnem.set("");
        // initi account events for better UX
        getAccountEvents(a, () => { });
        i$1("switch_profile", {
            account: a.account,
        })
            .then((res) => {
            responses.set(res);
            if (notifySucess) {
                notify_success("Account switched to " + a.nickname);
            }
        })
            .catch((e) => {
            raise_error(e, false, "setAccount");
            // fallback optimistic change
            signingAccount.set(previous);
        });
    };
    function addNewAccount(account) {
        let list = get_store_value(all_accounts);
        // account.on_chain = false;
        list.push(account);
        all_accounts.set(list);
    }
    function checkSigningAccountBalance() {
        let selected = get_store_value(signingAccount);
        i$1('query_balance', { account: selected.account })
            .then((balance) => {
            // update signingAccount
            selected.on_chain = true;
            selected.balance = Number(balance);
            signingAccount.set(selected);
            // update all accounts set
            let list = get_store_value(all_accounts).map(each => {
                if (each.account == selected.account) {
                    each.on_chain = true;
                    each.balance = Number(balance);
                }
                return each;
            });
            all_accounts.set(list);
        })
            .catch((e) => raise_error(e, false, "checkSigningAccountBalance"));
    }
    function getAccountEvents(account, errorCallback = null) {
        account.account;
        if (!account.on_chain) {
            return errorCallback && errorCallback("account_not_on_chain");
        }
        return;
        /*
        invoke('get_account_events', {account: address.toUpperCase()})
          .then((events: Array<T>) => {
            let all = get(accountEvents);
            all[address] = events
              .sort((a, b) => (a.transaction_version < b.transaction_version)
                ? 1
                : (b.transaction_version < a.transaction_version)
                  ? -1
                  : 0
              );
            accountEvents.set(all);
          })
          .catch(e => {
            if (errorCallback) {
              errorCallback(e.msg);
            } else {
              raise_error(e, false, "getAccountEvents");
            }
          });
          */
    }
    /*
    export let invoke_makewhole = async (account: String): Promise<number> => {
     // let demo_account = "613b6d9599f72134a4fa20bba4c75c36";
     // account = demo_account;
      
      console.log(">>> calling make whole");
      return await invoke("query_makewhole", { account })
        .then((a) => {
          if (a.length > 0) {
            console.log("MakeWhole " + account + ", coins: " + a[0].coins.value)
            console.log(a)
          }
          console.log(a);
          return a[0].coins.value
        })
    }
    */
    function updateMakeWhole(accounts) {
        let mk = get_store_value(makeWhole);
        accounts.forEach(each => {
            let account = each.account;
            if (mk[account] == null) {
                console.log(">>> query_makewhole called");
                i$1("query_makewhole", { account })
                    .then((credits) => {
                    mk[account] = credits;
                    makeWhole.set(mk);
                });
            }
        });
    }
    /*
      Function to claim coins credit from makewhole
    */
    function claimMakeWhole(account, callback = null) {
        // account to claim must be the signingAccount
        if (get_store_value(signingAccount).account != account) {
            if (get_store_value(minerLoopEnabled)) {
                return callback("To claim coins you need to turn miner off first.");
            }
            else {
                // set sigining account
                setAccount(account, false);
            }
        }
        let mk = get_store_value(makeWhole);
        i$1('claim_make_whole', { account })
            .then(() => {
            // update account make_whole status
            let accountCredits = mk[account];
            mk[account] = accountCredits.map(each => { each.claimed = true; return each; });
            makeWhole.set(mk);
            // update account balance
            checkSigningAccountBalance();
            callback(null);
        })
            .catch(e => {
            if (callback) {
                callback(e.msg);
            }
            else {
                raise_error(e, false, "claim_make_whole");
            }
        });
    }

    // This matches a subset of NamedChain enum in Rust.
    var Networks;
    (function (Networks) {
        Networks["MAINNET"] = "MAINNET";
        Networks["TESTNET"] = "TESTNET";
        Networks["TESTING"] = "TESTING";
    })(Networks || (Networks = {}));
    const network_profile = writable({
        chain_id: Networks.MAINNET,
        urls: ["string"],
        waypoint: "string",
        profile: "string",
    });
    const connected = writable(true);
    const scanning_fullnodes = writable(true);
    function setNetwork(network) {
        i$1("toggle_network", { network: Networks[network] })
            .then((res) => {
            network_profile.set(res);
            // update accounts from current network
            loadAccounts(); // TODO notify as an event dependency
        })
            .catch((error) => raise_error(error, false, "setNetwork"));
    }
    function getNetwork() {
        i$1("get_networks", {})
            .then((res) => network_profile.set(res))
            .catch((error) => raise_error(error, false, "getNetwork"));
    }
    const refreshWaypoint = async () => {
        console.log("refreshWaypoint");
        return i$1("refresh_waypoint", {})
            .then((res) => {
            network_profile.set(res);
            connected.set(true);
            // scanning_fullnodes.set(false);
        })
            .catch((error) => {
            connected.set(false);
            raise_error(error, true, "refreshWaypoint"); // we have a purpose-built error component for this
        });
    };
    const refreshUpstreamPeerStats = async () => {
        console.log(">>> calling refresh_upstream_peer_stats");
        return i$1("refresh_upstream_peer_stats", {})
            .then((res) => {
            console.log("update peers finished");
            // network_profile.set(res);
            connected.set(res);
            scanning_fullnodes.set(false);
        })
            .catch((error) => {
            connected.set(false);
            raise_error(error, true, "refreshUpstreamPeerStats"); // we have a purpose-built error component for this
        });
    };

    /* src/components/wallet/NetworkIcon.svelte generated by Svelte v3.59.2 */
    const file$Y = "src/components/wallet/NetworkIcon.svelte";

    // (21:0) {:else}
    function create_else_block$g(ctx) {
    	let span0;
    	let t0;
    	let span1;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			span1.textContent = "TESTNET";
    			attr_dev(span0, "uk-icon", "icon: warning");
    			add_location(span0, file$Y, 22, 2, 504);
    			add_location(span1, file$Y, 23, 2, 538);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(21:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:0) {#if !isTestNet}
    function create_if_block$u(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: user");
    			add_location(span, file$Y, 19, 2, 390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(19:0) {#if !isTestNet}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*isTestNet*/ ctx[0]) return create_if_block$u;
    		return create_else_block$g;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NetworkIcon', slots, []);
    	let isTestNet = false;
    	let unsubs;

    	onMount(async () => {
    		unsubs = network_profile.subscribe(network => {
    			$$invalidate(0, isTestNet = network.chain_id == Networks.Rex);
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NetworkIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		Networks,
    		network_profile,
    		isTestNet,
    		unsubs
    	});

    	$$self.$inject_state = $$props => {
    		if ('isTestNet' in $$props) $$invalidate(0, isTestNet = $$props.isTestNet);
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isTestNet];
    }

    class NetworkIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NetworkIcon",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    const app_version = writable({
        version: null,
        hash: null,
        head: null
    });
    function getVersion() {
        console.log("getVersion");
        i$1("get_app_version")
            .then((res) => {
            app_version.set(res);
        })
            .catch((error) => raise_error(error, true, "getVersion"));
    }

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return Object.propertyIsEnumerable.call(target, symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
    };

    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
    };

    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var ErrorKind;
    (function (ErrorKind) {
        /** Argument is unclosed (e.g. `{0`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
        /** Argument is empty (e.g. `{}`). */
        ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
        /** Argument is malformed (e.g. `{foo!}``) */
        ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
        /** Expect an argument type (e.g. `{foo,}`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
        /** Unsupported argument type (e.g. `{foo,foo}`) */
        ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
        /** Expect an argument style (e.g. `{foo, number, }`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
        /** The number skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
        /** The date time skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
        /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */
        ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
        /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */
        ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
        /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */
        ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
        /** Missing select argument options (e.g. `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
        /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Expecting a selector in `select` argument (e.g `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
        /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
        /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
        /**
         * Expecting a message fragment after the `plural` or `selectordinal` selector
         * (e.g. `{foo, plural, one}`)
         */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
        /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
        /**
         * Duplicate selectors in `plural` or `selectordinal` argument.
         * (e.g. {foo, plural, one {#} one {#}})
         */
        ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
        /** Duplicate selectors in `select` argument.
         * (e.g. {foo, select, apple {apple} apple {apple}})
         */
        ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
        /** Plural or select argument option must have `other` clause. */
        ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
        /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */
        ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
        /** The tag name is invalid. (e.g. `<123>foo</123>`) */
        ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
        /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */
        ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
        /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */
        ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
    })(ErrorKind || (ErrorKind = {}));

    var TYPE;
    (function (TYPE) {
        /**
         * Raw text
         */
        TYPE[TYPE["literal"] = 0] = "literal";
        /**
         * Variable w/o any format, e.g `var` in `this is a {var}`
         */
        TYPE[TYPE["argument"] = 1] = "argument";
        /**
         * Variable w/ number format
         */
        TYPE[TYPE["number"] = 2] = "number";
        /**
         * Variable w/ date format
         */
        TYPE[TYPE["date"] = 3] = "date";
        /**
         * Variable w/ time format
         */
        TYPE[TYPE["time"] = 4] = "time";
        /**
         * Variable w/ select format
         */
        TYPE[TYPE["select"] = 5] = "select";
        /**
         * Variable w/ plural format
         */
        TYPE[TYPE["plural"] = 6] = "plural";
        /**
         * Only possible within plural argument.
         * This is the `#` symbol that will be substituted with the count.
         */
        TYPE[TYPE["pound"] = 7] = "pound";
        /**
         * XML-like tag
         */
        TYPE[TYPE["tag"] = 8] = "tag";
    })(TYPE || (TYPE = {}));
    var SKELETON_TYPE;
    (function (SKELETON_TYPE) {
        SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
        SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
    })(SKELETON_TYPE || (SKELETON_TYPE = {}));
    /**
     * Type Guards
     */
    function isLiteralElement(el) {
        return el.type === TYPE.literal;
    }
    function isArgumentElement(el) {
        return el.type === TYPE.argument;
    }
    function isNumberElement(el) {
        return el.type === TYPE.number;
    }
    function isDateElement(el) {
        return el.type === TYPE.date;
    }
    function isTimeElement(el) {
        return el.type === TYPE.time;
    }
    function isSelectElement(el) {
        return el.type === TYPE.select;
    }
    function isPluralElement(el) {
        return el.type === TYPE.plural;
    }
    function isPoundElement(el) {
        return el.type === TYPE.pound;
    }
    function isTagElement(el) {
        return el.type === TYPE.tag;
    }
    function isNumberSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
    }
    function isDateTimeSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
    }

    // @generated from regex-gen.ts
    var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

    /**
     * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
     * with some tweaks
     */
    var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
    /**
     * Parse Date time skeleton into Intl.DateTimeFormatOptions
     * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * @public
     * @param skeleton skeleton string
     */
    function parseDateTimeSkeleton(skeleton) {
        var result = {};
        skeleton.replace(DATE_TIME_REGEX, function (match) {
            var len = match.length;
            switch (match[0]) {
                // Era
                case 'G':
                    result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                    break;
                // Year
                case 'y':
                    result.year = len === 2 ? '2-digit' : 'numeric';
                    break;
                case 'Y':
                case 'u':
                case 'U':
                case 'r':
                    throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
                // Quarter
                case 'q':
                case 'Q':
                    throw new RangeError('`q/Q` (quarter) patterns are not supported');
                // Month
                case 'M':
                case 'L':
                    result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
                    break;
                // Week
                case 'w':
                case 'W':
                    throw new RangeError('`w/W` (week) patterns are not supported');
                case 'd':
                    result.day = ['numeric', '2-digit'][len - 1];
                    break;
                case 'D':
                case 'F':
                case 'g':
                    throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
                // Weekday
                case 'E':
                    result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';
                    break;
                case 'e':
                    if (len < 4) {
                        throw new RangeError('`e..eee` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                case 'c':
                    if (len < 4) {
                        throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                // Period
                case 'a': // AM, PM
                    result.hour12 = true;
                    break;
                case 'b': // am, pm, noon, midnight
                case 'B': // flexible day periods
                    throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
                // Hour
                case 'h':
                    result.hourCycle = 'h12';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'H':
                    result.hourCycle = 'h23';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'K':
                    result.hourCycle = 'h11';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'k':
                    result.hourCycle = 'h24';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'j':
                case 'J':
                case 'C':
                    throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
                // Minute
                case 'm':
                    result.minute = ['numeric', '2-digit'][len - 1];
                    break;
                // Second
                case 's':
                    result.second = ['numeric', '2-digit'][len - 1];
                    break;
                case 'S':
                case 'A':
                    throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
                // Zone
                case 'z': // 1..3, 4: specific non-location format
                    result.timeZoneName = len < 4 ? 'short' : 'long';
                    break;
                case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
                case 'O': // 1, 4: miliseconds in day short, long
                case 'v': // 1, 4: generic non-location format
                case 'V': // 1, 2, 3, 4: time zone ID or city
                case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
                case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
                    throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
            }
            return '';
        });
        return result;
    }

    // @generated from regex-gen.ts
    var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

    function parseNumberSkeletonFromString(skeleton) {
        if (skeleton.length === 0) {
            throw new Error('Number skeleton cannot be empty');
        }
        // Parse the skeleton
        var stringTokens = skeleton
            .split(WHITE_SPACE_REGEX)
            .filter(function (x) { return x.length > 0; });
        var tokens = [];
        for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
            var stringToken = stringTokens_1[_i];
            var stemAndOptions = stringToken.split('/');
            if (stemAndOptions.length === 0) {
                throw new Error('Invalid number skeleton');
            }
            var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
            for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
                var option = options_1[_a];
                if (option.length === 0) {
                    throw new Error('Invalid number skeleton');
                }
            }
            tokens.push({ stem: stem, options: options });
        }
        return tokens;
    }
    function icuUnitToEcma(unit) {
        return unit.replace(/^(.*?)-/, '');
    }
    var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
    var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
    var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
    var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
    function parseSignificantPrecision(str) {
        var result = {};
        if (str[str.length - 1] === 'r') {
            result.roundingPriority = 'morePrecision';
        }
        else if (str[str.length - 1] === 's') {
            result.roundingPriority = 'lessPrecision';
        }
        str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
            // @@@ case
            if (typeof g2 !== 'string') {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits = g1.length;
            }
            // @@@+ case
            else if (g2 === '+') {
                result.minimumSignificantDigits = g1.length;
            }
            // .### case
            else if (g1[0] === '#') {
                result.maximumSignificantDigits = g1.length;
            }
            // .@@## or .@@@ case
            else {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits =
                    g1.length + (typeof g2 === 'string' ? g2.length : 0);
            }
            return '';
        });
        return result;
    }
    function parseSign(str) {
        switch (str) {
            case 'sign-auto':
                return {
                    signDisplay: 'auto',
                };
            case 'sign-accounting':
            case '()':
                return {
                    currencySign: 'accounting',
                };
            case 'sign-always':
            case '+!':
                return {
                    signDisplay: 'always',
                };
            case 'sign-accounting-always':
            case '()!':
                return {
                    signDisplay: 'always',
                    currencySign: 'accounting',
                };
            case 'sign-except-zero':
            case '+?':
                return {
                    signDisplay: 'exceptZero',
                };
            case 'sign-accounting-except-zero':
            case '()?':
                return {
                    signDisplay: 'exceptZero',
                    currencySign: 'accounting',
                };
            case 'sign-never':
            case '+_':
                return {
                    signDisplay: 'never',
                };
        }
    }
    function parseConciseScientificAndEngineeringStem(stem) {
        // Engineering
        var result;
        if (stem[0] === 'E' && stem[1] === 'E') {
            result = {
                notation: 'engineering',
            };
            stem = stem.slice(2);
        }
        else if (stem[0] === 'E') {
            result = {
                notation: 'scientific',
            };
            stem = stem.slice(1);
        }
        if (result) {
            var signDisplay = stem.slice(0, 2);
            if (signDisplay === '+!') {
                result.signDisplay = 'always';
                stem = stem.slice(2);
            }
            else if (signDisplay === '+?') {
                result.signDisplay = 'exceptZero';
                stem = stem.slice(2);
            }
            if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
                throw new Error('Malformed concise eng/scientific notation');
            }
            result.minimumIntegerDigits = stem.length;
        }
        return result;
    }
    function parseNotationOptions(opt) {
        var result = {};
        var signOpts = parseSign(opt);
        if (signOpts) {
            return signOpts;
        }
        return result;
    }
    /**
     * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
     */
    function parseNumberSkeleton(tokens) {
        var result = {};
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            switch (token.stem) {
                case 'percent':
                case '%':
                    result.style = 'percent';
                    continue;
                case '%x100':
                    result.style = 'percent';
                    result.scale = 100;
                    continue;
                case 'currency':
                    result.style = 'currency';
                    result.currency = token.options[0];
                    continue;
                case 'group-off':
                case ',_':
                    result.useGrouping = false;
                    continue;
                case 'precision-integer':
                case '.':
                    result.maximumFractionDigits = 0;
                    continue;
                case 'measure-unit':
                case 'unit':
                    result.style = 'unit';
                    result.unit = icuUnitToEcma(token.options[0]);
                    continue;
                case 'compact-short':
                case 'K':
                    result.notation = 'compact';
                    result.compactDisplay = 'short';
                    continue;
                case 'compact-long':
                case 'KK':
                    result.notation = 'compact';
                    result.compactDisplay = 'long';
                    continue;
                case 'scientific':
                    result = __assign(__assign(__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'engineering':
                    result = __assign(__assign(__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'notation-simple':
                    result.notation = 'standard';
                    continue;
                // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
                case 'unit-width-narrow':
                    result.currencyDisplay = 'narrowSymbol';
                    result.unitDisplay = 'narrow';
                    continue;
                case 'unit-width-short':
                    result.currencyDisplay = 'code';
                    result.unitDisplay = 'short';
                    continue;
                case 'unit-width-full-name':
                    result.currencyDisplay = 'name';
                    result.unitDisplay = 'long';
                    continue;
                case 'unit-width-iso-code':
                    result.currencyDisplay = 'symbol';
                    continue;
                case 'scale':
                    result.scale = parseFloat(token.options[0]);
                    continue;
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
                case 'integer-width':
                    if (token.options.length > 1) {
                        throw new RangeError('integer-width stems only accept a single optional option');
                    }
                    token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {
                        if (g1) {
                            result.minimumIntegerDigits = g2.length;
                        }
                        else if (g3 && g4) {
                            throw new Error('We currently do not support maximum integer digits');
                        }
                        else if (g5) {
                            throw new Error('We currently do not support exact integer digits');
                        }
                        return '';
                    });
                    continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
                result.minimumIntegerDigits = token.stem.length;
                continue;
            }
            if (FRACTION_PRECISION_REGEX.test(token.stem)) {
                // Precision
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
                // precision-integer case
                if (token.options.length > 1) {
                    throw new RangeError('Fraction-precision stems only accept a single optional option');
                }
                token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
                    // .000* case (before ICU67 it was .000+)
                    if (g2 === '*') {
                        result.minimumFractionDigits = g1.length;
                    }
                    // .### case
                    else if (g3 && g3[0] === '#') {
                        result.maximumFractionDigits = g3.length;
                    }
                    // .00## case
                    else if (g4 && g5) {
                        result.minimumFractionDigits = g4.length;
                        result.maximumFractionDigits = g4.length + g5.length;
                    }
                    else {
                        result.minimumFractionDigits = g1.length;
                        result.maximumFractionDigits = g1.length;
                    }
                    return '';
                });
                var opt = token.options[0];
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
                if (opt === 'w') {
                    result = __assign(__assign({}, result), { trailingZeroDisplay: 'stripIfInteger' });
                }
                else if (opt) {
                    result = __assign(__assign({}, result), parseSignificantPrecision(opt));
                }
                continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
            if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
                result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
                continue;
            }
            var signOpts = parseSign(token.stem);
            if (signOpts) {
                result = __assign(__assign({}, result), signOpts);
            }
            var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
            if (conciseScientificAndEngineeringOpts) {
                result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
            }
        }
        return result;
    }

    // @generated from time-data-gen.ts
    // prettier-ignore  
    var timeData = {
        "AX": [
            "H"
        ],
        "BQ": [
            "H"
        ],
        "CP": [
            "H"
        ],
        "CZ": [
            "H"
        ],
        "DK": [
            "H"
        ],
        "FI": [
            "H"
        ],
        "ID": [
            "H"
        ],
        "IS": [
            "H"
        ],
        "ML": [
            "H"
        ],
        "NE": [
            "H"
        ],
        "RU": [
            "H"
        ],
        "SE": [
            "H"
        ],
        "SJ": [
            "H"
        ],
        "SK": [
            "H"
        ],
        "AS": [
            "h",
            "H"
        ],
        "BT": [
            "h",
            "H"
        ],
        "DJ": [
            "h",
            "H"
        ],
        "ER": [
            "h",
            "H"
        ],
        "GH": [
            "h",
            "H"
        ],
        "IN": [
            "h",
            "H"
        ],
        "LS": [
            "h",
            "H"
        ],
        "PG": [
            "h",
            "H"
        ],
        "PW": [
            "h",
            "H"
        ],
        "SO": [
            "h",
            "H"
        ],
        "TO": [
            "h",
            "H"
        ],
        "VU": [
            "h",
            "H"
        ],
        "WS": [
            "h",
            "H"
        ],
        "001": [
            "H",
            "h"
        ],
        "AL": [
            "h",
            "H",
            "hB"
        ],
        "TD": [
            "h",
            "H",
            "hB"
        ],
        "ca-ES": [
            "H",
            "h",
            "hB"
        ],
        "CF": [
            "H",
            "h",
            "hB"
        ],
        "CM": [
            "H",
            "h",
            "hB"
        ],
        "fr-CA": [
            "H",
            "h",
            "hB"
        ],
        "gl-ES": [
            "H",
            "h",
            "hB"
        ],
        "it-CH": [
            "H",
            "h",
            "hB"
        ],
        "it-IT": [
            "H",
            "h",
            "hB"
        ],
        "LU": [
            "H",
            "h",
            "hB"
        ],
        "NP": [
            "H",
            "h",
            "hB"
        ],
        "PF": [
            "H",
            "h",
            "hB"
        ],
        "SC": [
            "H",
            "h",
            "hB"
        ],
        "SM": [
            "H",
            "h",
            "hB"
        ],
        "SN": [
            "H",
            "h",
            "hB"
        ],
        "TF": [
            "H",
            "h",
            "hB"
        ],
        "VA": [
            "H",
            "h",
            "hB"
        ],
        "CY": [
            "h",
            "H",
            "hb",
            "hB"
        ],
        "GR": [
            "h",
            "H",
            "hb",
            "hB"
        ],
        "CO": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "DO": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "KP": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "KR": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "NA": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "PA": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "PR": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "VE": [
            "h",
            "H",
            "hB",
            "hb"
        ],
        "AC": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "AI": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "BW": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "BZ": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "CC": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "CK": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "CX": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "DG": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "FK": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "GB": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "GG": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "GI": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "IE": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "IM": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "IO": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "JE": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "LT": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "MK": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "MN": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "MS": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "NF": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "NG": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "NR": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "NU": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "PN": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "SH": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "SX": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "TA": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "ZA": [
            "H",
            "h",
            "hb",
            "hB"
        ],
        "af-ZA": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "AR": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "CL": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "CR": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "CU": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "EA": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "es-BO": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "es-BR": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "es-EC": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "es-ES": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "es-GQ": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "es-PE": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "GT": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "HN": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "IC": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "KG": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "KM": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "LK": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "MA": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "MX": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "NI": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "PY": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "SV": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "UY": [
            "H",
            "h",
            "hB",
            "hb"
        ],
        "JP": [
            "H",
            "h",
            "K"
        ],
        "AD": [
            "H",
            "hB"
        ],
        "AM": [
            "H",
            "hB"
        ],
        "AO": [
            "H",
            "hB"
        ],
        "AT": [
            "H",
            "hB"
        ],
        "AW": [
            "H",
            "hB"
        ],
        "BE": [
            "H",
            "hB"
        ],
        "BF": [
            "H",
            "hB"
        ],
        "BJ": [
            "H",
            "hB"
        ],
        "BL": [
            "H",
            "hB"
        ],
        "BR": [
            "H",
            "hB"
        ],
        "CG": [
            "H",
            "hB"
        ],
        "CI": [
            "H",
            "hB"
        ],
        "CV": [
            "H",
            "hB"
        ],
        "DE": [
            "H",
            "hB"
        ],
        "EE": [
            "H",
            "hB"
        ],
        "FR": [
            "H",
            "hB"
        ],
        "GA": [
            "H",
            "hB"
        ],
        "GF": [
            "H",
            "hB"
        ],
        "GN": [
            "H",
            "hB"
        ],
        "GP": [
            "H",
            "hB"
        ],
        "GW": [
            "H",
            "hB"
        ],
        "HR": [
            "H",
            "hB"
        ],
        "IL": [
            "H",
            "hB"
        ],
        "IT": [
            "H",
            "hB"
        ],
        "KZ": [
            "H",
            "hB"
        ],
        "MC": [
            "H",
            "hB"
        ],
        "MD": [
            "H",
            "hB"
        ],
        "MF": [
            "H",
            "hB"
        ],
        "MQ": [
            "H",
            "hB"
        ],
        "MZ": [
            "H",
            "hB"
        ],
        "NC": [
            "H",
            "hB"
        ],
        "NL": [
            "H",
            "hB"
        ],
        "PM": [
            "H",
            "hB"
        ],
        "PT": [
            "H",
            "hB"
        ],
        "RE": [
            "H",
            "hB"
        ],
        "RO": [
            "H",
            "hB"
        ],
        "SI": [
            "H",
            "hB"
        ],
        "SR": [
            "H",
            "hB"
        ],
        "ST": [
            "H",
            "hB"
        ],
        "TG": [
            "H",
            "hB"
        ],
        "TR": [
            "H",
            "hB"
        ],
        "WF": [
            "H",
            "hB"
        ],
        "YT": [
            "H",
            "hB"
        ],
        "BD": [
            "h",
            "hB",
            "H"
        ],
        "PK": [
            "h",
            "hB",
            "H"
        ],
        "AZ": [
            "H",
            "hB",
            "h"
        ],
        "BA": [
            "H",
            "hB",
            "h"
        ],
        "BG": [
            "H",
            "hB",
            "h"
        ],
        "CH": [
            "H",
            "hB",
            "h"
        ],
        "GE": [
            "H",
            "hB",
            "h"
        ],
        "LI": [
            "H",
            "hB",
            "h"
        ],
        "ME": [
            "H",
            "hB",
            "h"
        ],
        "RS": [
            "H",
            "hB",
            "h"
        ],
        "UA": [
            "H",
            "hB",
            "h"
        ],
        "UZ": [
            "H",
            "hB",
            "h"
        ],
        "XK": [
            "H",
            "hB",
            "h"
        ],
        "AG": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "AU": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "BB": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "BM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "BS": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "CA": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "DM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "en-001": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "FJ": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "FM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "GD": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "GM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "GU": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "GY": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "JM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "KI": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "KN": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "KY": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "LC": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "LR": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "MH": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "MP": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "MW": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "NZ": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "SB": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "SG": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "SL": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "SS": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "SZ": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "TC": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "TT": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "UM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "US": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "VC": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "VG": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "VI": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "ZM": [
            "h",
            "hb",
            "H",
            "hB"
        ],
        "BO": [
            "H",
            "hB",
            "h",
            "hb"
        ],
        "EC": [
            "H",
            "hB",
            "h",
            "hb"
        ],
        "ES": [
            "H",
            "hB",
            "h",
            "hb"
        ],
        "GQ": [
            "H",
            "hB",
            "h",
            "hb"
        ],
        "PE": [
            "H",
            "hB",
            "h",
            "hb"
        ],
        "AE": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "ar-001": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "BH": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "DZ": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "EG": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "EH": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "HK": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "IQ": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "JO": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "KW": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "LB": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "LY": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "MO": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "MR": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "OM": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "PH": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "PS": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "QA": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "SA": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "SD": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "SY": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "TN": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "YE": [
            "h",
            "hB",
            "hb",
            "H"
        ],
        "AF": [
            "H",
            "hb",
            "hB",
            "h"
        ],
        "LA": [
            "H",
            "hb",
            "hB",
            "h"
        ],
        "CN": [
            "H",
            "hB",
            "hb",
            "h"
        ],
        "LV": [
            "H",
            "hB",
            "hb",
            "h"
        ],
        "TL": [
            "H",
            "hB",
            "hb",
            "h"
        ],
        "zu-ZA": [
            "H",
            "hB",
            "hb",
            "h"
        ],
        "CD": [
            "hB",
            "H"
        ],
        "IR": [
            "hB",
            "H"
        ],
        "hi-IN": [
            "hB",
            "h",
            "H"
        ],
        "kn-IN": [
            "hB",
            "h",
            "H"
        ],
        "ml-IN": [
            "hB",
            "h",
            "H"
        ],
        "te-IN": [
            "hB",
            "h",
            "H"
        ],
        "KH": [
            "hB",
            "h",
            "H",
            "hb"
        ],
        "ta-IN": [
            "hB",
            "h",
            "hb",
            "H"
        ],
        "BN": [
            "hb",
            "hB",
            "h",
            "H"
        ],
        "MY": [
            "hb",
            "hB",
            "h",
            "H"
        ],
        "ET": [
            "hB",
            "hb",
            "h",
            "H"
        ],
        "gu-IN": [
            "hB",
            "hb",
            "h",
            "H"
        ],
        "mr-IN": [
            "hB",
            "hb",
            "h",
            "H"
        ],
        "pa-IN": [
            "hB",
            "hb",
            "h",
            "H"
        ],
        "TW": [
            "hB",
            "hb",
            "h",
            "H"
        ],
        "KE": [
            "hB",
            "hb",
            "H",
            "h"
        ],
        "MM": [
            "hB",
            "hb",
            "H",
            "h"
        ],
        "TZ": [
            "hB",
            "hb",
            "H",
            "h"
        ],
        "UG": [
            "hB",
            "hb",
            "H",
            "h"
        ]
    };

    /**
     * Returns the best matching date time pattern if a date time skeleton
     * pattern is provided with a locale. Follows the Unicode specification:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#table-mapping-requested-time-skeletons-to-patterns
     * @param skeleton date time skeleton pattern that possibly includes j, J or C
     * @param locale
     */
    function getBestPattern(skeleton, locale) {
        var skeletonCopy = '';
        for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
            var patternChar = skeleton.charAt(patternPos);
            if (patternChar === 'j') {
                var extraLength = 0;
                while (patternPos + 1 < skeleton.length &&
                    skeleton.charAt(patternPos + 1) === patternChar) {
                    extraLength++;
                    patternPos++;
                }
                var hourLen = 1 + (extraLength & 1);
                var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
                var dayPeriodChar = 'a';
                var hourChar = getDefaultHourSymbolFromLocale(locale);
                if (hourChar == 'H' || hourChar == 'k') {
                    dayPeriodLen = 0;
                }
                while (dayPeriodLen-- > 0) {
                    skeletonCopy += dayPeriodChar;
                }
                while (hourLen-- > 0) {
                    skeletonCopy = hourChar + skeletonCopy;
                }
            }
            else if (patternChar === 'J') {
                skeletonCopy += 'H';
            }
            else {
                skeletonCopy += patternChar;
            }
        }
        return skeletonCopy;
    }
    /**
     * Maps the [hour cycle type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/hourCycle)
     * of the given `locale` to the corresponding time pattern.
     * @param locale
     */
    function getDefaultHourSymbolFromLocale(locale) {
        var hourCycle = locale.hourCycle;
        if (hourCycle === undefined &&
            // @ts-ignore hourCycle(s) is not identified yet
            locale.hourCycles &&
            // @ts-ignore
            locale.hourCycles.length) {
            // @ts-ignore
            hourCycle = locale.hourCycles[0];
        }
        if (hourCycle) {
            switch (hourCycle) {
                case 'h24':
                    return 'k';
                case 'h23':
                    return 'H';
                case 'h12':
                    return 'h';
                case 'h11':
                    return 'K';
                default:
                    throw new Error('Invalid hourCycle');
            }
        }
        // TODO: Once hourCycle is fully supported remove the following with data generation
        var languageTag = locale.language;
        var regionTag;
        if (languageTag !== 'root') {
            regionTag = locale.maximize().region;
        }
        var hourCycles = timeData[regionTag || ''] ||
            timeData[languageTag || ''] ||
            timeData["".concat(languageTag, "-001")] ||
            timeData['001'];
        return hourCycles[0];
    }

    var _a;
    var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
    var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
    function createLocation(start, end) {
        return { start: start, end: end };
    }
    // #region Ponyfills
    // Consolidate these variables up top for easier toggling during debugging
    var hasNativeStartsWith = !!String.prototype.startsWith;
    var hasNativeFromCodePoint = !!String.fromCodePoint;
    var hasNativeFromEntries = !!Object.fromEntries;
    var hasNativeCodePointAt = !!String.prototype.codePointAt;
    var hasTrimStart = !!String.prototype.trimStart;
    var hasTrimEnd = !!String.prototype.trimEnd;
    var hasNativeIsSafeInteger = !!Number.isSafeInteger;
    var isSafeInteger = hasNativeIsSafeInteger
        ? Number.isSafeInteger
        : function (n) {
            return (typeof n === 'number' &&
                isFinite(n) &&
                Math.floor(n) === n &&
                Math.abs(n) <= 0x1fffffffffffff);
        };
    // IE11 does not support y and u.
    var REGEX_SUPPORTS_U_AND_Y = true;
    try {
        var re$1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        /**
         * legacy Edge or Xbox One browser
         * Unicode flag support: supported
         * Pattern_Syntax support: not supported
         * See https://github.com/formatjs/formatjs/issues/2822
         */
        REGEX_SUPPORTS_U_AND_Y = ((_a = re$1.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';
    }
    catch (_) {
        REGEX_SUPPORTS_U_AND_Y = false;
    }
    var startsWith = hasNativeStartsWith
        ? // Native
            function startsWith(s, search, position) {
                return s.startsWith(search, position);
            }
        : // For IE11
            function startsWith(s, search, position) {
                return s.slice(position, position + search.length) === search;
            };
    var fromCodePoint = hasNativeFromCodePoint
        ? String.fromCodePoint
        : // IE11
            function fromCodePoint() {
                var codePoints = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    codePoints[_i] = arguments[_i];
                }
                var elements = '';
                var length = codePoints.length;
                var i = 0;
                var code;
                while (length > i) {
                    code = codePoints[i++];
                    if (code > 0x10ffff)
                        throw RangeError(code + ' is not a valid code point');
                    elements +=
                        code < 0x10000
                            ? String.fromCharCode(code)
                            : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);
                }
                return elements;
            };
    var fromEntries = 
    // native
    hasNativeFromEntries
        ? Object.fromEntries
        : // Ponyfill
            function fromEntries(entries) {
                var obj = {};
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var _a = entries_1[_i], k = _a[0], v = _a[1];
                    obj[k] = v;
                }
                return obj;
            };
    var codePointAt = hasNativeCodePointAt
        ? // Native
            function codePointAt(s, index) {
                return s.codePointAt(index);
            }
        : // IE 11
            function codePointAt(s, index) {
                var size = s.length;
                if (index < 0 || index >= size) {
                    return undefined;
                }
                var first = s.charCodeAt(index);
                var second;
                return first < 0xd800 ||
                    first > 0xdbff ||
                    index + 1 === size ||
                    (second = s.charCodeAt(index + 1)) < 0xdc00 ||
                    second > 0xdfff
                    ? first
                    : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
            };
    var trimStart = hasTrimStart
        ? // Native
            function trimStart(s) {
                return s.trimStart();
            }
        : // Ponyfill
            function trimStart(s) {
                return s.replace(SPACE_SEPARATOR_START_REGEX, '');
            };
    var trimEnd = hasTrimEnd
        ? // Native
            function trimEnd(s) {
                return s.trimEnd();
            }
        : // Ponyfill
            function trimEnd(s) {
                return s.replace(SPACE_SEPARATOR_END_REGEX, '');
            };
    // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
    function RE(s, flag) {
        return new RegExp(s, flag);
    }
    // #endregion
    var matchIdentifierAtIndex;
    if (REGEX_SUPPORTS_U_AND_Y) {
        // Native
        var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var _a;
            IDENTIFIER_PREFIX_RE_1.lastIndex = index;
            var match = IDENTIFIER_PREFIX_RE_1.exec(s);
            return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
        };
    }
    else {
        // IE11
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var match = [];
            while (true) {
                var c = codePointAt(s, index);
                if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                    break;
                }
                match.push(c);
                index += c >= 0x10000 ? 2 : 1;
            }
            return fromCodePoint.apply(void 0, match);
        };
    }
    var Parser = /** @class */ (function () {
        function Parser(message, options) {
            if (options === void 0) { options = {}; }
            this.message = message;
            this.position = { offset: 0, line: 1, column: 1 };
            this.ignoreTag = !!options.ignoreTag;
            this.locale = options.locale;
            this.requiresOtherClause = !!options.requiresOtherClause;
            this.shouldParseSkeletons = !!options.shouldParseSkeletons;
        }
        Parser.prototype.parse = function () {
            if (this.offset() !== 0) {
                throw Error('parser can only be used once');
            }
            return this.parseMessage(0, '', false);
        };
        Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {
            var elements = [];
            while (!this.isEOF()) {
                var char = this.char();
                if (char === 123 /* `{` */) {
                    var result = this.parseArgument(nestingLevel, expectingCloseTag);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else if (char === 125 /* `}` */ && nestingLevel > 0) {
                    break;
                }
                else if (char === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                    var position = this.clonePosition();
                    this.bump();
                    elements.push({
                        type: TYPE.pound,
                        location: createLocation(position, this.clonePosition()),
                    });
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    this.peek() === 47 // char code for '/'
                ) {
                    if (expectingCloseTag) {
                        break;
                    }
                    else {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    _isAlpha(this.peek() || 0)) {
                    var result = this.parseTag(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else {
                    var result = this.parseLiteral(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
            }
            return { val: elements, err: null };
        };
        /**
         * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
         * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
         * are accepted:
         *
         * ```
         * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
         * tagName ::= [a-z] (PENChar)*
         * PENChar ::=
         *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
         *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
         *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
         * ```
         *
         * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
         * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
         * since other tag-based engines like React allow it
         */
        Parser.prototype.parseTag = function (nestingLevel, parentArgType) {
            var startPosition = this.clonePosition();
            this.bump(); // `<`
            var tagName = this.parseTagName();
            this.bumpSpace();
            if (this.bumpIf('/>')) {
                // Self closing tag
                return {
                    val: {
                        type: TYPE.literal,
                        value: "<".concat(tagName, "/>"),
                        location: createLocation(startPosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            else if (this.bumpIf('>')) {
                var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
                if (childrenResult.err) {
                    return childrenResult;
                }
                var children = childrenResult.val;
                // Expecting a close tag
                var endTagStartPosition = this.clonePosition();
                if (this.bumpIf('</')) {
                    if (this.isEOF() || !_isAlpha(this.char())) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    var closingTagNameStartPosition = this.clonePosition();
                    var closingTagName = this.parseTagName();
                    if (tagName !== closingTagName) {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                    }
                    this.bumpSpace();
                    if (!this.bumpIf('>')) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    return {
                        val: {
                            type: TYPE.tag,
                            value: tagName,
                            children: children,
                            location: createLocation(startPosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                else {
                    return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
                }
            }
            else {
                return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
            }
        };
        /**
         * This method assumes that the caller has peeked ahead for the first tag character.
         */
        Parser.prototype.parseTagName = function () {
            var startOffset = this.offset();
            this.bump(); // the first tag name character
            while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
                this.bump();
            }
            return this.message.slice(startOffset, this.offset());
        };
        Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {
            var start = this.clonePosition();
            var value = '';
            while (true) {
                var parseQuoteResult = this.tryParseQuote(parentArgType);
                if (parseQuoteResult) {
                    value += parseQuoteResult;
                    continue;
                }
                var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
                if (parseUnquotedResult) {
                    value += parseUnquotedResult;
                    continue;
                }
                var parseLeftAngleResult = this.tryParseLeftAngleBracket();
                if (parseLeftAngleResult) {
                    value += parseLeftAngleResult;
                    continue;
                }
                break;
            }
            var location = createLocation(start, this.clonePosition());
            return {
                val: { type: TYPE.literal, value: value, location: location },
                err: null,
            };
        };
        Parser.prototype.tryParseLeftAngleBracket = function () {
            if (!this.isEOF() &&
                this.char() === 60 /* `<` */ &&
                (this.ignoreTag ||
                    // If at the opening tag or closing tag position, bail.
                    !_isAlphaOrSlash(this.peek() || 0))) {
                this.bump(); // `<`
                return '<';
            }
            return null;
        };
        /**
         * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
         * a character that requires quoting (that is, "only where needed"), and works the same in
         * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
         */
        Parser.prototype.tryParseQuote = function (parentArgType) {
            if (this.isEOF() || this.char() !== 39 /* `'` */) {
                return null;
            }
            // Parse escaped char following the apostrophe, or early return if there is no escaped char.
            // Check if is valid escaped character
            switch (this.peek()) {
                case 39 /* `'` */:
                    // double quote, should return as a single quote.
                    this.bump();
                    this.bump();
                    return "'";
                // '{', '<', '>', '}'
                case 123:
                case 60:
                case 62:
                case 125:
                    break;
                case 35: // '#'
                    if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                        break;
                    }
                    return null;
                default:
                    return null;
            }
            this.bump(); // apostrophe
            var codePoints = [this.char()]; // escaped char
            this.bump();
            // read chars until the optional closing apostrophe is found
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch === 39 /* `'` */) {
                    if (this.peek() === 39 /* `'` */) {
                        codePoints.push(39);
                        // Bump one more time because we need to skip 2 characters.
                        this.bump();
                    }
                    else {
                        // Optional closing apostrophe.
                        this.bump();
                        break;
                    }
                }
                else {
                    codePoints.push(ch);
                }
                this.bump();
            }
            return fromCodePoint.apply(void 0, codePoints);
        };
        Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {
            if (this.isEOF()) {
                return null;
            }
            var ch = this.char();
            if (ch === 60 /* `<` */ ||
                ch === 123 /* `{` */ ||
                (ch === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||
                (ch === 125 /* `}` */ && nestingLevel > 0)) {
                return null;
            }
            else {
                this.bump();
                return fromCodePoint(ch);
            }
        };
        Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {
            var openingBracePosition = this.clonePosition();
            this.bump(); // `{`
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            if (this.char() === 125 /* `}` */) {
                this.bump();
                return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            // argument name
            var value = this.parseIdentifierIfPossible().value;
            if (!value) {
                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            switch (this.char()) {
                // Simple argument: `{name}`
                case 125 /* `}` */: {
                    this.bump(); // `}`
                    return {
                        val: {
                            type: TYPE.argument,
                            // value does not include the opening and closing braces.
                            value: value,
                            location: createLocation(openingBracePosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                // Argument with options: `{name, format, ...}`
                case 44 /* `,` */: {
                    this.bump(); // `,`
                    this.bumpSpace();
                    if (this.isEOF()) {
                        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                    }
                    return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
                }
                default:
                    return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
        };
        /**
         * Advance the parser until the end of the identifier, if it is currently on
         * an identifier character. Return an empty string otherwise.
         */
        Parser.prototype.parseIdentifierIfPossible = function () {
            var startingPosition = this.clonePosition();
            var startOffset = this.offset();
            var value = matchIdentifierAtIndex(this.message, startOffset);
            var endOffset = startOffset + value.length;
            this.bumpTo(endOffset);
            var endPosition = this.clonePosition();
            var location = createLocation(startingPosition, endPosition);
            return { value: value, location: location };
        };
        Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {
            var _a;
            // Parse this range:
            // {name, type, style}
            //        ^---^
            var typeStartPosition = this.clonePosition();
            var argType = this.parseIdentifierIfPossible().value;
            var typeEndPosition = this.clonePosition();
            switch (argType) {
                case '':
                    // Expecting a style string number, date, time, plural, selectordinal, or select.
                    return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
                case 'number':
                case 'date':
                case 'time': {
                    // Parse this range:
                    // {name, number, style}
                    //              ^-------^
                    this.bumpSpace();
                    var styleAndLocation = null;
                    if (this.bumpIf(',')) {
                        this.bumpSpace();
                        var styleStartPosition = this.clonePosition();
                        var result = this.parseSimpleArgStyleIfPossible();
                        if (result.err) {
                            return result;
                        }
                        var style = trimEnd(result.val);
                        if (style.length === 0) {
                            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                        styleAndLocation = { style: style, styleLocation: styleLocation };
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_1 = createLocation(openingBracePosition, this.clonePosition());
                    // Extract style or skeleton
                    if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                        // Skeleton starts with `::`.
                        var skeleton = trimStart(styleAndLocation.style.slice(2));
                        if (argType === 'number') {
                            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                            if (result.err) {
                                return result;
                            }
                            return {
                                val: { type: TYPE.number, value: value, location: location_1, style: result.val },
                                err: null,
                            };
                        }
                        else {
                            if (skeleton.length === 0) {
                                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
                            }
                            var dateTimePattern = skeleton;
                            // Get "best match" pattern only if locale is passed, if not, let it
                            // pass as-is where `parseDateTimeSkeleton()` will throw an error
                            // for unsupported patterns.
                            if (this.locale) {
                                dateTimePattern = getBestPattern(skeleton, this.locale);
                            }
                            var style = {
                                type: SKELETON_TYPE.dateTime,
                                pattern: dateTimePattern,
                                location: styleAndLocation.styleLocation,
                                parsedOptions: this.shouldParseSkeletons
                                    ? parseDateTimeSkeleton(dateTimePattern)
                                    : {},
                            };
                            var type = argType === 'date' ? TYPE.date : TYPE.time;
                            return {
                                val: { type: type, value: value, location: location_1, style: style },
                                err: null,
                            };
                        }
                    }
                    // Regular style or no style.
                    return {
                        val: {
                            type: argType === 'number'
                                ? TYPE.number
                                : argType === 'date'
                                    ? TYPE.date
                                    : TYPE.time,
                            value: value,
                            location: location_1,
                            style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,
                        },
                        err: null,
                    };
                }
                case 'plural':
                case 'selectordinal':
                case 'select': {
                    // Parse this range:
                    // {name, plural, options}
                    //              ^---------^
                    var typeEndPosition_1 = this.clonePosition();
                    this.bumpSpace();
                    if (!this.bumpIf(',')) {
                        return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
                    }
                    this.bumpSpace();
                    // Parse offset:
                    // {name, plural, offset:1, options}
                    //                ^-----^
                    //
                    // or the first option:
                    //
                    // {name, plural, one {...} other {...}}
                    //                ^--^
                    var identifierAndLocation = this.parseIdentifierIfPossible();
                    var pluralOffset = 0;
                    if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                        if (!this.bumpIf(':')) {
                            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        this.bumpSpace();
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                        if (result.err) {
                            return result;
                        }
                        // Parse another identifier for option parsing
                        this.bumpSpace();
                        identifierAndLocation = this.parseIdentifierIfPossible();
                        pluralOffset = result.val;
                    }
                    var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                    if (optionsResult.err) {
                        return optionsResult;
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_2 = createLocation(openingBracePosition, this.clonePosition());
                    if (argType === 'select') {
                        return {
                            val: {
                                type: TYPE.select,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                    else {
                        return {
                            val: {
                                type: TYPE.plural,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                offset: pluralOffset,
                                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                }
                default:
                    return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            }
        };
        Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {
            // Parse: {value, number, ::currency/GBP }
            //
            if (this.isEOF() || this.char() !== 125 /* `}` */) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bump(); // `}`
            return { val: true, err: null };
        };
        /**
         * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
         */
        Parser.prototype.parseSimpleArgStyleIfPossible = function () {
            var nestedBraces = 0;
            var startPosition = this.clonePosition();
            while (!this.isEOF()) {
                var ch = this.char();
                switch (ch) {
                    case 39 /* `'` */: {
                        // Treat apostrophe as quoting but include it in the style part.
                        // Find the end of the quoted literal text.
                        this.bump();
                        var apostrophePosition = this.clonePosition();
                        if (!this.bumpUntil("'")) {
                            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                        }
                        this.bump();
                        break;
                    }
                    case 123 /* `{` */: {
                        nestedBraces += 1;
                        this.bump();
                        break;
                    }
                    case 125 /* `}` */: {
                        if (nestedBraces > 0) {
                            nestedBraces -= 1;
                        }
                        else {
                            return {
                                val: this.message.slice(startPosition.offset, this.offset()),
                                err: null,
                            };
                        }
                        break;
                    }
                    default:
                        this.bump();
                        break;
                }
            }
            return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null,
            };
        };
        Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {
            var tokens = [];
            try {
                tokens = parseNumberSkeletonFromString(skeleton);
            }
            catch (e) {
                return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
            }
            return {
                val: {
                    type: SKELETON_TYPE.number,
                    tokens: tokens,
                    location: location,
                    parsedOptions: this.shouldParseSkeletons
                        ? parseNumberSkeleton(tokens)
                        : {},
                },
                err: null,
            };
        };
        /**
         * @param nesting_level The current nesting level of messages.
         *     This can be positive when parsing message fragment in select or plural argument options.
         * @param parent_arg_type The parent argument's type.
         * @param parsed_first_identifier If provided, this is the first identifier-like selector of
         *     the argument. It is a by-product of a previous parsing attempt.
         * @param expecting_close_tag If true, this message is directly or indirectly nested inside
         *     between a pair of opening and closing tags. The nested message will not parse beyond
         *     the closing tag boundary.
         */
        Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
            var _a;
            var hasOtherClause = false;
            var options = [];
            var parsedSelectors = new Set();
            var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
            // Parse:
            // one {one apple}
            // ^--^
            while (true) {
                if (selector.length === 0) {
                    var startPosition = this.clonePosition();
                    if (parentArgType !== 'select' && this.bumpIf('=')) {
                        // Try parse `={number}` selector
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
                        if (result.err) {
                            return result;
                        }
                        selectorLocation = createLocation(startPosition, this.clonePosition());
                        selector = this.message.slice(startPosition.offset, this.offset());
                    }
                    else {
                        break;
                    }
                }
                // Duplicate selector clauses
                if (parsedSelectors.has(selector)) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR
                        : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
                }
                if (selector === 'other') {
                    hasOtherClause = true;
                }
                // Parse:
                // one {one apple}
                //     ^----------^
                this.bumpSpace();
                var openingBracePosition = this.clonePosition();
                if (!this.bumpIf('{')) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
                        : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
                }
                var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
                if (fragmentResult.err) {
                    return fragmentResult;
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                options.push([
                    selector,
                    {
                        value: fragmentResult.val,
                        location: createLocation(openingBracePosition, this.clonePosition()),
                    },
                ]);
                // Keep track of the existing selectors
                parsedSelectors.add(selector);
                // Prep next selector clause.
                this.bumpSpace();
                (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);
            }
            if (options.length === 0) {
                return this.error(parentArgType === 'select'
                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR
                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
            }
            if (this.requiresOtherClause && !hasOtherClause) {
                return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            return { val: options, err: null };
        };
        Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {
            var sign = 1;
            var startingPosition = this.clonePosition();
            if (this.bumpIf('+')) ;
            else if (this.bumpIf('-')) {
                sign = -1;
            }
            var hasDigits = false;
            var decimal = 0;
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {
                    hasDigits = true;
                    decimal = decimal * 10 + (ch - 48);
                    this.bump();
                }
                else {
                    break;
                }
            }
            var location = createLocation(startingPosition, this.clonePosition());
            if (!hasDigits) {
                return this.error(expectNumberError, location);
            }
            decimal *= sign;
            if (!isSafeInteger(decimal)) {
                return this.error(invalidNumberError, location);
            }
            return { val: decimal, err: null };
        };
        Parser.prototype.offset = function () {
            return this.position.offset;
        };
        Parser.prototype.isEOF = function () {
            return this.offset() === this.message.length;
        };
        Parser.prototype.clonePosition = function () {
            // This is much faster than `Object.assign` or spread.
            return {
                offset: this.position.offset,
                line: this.position.line,
                column: this.position.column,
            };
        };
        /**
         * Return the code point at the current position of the parser.
         * Throws if the index is out of bound.
         */
        Parser.prototype.char = function () {
            var offset = this.position.offset;
            if (offset >= this.message.length) {
                throw Error('out of bound');
            }
            var code = codePointAt(this.message, offset);
            if (code === undefined) {
                throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
            }
            return code;
        };
        Parser.prototype.error = function (kind, location) {
            return {
                val: null,
                err: {
                    kind: kind,
                    message: this.message,
                    location: location,
                },
            };
        };
        /** Bump the parser to the next UTF-16 code unit. */
        Parser.prototype.bump = function () {
            if (this.isEOF()) {
                return;
            }
            var code = this.char();
            if (code === 10 /* '\n' */) {
                this.position.line += 1;
                this.position.column = 1;
                this.position.offset += 1;
            }
            else {
                this.position.column += 1;
                // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
                this.position.offset += code < 0x10000 ? 1 : 2;
            }
        };
        /**
         * If the substring starting at the current position of the parser has
         * the given prefix, then bump the parser to the character immediately
         * following the prefix and return true. Otherwise, don't bump the parser
         * and return false.
         */
        Parser.prototype.bumpIf = function (prefix) {
            if (startsWith(this.message, prefix, this.offset())) {
                for (var i = 0; i < prefix.length; i++) {
                    this.bump();
                }
                return true;
            }
            return false;
        };
        /**
         * Bump the parser until the pattern character is found and return `true`.
         * Otherwise bump to the end of the file and return `false`.
         */
        Parser.prototype.bumpUntil = function (pattern) {
            var currentOffset = this.offset();
            var index = this.message.indexOf(pattern, currentOffset);
            if (index >= 0) {
                this.bumpTo(index);
                return true;
            }
            else {
                this.bumpTo(this.message.length);
                return false;
            }
        };
        /**
         * Bump the parser to the target offset.
         * If target offset is beyond the end of the input, bump the parser to the end of the input.
         */
        Parser.prototype.bumpTo = function (targetOffset) {
            if (this.offset() > targetOffset) {
                throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
            }
            targetOffset = Math.min(targetOffset, this.message.length);
            while (true) {
                var offset = this.offset();
                if (offset === targetOffset) {
                    break;
                }
                if (offset > targetOffset) {
                    throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
                }
                this.bump();
                if (this.isEOF()) {
                    break;
                }
            }
        };
        /** advance the parser through all whitespace to the next non-whitespace code unit. */
        Parser.prototype.bumpSpace = function () {
            while (!this.isEOF() && _isWhiteSpace(this.char())) {
                this.bump();
            }
        };
        /**
         * Peek at the *next* Unicode codepoint in the input without advancing the parser.
         * If the input has been exhausted, then this returns null.
         */
        Parser.prototype.peek = function () {
            if (this.isEOF()) {
                return null;
            }
            var code = this.char();
            var offset = this.offset();
            var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
            return nextCode !== null && nextCode !== void 0 ? nextCode : null;
        };
        return Parser;
    }());
    /**
     * This check if codepoint is alphabet (lower & uppercase)
     * @param codepoint
     * @returns
     */
    function _isAlpha(codepoint) {
        return ((codepoint >= 97 && codepoint <= 122) ||
            (codepoint >= 65 && codepoint <= 90));
    }
    function _isAlphaOrSlash(codepoint) {
        return _isAlpha(codepoint) || codepoint === 47; /* '/' */
    }
    /** See `parseTag` function docs. */
    function _isPotentialElementNameChar(c) {
        return (c === 45 /* '-' */ ||
            c === 46 /* '.' */ ||
            (c >= 48 && c <= 57) /* 0..9 */ ||
            c === 95 /* '_' */ ||
            (c >= 97 && c <= 122) /** a..z */ ||
            (c >= 65 && c <= 90) /* A..Z */ ||
            c == 0xb7 ||
            (c >= 0xc0 && c <= 0xd6) ||
            (c >= 0xd8 && c <= 0xf6) ||
            (c >= 0xf8 && c <= 0x37d) ||
            (c >= 0x37f && c <= 0x1fff) ||
            (c >= 0x200c && c <= 0x200d) ||
            (c >= 0x203f && c <= 0x2040) ||
            (c >= 0x2070 && c <= 0x218f) ||
            (c >= 0x2c00 && c <= 0x2fef) ||
            (c >= 0x3001 && c <= 0xd7ff) ||
            (c >= 0xf900 && c <= 0xfdcf) ||
            (c >= 0xfdf0 && c <= 0xfffd) ||
            (c >= 0x10000 && c <= 0xeffff));
    }
    /**
     * Code point equivalent of regex `\p{White_Space}`.
     * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isWhiteSpace(c) {
        return ((c >= 0x0009 && c <= 0x000d) ||
            c === 0x0020 ||
            c === 0x0085 ||
            (c >= 0x200e && c <= 0x200f) ||
            c === 0x2028 ||
            c === 0x2029);
    }
    /**
     * Code point equivalent of regex `\p{Pattern_Syntax}`.
     * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isPatternSyntax(c) {
        return ((c >= 0x0021 && c <= 0x0023) ||
            c === 0x0024 ||
            (c >= 0x0025 && c <= 0x0027) ||
            c === 0x0028 ||
            c === 0x0029 ||
            c === 0x002a ||
            c === 0x002b ||
            c === 0x002c ||
            c === 0x002d ||
            (c >= 0x002e && c <= 0x002f) ||
            (c >= 0x003a && c <= 0x003b) ||
            (c >= 0x003c && c <= 0x003e) ||
            (c >= 0x003f && c <= 0x0040) ||
            c === 0x005b ||
            c === 0x005c ||
            c === 0x005d ||
            c === 0x005e ||
            c === 0x0060 ||
            c === 0x007b ||
            c === 0x007c ||
            c === 0x007d ||
            c === 0x007e ||
            c === 0x00a1 ||
            (c >= 0x00a2 && c <= 0x00a5) ||
            c === 0x00a6 ||
            c === 0x00a7 ||
            c === 0x00a9 ||
            c === 0x00ab ||
            c === 0x00ac ||
            c === 0x00ae ||
            c === 0x00b0 ||
            c === 0x00b1 ||
            c === 0x00b6 ||
            c === 0x00bb ||
            c === 0x00bf ||
            c === 0x00d7 ||
            c === 0x00f7 ||
            (c >= 0x2010 && c <= 0x2015) ||
            (c >= 0x2016 && c <= 0x2017) ||
            c === 0x2018 ||
            c === 0x2019 ||
            c === 0x201a ||
            (c >= 0x201b && c <= 0x201c) ||
            c === 0x201d ||
            c === 0x201e ||
            c === 0x201f ||
            (c >= 0x2020 && c <= 0x2027) ||
            (c >= 0x2030 && c <= 0x2038) ||
            c === 0x2039 ||
            c === 0x203a ||
            (c >= 0x203b && c <= 0x203e) ||
            (c >= 0x2041 && c <= 0x2043) ||
            c === 0x2044 ||
            c === 0x2045 ||
            c === 0x2046 ||
            (c >= 0x2047 && c <= 0x2051) ||
            c === 0x2052 ||
            c === 0x2053 ||
            (c >= 0x2055 && c <= 0x205e) ||
            (c >= 0x2190 && c <= 0x2194) ||
            (c >= 0x2195 && c <= 0x2199) ||
            (c >= 0x219a && c <= 0x219b) ||
            (c >= 0x219c && c <= 0x219f) ||
            c === 0x21a0 ||
            (c >= 0x21a1 && c <= 0x21a2) ||
            c === 0x21a3 ||
            (c >= 0x21a4 && c <= 0x21a5) ||
            c === 0x21a6 ||
            (c >= 0x21a7 && c <= 0x21ad) ||
            c === 0x21ae ||
            (c >= 0x21af && c <= 0x21cd) ||
            (c >= 0x21ce && c <= 0x21cf) ||
            (c >= 0x21d0 && c <= 0x21d1) ||
            c === 0x21d2 ||
            c === 0x21d3 ||
            c === 0x21d4 ||
            (c >= 0x21d5 && c <= 0x21f3) ||
            (c >= 0x21f4 && c <= 0x22ff) ||
            (c >= 0x2300 && c <= 0x2307) ||
            c === 0x2308 ||
            c === 0x2309 ||
            c === 0x230a ||
            c === 0x230b ||
            (c >= 0x230c && c <= 0x231f) ||
            (c >= 0x2320 && c <= 0x2321) ||
            (c >= 0x2322 && c <= 0x2328) ||
            c === 0x2329 ||
            c === 0x232a ||
            (c >= 0x232b && c <= 0x237b) ||
            c === 0x237c ||
            (c >= 0x237d && c <= 0x239a) ||
            (c >= 0x239b && c <= 0x23b3) ||
            (c >= 0x23b4 && c <= 0x23db) ||
            (c >= 0x23dc && c <= 0x23e1) ||
            (c >= 0x23e2 && c <= 0x2426) ||
            (c >= 0x2427 && c <= 0x243f) ||
            (c >= 0x2440 && c <= 0x244a) ||
            (c >= 0x244b && c <= 0x245f) ||
            (c >= 0x2500 && c <= 0x25b6) ||
            c === 0x25b7 ||
            (c >= 0x25b8 && c <= 0x25c0) ||
            c === 0x25c1 ||
            (c >= 0x25c2 && c <= 0x25f7) ||
            (c >= 0x25f8 && c <= 0x25ff) ||
            (c >= 0x2600 && c <= 0x266e) ||
            c === 0x266f ||
            (c >= 0x2670 && c <= 0x2767) ||
            c === 0x2768 ||
            c === 0x2769 ||
            c === 0x276a ||
            c === 0x276b ||
            c === 0x276c ||
            c === 0x276d ||
            c === 0x276e ||
            c === 0x276f ||
            c === 0x2770 ||
            c === 0x2771 ||
            c === 0x2772 ||
            c === 0x2773 ||
            c === 0x2774 ||
            c === 0x2775 ||
            (c >= 0x2794 && c <= 0x27bf) ||
            (c >= 0x27c0 && c <= 0x27c4) ||
            c === 0x27c5 ||
            c === 0x27c6 ||
            (c >= 0x27c7 && c <= 0x27e5) ||
            c === 0x27e6 ||
            c === 0x27e7 ||
            c === 0x27e8 ||
            c === 0x27e9 ||
            c === 0x27ea ||
            c === 0x27eb ||
            c === 0x27ec ||
            c === 0x27ed ||
            c === 0x27ee ||
            c === 0x27ef ||
            (c >= 0x27f0 && c <= 0x27ff) ||
            (c >= 0x2800 && c <= 0x28ff) ||
            (c >= 0x2900 && c <= 0x2982) ||
            c === 0x2983 ||
            c === 0x2984 ||
            c === 0x2985 ||
            c === 0x2986 ||
            c === 0x2987 ||
            c === 0x2988 ||
            c === 0x2989 ||
            c === 0x298a ||
            c === 0x298b ||
            c === 0x298c ||
            c === 0x298d ||
            c === 0x298e ||
            c === 0x298f ||
            c === 0x2990 ||
            c === 0x2991 ||
            c === 0x2992 ||
            c === 0x2993 ||
            c === 0x2994 ||
            c === 0x2995 ||
            c === 0x2996 ||
            c === 0x2997 ||
            c === 0x2998 ||
            (c >= 0x2999 && c <= 0x29d7) ||
            c === 0x29d8 ||
            c === 0x29d9 ||
            c === 0x29da ||
            c === 0x29db ||
            (c >= 0x29dc && c <= 0x29fb) ||
            c === 0x29fc ||
            c === 0x29fd ||
            (c >= 0x29fe && c <= 0x2aff) ||
            (c >= 0x2b00 && c <= 0x2b2f) ||
            (c >= 0x2b30 && c <= 0x2b44) ||
            (c >= 0x2b45 && c <= 0x2b46) ||
            (c >= 0x2b47 && c <= 0x2b4c) ||
            (c >= 0x2b4d && c <= 0x2b73) ||
            (c >= 0x2b74 && c <= 0x2b75) ||
            (c >= 0x2b76 && c <= 0x2b95) ||
            c === 0x2b96 ||
            (c >= 0x2b97 && c <= 0x2bff) ||
            (c >= 0x2e00 && c <= 0x2e01) ||
            c === 0x2e02 ||
            c === 0x2e03 ||
            c === 0x2e04 ||
            c === 0x2e05 ||
            (c >= 0x2e06 && c <= 0x2e08) ||
            c === 0x2e09 ||
            c === 0x2e0a ||
            c === 0x2e0b ||
            c === 0x2e0c ||
            c === 0x2e0d ||
            (c >= 0x2e0e && c <= 0x2e16) ||
            c === 0x2e17 ||
            (c >= 0x2e18 && c <= 0x2e19) ||
            c === 0x2e1a ||
            c === 0x2e1b ||
            c === 0x2e1c ||
            c === 0x2e1d ||
            (c >= 0x2e1e && c <= 0x2e1f) ||
            c === 0x2e20 ||
            c === 0x2e21 ||
            c === 0x2e22 ||
            c === 0x2e23 ||
            c === 0x2e24 ||
            c === 0x2e25 ||
            c === 0x2e26 ||
            c === 0x2e27 ||
            c === 0x2e28 ||
            c === 0x2e29 ||
            (c >= 0x2e2a && c <= 0x2e2e) ||
            c === 0x2e2f ||
            (c >= 0x2e30 && c <= 0x2e39) ||
            (c >= 0x2e3a && c <= 0x2e3b) ||
            (c >= 0x2e3c && c <= 0x2e3f) ||
            c === 0x2e40 ||
            c === 0x2e41 ||
            c === 0x2e42 ||
            (c >= 0x2e43 && c <= 0x2e4f) ||
            (c >= 0x2e50 && c <= 0x2e51) ||
            c === 0x2e52 ||
            (c >= 0x2e53 && c <= 0x2e7f) ||
            (c >= 0x3001 && c <= 0x3003) ||
            c === 0x3008 ||
            c === 0x3009 ||
            c === 0x300a ||
            c === 0x300b ||
            c === 0x300c ||
            c === 0x300d ||
            c === 0x300e ||
            c === 0x300f ||
            c === 0x3010 ||
            c === 0x3011 ||
            (c >= 0x3012 && c <= 0x3013) ||
            c === 0x3014 ||
            c === 0x3015 ||
            c === 0x3016 ||
            c === 0x3017 ||
            c === 0x3018 ||
            c === 0x3019 ||
            c === 0x301a ||
            c === 0x301b ||
            c === 0x301c ||
            c === 0x301d ||
            (c >= 0x301e && c <= 0x301f) ||
            c === 0x3020 ||
            c === 0x3030 ||
            c === 0xfd3e ||
            c === 0xfd3f ||
            (c >= 0xfe45 && c <= 0xfe46));
    }

    function pruneLocation(els) {
        els.forEach(function (el) {
            delete el.location;
            if (isSelectElement(el) || isPluralElement(el)) {
                for (var k in el.options) {
                    delete el.options[k].location;
                    pruneLocation(el.options[k].value);
                }
            }
            else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
                delete el.style.location;
            }
            else if ((isDateElement(el) || isTimeElement(el)) &&
                isDateTimeSkeleton(el.style)) {
                delete el.style.location;
            }
            else if (isTagElement(el)) {
                pruneLocation(el.children);
            }
        });
    }
    function parse(message, opts) {
        if (opts === void 0) { opts = {}; }
        opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
        var result = new Parser(message, opts).parse();
        if (result.err) {
            var error = SyntaxError(ErrorKind[result.err.kind]);
            // @ts-expect-error Assign to error object
            error.location = result.err.location;
            // @ts-expect-error Assign to error object
            error.originalMessage = result.err.message;
            throw error;
        }
        if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
            pruneLocation(result.val);
        }
        return result.val;
    }

    //
    // Main
    //
    function memoize(fn, options) {
        var cache = options && options.cache ? options.cache : cacheDefault;
        var serializer = options && options.serializer ? options.serializer : serializerDefault;
        var strategy = options && options.strategy ? options.strategy : strategyDefault;
        return strategy(fn, {
            cache: cache,
            serializer: serializer,
        });
    }
    //
    // Strategy
    //
    function isPrimitive(value) {
        return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
    }
    function monadic(fn, cache, serializer, arg) {
        var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.call(this, arg);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function variadic(fn, cache, serializer) {
        var args = Array.prototype.slice.call(arguments, 3);
        var cacheKey = serializer(args);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.apply(this, args);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function assemble(fn, context, strategy, cache, serialize) {
        return strategy.bind(context, fn, cache, serialize);
    }
    function strategyDefault(fn, options) {
        var strategy = fn.length === 1 ? monadic : variadic;
        return assemble(fn, this, strategy, options.cache.create(), options.serializer);
    }
    function strategyVariadic(fn, options) {
        return assemble(fn, this, variadic, options.cache.create(), options.serializer);
    }
    function strategyMonadic(fn, options) {
        return assemble(fn, this, monadic, options.cache.create(), options.serializer);
    }
    //
    // Serializer
    //
    var serializerDefault = function () {
        return JSON.stringify(arguments);
    };
    //
    // Cache
    //
    function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.get = function (key) {
        return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
        this.cache[key] = value;
    };
    var cacheDefault = {
        create: function create() {
            // @ts-ignore
            return new ObjectWithoutPrototypeCache();
        },
    };
    var strategies = {
        variadic: strategyVariadic,
        monadic: strategyMonadic,
    };

    var ErrorCode;
    (function (ErrorCode) {
        // When we have a placeholder but no value to format
        ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
        // When value supplied is invalid
        ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
        // When we need specific Intl API but it's not available
        ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
    })(ErrorCode || (ErrorCode = {}));
    var FormatError = /** @class */ (function (_super) {
        __extends(FormatError, _super);
        function FormatError(msg, code, originalMessage) {
            var _this = _super.call(this, msg) || this;
            _this.code = code;
            _this.originalMessage = originalMessage;
            return _this;
        }
        FormatError.prototype.toString = function () {
            return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
        };
        return FormatError;
    }(Error));
    var InvalidValueError = /** @class */ (function (_super) {
        __extends(InvalidValueError, _super);
        function InvalidValueError(variableId, value, options, originalMessage) {
            return _super.call(this, "Invalid values for \"".concat(variableId, "\": \"").concat(value, "\". Options are \"").concat(Object.keys(options).join('", "'), "\""), ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueError;
    }(FormatError));
    var InvalidValueTypeError = /** @class */ (function (_super) {
        __extends(InvalidValueTypeError, _super);
        function InvalidValueTypeError(value, type, originalMessage) {
            return _super.call(this, "Value for \"".concat(value, "\" must be of type ").concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueTypeError;
    }(FormatError));
    var MissingValueError = /** @class */ (function (_super) {
        __extends(MissingValueError, _super);
        function MissingValueError(variableId, originalMessage) {
            return _super.call(this, "The intl string context variable \"".concat(variableId, "\" was not provided to the string \"").concat(originalMessage, "\""), ErrorCode.MISSING_VALUE, originalMessage) || this;
        }
        return MissingValueError;
    }(FormatError));

    var PART_TYPE;
    (function (PART_TYPE) {
        PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
        PART_TYPE[PART_TYPE["object"] = 1] = "object";
    })(PART_TYPE || (PART_TYPE = {}));
    function mergeLiteral(parts) {
        if (parts.length < 2) {
            return parts;
        }
        return parts.reduce(function (all, part) {
            var lastPart = all[all.length - 1];
            if (!lastPart ||
                lastPart.type !== PART_TYPE.literal ||
                part.type !== PART_TYPE.literal) {
                all.push(part);
            }
            else {
                lastPart.value += part.value;
            }
            return all;
        }, []);
    }
    function isFormatXMLElementFn(el) {
        return typeof el === 'function';
    }
    // TODO(skeleton): add skeleton support
    function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
    // For debugging
    originalMessage) {
        // Hot path for straight simple msg translations
        if (els.length === 1 && isLiteralElement(els[0])) {
            return [
                {
                    type: PART_TYPE.literal,
                    value: els[0].value,
                },
            ];
        }
        var result = [];
        for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
            var el = els_1[_i];
            // Exit early for string parts.
            if (isLiteralElement(el)) {
                result.push({
                    type: PART_TYPE.literal,
                    value: el.value,
                });
                continue;
            }
            // TODO: should this part be literal type?
            // Replace `#` in plural rules with the actual numeric value.
            if (isPoundElement(el)) {
                if (typeof currentPluralValue === 'number') {
                    result.push({
                        type: PART_TYPE.literal,
                        value: formatters.getNumberFormat(locales).format(currentPluralValue),
                    });
                }
                continue;
            }
            var varName = el.value;
            // Enforce that all required values are provided by the caller.
            if (!(values && varName in values)) {
                throw new MissingValueError(varName, originalMessage);
            }
            var value = values[varName];
            if (isArgumentElement(el)) {
                if (!value || typeof value === 'string' || typeof value === 'number') {
                    value =
                        typeof value === 'string' || typeof value === 'number'
                            ? String(value)
                            : '';
                }
                result.push({
                    type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: value,
                });
                continue;
            }
            // Recursively format plural and select parts' option — which can be a
            // nested pattern structure. The choosing of the option to use is
            // abstracted-by and delegated-to the part helper object.
            if (isDateElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.date[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTimeElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.time[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : formats.time.medium;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isNumberElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.number[el.style]
                    : isNumberSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                if (style && style.scale) {
                    value =
                        value *
                            (style.scale || 1);
                }
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getNumberFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTagElement(el)) {
                var children = el.children, value_1 = el.value;
                var formatFn = values[value_1];
                if (!isFormatXMLElementFn(formatFn)) {
                    throw new InvalidValueTypeError(value_1, 'function', originalMessage);
                }
                var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
                var chunks = formatFn(parts.map(function (p) { return p.value; }));
                if (!Array.isArray(chunks)) {
                    chunks = [chunks];
                }
                result.push.apply(result, chunks.map(function (c) {
                    return {
                        type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                        value: c,
                    };
                }));
            }
            if (isSelectElement(el)) {
                var opt = el.options[value] || el.options.other;
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
                continue;
            }
            if (isPluralElement(el)) {
                var opt = el.options["=".concat(value)];
                if (!opt) {
                    if (!Intl.PluralRules) {
                        throw new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", ErrorCode.MISSING_INTL_API, originalMessage);
                    }
                    var rule = formatters
                        .getPluralRules(locales, { type: el.pluralType })
                        .select(value - (el.offset || 0));
                    opt = el.options[rule] || el.options.other;
                }
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
                continue;
            }
        }
        return mergeLiteral(result);
    }

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    // -- MessageFormat --------------------------------------------------------
    function mergeConfig(c1, c2) {
        if (!c2) {
            return c1;
        }
        return __assign(__assign(__assign({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
            all[k] = __assign(__assign({}, c1[k]), (c2[k] || {}));
            return all;
        }, {}));
    }
    function mergeConfigs(defaultConfig, configs) {
        if (!configs) {
            return defaultConfig;
        }
        return Object.keys(defaultConfig).reduce(function (all, k) {
            all[k] = mergeConfig(defaultConfig[k], configs[k]);
            return all;
        }, __assign({}, defaultConfig));
    }
    function createFastMemoizeCache(store) {
        return {
            create: function () {
                return {
                    get: function (key) {
                        return store[key];
                    },
                    set: function (key, value) {
                        store[key] = value;
                    },
                };
            },
        };
    }
    function createDefaultFormatters(cache) {
        if (cache === void 0) { cache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        }; }
        return {
            getNumberFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.number),
                strategy: strategies.variadic,
            }),
            getDateTimeFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.dateTime),
                strategy: strategies.variadic,
            }),
            getPluralRules: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.pluralRules),
                strategy: strategies.variadic,
            }),
        };
    }
    var IntlMessageFormat = /** @class */ (function () {
        function IntlMessageFormat(message, locales, overrideFormats, opts) {
            var _this = this;
            if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
            this.formatterCache = {
                number: {},
                dateTime: {},
                pluralRules: {},
            };
            this.format = function (values) {
                var parts = _this.formatToParts(values);
                // Hot path for straight simple msg translations
                if (parts.length === 1) {
                    return parts[0].value;
                }
                var result = parts.reduce(function (all, part) {
                    if (!all.length ||
                        part.type !== PART_TYPE.literal ||
                        typeof all[all.length - 1] !== 'string') {
                        all.push(part.value);
                    }
                    else {
                        all[all.length - 1] += part.value;
                    }
                    return all;
                }, []);
                if (result.length <= 1) {
                    return result[0] || '';
                }
                return result;
            };
            this.formatToParts = function (values) {
                return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
            };
            this.resolvedOptions = function () { return ({
                locale: _this.resolvedLocale.toString(),
            }); };
            this.getAst = function () { return _this.ast; };
            // Defined first because it's used to build the format pattern.
            this.locales = locales;
            this.resolvedLocale = IntlMessageFormat.resolveLocale(locales);
            if (typeof message === 'string') {
                this.message = message;
                if (!IntlMessageFormat.__parse) {
                    throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
                }
                // Parse string messages into an AST.
                this.ast = IntlMessageFormat.__parse(message, {
                    ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
                    locale: this.resolvedLocale,
                });
            }
            else {
                this.ast = message;
            }
            if (!Array.isArray(this.ast)) {
                throw new TypeError('A message must be provided as a String or AST.');
            }
            // Creates a new object with the specified `formats` merged with the default
            // formats.
            this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
            this.formatters =
                (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
        }
        Object.defineProperty(IntlMessageFormat, "defaultLocale", {
            get: function () {
                if (!IntlMessageFormat.memoizedDefaultLocale) {
                    IntlMessageFormat.memoizedDefaultLocale =
                        new Intl.NumberFormat().resolvedOptions().locale;
                }
                return IntlMessageFormat.memoizedDefaultLocale;
            },
            enumerable: false,
            configurable: true
        });
        IntlMessageFormat.memoizedDefaultLocale = null;
        IntlMessageFormat.resolveLocale = function (locales) {
            var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
            if (supportedLocales.length > 0) {
                return new Intl.Locale(supportedLocales[0]);
            }
            return new Intl.Locale(typeof locales === 'string' ? locales : locales[0]);
        };
        IntlMessageFormat.__parse = parse;
        // Default format options used as the prototype of the `formats` provided to the
        // constructor. These are used when constructing the internal Intl.NumberFormat
        // and Intl.DateTimeFormat instances.
        IntlMessageFormat.formats = {
            number: {
                integer: {
                    maximumFractionDigits: 0,
                },
                currency: {
                    style: 'currency',
                },
                percent: {
                    style: 'percent',
                },
            },
            date: {
                short: {
                    month: 'numeric',
                    day: 'numeric',
                    year: '2-digit',
                },
                medium: {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                },
                long: {
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
                full: {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
            },
            time: {
                short: {
                    hour: 'numeric',
                    minute: 'numeric',
                },
                medium: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                },
                long: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
                full: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
            },
        };
        return IntlMessageFormat;
    }());

    function delve(obj, fullKey) {
      if (fullKey == null)
        return void 0;
      if (fullKey in obj) {
        return obj[fullKey];
      }
      const keys = fullKey.split(".");
      let result = obj;
      for (let p = 0; p < keys.length; p++) {
        if (typeof result === "object") {
          if (p > 0) {
            const partialKey = keys.slice(p, keys.length).join(".");
            if (partialKey in result) {
              result = result[partialKey];
              break;
            }
          }
          result = result[keys[p]];
        } else {
          result = void 0;
        }
      }
      return result;
    }

    const lookupCache = {};
    const addToCache = (path, locale, message) => {
      if (!message)
        return message;
      if (!(locale in lookupCache))
        lookupCache[locale] = {};
      if (!(path in lookupCache[locale]))
        lookupCache[locale][path] = message;
      return message;
    };
    const lookup = (path, refLocale) => {
      if (refLocale == null)
        return void 0;
      if (refLocale in lookupCache && path in lookupCache[refLocale]) {
        return lookupCache[refLocale][path];
      }
      const locales = getPossibleLocales(refLocale);
      for (let i = 0; i < locales.length; i++) {
        const locale = locales[i];
        const message = getMessageFromDictionary(locale, path);
        if (message) {
          return addToCache(path, refLocale, message);
        }
      }
      return void 0;
    };

    let dictionary;
    const $dictionary = writable({});
    function getLocaleDictionary(locale) {
      return dictionary[locale] || null;
    }
    function hasLocaleDictionary(locale) {
      return locale in dictionary;
    }
    function getMessageFromDictionary(locale, id) {
      if (!hasLocaleDictionary(locale)) {
        return null;
      }
      const localeDictionary = getLocaleDictionary(locale);
      const match = delve(localeDictionary, id);
      return match;
    }
    function getClosestAvailableLocale(refLocale) {
      if (refLocale == null)
        return void 0;
      const relatedLocales = getPossibleLocales(refLocale);
      for (let i = 0; i < relatedLocales.length; i++) {
        const locale = relatedLocales[i];
        if (hasLocaleDictionary(locale)) {
          return locale;
        }
      }
      return void 0;
    }
    function addMessages(locale, ...partials) {
      delete lookupCache[locale];
      $dictionary.update((d) => {
        d[locale] = cjs.all([d[locale] || {}, ...partials]);
        return d;
      });
    }
    derived(
      [$dictionary],
      ([dictionary2]) => Object.keys(dictionary2)
    );
    $dictionary.subscribe((newDictionary) => dictionary = newDictionary);

    const queue = {};
    function createLocaleQueue(locale) {
      queue[locale] = /* @__PURE__ */ new Set();
    }
    function removeLoaderFromQueue(locale, loader) {
      queue[locale].delete(loader);
      if (queue[locale].size === 0) {
        delete queue[locale];
      }
    }
    function getLocaleQueue(locale) {
      return queue[locale];
    }
    function getLocalesQueues(locale) {
      return getPossibleLocales(locale).map((localeItem) => {
        const localeQueue = getLocaleQueue(localeItem);
        return [localeItem, localeQueue ? [...localeQueue] : []];
      }).filter(([, localeQueue]) => localeQueue.length > 0);
    }
    function hasLocaleQueue(locale) {
      if (locale == null)
        return false;
      return getPossibleLocales(locale).some(
        (localeQueue) => {
          var _a;
          return (_a = getLocaleQueue(localeQueue)) == null ? void 0 : _a.size;
        }
      );
    }
    function loadLocaleQueue(locale, localeQueue) {
      const allLoadersPromise = Promise.all(
        localeQueue.map((loader) => {
          removeLoaderFromQueue(locale, loader);
          return loader().then((partial) => partial.default || partial);
        })
      );
      return allLoadersPromise.then((partials) => addMessages(locale, ...partials));
    }
    const activeFlushes = {};
    function flush(locale) {
      if (!hasLocaleQueue(locale)) {
        if (locale in activeFlushes) {
          return activeFlushes[locale];
        }
        return Promise.resolve();
      }
      const queues = getLocalesQueues(locale);
      activeFlushes[locale] = Promise.all(
        queues.map(
          ([localeName, localeQueue]) => loadLocaleQueue(localeName, localeQueue)
        )
      ).then(() => {
        if (hasLocaleQueue(locale)) {
          return flush(locale);
        }
        delete activeFlushes[locale];
      });
      return activeFlushes[locale];
    }
    function registerLocaleLoader(locale, loader) {
      if (!getLocaleQueue(locale))
        createLocaleQueue(locale);
      const localeQueue = getLocaleQueue(locale);
      if (getLocaleQueue(locale).has(loader))
        return;
      if (!hasLocaleDictionary(locale)) {
        $dictionary.update((d) => {
          d[locale] = {};
          return d;
        });
      }
      localeQueue.add(loader);
    }

    var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
    var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
    var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
    var __objRest$1 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$2)
        for (var prop of __getOwnPropSymbols$2(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    const defaultFormats = {
      number: {
        scientific: { notation: "scientific" },
        engineering: { notation: "engineering" },
        compactLong: { notation: "compact", compactDisplay: "long" },
        compactShort: { notation: "compact", compactDisplay: "short" }
      },
      date: {
        short: { month: "numeric", day: "numeric", year: "2-digit" },
        medium: { month: "short", day: "numeric", year: "numeric" },
        long: { month: "long", day: "numeric", year: "numeric" },
        full: { weekday: "long", month: "long", day: "numeric", year: "numeric" }
      },
      time: {
        short: { hour: "numeric", minute: "numeric" },
        medium: { hour: "numeric", minute: "numeric", second: "numeric" },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    function defaultMissingKeyHandler({ locale, id }) {
      console.warn(
        `[svelte-i18n] The message "${id}" was not found in "${getPossibleLocales(
      locale
    ).join('", "')}".${hasLocaleQueue(getCurrentLocale()) ? `

Note: there are at least one loader still registered to this locale that wasn't executed.` : ""}`
      );
    }
    const defaultOptions = {
      fallbackLocale: null,
      loadingDelay: 200,
      formats: defaultFormats,
      warnOnMissingMessages: true,
      handleMissingMessage: void 0,
      ignoreTag: true
    };
    const options = defaultOptions;
    function getOptions() {
      return options;
    }
    function init(opts) {
      const _a = opts, { formats } = _a, rest = __objRest$1(_a, ["formats"]);
      let initialLocale = opts.fallbackLocale;
      if (opts.initialLocale) {
        try {
          if (IntlMessageFormat.resolveLocale(opts.initialLocale)) {
            initialLocale = opts.initialLocale;
          }
        } catch (e) {
          console.warn(
            `[svelte-i18n] The initial locale "${opts.initialLocale}" is not a valid locale.`
          );
        }
      }
      if (rest.warnOnMissingMessages) {
        delete rest.warnOnMissingMessages;
        if (rest.handleMissingMessage == null) {
          rest.handleMissingMessage = defaultMissingKeyHandler;
        } else {
          console.warn(
            '[svelte-i18n] The "warnOnMissingMessages" option is deprecated. Please use the "handleMissingMessage" option instead.'
          );
        }
      }
      Object.assign(options, rest, { initialLocale });
      if (formats) {
        if ("number" in formats) {
          Object.assign(options.formats.number, formats.number);
        }
        if ("date" in formats) {
          Object.assign(options.formats.date, formats.date);
        }
        if ("time" in formats) {
          Object.assign(options.formats.time, formats.time);
        }
      }
      return $locale.set(initialLocale);
    }

    const $isLoading = writable(false);

    var __defProp$1 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
    var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
    var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$1 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp$1.call(b, prop))
          __defNormalProp$1(a, prop, b[prop]);
      if (__getOwnPropSymbols$1)
        for (var prop of __getOwnPropSymbols$1(b)) {
          if (__propIsEnum$1.call(b, prop))
            __defNormalProp$1(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    let current;
    const internalLocale = writable(null);
    function getSubLocales(refLocale) {
      return refLocale.split("-").map((_, i, arr) => arr.slice(0, i + 1).join("-")).reverse();
    }
    function getPossibleLocales(refLocale, fallbackLocale = getOptions().fallbackLocale) {
      const locales = getSubLocales(refLocale);
      if (fallbackLocale) {
        return [.../* @__PURE__ */ new Set([...locales, ...getSubLocales(fallbackLocale)])];
      }
      return locales;
    }
    function getCurrentLocale() {
      return current != null ? current : void 0;
    }
    internalLocale.subscribe((newLocale) => {
      current = newLocale != null ? newLocale : void 0;
      if (typeof window !== "undefined" && newLocale != null) {
        document.documentElement.setAttribute("lang", newLocale);
      }
    });
    const set = (newLocale) => {
      if (newLocale && getClosestAvailableLocale(newLocale) && hasLocaleQueue(newLocale)) {
        const { loadingDelay } = getOptions();
        let loadingTimer;
        if (typeof window !== "undefined" && getCurrentLocale() != null && loadingDelay) {
          loadingTimer = window.setTimeout(
            () => $isLoading.set(true),
            loadingDelay
          );
        } else {
          $isLoading.set(true);
        }
        return flush(newLocale).then(() => {
          internalLocale.set(newLocale);
        }).finally(() => {
          clearTimeout(loadingTimer);
          $isLoading.set(false);
        });
      }
      return internalLocale.set(newLocale);
    };
    const $locale = __spreadProps(__spreadValues$1({}, internalLocale), {
      set
    });
    const getLocaleFromNavigator = () => {
      if (typeof window === "undefined")
        return null;
      return window.navigator.language || window.navigator.languages[0];
    };

    const monadicMemoize = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      const memoizedFn = (arg) => {
        const cacheKey = JSON.stringify(arg);
        if (cacheKey in cache) {
          return cache[cacheKey];
        }
        return cache[cacheKey] = fn(arg);
      };
      return memoizedFn;
    };

    var __defProp = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    const getIntlFormatterOptions = (type, name) => {
      const { formats } = getOptions();
      if (type in formats && name in formats[type]) {
        return formats[type][name];
      }
      throw new Error(`[svelte-i18n] Unknown "${name}" ${type} format.`);
    };
    const createNumberFormatter = monadicMemoize(
      (_a) => {
        var _b = _a, { locale, format } = _b, options = __objRest(_b, ["locale", "format"]);
        if (locale == null) {
          throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
        }
        if (format) {
          options = getIntlFormatterOptions("number", format);
        }
        return new Intl.NumberFormat(locale, options);
      }
    );
    const createDateFormatter = monadicMemoize(
      (_c) => {
        var _d = _c, { locale, format } = _d, options = __objRest(_d, ["locale", "format"]);
        if (locale == null) {
          throw new Error('[svelte-i18n] A "locale" must be set to format dates');
        }
        if (format) {
          options = getIntlFormatterOptions("date", format);
        } else if (Object.keys(options).length === 0) {
          options = getIntlFormatterOptions("date", "short");
        }
        return new Intl.DateTimeFormat(locale, options);
      }
    );
    const createTimeFormatter = monadicMemoize(
      (_e) => {
        var _f = _e, { locale, format } = _f, options = __objRest(_f, ["locale", "format"]);
        if (locale == null) {
          throw new Error(
            '[svelte-i18n] A "locale" must be set to format time values'
          );
        }
        if (format) {
          options = getIntlFormatterOptions("time", format);
        } else if (Object.keys(options).length === 0) {
          options = getIntlFormatterOptions("time", "short");
        }
        return new Intl.DateTimeFormat(locale, options);
      }
    );
    const getNumberFormatter = (_g = {}) => {
      var _h = _g, {
        locale = getCurrentLocale()
      } = _h, args = __objRest(_h, [
        "locale"
      ]);
      return createNumberFormatter(__spreadValues({ locale }, args));
    };
    const getDateFormatter = (_i = {}) => {
      var _j = _i, {
        locale = getCurrentLocale()
      } = _j, args = __objRest(_j, [
        "locale"
      ]);
      return createDateFormatter(__spreadValues({ locale }, args));
    };
    const getTimeFormatter = (_k = {}) => {
      var _l = _k, {
        locale = getCurrentLocale()
      } = _l, args = __objRest(_l, [
        "locale"
      ]);
      return createTimeFormatter(__spreadValues({ locale }, args));
    };
    const getMessageFormatter = monadicMemoize(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (message, locale = getCurrentLocale()) => new IntlMessageFormat(message, locale, getOptions().formats, {
        ignoreTag: getOptions().ignoreTag
      })
    );

    const formatMessage = (id, options = {}) => {
      var _a, _b, _c, _d;
      let messageObj = options;
      if (typeof id === "object") {
        messageObj = id;
        id = messageObj.id;
      }
      const {
        values,
        locale = getCurrentLocale(),
        default: defaultValue
      } = messageObj;
      if (locale == null) {
        throw new Error(
          "[svelte-i18n] Cannot format a message without first setting the initial locale."
        );
      }
      let message = lookup(id, locale);
      if (!message) {
        message = (_d = (_c = (_b = (_a = getOptions()).handleMissingMessage) == null ? void 0 : _b.call(_a, { locale, id, defaultValue })) != null ? _c : defaultValue) != null ? _d : id;
      } else if (typeof message !== "string") {
        console.warn(
          `[svelte-i18n] Message with id "${id}" must be of type "string", found: "${typeof message}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`
        );
        return message;
      }
      if (!values) {
        return message;
      }
      let result = message;
      try {
        result = getMessageFormatter(message, locale).format(values);
      } catch (e) {
        if (e instanceof Error) {
          console.warn(
            `[svelte-i18n] Message "${id}" has syntax error:`,
            e.message
          );
        }
      }
      return result;
    };
    const formatTime = (t, options) => {
      return getTimeFormatter(options).format(t);
    };
    const formatDate = (d, options) => {
      return getDateFormatter(options).format(d);
    };
    const formatNumber = (n, options) => {
      return getNumberFormatter(options).format(n);
    };
    const getJSON = (id, locale = getCurrentLocale()) => {
      return lookup(id, locale);
    };
    const $format = derived([$locale, $dictionary], () => formatMessage);
    derived([$locale], () => formatTime);
    derived([$locale], () => formatDate);
    derived([$locale], () => formatNumber);
    derived([$locale, $dictionary], () => getJSON);

    /* src/components/about/AboutLink.svelte generated by Svelte v3.59.2 */

    // (14:0) <Link to="about" class="uk-text-muted">
    function create_default_slot$6(ctx) {
    	let t0_value = /*$_*/ ctx[1]("about.about") + "";
    	let t0;
    	let t1;
    	let t2_value = /*appVersion*/ ctx[0].version + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" - v");
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("about.about") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*appVersion*/ 1 && t2_value !== (t2_value = /*appVersion*/ ctx[0].version + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(14:0) <Link to=\\\"about\\\" class=\\\"uk-text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				to: "about",
    				class: "uk-text-muted",
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};

    			if (dirty & /*$$scope, appVersion, $_*/ 7) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AboutLink', slots, []);
    	let appVersion = {};

    	onMount(async () => {
    		app_version.subscribe(v => $$invalidate(0, appVersion = v));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AboutLink> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Link: Link$1,
    		app_version,
    		_: $format,
    		appVersion,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('appVersion' in $$props) $$invalidate(0, appVersion = $$props.appVersion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [appVersion, $_];
    }

    class AboutLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AboutLink",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    /* src/components/wallet/AccountSwitcher.svelte generated by Svelte v3.59.2 */
    const file$X = "src/components/wallet/AccountSwitcher.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (26:6) {#if account_list && account_list.length > 0}
    function create_if_block_2$8(ctx) {
    	let span;

    	function select_block_type(ctx, dirty) {
    		if (/*my_account*/ ctx[0]) return create_if_block_3$6;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "uk-margin-small-left");
    			add_location(span, file$X, 26, 8, 912);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(26:6) {#if account_list && account_list.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (30:10) {:else}
    function create_else_block_1$5(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_switcher.select_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_switcher.select_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(30:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (28:10) {#if my_account}
    function create_if_block_3$6(ctx) {
    	let t_value = /*my_account*/ ctx[0].nickname + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*my_account*/ 1 && t_value !== (t_value = /*my_account*/ ctx[0].nickname + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(28:10) {#if my_account}",
    		ctx
    	});

    	return block;
    }

    // (39:8) {#if account_list && account_list.length > 0}
    function create_if_block$t(ctx) {
    	let li0;
    	let t0_value = /*$_*/ ctx[2]("wallet.account_switcher.switch_account") + "";
    	let t0;
    	let t1;
    	let li1;
    	let t2;
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (!/*account_list*/ ctx[1]) return create_if_block_1$f;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			li1 = element("li");
    			t2 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(li0, "class", "uk-text-muted");
    			add_location(li0, file$X, 39, 10, 1271);
    			attr_dev(li1, "class", "uk-nav-divider");
    			add_location(li1, file$X, 41, 10, 1372);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			append_dev(li0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, li1, anchor);
    			insert_dev(target, t2, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.account_switcher.switch_account") + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(li1);
    			if (detaching) detach_dev(t2);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(39:8) {#if account_list && account_list.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (45:10) {:else}
    function create_else_block$f(ctx) {
    	let t;
    	let li;
    	let each_value = /*account_list*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			li = element("li");
    			attr_dev(li, "class", "uk-nav-divider");
    			add_location(li, file$X, 56, 12, 1881);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, li, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*my_account, account_list, setAccount*/ 3) {
    				each_value = /*account_list*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(45:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:10) {#if !account_list}
    function create_if_block_1$f(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "loading...";
    			add_location(p, file$X, 43, 12, 1468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(43:10) {#if !account_list}",
    		ctx
    	});

    	return block;
    }

    // (46:12) {#each account_list as acc}
    function create_each_block$6(ctx) {
    	let li;
    	let a;
    	let t_value = /*acc*/ ctx[6].nickname + "";
    	let t;
    	let a_class_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*acc*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#");

    			attr_dev(a, "class", a_class_value = /*my_account*/ ctx[0].account == /*acc*/ ctx[6].account
    			? 'uk-text-primary'
    			: '');

    			add_location(a, file$X, 47, 16, 1579);
    			add_location(li, file$X, 46, 14, 1558);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*account_list*/ 2 && t_value !== (t_value = /*acc*/ ctx[6].nickname + "")) set_data_dev(t, t_value);

    			if (dirty & /*my_account, account_list*/ 3 && a_class_value !== (a_class_value = /*my_account*/ ctx[0].account == /*acc*/ ctx[6].account
    			? 'uk-text-primary'
    			: '')) {
    				attr_dev(a, "class", a_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(46:12) {#each account_list as acc}",
    		ctx
    	});

    	return block;
    }

    // (62:12) <Link to="settings" class="uk-text-muted">
    function create_default_slot_1$3(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_switcher.setting") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_switcher.setting") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(62:12) <Link to=\\\"settings\\\" class=\\\"uk-text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:12) <Link to="dev" class="uk-text-muted">
    function create_default_slot$5(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_switcher.developers") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_switcher.developers") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(67:12) <Link to=\\\"dev\\\" class=\\\"uk-text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let main;
    	let div1;
    	let button;
    	let networkicon;
    	let t0;
    	let t1;
    	let div0;
    	let ul;
    	let t2;
    	let li0;
    	let a0;
    	let link0;
    	let t3;
    	let li1;
    	let a1;
    	let link1;
    	let t4;
    	let li2;
    	let aboutlink;
    	let current;
    	networkicon = new NetworkIcon({ $$inline: true });
    	let if_block0 = /*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0 && create_if_block_2$8(ctx);
    	let if_block1 = /*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0 && create_if_block$t(ctx);

    	link0 = new Link$1({
    			props: {
    				to: "settings",
    				class: "uk-text-muted",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				to: "dev",
    				class: "uk-text-muted",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	aboutlink = new AboutLink({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			button = element("button");
    			create_component(networkicon.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div0 = element("div");
    			ul = element("ul");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			li0 = element("li");
    			a0 = element("a");
    			create_component(link0.$$.fragment);
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			create_component(link1.$$.fragment);
    			t4 = space();
    			li2 = element("li");
    			create_component(aboutlink.$$.fragment);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$X, 23, 4, 770);
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$X, 60, 10, 1964);
    			add_location(li0, file$X, 59, 8, 1949);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$X, 65, 10, 2136);
    			add_location(li1, file$X, 64, 8, 2121);
    			attr_dev(li2, "class", "uk-text-muted");
    			add_location(li2, file$X, 69, 8, 2291);
    			attr_dev(ul, "class", "uk-nav uk-dropdown-nav");
    			add_location(ul, file$X, 37, 6, 1171);
    			attr_dev(div0, "uk-dropdown", "");
    			add_location(div0, file$X, 36, 4, 1147);
    			add_location(div1, file$X, 22, 2, 760);
    			add_location(main, file$X, 21, 0, 751);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, button);
    			mount_component(networkicon, button, null);
    			append_dev(button, t0);
    			if (if_block0) if_block0.m(button, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, ul);
    			if (if_block1) if_block1.m(ul, null);
    			append_dev(ul, t2);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			mount_component(link0, a0, null);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			mount_component(link1, a1, null);
    			append_dev(ul, t4);
    			append_dev(ul, li2);
    			mount_component(aboutlink, li2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$8(ctx);
    					if_block0.c();
    					if_block0.m(button, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*account_list*/ ctx[1] && /*account_list*/ ctx[1].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$t(ctx);
    					if_block1.c();
    					if_block1.m(ul, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 516) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 516) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(networkicon.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(aboutlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(networkicon.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(aboutlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(networkicon);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(aboutlink);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountSwitcher', slots, []);
    	let my_account;
    	let account_list;
    	let unsubsSigningAccount;
    	let unsubsAll_accounts;

    	onMount(async () => {
    		unsubsSigningAccount = signingAccount.subscribe(value => $$invalidate(0, my_account = value));
    		unsubsAll_accounts = all_accounts.subscribe(all => $$invalidate(1, account_list = all));
    	});

    	onDestroy(() => {
    		unsubsSigningAccount && unsubsSigningAccount();
    		unsubsAll_accounts && unsubsAll_accounts();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountSwitcher> was created with unknown prop '${key}'`);
    	});

    	const click_handler = acc => setAccount(acc.account);

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		signingAccount,
    		all_accounts,
    		setAccount,
    		Link: Link$1,
    		NetworkIcon,
    		AboutLink,
    		_: $format,
    		my_account,
    		account_list,
    		unsubsSigningAccount,
    		unsubsAll_accounts,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('my_account' in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ('account_list' in $$props) $$invalidate(1, account_list = $$props.account_list);
    		if ('unsubsSigningAccount' in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ('unsubsAll_accounts' in $$props) unsubsAll_accounts = $$props.unsubsAll_accounts;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [my_account, account_list, $_, click_handler];
    }

    class AccountSwitcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountSwitcher",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    const routes = {
        home: '/',
        addAccount: '/add-account',
        accountFromMnem: '/account-from-mnem',
        keygen: '/keygen',
        miner: '/miner',
        transactions: '/txs',
        events: '/events',
        settings: '/settings',
        about: '/about',
        developer: '/dev',
        swarm: '/swarm',
        makeWhole: '/make-whole'
    };

    var nav$7={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout$7={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"},recovery_mode:{title:"Recovery Mode",body:"The network is up! But we are in Recovery Mode, and no rewards are being paid for proofs yet. Wait until Recovery Mode is finished to send proofs for rewards. Recovery ends when epoch {epoch_recovery_ends} changes to {epoch_recovery_ends_after}"}};var wallet$7={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Settings",developers:"Developers"}};var about$7={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$7={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"English",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner$7={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs$7={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",error_account_does_not_exist:"Recipient account does not exist.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events$7={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Events Temporarily Unavailable",corrupted_db:"The server you are connected to does not have all your event history available.",account_off_chain:"Account selected not onboarded yet, and has no events."}};var make_whole$7={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transaction confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var en = {nav:nav$7,layout:layout$7,wallet:wallet$7,about:about$7,settings:settings$7,miner:miner$7,txs:txs$7,events:events$7,make_whole:make_whole$7};

    var nav$6={wallet:"钱包",miner:"矿工",transactions:"交易",events:"事件"};var layout$6={connection_error:{title:"糟糕, 居然无法连上OL网络",body:"<p> 很有可能是上游节点已断开。</p> <h3> 别担心！您的账号和资产是安全的.</h3> <p>如果您需要更新连接节点，请点这里：</p>"},error_accordion:{title:"错误报告",category:"错误分类",id:"ID"}};var wallet$6={wallet:"钱包",carpe:"CARPE",btn_new_account:"创建账号",btn_restore_account:"恢复账号",newbie_message:"您似乎还没有创建账号。",reminder_create:{card_title:"激活",message_headline:"您的账号已经创建成功，但是还没有激活。",message_prefix:"加我们的",message_suffix:" 社区并提供您的激活码，社区成员会帮助您完成账户激活。",onboard_key:"激活码（AuthKey）"},account_list:{nickname:"昵称",address:"地址",authkey:"激活码",balance:"余额",offline:"断线",loading:"加载中",account_on_chain:"未激活",message:" 所有发送的交易（包括：挖矿）都会消耗一些余额作为手续费。"},keygen:{title:"创建新账号",description:"创建账户后，您的账户需要收到来自链上的任意一个钱包至少1个0L代币，才能够被激活上链。",btn_generate_keys:"生成密钥",btn_generate_keys_2:"换一个密钥",btn_create_account:"创建账户",account_address:"账户地址",onboard_key:"激活码（AuthKey）",onboard_key_description:"这个激活码用来将您账户激活到链上",securite_recovery_phrase:"账号助记词",securite_note:"这是您账号的助记词。如果丢失，您的账户将永远无法恢复。建议您用纸和笔记下来，妥善保管。",account_tips:"您的账号还没有上链，您需要将激活码发给一个已经拥有链上钱包的用户，来帮助您完成账号创建。"},account_from_mnem_submit:{title:" 备份好了吗？",body:" <p>您确定要使用这个助记词吗？</p> <p>如果助记词丢失或者忘记，您将不能恢复您的账号！</p><p> 请检查已经完成助记词备份！</p>",btn_cancel:"返回检查",btn_submit:"确认提交",btn_submiting:"提交中"},account_from_mnem_from:{title:"恢复账号",description:"使用您已备份的钱包账户助记词，在 CARPE 恢复账号，查看资产和发送交易。",placeholder:"助记词"},account_switcher:{select_account:"选择账号",switch_account:"切换账号",setting:"设置菜单",developers:"开发者模式"}};var about$6={about:"关于",release:"版本信息",version:"版本号",branch:"分支",commit:"Commit"};var settings$6={title:"设置",langapp_settings:{title:"语言和显示",lang:"语言",lang_description:"请选择您要显示的语言",lang_button:"中文",theme:"主题",theme_description:"请选择您喜欢的界面主题"},network_settings:{title:"网络设置",list_of_peers:"节点列表",description:"选择节点列表，自动化切换上游节点。Carpe 会在列表中随机连接上游节点，直至链接成功。您可以链接任何的 playlist.json 文件来更新节点。",playlist:"更新网络节点",override_peers:"覆盖节点",override_peers_description:"您可以设置只使用一个指定节点，请输入该节点 IP 地址，点击确认。注：覆盖节点模式下，节点列表功能将默认关闭。",url_of_upstream_node:"指定节点URL",btn_update:"确认",upstream_title:"获取新的WAYPOINT",upstream_subtitle:"通过切换获取新的 waypoint 来解决连接问题。",btn_fetch_new_waypoint:"获取新的Waypoint",btn_cancel:"取消",btn_submit:"使用节点列表"},account_settings:{title:"账号设置",btn_remove:"删除账号",comfirm:"请确认要从本设备中删除当前账号吗？本操作不可逆。",description:"本操作不会删除链上账号，只会删除本地设备上的信息，请注意如果您没有备份助记词，您的账号将无法被恢复。"}};var miner$6={title:"矿工",miner_backlog:{title:"同步塔（Tower）证明",subtitle:"手动提交本地积压证明",in_process:"提交中",btn_submit:"提交本地积压证明"},miner_phases:{backlog_started:"积压监听启动",backlog_in_process:"积压提交中",backlog_complete:"积压处理完成",mining_enabled:"启动挖矿",proof_started:"证明请求开始",proof_complete:"证明完成"},miner_process:{status_complete:"证明完成",status_in_process:"挖矿进行中",notes:"百分比是预估值 <br> 它是根据您前一个证明的消耗时间估算的。",notes2:"超过100%，意味着当前证明比前一个所需要的时间更长。"},tower_state:{local_height:"本地塔高",on_chain_height:"链上塔高",mined_in_last_epoch:"当前纪元",sent_in_this_epoch:"现已提交",empty:"当前设备未发现证明",proof_more:"您提交的证明数已达到今天的最大值（72）",proof_less:"证明数量未达获取奖励的最小值 (8)",proof_ok:"恭喜您完成了本期需要的最小的证明数（8）"},cards:{cant_start:{title:"您的账号还未激活在链上。",body:"账号激活上链后，挖矿程序才能启动。可能您已经在本地创建了钱包地址，但是需要一个已经拥有链上钱包的用户转账1个0L币激活您的账户。"},disco_error:{title:"中断",body:"您当前提交的证明中存在空缺. 每一个证明的提交都需要基于前一个的数据，因此现在这个证明被拒绝了。"},epoch_status:{empty_title:"没有提交证明",empty_body:"没有在链上找到任何证明，如果您成功提交了一个证明，这里会显示统计数据。",in_process_title:"加油！",in_process_body:"您的账户每天（epoch）需要至少提交8个证明，第二天（下一个epoch）才会收到奖励。",complete_title:"成功！请保持",complete_body:"您已经完成今日所需的最低证明提交数量，（最少8个每天（epoch）保持挖矿将收获更多奖励。 您将会在明天（下一个epoch）开始的时候收到奖励",exceed_title:"牛哇！牛！",exceed_body:"您已经提交了72个证明，这是每天可以提交的最大数量。塔会继续提交证明，并在新的周期开始后一口气提交到连上。"},first_proof:{title:"开始提交第一个证明吧！",body:"<p>这将需要大约30分钟或者1小时左右的时间</p> <p> 挖取证明将会消耗您余额中一定数量的代币作为手续费. 如果您提交的证明数达到每天所需的最小值（8个）, 您就会在第二天（下一个epoch）收到奖励.</p> <p> 请检查您的计算机设置，关闭显示器后，电脑不会进入休眠状态，休眠状态 Carpe 会停止运行。</p>",body_disabled:"打开按钮开始挖矿吧!"},invalid_proof:{title:"证明验证失败！",body:"奇怪. 这个证明被拒绝了，因为它不是一个有效的“延时证明”。这通常是参数设置错误。"},oops:{title:"喔！~",body:"挖取证明的过程中出错了。"},too_many_proofs:{title:"太多错误",body:"您在最近24小时内已经提交了太多的证明. 每个周期最多接受{maxNum}证明. 您可以在下一个周期开始的时候重新提交."},wrong_difficulty:{title:"错误的难度",body:"您证明文件中使用了错误的难度参数。检查您连接的网络是否使用了正确的难度参数。"},sync_proof:{title:"同步证明",body:"等待证明交易确认 {delta} ",body_0:"出现了一些小错误, 您本地的证明比链上的多，也有可能是您本地丢失了一些证明文件。"}}};var txs$6={deno_tx:"测试交易",account:"账号",balance:"余额",btn_onboard:"激活账户",btn_transfer:"发送代币",onboard:{title:"激活账号","await":"处理中",btn_onboard:"激活",btn_cancel:"取消",no_balance_title:"余额不足",no_balance_body1:"{onboard_key}尚未激活成功.",no_balance_body2:"您的账户资产少于2个币，您不可以激活任何人。"},set_wallet_type:{title:"设置账户类型",subtitle:"确认您务必确认本次操作. 本操作不可逆. 慢钱包和社区钱包是永久性的。",btn_slow:"设为慢钱包",btn_confirm_slow:"确认设置慢钱包吗？本操作不可逆。",slow_confirm:"设为慢钱包",btn_community:"设为社区钱包",btn_confirm_community:"设为社区钱包",community_confirm:"确认要设为社区钱包吗？本操作不可逆。"},transfer:{title:"代币转账",sender:"发送者",balance:"余额",receiver:"接收者",amount:"代币数量",amount_label:"数量 (不能使用小数)",receiver_placeholder:"请输入接收者钱包账户地址",amount_placeholder:"请输入需要转账的数量",confirm_title:"注意！",please_confirm:"请确认您的转账信息:","await":"处理中",btn_next:"下一步",btn_confirm:"确认",btn_cancel:"取消",btn_close:"关闭",error_amount_greater_than_balance:"数量不能大于账户余额",error_receiver_equals_sender:"接收地址不能是发送地址",error_slow_wallet:"慢钱包转账功能尚未启动",success:"转账成功！",failed:"转账失败。 错误码: {code}"}};var events$6={account_events:"账户事件",version:"版本",type:"类型",amount:"数量",sender:"发送者",receiver:"接收者",received_payment:"转入记录",sent_payment:"转出记录",loading:{error:"账户事件加载失败:",corrupted_db:"当前连接的节点无法查询您的账户信息. 别担心，您的资产是安全的，您可以尝试其他节点！",account_off_chain:"当前选中的账号未激活！"}};var make_whole$6={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var zh_cn = {nav:nav$6,layout:layout$6,wallet:wallet$6,about:about$6,settings:settings$6,miner:miner$6,txs:txs$6,events:events$6,make_whole:make_whole$6};

    var nav$5={wallet:"Wallet",miner:"Miner",transactions:"Transaktionen",events:"Ereignisse"};var layout$5={connection_error:{title:"Ups, wir können keine Verbindung zum 0L-Netzwerk herstellen",body:"<p> Dies liegt wahrscheinlich daran, dass der von dir verwendete Upstream-Peer (Server) nicht verfügbar ist.</p> <h3> Keine Sorge, dein Konto und deine Coins sind sicher.</h3> <p>Wenn Du Deine Peers ändern oder aktualisieren musst, kannst Du das hier tun:</p>"},error_accordion:{title:"Fehlerbericht",category:"Fehler-Kategorie",id:"ID"},recovery_mode:{title:"Wiederherstellungsmodus",body:"Das Netz ist wieder in Betrieb! Aber wir befinden uns im Wiederherstellungsmodus, und es werden noch keine Belohnungen für Proofs gezahlt. Warte, bis der Wiederherstellungsmodus beendet ist, um Proofs für Belohnungen zu senden. Die Wiederherstellung endet, wenn die Epoche {epoch_recovery_ends} auf {epoch_recovery_ends_after} wechselt."}};var wallet$5={wallet:"Wallet",carpe:"CARPE",btn_new_account:"Neues Konto",btn_restore_account:"Konto wiederherstellen",newbie_message:"Sieht aus, als hättest du keine Konten",reminder_create:{card_title:"Onboarding",message_headline:"Du hast Keys für ein Konto erzeugt, aber es existiert noch nicht auf der Chain.",message_prefix:"Tritt unserer Gemeinschaft bei auf ",message_suffix:" und gib uns deinen Onboard Key, um an Bord zu kommen.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Spitzname",address:"Adresse",authkey:"Authkey",balance:"Guthaben",offline:"offline",loading:"wird geladen",account_on_chain:"Konto nicht auf der Chain",message:" Dein Guthaben verringert sich bei jeder Transaktion, die du sendest, einschließlich Mining."},keygen:{title:"Neues Konto anlegen",description:"Nachdem du ein Konto und eine geheime Phrase erstellt hast, muss jemand einen 0L-Coin an dieses Konto senden, damit es auf der Chain erstellt wird.",btn_generate_keys:"Key erzeugen",btn_generate_keys_2:"Unterschiedliche Keys erzeugen",btn_create_account:"Dieses Konto anlegen",account_address:"Adresse des Kontos",onboard_key:"Onboarding Key",onboard_key_description:"Dieser wird auch als Auth Key bezeichnet. Du brauchst ihn, um das Konto auf der Chain erstellen zu können.",securite_recovery_phrase:"GEHEIME WIEDERHERSTELLUNGSPHRASE",securite_note:"Dies ist dein geheimes Kontopasswort (Mnemonic). Wenn du es verlierst, kann dir niemand helfen! Schreib es dir jetzt auf.",account_tips:"Dein Konto existiert noch nicht auf der Chain. Du musst jemandem deinen Onboarding Key geben, damit er dein Konto erzeugen kann."},account_from_mnem_submit:{title:" Aufgepasst!",body:" <p>Bist du sicher, dass du deine Mnemonic Phrase aufgeschrieben hast?</p> <p>Ohne sie kannst du dein Konto nicht wiederherstellen. Niemand kann dir helfen, wenn du sie verlierst.</p><p>Dies ist die letzte Chance, sie aufzuschreiben.</p>",btn_cancel:"Ich schaue nochmal nach",btn_submit:"Jetzt Abschicken",btn_submiting:"Abschicken"},account_from_mnem_from:{title:"KONTO WIEDERHERSTELLEN",description:"Mit deinen Wiederherstellungswörtern (Mnemonik) kannst du Carpe als Wallet zur Überwachung und zum Senden von Transaktionen konfigurieren",placeholder:"Wiederherstellungs Mnemonik"},account_switcher:{select_account:"Konto auswählen",switch_account:"Konto wechseln",setting:"Gehe zu Einstellung",developers:"Entwickler"}};var about$5={about:"Über",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$5={title:"EINSTELLUNGEN",langapp_settings:{title:"Sprache und Erscheinungsbild",lang:"Sprache",lang_description:"Wähle die Anzeigesprache",lang_button:"Deutsch",theme:"Theme",theme_description:"Wähle das Theme"},network_settings:{title:"NETZWERKEINSTELLUNGEN",list_of_peers:"LISTE DER PEERS",description:"Wählen Sie eine Playlist mit vorgelagerten Knoten, damit ein Zugriff auf die Kette möglich ist. Netzwerkverbindungen werden die Liste in zufälliger Reihenfolge ausprobieren, bis eine Verbindung hergestellt ist. Verweise hier einfach auf eine beliebige playlist.json-Datei, um die Peers zu aktualisieren.",playlist:"Playlist der Netzwerkserver aktualisieren",override_peers:"PEERS ÜBERSCHREIBEN",override_peers_description:"Du kannst die Verwendung eines anderen Peers erzwingen. Mit dieser Einstellung kannst du nur einen Peer auswählen. Dadurch wird die Playlist entfernt. Diese besteht nun aus einem einzigen Element.",url_of_upstream_node:"URL des vorgelagerten Knotens",btn_update:"AKTUALISIERUNG",upstream_title:"EINEN NEUEN WEGPUNKT VON OBERHALB ABRUFEN",upstream_subtitle:"Die meisten Probleme mit Wegpunkten lassen sich leicht beheben, indem man einen aktualisierten Wegpunkt von einem verbundenen Upstream-Peer abruft.",btn_fetch_new_waypoint:"Neuen Wegpunkt abrufen",btn_cancel:"Abbrechen",btn_submit:"PLAYLIST VERWENDEN"},account_settings:{title:"KONTOEINSTELLUNGEN",btn_remove:"KONTO LÖSCHEN",comfirm:"Das Löschen von Konten auf diesem Gerät bestätigen? Das kann nicht rückgängig gemacht werden.",description:"Dabei werden keine Konten von der Chain gelöscht. Die Konten werden nur von diesem Gerät entfernt. Wenn du deine Wiederherstellungscodes (Mnemonik) nicht irgendwo aufbewahrst, kann es sein, dass du dauerhaft aus diesem Konto ausgesperrt wirst. NIEMAND KANN DIR HELFEN, DIE MNEMONIK WIEDERZUBEKOMMEN. "}};var miner$5={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Lokale Proofs manuell erneut einreichen",in_process:"Backlog in Arbeit",btn_submit:"Lokalen Backlog einreichen"},miner_phases:{backlog_started:"Backlog Listener Gestartet",backlog_in_process:"Backlog in Arbeit",backlog_complete:"Backlog Fertig",mining_enabled:"Mining Aktiviert",proof_started:"Anforderung für Proof-Start erhalten",proof_complete:"Proof Fertig"},miner_process:{status_complete:"Proof Fertig",status_in_process:"Mining Läuft",notes:"Der Prozentsatz ist eine Schätzung. <br> Es basiert auf der für den letzten Proof verwendeten Zeitspanne.",notes2:"Über 100% bedeutet nur, dass es länger dauert als der vorherige Proof."},tower_state:{local_height:"Lokale Turmhöhe",on_chain_height:"On-chain Turmhöhe",mined_in_last_epoch:"Letzte Epoche gemined",sent_in_this_epoch:"In dieser Epoche übermittelte Proofs",empty:"Keine Proofs auf dem Gerät gefunden",proof_more:"Du hast heute ein Maximum an Proofs übermittelt (max. 72)",proof_less:"Nicht genügend Proofs, um heute eine Belohnung zu erhalten (mindestens 8)",proof_ok:"Dein Konto hat heute genügend Proofs übermittelt (mindestens 8)"},cards:{cant_start:{title:"Dein Konto existiert noch nicht in der Chain ",body:"Der Miner kann erst starten, wenn das Konto auf der Chain gefunden werden kann. Vielleicht hast du lokal neue Schlüssel generiert, aber niemand hat Coins an die Adresse geschickt?"},disco_error:{title:"Unterbrechung ",body:"Sieht aus, als gäbe es eine Lücke in den von dir übermittelten Proofs. Jeder Proof muss auf den vorhergehenden verweisen, und der Proof wurde deshalb abgelehnt."},epoch_status:{empty_title:"Keine Proofs übermittelt",empty_body:"Es sind keine Proofs auf der Chain gespeichert. Wenn du deinen ersten Proof erfolgreich übermittelt hast, wirst du hier einige Statistiken sehen.",in_process_title:"Weiter so",in_process_body:"Dein Konto muss mindestens 8 Proofs pro Tag (Epoche) übermitteln, um eine Belohnung zu erhalten. Du erhältst die Belohnung am nächsten Tag.",complete_title:"Geschafft!",complete_body:"Dein Konto hat heute genügend Proofs geliefert (mindestens 8 Proofs pro Epoche). Du solltest die Belohnungen zu Beginn der nächsten Epoche erhalten.",exceed_title:"Brrrr",exceed_body:"Du hast 72 Proofs erzeugt, das ist die maximale Anzahl von Proofs pro Epoche. Der Turm kann weiterhin Proofs machen, aber sie werden erst in der nächsten Epoche akzeptiert."},first_proof:{title:"Machen wir uns an deinen ersten Proof",body:"<p> Abwarten! Das dauert mindestens 30 Minuten, vielleicht bis zu 1 Stunde.</p> <p> Während du Proofs schürfst, wird dein Kontostand sinken. Wenn du das Minimum pro Tag erreichst, erhältst du am nächsten Tag (Epoche) eine Belohnung.</p> <p> Prüfe deine Computereinstellungen, damit der Computer nicht in den Ruhezustand geht, wenn sich der Bildschirm ausschaltet. Du möchtest, dass der Miner läuft, wenn du nicht da bist.</p>",body_disabled:"Leg den Schalter um und fang an zu minen!"},invalid_proof:{title:"Kann den Proof nicht bestätigen",body:"Seltsam. Dieser Proof wurde abgelehnt, weil er kein gültiger \"Delay Proof\" ist. Dies liegt in der Regel daran, dass die Parameter nicht korrekt eingestellt sind."},oops:{title:"Hoppla",body:"Sieht aus, als gäbe es einen Fehler beim Mining eines Delay Proofs"},too_many_proofs:{title:"Zu Viele Proofs",body:"Sieht aus, als hättest du in den letzten 24 Stunden mehr Proofs geschickt als erwartet. Die Chain erwartet maximal {maxNum} Proofs pro Epoche. In der nächsten Epoche werden deine Proofs wieder übermittelt."},wrong_difficulty:{title:"Falsche Difficulty",body:"Es sieht so aus, als würdest du einen Proof mit den falschen Difficulty-Parametern an die Chain senden. Stelle sicher, dass du mit dem richtigen Netzwerk und den richtigen Difficulty-Einstellungen verbunden bist."},sync_proof:{title:"Synchronisierung Deiner Proofs",body:"Auf Transaktion wartende Proofs: {delta} ",body_0:"Irgendetwas stimmt nicht. Du hast mehr Proofs auf der Chain, als auf diesem Gerät. Möglicherweise fehlen dir lokale Proofs."}}};var txs$5={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Konto Onboarden","await":"",btn_onboard:"Onboarden",btn_cancel:"Abbrechen",no_balance_title:"Niedriger Kontostand",no_balance_body1:"Das Onboarding von {onboard_key} war nicht erfolgreich.",no_balance_body2:"Sieht so aus, als hättest du weniger als 2 Coins auf deinem Konto, das bedeutet, dass du niemanden onboarden kannst."},set_wallet_type:{title:"Kontotyp Auswählen",subtitle:" Es ist wichtig, dass du weißt, was du tust. Dies kann nicht mehr rückgängig gemacht werden. Slow und Community Wallets sind unveränderlich.",btn_slow:"Slow Wallet Wählen",btn_confirm_slow:"Slow Wallet bestätigen? Dies kann nicht rückgängig gemacht werden.",slow_confirm:"Slow Wählen",btn_community:"Community Wallet Wählen",btn_confirm_community:"Community Wählen",community_confirm:"Community Wallet bestätigen? Dies kann nicht rückgängig gemacht werden."},transfer:{title:"Überweisung von Coins",sender:"Sender",balance:"Betrag",receiver:"Receiver",amount:"Empfänger",amount_label:"Empfänger (Dezimalstellen noch nicht unterstützt)",receiver_placeholder:"Empfänger Adresse",amount_placeholder:"Überweisungsbetrag",confirm_title:"Achtung!",please_confirm:"Bitte die Überweisungsdaten bestätigen:","await":"Auf Txs warten",btn_next:"Weiter",btn_confirm:"Bestätigen",btn_cancel:"Abbrechen",btn_close:"Schließen",error_amount_greater_than_balance:"Der Betrag kann nicht größer als der Kontostand sein",error_receiver_equals_sender:"Die Empfängeradresse muss sich von der Absenderadresse unterscheiden",error_slow_wallet:"Die Überweisung von Coins ist für Slow Wallets deaktiviert.",success:"Überweisung erfolgreich durchgeführt",failed:"Überweisung fehlgeschlagen. Code: {code}"}};var events$5={account_events:"Kontoereignisse",version:"Version",type:"Typ",amount:"Betrag",sender:"Sender",receiver:"Empfänger",received_payment:"Empfangene Zahlung",sent_payment:"Gesendete Zahlung",loading:{error:"Fehler beim Laden der Kontoereignisse:",corrupted_db:"Der aktuell verbundene Knoten verfügt nicht über alle Kontoereignisse. Keine Sorge. Deine Wallet und Coins sind in Sicherheit auf der Chain. Probiere, dich mit einem anderen Upstream-Knoten zu verbinden.",account_off_chain:"Das ausgewählte Konto wurde noch nicht geonboarded."}};var make_whole$5={link_title:"Coins einfordern",card:{title:"Deine Fehlenden Coins Einfordern",body:"<p>Hoppla. Gelegentlich machen Blockchains mathematische Fehler. 0L versucht, diese so schnell wie möglich zu beheben.</p><p>Vorfall bei Miner-Identitäts-Subventionierung: Von Epoche 0 bis Epoche 52 waren die Auszahlungen an Miner geringer als erwartet. Nachfolgend kannst du deine fehlenden Coins aus diesem Zeitraum gutschreiben lassen.</p>"},table:{account:"Konto",amount:"Betrag",claim:"Forderung"},claim_btn:{"await":"Warten...",claim:"Jetzt Einfordern"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>Du hast <span class=\"uk-text-bold\">{coins} Coins</span> für Konto <br><span class=\"uk-text-bold\">{account}</span> beansprucht.</p>",check_balance:"Du kannst dein Guthaben jetzt überprüfen.",ok_btn:"OK"},modal_error:{title:"Fehler bei Anforderung",body:"Du musst den Miner abstellen, um die Coins für dieses Konto zu beanspruchen.",ok_btn:"OK"}};var de = {nav:nav$5,layout:layout$5,wallet:wallet$5,about:about$5,settings:settings$5,miner:miner$5,txs:txs$5,events:events$5,make_whole:make_whole$5};

    var nav$4={wallet:"Porte-feuille",miner:"Mineur",transactions:"Transactions",events:"Évènement"};var layout$4={connection_error:{title:"Oops, connexion au réseau 0L impossible",body:"<p> Il est probable que le noeud pair en amont (server) soit déconnecté.</p> <h3> Ne vous inquiétez pas, votre compte et vos coins sont en sécurité.</h3> <p>Pour mettre à jour vos noeuds de paires, vous pouvez allez là:</p>"},error_accordion:{title:"Rapport d'erreurs",category:"Categorie d'erreur",id:"ID"}};var wallet$4={wallet:"Porte-feuille",carpe:"CARPE",btn_new_account:"Nouveau Compte",btn_restore_account:"Récupération de Compte",newbie_message:"Pas de compte trouvé.",reminder_create:{card_title:"Embarquement",message_headline:"Vous avez généré les clés de votre compte, mais il n'existe pas encore sur la chaine.",message_prefix:"Rejoingnez notre communauté sur ",message_suffix:" et joingnez votre clé d'embarquement pour etre embarqué.",onboard_key:"CLÉ D'EMBARQUEMENT"},account_list:{nickname:"Surnom",address:"Adresse",authkey:"Authkey",balance:"Solde",offline:"hors-ligne",loading:"chargement",account_on_chain:"Compte pas sur Chaine",message:" Votre solde diminera pour toutes transactions que vous envoyées, incluant celles du minage."},keygen:{title:"Creer un Nouveau Compte",description:"Àprés avoir généré votre compte et phrase secrète, vous aurez besoin qu'une personne vous envoi un jeton 0L à ce compte pour qu'il soit sur la chaine.",btn_generate_keys:"Générer des clés",btn_generate_keys_2:"Générer différentes clés",btn_create_account:"Créer ce compte",account_address:"Adresse du compte",onboard_key:"Clé d'embarquement",onboard_key_description:"Aussi appelée clé d'authenfication. Vous en avez besoin pour créer ce compte sur la chaine.",securite_recovery_phrase:"PHRASE SECRÈTE DE RECUPÉRATION",securite_note:"Clé secrète de votre compte (mnémonique). Si vous la perdez, personne ne pourra vous aider. Donc notez la et sécurisez la.",account_tips:"Votre compte n'existe pas encore sur la chaine. Vous devrez fournir votre clé d'embarquement à quelqu'un pour qu'il soit créé."},account_from_mnem_submit:{title:" Attention!",body:" <p>Avez-vous bien noté vore phrase mnemonique secrète?</p> <p>Vous ne pourrez pas récupérer votre compte sans. Personne ne peut vous aider si vous la perdez.</p><p>Dernier avertissement pour la noter.</p>",btn_cancel:"Je veux re-vérifier",btn_submit:"Créer ce compte",btn_submiting:"Création en cours"},account_from_mnem_from:{title:"RÉCUPÉRATION DE COMPTE",description:"En utilisant votre phrase de récupération (mnémonique) vous pouvez configurer Carpe en porte-feuille pour surveiller et effectuer des transactions",placeholder:"Récupération Mnémonique"},account_switcher:{select_account:"Selection du Compte",switch_account:"Changer de Compte",setting:"Paramètres",developers:"Dévelopeurs"}};var about$4={about:"À propos",release:"Release",version:"Version",branch:"Branche",commit:"Commit"};var settings$4={title:"PARAMÈTRES",langapp_settings:{title:"Language and Apparence",lang:"Language",lang_description:"Choisissez le language à afficher",lang_button:"Français",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"PARAMÈTRES RÉSEAU",list_of_peers:"LISTE DES PAIRES",description:"Choisissez une playlist de noeuds paires pour accéder à la chaîne. Un noeud aléatoire de la liste sera utilisé pour se connecter au réseau. Fournissez un fichier playlist.json pour mettre à jour les paires.",playlist:"Rafraichir la Playlist des Serveurs",override_peers:"ÉCRASER LES PAIRES",override_peers_description:"Vous pouvez forcer l'utilisation de paire different. Vous pouvez choisir qu'un seul paire avec ce paramètre. La playlist sera remplacée par une liste d'un élément.",url_of_upstream_node:"URL du noeud en amont",btn_update:"RAFRAICHIR",upstream_title:"RECUPÉRER UN NOUVEAU POINT DE CHEMINEMENT DU NOEUD EN AMONT",upstream_subtitle:"La plupart des problèmes de cheminement sont résolu en récupérant un nouveau point d'un noeud en amont.",btn_fetch_new_waypoint:"Récupérer Nouveau Point deCheminement",btn_cancel:"Annuler",btn_submit:"UTILISER LA PLAYLIST"},account_settings:{title:"PARAMÈTRES DE COMPTE",btn_remove:"SUPPRIMER LE COMPE",comfirm:"Confirmer la suppression du compte de ce dispositif? Cela est irreversible.",description:"Votre compte sera toujours sur la chaine. Cela l'enlève juste de ce dispositif. Si vous n'avez plus votre phrase de récupération (mnémonique), vous pourrez être vérrouillé de ce compte définitivement. PERSONNE NE PEUT RETROUVER VOTRE MNÉMONIQUE."}};var miner$4={title:"Mineur",miner_backlog:{title:"Synchroniser vos preuves",subtitle:"Re-soumettre les preuves locales",in_process:"Backlog en cours de soumission",btn_submit:"Soumettre le backlog"},miner_phases:{backlog_started:"Auditeur du backlog lancé",backlog_in_process:"Backlog en cours",backlog_complete:"Backlog complété",mining_enabled:"Minage activé",proof_started:"Requête de démarrage recue",proof_complete:"Preuve complétée"},miner_process:{status_complete:"Preuve complétée",status_in_process:"Minage en cours",notes:"Le pourcentage est une estimation. <br>Il est basé sur le temps pris par les preuves précédentes.",notes2:"Dépassé 100% signifie juste que la preuve en cours prend plus de temps que la précédente."},tower_state:{local_height:"Hauteur locale de la Tour",on_chain_height:"Hauteur On-chain de la Tour",mined_in_last_epoch:"Dernier Epoch Miné",sent_in_this_epoch:"Preuves envoyées pour cette Epoch",empty:"Pas de preuve locales trouvée",proof_more:"Vous avez soumis le maximum de preuves (max 72)",proof_less:"Nombre de preuves insuffisantes pour recevoir la récompense (min 8)",proof_ok:"Vous avez soumis suffisament de preuve (min 8)"},cards:{cant_start:{title:"Votre compte n'est présentement pas sur la chaine",body:"Le mineur ne peut débuter tant que votre compte n'est pas sur la chaine. Si vous avez généré vos clés localement, quelqu'un doit vous envoyer des coins."},disco_error:{title:"Discontinuité ",body:"Il semblerait qu'il y a une preuve manquante dans votre soumission. Chaque preuve a besoin de sa précédente, et votre preuve a été rejetée de fait."},epoch_status:{empty_title:"Pas de preuves envoyées",empty_body:"Aucune preuve présente sur la chaine. Quand vous aurez soumis votre première preuve, vous trouverez vos stats ici.",in_process_title:"Allez!",in_process_body:"Votre compte doit soumettre au moins 8 preuves par epoch pour recevoir une récompense. Les récompenses sont distribuée au prochain epoch.",complete_title:"Victoire!",complete_body:"Votre compte a soumis assez de preuve pour cet epoch (minimum 8 preuves par epoch). Vous recevrez votre récompense au début du prochain epoch.",exceed_title:"Whoa!!!",exceed_body:"Vous avez miné 72 proofs, le nombre maximum de preuves par epoch. La Tower peut continuer de miner des preuves, mais elles seront soumises au prochain epoch."},first_proof:{title:"Minons votre première preuve",body:"<p> Un peu de patience! Cela va prendre de 30mins à 1hr</p> <p> Votre solde diminura en minant vos preuves. Si vous soumettez le minimum requis, vous recevrez votre récompense au prochain epoch.</p> <p> Désactivez les paramètres de Veille sur votre ordinateur afin que le mineur continue de tourner en votre absence.</p>",body_disabled:"Clickez sur le switch pour démarrer le minage!"},invalid_proof:{title:"Vérification impossible des preuves",body:"Bizarre. Cette preuve a été rejetée car elle n'est pas une \"delay proof\" valide. Ceci est habituellement dû à des mauvais paramètres."},oops:{title:"Oops",body:"Une erreur s'est passée durant le minage de la \"delay proof\""},too_many_proofs:{title:"Trop de preuves",body:"Vous aurez soumis plus de preuves que prévu durant cet epoch. La chaine supporte un max de {maxNum} preuves durant chaque epoch. Vos preuves additionnelles seront soumises au prochain epoch."},wrong_difficulty:{title:"Mauvaise Difficulté",body:"La difficulté de votre preuve ne correspond pas à celle de la chaîne. Vérifiez que vous êtes connecté au bon réseau avec le bon paramètre de difficulté."},sync_proof:{title:"Synchronisation des preuves",body:"Preuves en attente de la transaction : {delta} ",body_0:"Vous avez plus de preuves sur la chaîne que sur votre dispositif. Il vous manque des preuves localement."}}};var txs$4={deno_tx:"Demo Tx",account:"Compte",balance:"Solde",btn_onboard:"Embarquer Compte",btn_transfer:"Transfert de Coins",onboard:{title:"Embarquer un Compte","await":"",btn_onboard:"Embarquer",btn_cancel:"Annuler",no_balance_title:"Solde insuffisant",no_balance_body1:"L'embarquement de {onboard_key} a échoué.",no_balance_body2:"Vous avez moins que 2 coins dans votre compte, vous ne pouvez donc pas embarquer d'autres comptes."},set_wallet_type:{title:"Modifier le Type de Compte",subtitle:" Soyez sûr de vous, cette opération est irreversible! Les porte-feuilles \"Slow\" et \"Community\" sont permanents.",btn_slow:"Changer en \"Slow\"",btn_confirm_slow:"Confirmez le passage en \"Slow\"? Cet opération est irreversible.",slow_confirm:"Changer en \"Slow\"",btn_community:"Changer en \"Community\"",btn_confirm_community:"Changer en \"Community\"",community_confirm:"Confirmez le passage en \"Community\"? Cet opération est irreversible"},transfer:{title:"Transfert de Coins",sender:"Envoyeur",balance:"Solde",receiver:"Receveur",amount:"Montant",amount_label:"Montant (fractions non permises)",receiver_placeholder:"Adresse du Receveur",amount_placeholder:"Montant à transferer",confirm_title:"Attention!",please_confirm:"Veuillez confirmer les informations du transfert:","await":"Attente de txs",btn_next:"Suivant",btn_confirm:"Confirmer",btn_cancel:"Annuler",btn_close:"Fermer",error_amount_greater_than_balance:"Le montant ne peut pas être supérieur au solde de compte",error_receiver_equals_sender:"Les adresses de l'Envoyeur et Receveur doivent être differentes",error_slow_wallet:"Le transfert de Coin est désactivé pour les porte-feuilles 'slow'.",success:"Transfert executé avec succés",failed:"Transfert échoué. Code: {code}"}};var events$4={account_events:"Évènements du compte",version:"Version",type:"Type",amount:"Montant",sender:"Expéditeur",receiver:"Receveur",received_payment:"Paiement recu",sent_payment:"Paiement envoyé",loading:{error:"Erreur durant le chargement des évènements:",corrupted_db:"Actuellement connecté à un noeud n'ayant pas tous les évènements.",data_safe:"Ne vous inquiétez pas, votre compte est sécurisé sur la chaine. Essayez de vous connecter à un autre noeud en amont."}};var make_whole$4={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var fr = {nav:nav$4,layout:layout$4,wallet:wallet$4,about:about$4,settings:settings$4,miner:miner$4,txs:txs$4,events:events$4,make_whole:make_whole$4};

    var nav$3={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout$3={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"}};var wallet$3={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Go To Setting",developers:"Developers"}};var about$3={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$3={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"Spanish",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner$3={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs$3={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events$3={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Error loading the account events:",corrupted_db:"Current connected node does not have all account events. Don't worry. Your wallet and coins are safe on the chain. Try connecting to another upstream node.",account_off_chain:"Account selected not onboarded yet."}};var make_whole$3={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var es = {nav:nav$3,layout:layout$3,wallet:wallet$3,about:about$3,settings:settings$3,miner:miner$3,txs:txs$3,events:events$3,make_whole:make_whole$3};

    var nav$2={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout$2={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"}};var wallet$2={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Go To Setting",developers:"Developers"}};var about$2={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings$2={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"Italian",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner$2={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs$2={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events$2={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Error loading the account events:",corrupted_db:"Current connected node does not have all account events. Don't worry. Your wallet and coins are safe on the chain. Try connecting to another upstream node.",account_off_chain:"Account selected not onboarded yet."}};var make_whole$2={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var it = {nav:nav$2,layout:layout$2,wallet:wallet$2,about:about$2,settings:settings$2,miner:miner$2,txs:txs$2,events:events$2,make_whole:make_whole$2};

    var nav$1={wallet:"Carteira",miner:"Minerador",transactions:"Transações",events:"Eventos"};var layout$1={connection_error:{title:"Opa, não foi possível conectar à rede 0L",body:"<p>Isto geralmente acontece porque o node (servidor) que você está usando está fora do ar.</p> <h3> Não se preocupe, sua conta e moedas estão seguras.</h3> <p>Se você precisar configurar ou atualizar seus nodes, você pode fazer isso aqui:</p>"},error_accordion:{title:"Relatório de Erros",category:"Categoria de Erro",id:"ID"}};var wallet$1={wallet:"Carteira",carpe:"CARPE",btn_new_account:"Criar Conta",btn_restore_account:"Restaurar Conta",newbie_message:"Parece que você não tem nenhuma conta ainda",reminder_create:{card_title:"Integração",message_headline:"Você gerou chaves para uma conta, mas ela não existe na rede ainda.",message_prefix:"Junte-se à nossa comunidade no ",message_suffix:" e forneça-nos a sua Chave de Integração para criar sua conta na rede.",onboard_key:"CHAVE DE INTEGRAÇÃO"},account_list:{nickname:"Apelido",address:"Conta",authkey:"Chave de autenticação",balance:"Saldo",offline:"offline",loading:"carregando",account_on_chain:"Conta não criada na rede",message:"Seu saldo diminuirá para cada transação que você enviar, incluindo as de mineração."},keygen:{title:"Criar nova conta",description:"Depois de gerar uma conta e a frase secreta, você precisará que alguém envie uma moeda do 0L para esta conta para que ela seja criada na rede.",btn_generate_keys:"Gerar Chaves",btn_generate_keys_2:"Gerar Chaves Diferentes",btn_create_account:"Criar Esta Conta",account_address:"Endereço da Conta",onboard_key:"Chave de Integração",onboard_key_description:"Isto também é conhecido como Chave de Autenticação. Por enquanto, você precisará dele para poder criar a conta na rede.",securite_recovery_phrase:"FRASE SECRETA DE RECUPERAÇÃO",securite_note:"Esta é a chave secreta da sua conta (mnemônico). Se você perder ela, ninguém poderá te ajudar! Escreva ela em algum lugar agora.",account_tips:"Sua conta não existe na rede ainda. Você precisará enviar para alguém sua Chave de Integração para que possam criar sua conta."},account_from_mnem_submit:{title:"Anteção!",body:"<p>Você tem certeza que escreveu sua frase mnemônica?</p><p>Você não conseguirá recuperar sua conta sem ela de jeito algum. Ninguém pode te ajudar se você perdê-la.</p><p>Esta é a sua última oportunidade de escrevê-la em algum lugar.</p>",btn_cancel:"Deixe-me verificar novamente",btn_submit:"Enviar Agora",btn_submiting:"Enviando"},account_from_mnem_from:{title:"RESTAURAR CONTA",description:"Usando suas palavras de recuperação (mnemônicos), você pode configurar o Carpe como uma carteira para monitorar e enviar transações",placeholder:"Mnemônico de Recuperação"},account_switcher:{select_account:"Selecionar Conta",switch_account:"Mudar de Conta",setting:"Configurações",developers:"Desenvolvedores"}};var about$1={about:"Sobre",release:"Lançamento",version:"Versão",branch:"Branch",commit:"Commit"};var settings$1={title:"CONFIGURAÇÕES",langapp_settings:{title:"Língua e Aparência",lang:"Língua",lang_description:"Escolha o idioma",lang_button:"Português",theme:"Tema",theme_description:"Escolha o tema"},network_settings:{title:"CONFIGURAÇÕES DE REDE",list_of_peers:"LISTA DE PARES",description:"Escolha uma lista de nós ascendentes, para que você possa acessar o blockchain. As conexões de rede tentarão a lista em ordem aleatória até que uma conexão seja estabelecida. Basta vincular a qualquer arquivo playlist.json aqui para atualizar os pares.",playlist:"Atualizar Lista de Servidores de Rede",override_peers:"SUBSTITUIR PARES",override_peers_description:"Você pode forçar usando um par diferente. Você só pode escolher um par com essa configuração. Ela irá remover a lista de pares. Esta será agora uma lista de um elemento.",url_of_upstream_node:"URL do nó ascendente",btn_update:"ATUALIZAR",upstream_title:"BUSCAR UM NOVO PONTO DE CAMINHO DO NODE ASCENDENTE",upstream_subtitle:"A maioria dos problemas de Ponto de Caminho pode ser facilmente corrigida ao buscar um atualizado de um par ascendente conectado.",btn_fetch_new_waypoint:"Buscar Novo Ponto de Caminho",btn_cancel:"Cancelar",btn_submit:"USAR LISTA"},account_settings:{title:"CONFIGURAÇÕES DA CONTA",btn_remove:"REMOVER CONTA",comfirm:"Confirmar remover contas deste dispositivo? Isso não é reversível.",description:"Isso não exclui nenhuma conta da rede. Apenas remove as contas deste dispositivo. Se você não tiver seus códigos de recuperação (mnemônicos) armazenados em algum lugar, poderá ser bloqueado desta conta permanentemente. NINGUÉM PODE AJUDÁ-LO A RECUPERAR O MNEMONIC."}};var miner$1={title:"Minerador",miner_backlog:{title:"Provas de Sincronização da Torre",subtitle:"Reenviar manualmente as provas locais",in_process:"Backlog em Andamento",btn_submit:"Enviar Backlog Local"},miner_phases:{backlog_started:"Ouvinte de backlog iniciado",backlog_in_process:"Backlog em Andamento",backlog_complete:"Backlog Concluído",mining_enabled:"Mineração Ativada",proof_started:"Solicitação de início de prova recebida",proof_complete:"Prova Concluída"},miner_process:{status_complete:"Prova Concluída",status_in_process:"Mineração em Andamento",notes:"A porcentagem é uma estimativa. <br> É baseada no tempo decorrido da sua prova anterior.",notes2:"Mais de 100% significa apenas que isso está demorando mais do que a prova anterior."},tower_state:{local_height:"Altura da Torre Local",on_chain_height:"Altura da Torre no Blockchain",mined_in_last_epoch:"Última Época Minerada.",sent_in_this_epoch:"Provas enviadas nesta época",empty:"Nenhuma prova encontrada no dispositivo",proof_more:"Você enviou o máximo de provas hoje (máximo de 72)",proof_less:"Provas insuficientes para receber uma recompensa hoje (min 8)",proof_ok:"Sua conta enviou provas suficientes hoje (min 8)"},cards:{cant_start:{title:"Sua conta ainda não existe na rede",body:"O minerador não pode iniciar até que a conta seja encontrada na rede. Talvez você tenha gerado novas chaves localmente, mas ninguém enviou moedas para esse endereço ainda?"},disco_error:{title:"Descontinuidade",body:"Parece que há uma lacuna nas provas que você está enviando. Cada prova precisa referenciar a anterior, e a prova foi rejeitada por causa disso."},epoch_status:{empty_title:"Nenhuma prova enviada",empty_body:"Não há provas salvas na rede. Quando você enviar sua primeira prova com sucesso, verá algumas estatísticas aqui.",in_process_title:"Continue assim",in_process_body:"Sua conta precisa enviar pelo menos 8 provas por dia (época) para receber uma recompensa. Você receberá a recompensa no dia seguinte.",complete_title:"Sucesso!",complete_body:"Sua conta enviou provas suficientes hoje (mínimo de 8 provas por época). Você deve receber recompensas no início da próxima época.",exceed_title:"Uau",exceed_body:"Você minerou 72 provas, o número máximo de provas por época. A torre pode continuar fazendo provas, mas elas só serão aceitas na próxima época."},first_proof:{title:"Vamos minerar sua primeira prova",body:"<p> Aguente firme! Isso levará pelo menos 30 minutos, talvez até 1 hora.</p> <p> Você verá seu saldo cair enquanto você minera provas. Se você atingir o mínimo por dia, receberá uma recompensa, no dia seguinte (época).</p> <p> Verifique as configurações do seu computador para que o computador não durma quando a tela for desligada. Você quer que o minerador funcione enquanto você não está aqui.</p>",body_disabled:"Ligue o interruptor para iniciar a mineração!"},invalid_proof:{title:"Não é Possível Verificar a Prova",body:"Esquisito. Esta prova foi rejeitada porque não é uma \"prova de atraso\" válida. Isso geralmente ocorre porque os parâmetros não estão definidos corretamente."},oops:{title:"Opa",body:"Parece que há um erro ao minerar uma prova de atraso"},too_many_proofs:{title:"Muitas Provas",body:"Parece que você enviou mais provas do que o esperado nas últimas 24 horas. A rede espera um máximo de {maxNum} provas durante cada época. Na próxima época suas provas começarão a ser submetidas novamente."},wrong_difficulty:{title:"Dificuldade Errada",body:"Parece que você está enviando uma prova com os parâmetros de dificuldade errados para a rede. Verifique se você está conectado à rede correta com as configurações de dificuldade corretas."},sync_proof:{title:"Sincronizando suas provas",body:"Provas aguardando transação: {delta} ",body_0:"Algo está errado, você tem mais provas na rede do que neste dispositivo. Pode estar faltando provas localmente."}}};var txs$1={deno_tx:"Demo Tx",account:"Conta",balance:"Saldo",btn_onboard:"Integrar Conta",btn_transfer:"Transferir Moedas",onboard:{title:"Integrar uma conta","await":"Aguardando",btn_onboard:"Integrar",btn_cancel:"Cancelar",no_balance_title:"Saldo Insuficiente",no_balance_body1:"A integração de {onboard_key} não foi bem-sucedida.",no_balance_body2:"Parece que você tem menos de 2 moedas em sua conta, isso significa que você não poderá embarcar ninguém."},set_wallet_type:{title:"Defina seu Tipo de Conta",subtitle:"Certifique-se de que você sabe o que está fazendo. Essa operação não é reversível. As carteiras lentas e comunitárias são permanentes.",btn_slow:"Definir Carteira Lenta",btn_confirm_slow:"Confirmar Definir Carteira Lenta? Esta operação não é reversível.",slow_confirm:"Definir Lenta",btn_community:"Definir Carteira de Comunidade",btn_confirm_community:"Definir Comunidade",community_confirm:"Confirmar Definir Carteira de Comunidade? Esta operação não é reversível."},transfer:{title:"Transferência de Moedas",sender:"Pagador",balance:"Saldo",receiver:"Recebedor",amount:"Valor",amount_label:"Valor (frações não são permitidas ainda)",receiver_placeholder:"Endereço do Recebedor",amount_placeholder:"Valor a ser transferido",confirm_title:"Atenção!",please_confirm:"Por favor, confirme as informações da sua transferência:","await":"Aguarde",btn_next:"Próximo",btn_confirm:"Confirmar",btn_cancel:"Cancelar",btn_close:"Fechar",error_amount_greater_than_balance:"Valor não pode ser maior que o saldo da conta",error_receiver_equals_sender:"Endereço do recebedor deve ser diferente do endereço do emissor.",error_slow_wallet:"Transferência de moedas está desabilidato para slow wallets.",success:"Transferência executada com sucesso!",failed:"Transferência falhou. Código: {code}"}};var events$1={account_events:"Eventos da Conta",version:"Versão",type:"Tipo",amount:"Valor",sender:"Pagador",receiver:"Recebedor",received_payment:"Pagamento Recebido",sent_payment:"Pagamento Enviado",loading:{error:"Erro ao carregar os eventos da conta:",corrupted_db:"O nó conectado atual não possui todos os eventos da conta. Não se preocupe. Sua carteira e moedas estão seguras na rede. Tente conectar-se a outro nó ascendente.",account_off_chain:"Conta selecionada não foi integrada ainda."}};var make_whole$1={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var pt = {nav:nav$1,layout:layout$1,wallet:wallet$1,about:about$1,settings:settings$1,miner:miner$1,txs:txs$1,events:events$1,make_whole:make_whole$1};

    var nav={wallet:"Wallet",miner:"Miner",transactions:"Transaction",events:"Events"};var layout={connection_error:{title:"Oops, We Can't Connect to 0L Network",body:"<p> This is likely because the upstream peer (server) you use is down.</p> <h3> Don't worry, your account and coins are safe.</h3> <p>If you need to update or refresh your peers you can do so here:</p>"},error_accordion:{title:"Error Report",category:"Error Category",id:"ID"}};var wallet={wallet:"Wallet",carpe:"CARPE",btn_new_account:"New Account",btn_restore_account:"Restore Account",newbie_message:"Looks like you don't have any accounts",reminder_create:{card_title:"Onboarding",message_headline:"You have generated keys for an account, but it does not yet exist on chain.",message_prefix:"Join our community on ",message_suffix:" and provide us your Onboard Key to get onboarded.",onboard_key:"ONBOARD KEY"},account_list:{nickname:"Nickname",address:"Address",authkey:"Authkey",balance:"Balance",offline:"offline",loading:"loading",account_on_chain:"Account Not On Chain",message:" Your balance will go down for every transaction you send, including mining."},keygen:{title:"Create New Account",description:"After you generate an account and secret phrase, you'll need someone to send one 0L coin to that account for it to be created on chain.",btn_generate_keys:"Generate Keys",btn_generate_keys_2:"Generate Different Keys",btn_create_account:"Create This Account",account_address:"Account Address",onboard_key:"Onboarding Key",onboard_key_description:"This is also known as an Auth Key. For now you'll need it to be able to create the account on chain.",securite_recovery_phrase:"SECRET RECOVERY PHRASE",securite_note:"This is your secret account password (mnemonic). If you lose it no one can help you! Write it down now.",account_tips:"Your account does not exist yet on chain. You'll need to give someone your Onboarding Key so that they can create your account."},account_from_mnem_submit:{title:" Heads Up!",body:" <p>Are you sure you wrote down your mnemonic phrase?</p> <p>You won't be able to recover your account without it. No one can help you if lose it.</p><p>This is the last opportunity to write it down.</p>",btn_cancel:"Let me check again",btn_submit:"Submit Now",btn_submiting:"Submiting"},account_from_mnem_from:{title:"RESTORE ACCOUNT",description:"Using your recovery words (mnemonic) you can configure Carpe as a wallet to monitor, and send transactions",placeholder:"Recovery Mnemonic"},account_switcher:{select_account:"Select Account",switch_account:"Switch Account",setting:"Go To Setting",developers:"Developers"}};var about={about:"About",release:"Release",version:"Version",branch:"Branch",commit:"Commit"};var settings={title:"SETTINGS",langapp_settings:{title:"Language and Appearance",lang:"Language",lang_description:"Choose the language used to display",lang_button:"Arabic",theme:"Theme",theme_description:"Choose the theme"},network_settings:{title:"NETWORK SETTINGS",list_of_peers:"LIST OF PEERS",description:"Choose a playlist of upstream nodes, so you can access the chain. Network connections will try the list in random order until a connection is made. Simply link to any playlist.json file here to update peers.",playlist:"Update Playlist of Network Servers",override_peers:"OVERRIDE PEERS",override_peers_description:"You can force using a different peer. You can only choose one peer with this setting. It will remove the playlist. This will now be a list of one element.",url_of_upstream_node:"URL of upstream node",btn_update:"UPDATE",upstream_title:"FETCH A NEW WAYPOINT FROM UPSTREAM",upstream_subtitle:"Most waypoint issues can easily be fixed by fetching an updated one from a connected upstream peer.",btn_fetch_new_waypoint:"Fetch New Waypoint",btn_cancel:"Cancel",btn_submit:"USE PLAYLIST"},account_settings:{title:"ACCOUNT SETTINGS",btn_remove:"REMOVE ACCOUNT",comfirm:"Confirm remove accounts from this device? This is not reversable.",description:"This does not delete any accounts from the chain. It only removes the accounts from this device. If you do not have your recovery codes (mnemonic) stored somewhere, you may be locked out of this account permanently. NO ONE CAN HELP YOU RECOVER THE MNEMONIC. "}};var miner={title:"Miner",miner_backlog:{title:"Sync Tower Proofs",subtitle:"Manually resubmit local proofs",in_process:"Backlog in Progress",btn_submit:"Submit Local Backlog"},miner_phases:{backlog_started:"Backlog Listener Started",backlog_in_process:"Backlog in Progress",backlog_complete:"Backlog Complete",mining_enabled:"Mining Enabled",proof_started:"Proof start request received",proof_complete:"Proof Complete"},miner_process:{status_complete:"Proof Complete",status_in_process:"Mining in Progress",notes:"The percentage is an estimate. <br> It is based on your previous proof's elapsed time.",notes2:"Over 100% only means this is taking longer than previous proof"},tower_state:{local_height:"Local Tower Height",on_chain_height:"On-chain Tower Height",mined_in_last_epoch:"Last Epoch Mined",sent_in_this_epoch:"Proofs Sent this Epoch",empty:"No proofs found on device",proof_more:"You have submitted max proofs today (max 72)",proof_less:"Insufficient proofs to receive a reward today (min 8)",proof_ok:"Your account has submitted enough proofs today (min 8)"},cards:{cant_start:{title:"Your account does not exist on chain yet ",body:"The miner can't start until the account can be found on chain. Maybe you've generated new keys locally, but no one has sent any coins to that address?"},disco_error:{title:"Discontinuity ",body:"Looks like there's a gap in the proofs you are submitting. Each proof needs to reference the previous one, and the proof was rejected because of this."},epoch_status:{empty_title:"No proofs sent",empty_body:"There are no proofs saved to the chain. When you successfully submit your first proof, you will see some stats here.",in_process_title:"Keep it up",in_process_body:"Your account needs to submit at least 8 proofs per day (epoch) to receive a reward. You will receive the reward on the next day.",complete_title:"Success!",complete_body:"Your account has submitted enough proofs today (minimum 8 proofs per epoch). You should receive rewards at the start of next epoch.",exceed_title:"Whoa",exceed_body:"You have mined 72 proofs, the maximum number of proofs per epoch. The tower can keep making proofs but they will only be accepted in the next epoch."},first_proof:{title:"Let's mine your first proof",body:"<p> Hang tight! This will take at least 30mins, maybe up to 1hr</p> <p> You will see your balance go down while you mine proofs. If you reach the minimum per day, you will receive a reward, on the next day (epoch).</p> <p> Check your computer settings so that the computer doesn't sleep when the screen shuts off. You want the miner running while you're not here.</p>",body_disabled:"Turn the switch on to start mining!"},invalid_proof:{title:"Cannot Verify Proof",body:"Weird. This proof was rejected because it is not a valid \"delay proof\". This is usually because parameters are not set correctly."},oops:{title:"Oops",body:"Looks like there's an error with mining a delay proof"},too_many_proofs:{title:"Too Many Proofs",body:"Looks like you've sent more proofs than expected during the last 24 hours. The chain expects a max {maxNum} proofs during each epoch. On the next epoch your proofs will begin to be submitted again."},wrong_difficulty:{title:"Wrong Difficulty",body:"Looks like you're sending a proof with the wrong difficulty parameters to the chain. Check you are connected to the right network with the correct difficulty settings."},sync_proof:{title:"Syncing your proofs",body:"Proofs awaiting transaction: {delta} ",body_0:"Something is wrong, you have more proofs on-chain, than on this device. You may be missing proofs locally."}}};var txs={deno_tx:"Demo Tx",account:"Account",balance:"Balance",btn_onboard:"Onboard Account",btn_transfer:"Transfer Coins",onboard:{title:"Onboard an Account","await":"Awaiting Tx",btn_onboard:"Onboard",btn_cancel:"Cancel",no_balance_title:"Low Balance",no_balance_body1:"Onboarding {onboard_key} was not successful.",no_balance_body2:"Looks like you have less than 2 coins in your account, this means you won't be able to onboard anyone."},set_wallet_type:{title:"Set your Account Type",subtitle:" Make sure you know what you are doing. This is not reversible. Slow and Community wallets are permanent.",btn_slow:"Set Slow Wallet",btn_confirm_slow:"Confirm Set Slow Wallet? This is not reversable.",slow_confirm:"Set Slow",btn_community:"Set Community Wallet",btn_confirm_community:"Set Community",community_confirm:"Confirm Set Community Wallet? This is not reversable."},transfer:{title:"Coin Transfer",sender:"Sender",balance:"Balance",receiver:"Receiver",amount:"Amount",amount_label:"Amount (fractions not allowed yet)",receiver_placeholder:"Receiver address",amount_placeholder:"Amount to be transfered",confirm_title:"Heads up!",please_confirm:"Please confirm your transfer information:","await":"Await txs",btn_next:"Next",btn_confirm:"Confirm",btn_cancel:"Cancel",btn_close:"Close",error_amount_greater_than_balance:"Amount cannot be greater than account balance",error_receiver_equals_sender:"Receiver address must be different from sender address",error_slow_wallet:"Coin transfer is disabled for slow wallets.",success:"Transfer executed with success",failed:"Transfer failed. Code: {code}"}};var events={account_events:"Account Events",version:"Version",type:"Type",amount:"Amount",sender:"Sender",receiver:"Receiver",received_payment:"Received Payment",sent_payment:"Sent Payment",loading:{error:"Error loading the account events:",corrupted_db:"Current connected node does not have all account events. Don't worry. Your wallet and coins are safe on the chain. Try connecting to another upstream node.",account_off_chain:"Account selected not onboarded yet."}};var make_whole={link_title:"Claim Coins",card:{title:"Claim Your Missing Coins",body:"<p>Oops. Occasionally blockchains make math mistakes. 0L tries to fix them as quickly as possible.</p><p>Miner Identity Subsidy Incident: From Epoch 0 to epoch 52, the payouts to miners was lower than expected. Below you can credit your missing coins from that period.</p>"},table:{account:"Account",amount:"Amount",claim:"Claim"},claim_btn:{"await":"Await...",claim:"Claim Now"},modal_success:{title:"Transation confirmed!",amount_for_account:"<p>You have claimed <span class=\"uk-text-bold\">{coins} coins</span> for account <br><span class=\"uk-text-bold\">{account}</span>.</p>",check_balance:"You can check your balance now.",ok_btn:"OK"},modal_error:{title:"Claim Error",body:"You must turn off miner to claim this account coins.",ok_btn:"OK"}};var ar = {nav:nav,layout:layout,wallet:wallet,about:about,settings:settings,miner:miner,txs:txs,events:events,make_whole:make_whole};

    registerLocaleLoader('en', async () => en);
    registerLocaleLoader('zh_cn', async () => zh_cn);
    registerLocaleLoader('de', async () => de);
    registerLocaleLoader('fr', async () => fr);
    registerLocaleLoader('es', async () => es);
    registerLocaleLoader('it', async () => it);
    registerLocaleLoader('pt', async () => pt);
    registerLocaleLoader('ar', async () => ar);
    function setupI18n(options) {
        const { withLocale: locale_ } = options;
        // Initialize svelte-i18n
        init({
            initialLocale: locale_,
            fallbackLocale: 'en',
        });
    }

    function init_preferences() {
        console.log(">>> call init_preferences");
        // avoid using lib without init finished
        setupI18n({
            withLocale: 'en',
            fallbackLocale: 'en',
        });
        i$1('get_preferences')
            .then((result) => {
            // init locale preference
            const locale = result.locale
                ? result.locale
                : getLocaleFromNavigator();
            setupI18n({
                withLocale: locale,
                fallbackLocale: 'en',
            });
        });
    }
    function setLocale(locale) {
        i$1('set_preferences_locale', { locale: locale })
            .then(() => {
            setupI18n({
                withLocale: locale,
                fallbackLocale: 'en',
            });
        });
    }

    /* src/components/Nav.svelte generated by Svelte v3.59.2 */
    const file$W = "src/components/Nav.svelte";

    // (33:4) {#if secondaryRoutes.includes($location.pathname)}
    function create_if_block_1$e(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				to: routes.home,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(33:4) {#if secondaryRoutes.includes($location.pathname)}",
    		ctx
    	});

    	return block;
    }

    // (34:6) <Link to={routes.home}>
    function create_default_slot_3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-muted");
    			attr_dev(span, "uk-icon", "icon: arrow-left; ratio: 2");
    			add_location(span, file$W, 33, 29, 1096);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(34:6) <Link to={routes.home}>",
    		ctx
    	});

    	return block;
    }

    // (38:12) <Link to={routes.home}>
    function create_default_slot_2(ctx) {
    	let t_value = /*$_*/ ctx[3]("nav.wallet") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("nav.wallet") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(38:12) <Link to={routes.home}>",
    		ctx
    	});

    	return block;
    }

    // (39:12) <Link to={routes.miner}>
    function create_default_slot_1$2(ctx) {
    	let t_value = /*$_*/ ctx[3]("nav.miner") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("nav.miner") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(39:12) <Link to={routes.miner}>",
    		ctx
    	});

    	return block;
    }

    // (40:12) <Link to={routes.transactions}>
    function create_default_slot$4(ctx) {
    	let t_value = /*$_*/ ctx[3]("nav.transactions") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("nav.transactions") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(40:12) <Link to={routes.transactions}>",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#if init }
    function create_if_block$s(ctx) {
    	let div;
    	let ul;
    	let li;
    	let accountswitcher;
    	let current;
    	accountswitcher = new AccountSwitcher({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");
    			li = element("li");
    			create_component(accountswitcher.$$.fragment);
    			add_location(li, file$W, 50, 8, 1888);
    			attr_dev(ul, "class", "uk-navbar-nav");
    			add_location(ul, file$W, 49, 6, 1853);
    			attr_dev(div, "class", "uk-navbar-right");
    			add_location(div, file$W, 48, 4, 1817);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);
    			append_dev(ul, li);
    			mount_component(accountswitcher, li, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountswitcher.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountswitcher.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(accountswitcher);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(48:4) {#if init }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let main;
    	let nav;
    	let show_if = /*secondaryRoutes*/ ctx[4].includes(/*$location*/ ctx[2].pathname);
    	let t0;
    	let div;
    	let ul;
    	let li0;
    	let link0;
    	let t1;
    	let li1;
    	let link1;
    	let t2;
    	let li2;
    	let link2;
    	let ul_class_value;
    	let t3;
    	let current;
    	let if_block0 = show_if && create_if_block_1$e(ctx);

    	link0 = new Link$1({
    			props: {
    				to: routes.home,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				to: routes.miner,
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link$1({
    			props: {
    				to: routes.transactions,
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = /*init*/ ctx[1] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			nav = element("nav");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			create_component(link0.$$.fragment);
    			t1 = space();
    			li1 = element("li");
    			create_component(link1.$$.fragment);
    			t2 = space();
    			li2 = element("li");
    			create_component(link2.$$.fragment);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			add_location(li0, file$W, 37, 8, 1309);
    			add_location(li1, file$W, 38, 8, 1377);
    			add_location(li2, file$W, 39, 8, 1443);

    			attr_dev(ul, "class", ul_class_value = "uk-navbar-nav " + (/*init*/ ctx[1] && /*myAccountIsOnChain*/ ctx[0]
    			? ""
    			: "uk-invisible"));

    			add_location(ul, file$W, 36, 6, 1222);
    			attr_dev(div, "class", "uk-navbar-center");
    			add_location(div, file$W, 35, 4, 1185);
    			attr_dev(nav, "class", "uk-navbar-container");
    			attr_dev(nav, "uk-navbar", "");
    			add_location(nav, file$W, 31, 2, 968);
    			attr_dev(main, "class", "uk-margin-top");
    			add_location(main, file$W, 30, 0, 937);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, nav);
    			if (if_block0) if_block0.m(nav, null);
    			append_dev(nav, t0);
    			append_dev(nav, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			mount_component(link0, li0, null);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			mount_component(link1, li1, null);
    			append_dev(ul, t2);
    			append_dev(ul, li2);
    			mount_component(link2, li2, null);
    			append_dev(nav, t3);
    			if (if_block1) if_block1.m(nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$location*/ 4) show_if = /*secondaryRoutes*/ ctx[4].includes(/*$location*/ ctx[2].pathname);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$location*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$e(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(nav, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 72) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 72) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope, $_*/ 72) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);

    			if (!current || dirty & /*init, myAccountIsOnChain*/ 3 && ul_class_value !== (ul_class_value = "uk-navbar-nav " + (/*init*/ ctx[1] && /*myAccountIsOnChain*/ ctx[0]
    			? ""
    			: "uk-invisible"))) {
    				attr_dev(ul, "class", ul_class_value);
    			}

    			if (/*init*/ ctx[1]) {
    				if (if_block1) {
    					if (dirty & /*init*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$s(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(nav, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(link2);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let $location;
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(3, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav', slots, []);
    	init_preferences();

    	const secondaryRoutes = [
    		routes.settings,
    		routes.about,
    		routes.developer,
    		routes.keygen,
    		routes.accountFromMnem
    	];

    	const location = useLocation();
    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(2, $location = value));
    	let myAccountIsOnChain = false; // assume initialized until not
    	let init = false; // assume initialized until not

    	onMount(async () => {
    		isInit.subscribe(i => $$invalidate(1, init = i));

    		signingAccount.subscribe(myAccount => {
    			if (myAccount) {
    				$$invalidate(0, myAccountIsOnChain = myAccount.on_chain);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Nav> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Link: Link$1,
    		useLocation,
    		signingAccount,
    		isInit,
    		AccountSwitcher,
    		routes,
    		_: $format,
    		init_preferences,
    		secondaryRoutes,
    		location,
    		myAccountIsOnChain,
    		init,
    		$location,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('myAccountIsOnChain' in $$props) $$invalidate(0, myAccountIsOnChain = $$props.myAccountIsOnChain);
    		if ('init' in $$props) $$invalidate(1, init = $$props.init);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [myAccountIsOnChain, init, $location, $_, secondaryRoutes, location];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src/components/dev/DebugCard.svelte generated by Svelte v3.59.2 */
    const file$V = "src/components/dev/DebugCard.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (38:8) {#if this_error != undefined}
    function create_if_block_1$d(ctx) {
    	let each_1_anchor;
    	let each_value = /*this_error*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*this_error*/ 2) {
    				each_value = /*this_error*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(38:8) {#if this_error != undefined}",
    		ctx
    	});

    	return block;
    }

    // (39:10) {#each this_error as e}
    function create_each_block$5(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*e*/ ctx[4].uid + "";
    	let t1;
    	let t2;
    	let br0;
    	let t3;
    	let t4_value = /*e*/ ctx[4].msg + "";
    	let t4;
    	let t5;
    	let br1;
    	let t6;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Error ID: ");
    			t1 = text(t1_value);
    			t2 = space();
    			br0 = element("br");
    			t3 = text("\n              Message: ");
    			t4 = text(t4_value);
    			t5 = space();
    			br1 = element("br");
    			t6 = space();
    			add_location(br0, file$V, 40, 32, 1543);
    			add_location(br1, file$V, 42, 14, 1595);
    			attr_dev(p, "class", "uk-text-break");
    			add_location(p, file$V, 39, 12, 1485);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, br0);
    			append_dev(p, t3);
    			append_dev(p, t4);
    			append_dev(p, t5);
    			append_dev(p, br1);
    			append_dev(p, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*this_error*/ 2 && t1_value !== (t1_value = /*e*/ ctx[4].uid + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*this_error*/ 2 && t4_value !== (t4_value = /*e*/ ctx[4].msg + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(39:10) {#each this_error as e}",
    		ctx
    	});

    	return block;
    }

    // (51:10) {#if result_string && result_string.length !== 0}
    function create_if_block$r(ctx) {
    	let span;
    	let t1;
    	let br;
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "LATEST REQUEST";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			t3 = text(/*result_string*/ ctx[0]);
    			add_location(span, file$V, 51, 10, 1793);
    			add_location(br, file$V, 53, 12, 1846);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*result_string*/ 1) set_data_dev(t3, /*result_string*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(51:10) {#if result_string && result_string.length !== 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let main;
    	let div5;
    	let div0;
    	let h5;
    	let t1;
    	let div3;
    	let div2;
    	let span0;
    	let t3;
    	let div1;
    	let span1;
    	let t4;
    	let span2;
    	let t5;
    	let t6;
    	let hr;
    	let t7;
    	let div4;
    	let p;
    	let t8;
    	let br;
    	let mounted;
    	let dispose;
    	let if_block0 = /*this_error*/ ctx[1] != undefined && create_if_block_1$d(ctx);
    	let if_block1 = /*result_string*/ ctx[0] && /*result_string*/ ctx[0].length !== 0 && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div5 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "LOGS";
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "ERRORS";
    			t3 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t4 = space();
    			span2 = element("span");
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			hr = element("hr");
    			t7 = space();
    			div4 = element("div");
    			p = element("p");
    			if (if_block1) if_block1.c();
    			t8 = space();
    			br = element("br");
    			attr_dev(h5, "class", "uk-card-title uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h5, file$V, 21, 10, 828);
    			attr_dev(div0, "class", "uk-row");
    			add_location(div0, file$V, 20, 6, 797);
    			attr_dev(span0, "class", "uk-margin-small-right");
    			add_location(span0, file$V, 29, 10, 1018);
    			attr_dev(span1, "class", "uk-margin-medium");
    			attr_dev(span1, "uk-icon", "trash");
    			attr_dev(span1, "uk-tooltip", "title: Clear Errors");
    			add_location(span1, file$V, 31, 12, 1122);
    			attr_dev(span2, "uk-icon", "sign-out");
    			attr_dev(span2, "uk-tooltip", "title: Exit Debug Mode");
    			add_location(span2, file$V, 32, 12, 1254);
    			attr_dev(div1, "class", "uk-align-right");
    			add_location(div1, file$V, 30, 10, 1081);
    			attr_dev(div2, "class", "uk-vertical-align-middle");
    			add_location(div2, file$V, 28, 8, 969);
    			add_location(div3, file$V, 27, 6, 955);
    			add_location(hr, file$V, 47, 6, 1670);
    			add_location(br, file$V, 56, 10, 1907);
    			attr_dev(p, "class", "uk-text-break");
    			add_location(p, file$V, 49, 8, 1697);
    			add_location(div4, file$V, 48, 6, 1683);
    			set_style(div5, "margin", "0px", 1);
    			set_style(div5, "min-height", "100%");
    			attr_dev(div5, "class", "uk-margin-top uk-margin-bottom uk-card uk-card-default uk-card-body uk-width-1-1");
    			add_location(div5, file$V, 17, 4, 636);
    			set_style(main, "position", "fixed");
    			set_style(main, "bottom", "0px");
    			set_style(main, "left", "0px");
    			set_style(main, "right", "0px");
    			set_style(main, "height", "280px");
    			set_style(main, "overflow-y", "auto");
    			set_style(main, "z-index", "10");
    			set_style(main, "border-style", "ridge");
    			add_location(main, file$V, 16, 0, 497);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h5);
    			append_dev(div5, t1);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, span0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, span1);
    			append_dev(div1, t4);
    			append_dev(div1, span2);
    			append_dev(div3, t5);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div5, t6);
    			append_dev(div5, hr);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, p);
    			if (if_block1) if_block1.m(p, null);
    			append_dev(p, t8);
    			append_dev(p, br);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span1, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(span2, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*this_error*/ ctx[1] != undefined) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$d(ctx);
    					if_block0.c();
    					if_block0.m(div3, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*result_string*/ ctx[0] && /*result_string*/ ctx[0].length !== 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$r(ctx);
    					if_block1.c();
    					if_block1.m(p, t8);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DebugCard', slots, []);
    	let result_string = "";
    	let this_error = get_store_value(carpeErrorLog);

    	afterUpdate(async () => {
    		responses.subscribe(value => {
    			$$invalidate(0, result_string = value);
    		});

    		carpeErrorLog.subscribe(value => {
    			$$invalidate(1, this_error = value);
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DebugCard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => clearErrors();
    	const click_handler_1 = () => debugModeToggle();

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		get: get_store_value,
    		carpeErrorLog,
    		clearErrors,
    		responses,
    		debugModeToggle,
    		result_string,
    		this_error
    	});

    	$$self.$inject_state = $$props => {
    		if ('result_string' in $$props) $$invalidate(0, result_string = $$props.result_string);
    		if ('this_error' in $$props) $$invalidate(1, this_error = $$props.this_error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [result_string, this_error, click_handler, click_handler_1];
    }

    class DebugCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugCard",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src/components/wallet/Newbie.svelte generated by Svelte v3.59.2 */
    const file$U = "src/components/wallet/Newbie.svelte";

    // (15:4) <Link to={routes.keygen}>
    function create_default_slot_1$1(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[0]("wallet.btn_new_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-secondary");
    			add_location(button, file$U, 15, 6, 662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("wallet.btn_new_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(15:4) <Link to={routes.keygen}>",
    		ctx
    	});

    	return block;
    }

    // (18:4) <Link to={routes.accountFromMnem}>
    function create_default_slot$3(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[0]("wallet.btn_restore_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$U, 18, 6, 805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("wallet.btn_restore_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(18:4) <Link to={routes.accountFromMnem}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let main;
    	let div0;
    	let h1;
    	let t0_value = /*$_*/ ctx[0]("wallet.carpe") + "";
    	let t0;
    	let t1;
    	let h5;
    	let t2_value = /*$_*/ ctx[0]("wallet.newbie_message") + "";
    	let t2;
    	let t3;
    	let div1;
    	let link0;
    	let t4;
    	let link1;
    	let current;

    	link0 = new Link$1({
    			props: {
    				to: routes.keygen,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				to: routes.accountFromMnem,
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			h5 = element("h5");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t4 = space();
    			create_component(link1.$$.fragment);
    			attr_dev(h1, "class", "uk-text-light uk-text-muted uk-text-uppercase uk-text-center");
    			add_location(h1, file$U, 9, 4, 346);
    			attr_dev(h5, "class", "uk-text-light uk-text-muted uk-text-uppercase uk-text-center");
    			add_location(h5, file$U, 10, 4, 449);
    			attr_dev(div0, "class", "uk-container uk-align-center");
    			add_location(div0, file$U, 8, 2, 299);
    			attr_dev(div1, "uk-grid", "");
    			attr_dev(div1, "class", "uk-margin uk-flex uk-flex-center");
    			add_location(div1, file$U, 13, 4, 571);
    			set_style(main, "position", "absolute");
    			attr_dev(main, "class", "uk-position-center uk-margin-large");
    			add_location(main, file$U, 7, 0, 221);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, h1);
    			append_dev(h1, t0);
    			append_dev(div0, t1);
    			append_dev(div0, h5);
    			append_dev(h5, t2);
    			append_dev(main, t3);
    			append_dev(main, div1);
    			mount_component(link0, div1, null);
    			append_dev(div1, t4);
    			mount_component(link1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("wallet.carpe") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$_*/ 1) && t2_value !== (t2_value = /*$_*/ ctx[0]("wallet.newbie_message") + "")) set_data_dev(t2, t2_value);
    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Newbie', slots, []);
    	init_preferences();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Newbie> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: $format, Link: Link$1, routes, init_preferences, $_ });
    	return [$_];
    }

    class Newbie extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newbie",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /* src/components/icons/IconMining.svelte generated by Svelte v3.59.2 */

    const file$T = "src/components/icons/IconMining.svelte";

    function create_fragment$T(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			attr_dev(path0, "d", "M5.393 1.072v0c-.12-.07-.16-.23-.1-.35 .04-.08.12-.13.21-.13 4.881-.06 10.185 1.6 14.6 8v0 0c.27.39.23.92-.1 1.26l-1.44 1.48v0c-.39.39-1.02.4-1.42.01 -.08-.08-.14-.16-.19-.25l-.37-.7C14.35 6.12 8.953 3.14 5.35 1.03Z");
    			add_location(path0, file$T, 0, 162, 162);
    			attr_dev(path1, "d", "M11.947 5.266L.95 15.609H.95c-.59.55-.62 1.47-.07 2.05 .01.01.02.02.03.03v0h0c.56.56 1.49.56 2.05 0 .01-.02.02-.03.02-.04l10.47-11.12");
    			add_location(path1, file$T, 0, 389, 389);
    			attr_dev(path2, "d", "M10.752 15.961l0 0c-.16.08-.26.25-.26.43v2.92 0c0 .17.09.34.25.43l3 1.71v0c.15.08.34.08.5 0l3-1.72v-.001c.15-.09.25-.26.25-.44v-2.92 0c-.01-.18-.1-.35-.26-.44l-3-1.72v0c-.16-.09-.35-.09-.5 0Z");
    			add_location(path2, file$T, 0, 534, 534);
    			attr_dev(path3, "d", "M19.7 14.05v0c-.13.09-.2.24-.2.4v.99 0c0 .16.07.31.21.4l1.5 1.05v0c.17.12.4.12.57-.001l1.5-1.05v0c.13-.1.21-.25.21-.41v-.99h0c0-.16-.08-.31-.2-.4l-1.5-1.13v0c-.18-.14-.43-.14-.6 0Z");
    			add_location(path3, file$T, 0, 737, 737);
    			attr_dev(path4, "d", "M19.7 20.455v0c-.13.09-.2.24-.2.4v.99 0c0 .16.07.31.21.4l1.5 1.05v0c.17.12.4.12.57-.001l1.5-1.05v0c.13-.1.21-.25.21-.41v-.99h0c0-.16-.08-.31-.2-.4l-1.5-1.13v0c-.18-.14-.43-.14-.6 0Z");
    			add_location(path4, file$T, 0, 929, 929);
    			attr_dev(g, "stroke-linecap", "round");
    			attr_dev(g, "stroke", "#1e87f0");
    			attr_dev(g, "fill", "none");
    			attr_dev(g, "stroke-linejoin", "round");
    			add_location(g, file$T, 0, 83, 83);
    			attr_dev(svg, "width", "20");
    			attr_dev(svg, "height", "20");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$T, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(g, path2);
    			append_dev(g, path3);
    			append_dev(g, path4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconMining', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconMining> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconMining extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconMining",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /*! UIkit 3.17.11 | https://www.getuikit.com | (c) 2014 - 2023 YOOtheme | MIT License */

    var uikitIcons = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        function plugin(UIkit) {
          if (plugin.installed) {
            return;
          }
          UIkit.icon.add({
            "youtube": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z"/></svg>',
            "yootheme": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m16.15,5.48c-1.37,0-2.45.61-3.11,1.54-.66-.93-1.74-1.54-3.11-1.54-1.75,0-3.03,1-3.57,2.41v-2.22h-2.01v4.45c0,.85-.31,1.35-1.18,1.35s-1.18-.5-1.18-1.35v-4.45H0v4.86c0,.7.17,1.33.53,1.82.34.49.88.85,1.6,1v3.16h2.1v-3.16c1.28-.28,1.96-1.17,2.1-2.35.52,1.44,1.81,2.48,3.59,2.48,1.37,0,2.45-.61,3.11-1.54.66.93,1.74,1.54,3.11,1.54,2.37,0,3.85-1.82,3.85-4s-1.49-4-3.85-4Zm-6.22,5.99c-1.11,0-1.85-.72-1.85-1.99s.74-1.99,1.85-1.99,1.85.72,1.85,1.99-.74,1.99-1.85,1.99Zm6.22,0c-1.11,0-1.85-.72-1.85-1.99s.74-1.99,1.85-1.99,1.85.72,1.85,1.99-.74,1.99-1.85,1.99Z"/></svg>',
            "yelp": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069	c-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276	c0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789	c-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025	c0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155	c-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351	c-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479	c0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421	c-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272	c0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749	C10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794	C2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667	c0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z"/></svg>',
            "xing": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z"/><path d="M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z"/></svg>',
            "world": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M1,10.5 L19,10.5"/><path fill="none" stroke="#000" d="M2.35,15.5 L17.65,15.5"/><path fill="none" stroke="#000" d="M2.35,5.5 L17.523,5.5"/><path fill="none" stroke="#000" d="M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z"/><circle fill="none" stroke="#000" cx="10" cy="10.5" r="9"/></svg>',
            "wordpress": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z"/></svg>',
            "whatsapp": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9"/></svg>',
            "warning": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="14" r="1"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><path d="M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z"/></svg>',
            "vimeo": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z"/></svg>',
            "video-camera": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="19.5 5.9 19.5 14.1 14.5 10.4 14.5 15.5 .5 15.5 .5 4.5 14.5 4.5 14.5 9.6 19.5 5.9"/></svg>',
            "users": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="7.7" cy="8.6" r="3.5"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3"/><path fill="none" stroke="#000" stroke-width="1.1" d="M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1"/></svg>',
            "user": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9.9" cy="6.4" r="4.4"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2"/></svg>',
            "upload": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="5 8 9.5 3.5 14 8"/><rect x="3" y="17" width="13" height="1"/><line fill="none" stroke="#000" x1="9.5" y1="15" x2="9.5" y2="4"/></svg>',
            "unlock": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" x="3.5" y="8.5" width="13" height="10"/><path fill="none" stroke="#000" d="M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9"/></svg>',
            "uikit": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3"/><polygon points="9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3"/></svg>',
            "twitter": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74"/></svg>',
            "twitch": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z"/><rect x="12.98" y="4.55" width="1.29" height="3.88"/><rect x="9.43" y="4.55" width="1.29" height="3.88"/></svg>',
            "tv": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="7" y="16" width="6" height="1"/><rect fill="none" stroke="#000" x=".5" y="3.5" width="19" height="11"/></svg>',
            "tumblr": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z"/></svg>',
            "tripadvisor": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0	c0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009	c1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15	c2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594	c-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811	c-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079	c2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066	c-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002	c2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775	c0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468	C3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479	c1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775	c0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627	c-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618	c0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968	c-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72	C9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z"/></svg>',
            "triangle-up": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="5 13 10 8 15 13"/></svg>',
            "triangle-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="8 5 13 10 8 15"/></svg>',
            "triangle-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="12 5 7 10 12 15"/></svg>',
            "triangle-down": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="5 7 15 7 10 12"/></svg>',
            "trash": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="6.5 3 6.5 1.5 13.5 1.5 13.5 3"/><polyline fill="none" stroke="#000" points="4.5 4 4.5 18.5 15.5 18.5 15.5 4"/><rect x="8" y="7" width="1" height="9"/><rect x="11" y="7" width="1" height="9"/><rect x="2" y="3" width="16" height="1"/></svg>',
            "tiktok": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z"/></svg>',
            "thumbnails": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" x="3.5" y="3.5" width="5" height="5"/><rect fill="none" stroke="#000" x="11.5" y="3.5" width="5" height="5"/><rect fill="none" stroke="#000" x="11.5" y="11.5" width="5" height="5"/><rect fill="none" stroke="#000" x="3.5" y="11.5" width="5" height="5"/></svg>',
            "tag": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z"/><circle cx="14" cy="6" r="1"/></svg>',
            "tablet": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z"/><circle cx="10.5" cy="16.3" r=".8"/></svg>',
            "tablet-landscape": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z"/><circle cx="3.7" cy="10.5" r=".8"/></svg>',
            "table": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="1" y="3" width="18" height="1"/><rect x="1" y="7" width="18" height="1"/><rect x="1" y="11" width="18" height="1"/><rect x="1" y="15" width="18" height="1"/></svg>',
            "strikethrough": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z"/><rect x="3" y="10" width="15" height="1"/></svg>',
            "star": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" stroke-width="1.01" points="10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27"/></svg>',
            "soundcloud": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z"/><rect x="6" y="6.5" width="1.5" height="8.5"/><rect x="3" y="8" width="1.5" height="7"/><rect y="10" width="1.5" height="5"/></svg>',
            "social": '<svg width="20" height="20" viewBox="0 0 20 20"><line fill="none" stroke="#000" stroke-width="1.1" x1="13.4" y1="14" x2="6.3" y2="10.7"/><line fill="none" stroke="#000" stroke-width="1.1" x1="13.5" y1="5.5" x2="6.5" y2="8.8"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="15.5" cy="4.6" r="2.3"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="15.5" cy="14.8" r="2.3"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="4.5" cy="9.8" r="2.3"/></svg>',
            "sign-out": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5"/><polygon points="13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3"/></svg>',
            "sign-in": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3"/><polygon points="9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5"/></svg>',
            "shrink": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="11 4 12 4 12 8 16 8 16 9 11 9"/><polygon points="4 11 9 11 9 16 8 16 8 12 4 12"/><path fill="none" stroke="#000" stroke-width="1.1" d="M12,8 L18,2"/><path fill="none" stroke="#000" stroke-width="1.1" d="M2,18 L8,12"/></svg>',
            "settings": '<svg width="20" height="20" viewBox="0 0 20 20"><ellipse fill="none" stroke="#000" cx="6.11" cy="3.55" rx="2.11" ry="2.15"/><ellipse fill="none" stroke="#000" cx="6.11" cy="15.55" rx="2.11" ry="2.15"/><circle fill="none" stroke="#000" cx="13.15" cy="9.55" r="2.15"/><rect x="1" y="3" width="3" height="1"/><rect x="10" y="3" width="8" height="1"/><rect x="1" y="9" width="8" height="1"/><rect x="15" y="9" width="3" height="1"/><rect x="1" y="15" width="3" height="1"/><rect x="10" y="15" width="8" height="1"/></svg>',
            "server": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="3" y="3" width="1" height="2"/><rect x="5" y="3" width="1" height="2"/><rect x="7" y="3" width="1" height="2"/><rect x="16" y="3" width="1" height="1"/><rect x="16" y="10" width="1" height="1"/><circle fill="none" stroke="#000" cx="9.9" cy="17.4" r="1.4"/><rect x="3" y="10" width="1" height="2"/><rect x="5" y="10" width="1" height="2"/><rect x="9.5" y="14" width="1" height="2"/><rect x="3" y="17" width="6" height="1"/><rect x="11" y="17" width="6" height="1"/><rect fill="none" stroke="#000" x="1.5" y="1.5" width="17" height="5"/><rect fill="none" stroke="#000" x="1.5" y="8.5" width="17" height="5"/></svg>',
            "search": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9" cy="9" r="7"/><path fill="none" stroke="#000" stroke-width="1.1" d="M14,14 L18,18 L14,14 Z"/></svg>',
            "rss": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="3.12" cy="16.8" r="1.85"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5"/></svg>',
            "reply": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z"/></svg>',
            "refresh": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5"/><polyline fill="none" stroke="#000" points="9.9 2 12.79 4.89 9.79 7.9"/></svg>',
            "reddit": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z"/><path d="M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z"/><path d="M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z"/><path d="M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z"/></svg>',
            "receiver": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.01" d="M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611"/></svg>',
            "quote-right": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z"/><path d="M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z"/></svg>',
            "question": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><circle cx="9.99" cy="14.24" r="1.05"/><path fill="none" stroke="#000" stroke-width="1.2" d="m7.72,7.61c0-3.04,4.55-3.06,4.55-.07,0,.95-.91,1.43-1.49,2.03-.48.49-.72.98-.78,1.65-.01.13-.02.24-.02.35"/></svg>',
            "push": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3"/><line fill="none" stroke="#000" x1="9.5" y1="10" x2="9.5" y2="1"/><polyline fill="none" stroke="#000" points="6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5"/></svg>',
            "pull": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7"/><line fill="none" stroke="#000" x1="9.5" y1="11" x2="9.5" y2="2"/><polyline fill="none" stroke="#000" points="6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5"/></svg>',
            "print": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5"/><polyline fill="none" stroke="#000" points="15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5"/><rect fill="none" stroke="#000" width="11" height="6" x="4.5" y="11.5"/><rect width="8" height="1" x="6" y="13"/><rect width="8" height="1" x="6" y="15"/></svg>',
            "plus": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="9" y="1" width="1" height="17"/><rect x="1" y="9" width="17" height="1"/></svg>',
            "plus-circle": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9.5" cy="9.5" r="9"/><line fill="none" stroke="#000" x1="9.5" y1="5" x2="9.5" y2="14"/><line fill="none" stroke="#000" x1="5" y1="9.5" x2="14" y2="9.5"/></svg>',
            "play": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="6.5,5 14.5,10 6.5,15"/></svg>',
            "play-circle": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" stroke-width="1.1" points="8.5 7 13.5 10 8.5 13"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/></svg>',
            "pinterest": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1"/></svg>',
            "phone": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z"/><circle cx="10.5" cy="16.5" r=".8"/></svg>',
            "phone-landscape": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z"/><circle cx="3.8" cy="10.5" r=".8"/></svg>',
            "pencil": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z"/><path fill="none" stroke="#000" d="M15.98,7.268 L13.851,5.148"/></svg>',
            "paint-bucket": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="m6.42,2.16l5.28,5.28"/><path d="m18.49,11.83s1.51,2.06,1.51,3.36c0,.92-.76,1.64-1.51,1.64h0c-.75,0-1.49-.72-1.49-1.64,0-1.3,1.49-3.36,1.49-3.36h0Z"/><line fill="none" stroke="#000" x1="1.26" y1="10.5" x2="16" y2="10.5"/><polygon fill="none" stroke="#000" stroke-width="1.1" points="10.2 1.55 17.6 8.93 8.08 18.45 .7 11.07 10.2 1.55"/></svg>',
            "pagekit": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19"/></svg>',
            "nut": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3"/><circle fill="none" stroke="#000" cx="10" cy="10" r="3.5"/></svg>',
            "move": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="4,5 1,5 1,9 2,9 2,6 4,6"/><polygon points="1,16 2,16 2,18 4,18 4,19 1,19"/><polygon points="14,16 14,19 11,19 11,18 13,18 13,16"/><rect fill="none" stroke="#000" x="5.5" y="1.5" width="13" height="13"/><rect x="1" y="11" width="1" height="3"/><rect x="6" y="18" width="3" height="1"/></svg>',
            "more": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="3" cy="10" r="2"/><circle cx="10" cy="10" r="2"/><circle cx="17" cy="10" r="2"/></svg>',
            "more-vertical": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="3" r="2"/><circle cx="10" cy="10" r="2"/><circle cx="10" cy="17" r="2"/></svg>',
            "minus": '<svg width="20" height="20" viewBox="0 0 20 20"><rect height="1" width="18" y="9" x="1"/></svg>',
            "minus-circle": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9.5" cy="9.5" r="9"/><line fill="none" stroke="#000" x1="5" y1="9.5" x2="14" y2="9.5"/></svg>',
            "microsoft": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m2,2h7.58v7.58H2V2Zm8.42,0h7.58v7.58h-7.58V2ZM2,10.42h7.58v7.58H2v-7.58Zm8.42,0h7.58v7.58h-7.58"/></svg>',
            "microphone": '<svg width="20" height="20" viewBox="0 0 20 20"><line fill="none" stroke="#000" x1="10" x2="10" y1="16.44" y2="18.5"/><line fill="none" stroke="#000" x1="7" x2="13" y1="18.5" y2="18.5"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z"/><path fill="none" stroke="#000" stroke-width="1.1" d="M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6"/></svg>',
            "menu": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="2" y="4" width="16" height="1"/><rect x="2" y="9" width="16" height="1"/><rect x="2" y="14" width="16" height="1"/></svg>',
            "mastodon": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m18.5,6.87c0-3.95-2.59-5.11-2.59-5.11-1.31-.6-3.55-.85-5.88-.87h-.06c-2.33.02-4.57.27-5.88.87,0,0-2.59,1.16-2.59,5.11,0,.91-.02,1.99.01,3.14.09,3.87.71,7.68,4.28,8.62,1.65.44,3.06.53,4.2.47,2.07-.11,3.23-.74,3.23-.74l-.07-1.5s-1.48.47-3.14.41c-1.64-.06-3.38-.18-3.64-2.2-.02-.18-.04-.37-.04-.57,0,0,1.61.39,3.66.49,1.25.06,2.42-.07,3.61-.22,2.28-.27,4.27-1.68,4.52-2.97.39-2.02.36-4.94.36-4.94Zm-3.05,5.09h-1.9v-4.65c0-.98-.41-1.48-1.24-1.48-.91,0-1.37.59-1.37,1.76v2.54h-1.89v-2.54c0-1.17-.46-1.76-1.37-1.76-.82,0-1.24.5-1.24,1.48v4.65h-1.9v-4.79c0-.98.25-1.76.75-2.33.52-.58,1.19-.87,2.03-.87.97,0,1.71.37,2.19,1.12l.47.79.47-.79c.49-.75,1.22-1.12,2.19-1.12.84,0,1.51.29,2.03.87.5.58.75,1.35.75,2.33v4.79Z"/></svg>',
            "mail": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="1.4,6.5 10,11 18.6,6.5"/><path d="M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z"/></svg>',
            "lock": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" height="10" width="13" y="8.5" x="3.5"/><path fill="none" stroke="#000" d="M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8"/></svg>',
            "location": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.01" d="M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z"/><circle fill="none" stroke="#000" cx="10" cy="6.8" r="2.3"/></svg>',
            "list": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="6" y="4" width="12" height="1"/><rect x="6" y="9" width="12" height="1"/><rect x="6" y="14" width="12" height="1"/><rect x="2" y="4" width="2" height="1"/><rect x="2" y="9" width="2" height="1"/><rect x="2" y="14" width="2" height="1"/></svg>',
            "linkedin": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z"/><path d="M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z"/></svg>',
            "link": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375"/><path fill="none" stroke="#000" stroke-width="1.1" d="M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375"/><path fill="none" stroke="#000" stroke-width="1.1" d="M7.925,11.875 L11.925,7.975"/></svg>',
            "lifesaver": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="10" cy="10" r="9"/><circle fill="none" stroke="#000" cx="10" cy="10" r="5"/><line fill="none" stroke="#000" stroke-width="1.1" x1="5.17" y1="2.39" x2="8.11" y2="5.33"/><line fill="none" stroke="#000" stroke-width="1.1" x1="5.33" y1="8.11" x2="2.39" y2="5.17"/><line fill="none" stroke="#000" stroke-width="1.1" x1="14.83" y1="17.61" x2="11.89" y2="14.67"/><line fill="none" stroke="#000" stroke-width="1.1" x1="14.67" y1="11.89" x2="17.61" y2="14.83"/><line fill="none" stroke="#000" stroke-width="1.1" x1="17.61" y1="5.17" x2="14.67" y2="8.11"/><line fill="none" stroke="#000" stroke-width="1.1" x1="11.89" y1="5.33" x2="14.83" y2="2.39"/><line fill="none" stroke="#000" stroke-width="1.1" x1="8.11" y1="14.67" x2="5.17" y2="17.61"/><line fill="none" stroke="#000" stroke-width="1.1" x1="2.39" y1="14.83" x2="5.33" y2="11.89"/></svg>',
            "laptop": '<svg width="20" height="20" viewBox="0 0 20 20"><rect y="16" width="20" height="1"/><rect fill="none" stroke="#000" x="2.5" y="4.5" width="15" height="10"/></svg>',
            "joomla": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z"/><path d="M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8"/><path d="M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8"/><path d="M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7"/></svg>',
            "italic": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z"/></svg>',
            "instagram": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z"/><circle cx="14.87" cy="5.26" r="1.09"/><path d="M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z"/></svg>',
            "info": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/></svg>',
            "image": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="16.1" cy="6.1" r="1.1"/><rect fill="none" stroke="#000" x=".5" y="2.5" width="19" height="15"/><polyline fill="none" stroke="#000" stroke-width="1.01" points="4,13 8,9 13,14"/><polyline fill="none" stroke="#000" stroke-width="1.01" points="11,12 12.5,10.5 16,14"/></svg>',
            "home": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65"/><polygon points="15 4 18 4 18 7 17 7 17 5 15 5"/><polygon points="3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19"/></svg>',
            "history": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="#000" points="1 2 2 2 2 6 6 6 6 7 1 7 1 2"/><path fill="none" stroke="#000" stroke-width="1.1" d="M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10"/><rect x="9" y="4" width="1" height="7"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.018,14.197 L9.445,10.625"/></svg>',
            "heart": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.03" d="M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z"/></svg>',
            "hashtag": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z"/></svg>',
            "happy": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="13" cy="7" r="1"/><circle cx="7" cy="7" r="1"/><circle fill="none" stroke="#000" cx="10" cy="10" r="8.5"/><path fill="none" stroke="#000" d="M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4"/></svg>',
            "grid": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="2" y="2" width="3" height="3"/><rect x="8" y="2" width="3" height="3"/><rect x="14" y="2" width="3" height="3"/><rect x="2" y="8" width="3" height="3"/><rect x="8" y="8" width="3" height="3"/><rect x="14" y="8" width="3" height="3"/><rect x="2" y="14" width="3" height="3"/><rect x="8" y="14" width="3" height="3"/><rect x="14" y="14" width="3" height="3"/></svg>',
            "google": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z"/></svg>',
            "gitter": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="3.5" y="1" width="1.531" height="11.471"/><rect x="7.324" y="4.059" width="1.529" height="15.294"/><rect x="11.148" y="4.059" width="1.527" height="15.294"/><rect x="14.971" y="4.059" width="1.529" height="8.412"/></svg>',
            "github": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z"/></svg>',
            "github-alt": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z"/></svg>',
            "git-fork": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.2" cx="5.79" cy="2.79" r="1.79"/><circle fill="none" stroke="#000" stroke-width="1.2" cx="14.19" cy="2.79" r="1.79"/><circle fill="none" stroke="#000" stroke-width="1.2" cx="10.03" cy="16.79" r="1.79"/><path fill="none" stroke="#000" stroke-width="2" d="M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57"/></svg>',
            "git-branch": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.2" cx="7" cy="3" r="2"/><circle fill="none" stroke="#000" stroke-width="1.2" cx="14" cy="6" r="2"/><circle fill="none" stroke="#000" stroke-width="1.2" cx="7" cy="17" r="2"/><path fill="none" stroke="#000" stroke-width="2" d="M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5"/></svg>',
            "future": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline points="19 2 18 2 18 6 14 6 14 7 19 7 19 2"/><path fill="none" stroke="#000" stroke-width="1.1" d="M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10"/><rect x="9" y="4" width="1" height="7"/><path d="M13.018,14.197 L9.445,10.625" fill="none" stroke="#000" stroke-width="1.1"/></svg>',
            "foursquare": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z"/></svg>',
            "forward": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z"/></svg>',
            "folder": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5"/></svg>',
            "flickr": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="5.5" cy="9.5" r="3.5"/><circle cx="14.5" cy="9.5" r="3.5"/></svg>',
            "file": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" x="3.5" y="1.5" width="13" height="17"/></svg>',
            "file-text": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" width="13" height="17" x="3.5" y="1.5"/><line fill="none" stroke="#000" x1="6" x2="12" y1="12.5" y2="12.5"/><line fill="none" stroke="#000" x1="6" x2="14" y1="8.5" y2="8.5"/><line fill="none" stroke="#000" x1="6" x2="14" y1="6.5" y2="6.5"/><line fill="none" stroke="#000" x1="6" x2="14" y1="10.5" y2="10.5"/></svg>',
            "file-pdf": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" width="13" height="17" x="3.5" y="1.5"/><path d="M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z"/></svg>',
            "file-edit": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z"/><polyline fill="none" stroke="#000" points="16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5"/></svg>',
            "facebook": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z"/></svg>',
            "eye": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="10" cy="10" r="3.45"/><path fill="none" stroke="#000" d="m19.5,10c-2.4,3.66-5.26,7-9.5,7h0,0,0c-4.24,0-7.1-3.34-9.49-7C2.89,6.34,5.75,3,9.99,3h0,0,0c4.25,0,7.11,3.34,9.5,7Z"/></svg>',
            "eye-slash": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="m7.56,7.56c.62-.62,1.49-1.01,2.44-1.01,1.91,0,3.45,1.54,3.45,3.45,0,.95-.39,1.82-1.01,2.44"/><path fill="none" stroke="#000" d="m19.5,10c-2.4,3.66-5.26,7-9.5,7h0,0,0c-4.24,0-7.1-3.34-9.49-7C2.89,6.34,5.75,3,9.99,3h0,0,0c4.25,0,7.11,3.34,9.5,7Z"/><line fill="none" stroke="#000" x1="2.5" y1="2.5" x2="17.5" y2="17.5"/></svg>',
            "expand": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="13 2 18 2 18 7 17 7 17 3 13 3"/><polygon points="2 13 3 13 3 17 7 17 7 18 2 18"/><path fill="none" stroke="#000" stroke-width="1.1" d="M11,9 L17,3"/><path fill="none" stroke="#000" stroke-width="1.1" d="M3,17 L9,11"/></svg>',
            "etsy": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z"/></svg>',
            "dribbble": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.4" d="M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5"/><path fill="none" stroke="#000" stroke-width="1.4" d="M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6"/><path fill="none" stroke="#000" stroke-width="1.4" d="M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4"/><circle fill="none" stroke="#000" stroke-width="1.4" cx="10" cy="10" r="9"/></svg>',
            "download": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="14,10 9.5,14.5 5,10"/><rect x="3" y="17" width="13" height="1"/><line fill="none" stroke="#000" x1="9.5" y1="13.91" x2="9.5" y2="3"/></svg>',
            "discord": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z"/></svg>',
            "desktop": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="8" y="15" width="1" height="2"/><rect x="11" y="15" width="1" height="2"/><rect x="5" y="16" width="10" height="1"/><rect fill="none" stroke="#000" x="1.5" y="3.5" width="17" height="11"/></svg>',
            "database": '<svg width="20" height="20" viewBox="0 0 20 20"><ellipse fill="none" stroke="#000" cx="10" cy="4.64" rx="7.5" ry="3.14"/><path fill="none" stroke="#000" d="M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11"/><path fill="none" stroke="#000" d="M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25"/><path fill="none" stroke="#000" d="M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64"/></svg>',
            "crosshairs": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="10" cy="10" r="7.5"/><line fill="none" stroke="#000" x1="10" x2="10" y2="8"/><line fill="none" stroke="#000" x1="10" y1="12" x2="10" y2="20"/><line fill="none" stroke="#000" y1="10" x2="8" y2="10"/><line fill="none" stroke="#000" x1="12" y1="10" x2="20" y2="10"/></svg>',
            "credit-card": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" x="1.5" y="4.5" width="17" height="12"/><rect x="1" y="7" width="18" height="3"/></svg>',
            "copy": '<svg width="20" height="20" viewBox="0 0 20 20"><rect fill="none" stroke="#000" x="3.5" y="2.5" width="12" height="16"/><polyline fill="none" stroke="#000" points="5 0.5 17.5 0.5 17.5 17"/></svg>',
            "comments": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="2 0.5 19.5 0.5 19.5 13"/><path d="M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z"/></svg>',
            "commenting": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5"/><circle cx="10" cy="8" r="1"/><circle cx="6" cy="8" r="1"/><circle cx="14" cy="8" r="1"/></svg>',
            "comment": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z"/></svg>',
            "cog": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="9.997" cy="10" r="3.31"/><path fill="none" stroke="#000" d="M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z"/></svg>',
            "code": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.01" points="13,4 19,10 13,16"/><polyline fill="none" stroke="#000" stroke-width="1.01" points="7,4 1,10 7,16"/></svg>',
            "cloud-upload": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6"/><polyline fill="none" stroke="#000" points="7.25 11.75 9.5 9.5 11.75 11.75"/><path fill="none" stroke="#000" d="M9.5,18 L9.5,9.5"/></svg>',
            "cloud-download": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6"/><polyline fill="none" stroke="#000" points="11.75 16 9.5 18.25 7.25 16"/><path fill="none" stroke="#000" d="M9.5,18 L9.5,9.5"/></svg>',
            "close": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.06" d="M16,16 L4,4"/><path fill="none" stroke="#000" stroke-width="1.06" d="M16,4 L4,16"/></svg>',
            "clock": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><rect x="9" y="4" width="1" height="7"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.018,14.197 L9.445,10.625"/></svg>',
            "chevron-up": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="4 13 10 7 16 13"/></svg>',
            "chevron-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="7 4 13 10 7 16"/></svg>',
            "chevron-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="13 16 7 10 13 4"/></svg>',
            "chevron-down": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="16 7 10 13 4 7"/></svg>',
            "chevron-double-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="10 6 14 10 10 14"/><polyline fill="none" stroke="#000" stroke-width="1.03" points="6 6 10 10 6 14"/></svg>',
            "chevron-double-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="10 14 6 10 10 6"/><polyline fill="none" stroke="#000" stroke-width="1.03" points="14 14 10 10 14 6"/></svg>',
            "check": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.1" points="4,10 8,15 17,4"/></svg>',
            "cart": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="7.3" cy="17.3" r="1.4"/><circle cx="13.3" cy="17.3" r="1.4"/><polyline fill="none" stroke="#000" points="0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5"/></svg>',
            "camera": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10.8" r="3.8"/><path fill="none" stroke="#000" d="M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z"/></svg>',
            "calendar": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z"/><rect width="1" height="3" x="6" y="2"/><rect width="1" height="3" x="13" y="2"/></svg>',
            "bookmark": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5"/></svg>',
            "bolt": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z"/></svg>',
            "bold": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z"/></svg>',
            "bell": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z"/><path fill="none" stroke="#000" d="M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16"/></svg>',
            "behance": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z"/><path d="M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z"/><rect x="13" y="4" width="5" height="1.4"/></svg>',
            "ban": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><line fill="none" stroke="#000" stroke-width="1.1" x1="4" y1="3.5" x2="16" y2="16.5"/></svg>',
            "bag": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5"/><polygon fill="none" stroke="#000" points="16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5"/></svg>',
            "arrow-up": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4"/><line fill="none" stroke="#000" x1="10.5" y1="16" x2="10.5" y2="5"/></svg>',
            "arrow-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="10 5 15 9.5 10 14"/><line fill="none" stroke="#000" x1="4" y1="9.5" x2="15" y2="9.5"/></svg>',
            "arrow-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="10 14 5 9.5 10 5"/><line fill="none" stroke="#000" x1="16" y1="9.5" x2="5" y2="9.52"/></svg>',
            "arrow-down": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66"/><line fill="none" stroke="#000" x1="10.5" y1="4" x2="10.5" y2="15"/></svg>',
            "apple": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m17.23,6.93c-.1.08-1.95,1.12-1.95,3.43,0,2.67,2.35,3.62,2.42,3.64-.01.06-.37,1.29-1.24,2.55-.77,1.11-1.58,2.22-2.8,2.22s-1.54-.71-2.95-.71-1.87.73-2.99.73-1.9-1.03-2.8-2.29c-1.04-1.48-1.88-3.78-1.88-5.96,0-3.5,2.28-5.36,4.51-5.36,1.19,0,2.18.78,2.93.78s1.82-.83,3.17-.83c.51,0,2.36.05,3.57,1.79h0Zm-4.21-3.27c.56-.66.96-1.59.96-2.51,0-.13-.01-.26-.03-.36-.91.03-1.99.61-2.65,1.36-.51.58-.99,1.5-.99,2.44,0,.14.02.28.03.33.06.01.15.02.24.02.82,0,1.85-.55,2.44-1.28h0Z"/></svg>',
            "android": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m14.88,6.77l1.66-2.87c.09-.16.04-.37-.12-.46-.16-.09-.37-.04-.46.12l-1.68,2.91c-1.28-.59-2.73-.91-4.28-.91s-3,.33-4.28.91l-1.68-2.91c-.09-.16-.3-.22-.46-.12-.16.09-.22.3-.12.46l1.66,2.87C2.26,8.32.32,11.22,0,14.61h20c-.32-3.39-2.26-6.29-5.12-7.84h0Zm-9.47,5.03c-.46,0-.84-.38-.84-.84s.38-.84.84-.84.84.38.84.84c0,.46-.37.84-.84.84Zm9.18,0c-.46,0-.84-.38-.84-.84s.38-.84.84-.84.84.38.84.84c0,.46-.37.84-.84.84Z"/></svg>',
            "android-robot": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m17.61,7.96v4.64c-.06,1.48-2.17,1.48-2.23,0v-4.64c.06-1.48,2.17-1.48,2.23,0Z"/><path d="m4.62,7.96v4.64c-.06,1.48-2.17,1.48-2.23,0v-4.64c.06-1.48,2.17-1.48,2.23,0Z"/><path d="m12.78,2.85c-.11-.07-.23-.13-.34-.19.13-.23.65-1.17.79-1.42.07-.12-.05-.27-.18-.23-.04.01-.07.04-.09.08l-.79,1.43c-1.32-.6-2.98-.6-4.3,0-.13-.23-.65-1.18-.79-1.43-.04-.07-.14-.1-.21-.06-.08.04-.1.14-.06.21,0,0,.79,1.42.79,1.42-1.49.77-2.53,2.28-2.53,3.99-.02,0,9.93,0,9.93,0,.01-1.55-.87-2.98-2.19-3.8Zm-5.07,1.98c-.23,0-.41-.19-.41-.41.01-.27.21-.41.41-.41s.4.14.42.41c0,.22-.18.42-.41.41Zm4.58,0c-.23,0-.42-.19-.41-.41.01-.28.21-.41.41-.41s.4.14.41.41c0,.23-.19.41-.41.41Z"/><path d="m14.97,7.03v7.2c0,.66-.54,1.2-1.2,1.2h-.8v2.46c-.06,1.48-2.16,1.48-2.23,0,0,0,0-2.46,0-2.46h-1.48v2.46c0,.61-.5,1.11-1.11,1.11s-1.11-.5-1.11-1.11v-2.46h-.8c-.66,0-1.2-.54-1.2-1.2,0,0,0-7.2,0-7.2h9.93Z"/></svg>',
            "album": '<svg width="20" height="20" viewBox="0 0 20 20"><rect x="5" y="2" width="10" height="1"/><rect x="3" y="4" width="14" height="1"/><rect fill="none" stroke="#000" x="1.5" y="6.5" width="17" height="11"/></svg>',
            "500px": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z"/><path d="M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z"/><path d="M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z"/><path d="M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z"/></svg>'
          });
        }
        if (typeof window !== "undefined" && window.UIkit) {
          window.UIkit.use(plugin);
        }

        return plugin;

    }));
    });

    const scaleFactor = 1000000;
    const fixedLocales = {
        "zh_cn": "zh"
    };
    function getLocale() {
        let res = get_store_value($locale);
        return fixLocale(res);
    }
    function printCoins(amount) {
        const scaled = unscaledCoins(amount);
        const selectedLocale = getLocale();
        return scaled.toLocaleString(selectedLocale, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        });
    }
    function printUnscaledCoins(amount, min = 2, max = 6) {
        const selectedLocale = getLocale();
        return amount.toLocaleString(selectedLocale, {
            minimumFractionDigits: min,
            maximumFractionDigits: max,
        });
    }
    function unscaledCoins(amount) {
        return amount / scaleFactor;
    }
    function fixLocale(locale) {
        return fixedLocales[locale] || locale;
    }

    /* src/components/wallet/AccountsList.svelte generated by Svelte v3.59.2 */
    const file$S = "src/components/wallet/AccountsList.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (17:35) 
    function create_if_block_1$c(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let th1;
    	let t1_value = /*$_*/ ctx[4]("wallet.account_list.nickname") + "";
    	let t1;
    	let t2;
    	let th2;
    	let t3_value = /*$_*/ ctx[4]("wallet.account_list.address") + "";
    	let t3;
    	let t4;
    	let th3;
    	let t5_value = /*$_*/ ctx[4]("wallet.account_list.authkey") + "";
    	let t5;
    	let t6;
    	let th4;
    	let t7_value = /*$_*/ ctx[4]("wallet.account_list.balance") + "";
    	let t7;
    	let t8;
    	let tbody;
    	let current;
    	let each_value = /*accountList*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			t1 = text(t1_value);
    			t2 = space();
    			th2 = element("th");
    			t3 = text(t3_value);
    			t4 = space();
    			th3 = element("th");
    			t5 = text(t5_value);
    			t6 = space();
    			th4 = element("th");
    			t7 = text(t7_value);
    			t8 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$S, 20, 10, 591);
    			add_location(th1, file$S, 21, 10, 608);
    			add_location(th2, file$S, 22, 10, 664);
    			add_location(th3, file$S, 23, 10, 719);
    			attr_dev(th4, "class", "uk-text-right");
    			add_location(th4, file$S, 24, 10, 774);
    			add_location(tr, file$S, 19, 8, 576);
    			add_location(thead, file$S, 18, 6, 560);
    			add_location(tbody, file$S, 27, 6, 876);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$S, 17, 4, 512);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(th1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, th2);
    			append_dev(th2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, th3);
    			append_dev(th3, t5);
    			append_dev(tr, t6);
    			append_dev(tr, th4);
    			append_dev(th4, t7);
    			append_dev(table, t8);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(tbody, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 16) && t1_value !== (t1_value = /*$_*/ ctx[4]("wallet.account_list.nickname") + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*$_*/ 16) && t3_value !== (t3_value = /*$_*/ ctx[4]("wallet.account_list.address") + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*$_*/ 16) && t5_value !== (t5_value = /*$_*/ ctx[4]("wallet.account_list.authkey") + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*$_*/ 16) && t7_value !== (t7_value = /*$_*/ ctx[4]("wallet.account_list.balance") + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*isMining, accountList, my_account, setAccount, $_, printCoins, unscaledCoins, isConnected*/ 31) {
    				each_value = /*accountList*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(17:35) ",
    		ctx
    	});

    	return block;
    }

    // (15:2) {#if accountList == null}
    function create_if_block$q(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			add_location(span, file$S, 15, 4, 452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(15:2) {#if accountList == null}",
    		ctx
    	});

    	return block;
    }

    // (38:14) {#if a.account == my_account.account}
    function create_if_block_7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_8, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*isMining*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(38:14) {#if a.account == my_account.account}",
    		ctx
    	});

    	return block;
    }

    // (41:16) {:else}
    function create_else_block_1$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "user");
    			add_location(span, file$S, 41, 18, 1342);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(41:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (39:16) {#if isMining}
    function create_if_block_8(ctx) {
    	let iconmining;
    	let current;
    	iconmining = new IconMining({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconmining.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconmining, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconmining.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconmining.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconmining, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(39:16) {#if isMining}",
    		ctx
    	});

    	return block;
    }

    // (72:14) {:else}
    function create_else_block$e(ctx) {
    	let t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(72:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:37) 
    function create_if_block_6(ctx) {
    	let t0_value = /*$_*/ ctx[4]("wallet.account_list.offline") + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.account_list.offline") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(70:37) ",
    		ctx
    	});

    	return block;
    }

    // (68:42) 
    function create_if_block_5$1(ctx) {
    	let t0_value = /*$_*/ ctx[4]("wallet.account_list.loading") + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.account_list.loading") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(68:42) ",
    		ctx
    	});

    	return block;
    }

    // (52:35) 
    function create_if_block_3$5(ctx) {
    	let div;
    	let show_if = unscaledCoins(/*a*/ ctx[6].balance) < 1;
    	let t0;
    	let t1_value = printCoins(/*a*/ ctx[6].balance) + "";
    	let t1;
    	let if_block = show_if && create_if_block_4$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(div, "class", "uk-inline");
    			add_location(div, file$S, 52, 16, 1759);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*accountList*/ 2) show_if = unscaledCoins(/*a*/ ctx[6].balance) < 1;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$3(ctx);
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*accountList*/ 2 && t1_value !== (t1_value = printCoins(/*a*/ ctx[6].balance) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(52:35) ",
    		ctx
    	});

    	return block;
    }

    // (50:14) {#if (a.on_chain != null) && (a.on_chain == false)}
    function create_if_block_2$7(ctx) {
    	let t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("wallet.account_list.account_on_chain") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(50:14) {#if (a.on_chain != null) && (a.on_chain == false)}",
    		ctx
    	});

    	return block;
    }

    // (55:18) {#if unscaledCoins(a.balance) < 1}
    function create_if_block_4$3(ctx) {
    	let span;
    	let t0;
    	let div;
    	let t1_value = /*$_*/ ctx[4]("wallet.account_list.message") + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = space();
    			div = element("div");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "uk-margin uk-text-warning");
    			attr_dev(span, "uk-icon", "icon: info");
    			add_location(span, file$S, 56, 20, 1947);
    			attr_dev(div, "uk-dropdown", "");
    			add_location(div, file$S, 60, 20, 2095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t1_value !== (t1_value = /*$_*/ ctx[4]("wallet.account_list.message") + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(55:18) {#if unscaledCoins(a.balance) < 1}",
    		ctx
    	});

    	return block;
    }

    // (29:8) {#each accountList as a, i}
    function create_each_block$4(ctx) {
    	let tr;
    	let td0;
    	let t0;
    	let td1;
    	let t1_value = /*a*/ ctx[6].nickname + "";
    	let t1;
    	let t2;
    	let td2;
    	let t3_value = /*a*/ ctx[6].account + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5_value = /*a*/ ctx[6].authkey.slice(0, 5) + "";
    	let t5;
    	let t6;
    	let t7;
    	let td4;
    	let t8;
    	let tr_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*a*/ ctx[6].account == /*my_account*/ ctx[0].account && create_if_block_7(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*a*/ ctx[6].on_chain != null && /*a*/ ctx[6].on_chain == false) return create_if_block_2$7;
    		if (/*a*/ ctx[6].on_chain) return create_if_block_3$5;
    		if (/*a*/ ctx[6].balance == null) return create_if_block_5$1;
    		if (!/*isConnected*/ ctx[3]) return create_if_block_6;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block1 = current_block_type(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*a*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			td2 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = text(t5_value);
    			t6 = text("...");
    			t7 = space();
    			td4 = element("td");
    			if_block1.c();
    			t8 = space();
    			add_location(td0, file$S, 36, 12, 1179);
    			add_location(td1, file$S, 45, 12, 1438);
    			add_location(td2, file$S, 46, 12, 1472);
    			add_location(td3, file$S, 47, 12, 1505);
    			attr_dev(td4, "class", "uk-text-right");
    			add_location(td4, file$S, 48, 12, 1553);

    			attr_dev(tr, "class", tr_class_value = /*isMining*/ ctx[2] && /*a*/ ctx[6].account == /*my_account*/ ctx[0].account
    			? "uk-text-primary"
    			: "");

    			add_location(tr, file$S, 30, 10, 983);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			if (if_block0) if_block0.m(td0, null);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, t5);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			if_block1.m(td4, null);
    			append_dev(tr, t8);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*a*/ ctx[6].account == /*my_account*/ ctx[0].account) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*accountList, my_account*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(td0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*accountList*/ 2) && t1_value !== (t1_value = /*a*/ ctx[6].nickname + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*accountList*/ 2) && t3_value !== (t3_value = /*a*/ ctx[6].account + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*accountList*/ 2) && t5_value !== (t5_value = /*a*/ ctx[6].authkey.slice(0, 5) + "")) set_data_dev(t5, t5_value);

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(td4, null);
    				}
    			}

    			if (!current || dirty & /*isMining, accountList, my_account*/ 7 && tr_class_value !== (tr_class_value = /*isMining*/ ctx[2] && /*a*/ ctx[6].account == /*my_account*/ ctx[0].account
    			? "uk-text-primary"
    			: "")) {
    				attr_dev(tr, "class", tr_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(29:8) {#each accountList as a, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$q, create_if_block_1$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*accountList*/ ctx[1] == null) return 0;
    		if (/*accountList*/ ctx[1].length > 0) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$S, 13, 0, 413);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountsList', slots, []);
    	uikit.use(uikitIcons);
    	let { my_account } = $$props;
    	let { accountList } = $$props;
    	let { isMining } = $$props;
    	let { isConnected } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (my_account === undefined && !('my_account' in $$props || $$self.$$.bound[$$self.$$.props['my_account']])) {
    			console.warn("<AccountsList> was created without expected prop 'my_account'");
    		}

    		if (accountList === undefined && !('accountList' in $$props || $$self.$$.bound[$$self.$$.props['accountList']])) {
    			console.warn("<AccountsList> was created without expected prop 'accountList'");
    		}

    		if (isMining === undefined && !('isMining' in $$props || $$self.$$.bound[$$self.$$.props['isMining']])) {
    			console.warn("<AccountsList> was created without expected prop 'isMining'");
    		}

    		if (isConnected === undefined && !('isConnected' in $$props || $$self.$$.bound[$$self.$$.props['isConnected']])) {
    			console.warn("<AccountsList> was created without expected prop 'isConnected'");
    		}
    	});

    	const writable_props = ['my_account', 'accountList', 'isMining', 'isConnected'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountsList> was created with unknown prop '${key}'`);
    	});

    	const click_handler = a => setAccount(a.account);

    	$$self.$$set = $$props => {
    		if ('my_account' in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ('accountList' in $$props) $$invalidate(1, accountList = $$props.accountList);
    		if ('isMining' in $$props) $$invalidate(2, isMining = $$props.isMining);
    		if ('isConnected' in $$props) $$invalidate(3, isConnected = $$props.isConnected);
    	};

    	$$self.$capture_state = () => ({
    		_: $format,
    		setAccount,
    		IconMining,
    		UIkit: uikit,
    		Icons: uikitIcons,
    		printCoins,
    		unscaledCoins,
    		my_account,
    		accountList,
    		isMining,
    		isConnected,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('my_account' in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ('accountList' in $$props) $$invalidate(1, accountList = $$props.accountList);
    		if ('isMining' in $$props) $$invalidate(2, isMining = $$props.isMining);
    		if ('isConnected' in $$props) $$invalidate(3, isConnected = $$props.isConnected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [my_account, accountList, isMining, isConnected, $_, click_handler];
    }

    class AccountsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$S, create_fragment$S, safe_not_equal, {
    			my_account: 0,
    			accountList: 1,
    			isMining: 2,
    			isConnected: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountsList",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get my_account() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set my_account(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accountList() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accountList(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMining() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMining(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isConnected() {
    		throw new Error("<AccountsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isConnected(value) {
    		throw new Error("<AccountsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/wallet/ReminderCreate.svelte generated by Svelte v3.59.2 */
    const file$R = "src/components/wallet/ReminderCreate.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (7:2) {#if pendingAccounts.length > 0 && isConnected }
    function create_if_block$p(ctx) {
    	let div1;
    	let div0;
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("wallet.reminder_create.card_title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[2]("wallet.reminder_create.message_headline") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[2]("wallet.reminder_create.message_prefix") + "";
    	let t4;
    	let t5;
    	let a;
    	let t6;
    	let span;
    	let t7;
    	let t8_value = /*$_*/ ctx[2]("wallet.reminder_create.message_suffix") + "";
    	let t8;
    	let t9;
    	let each_value = /*pendingAccounts*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			a = element("a");
    			t6 = text("Discord ");
    			span = element("span");
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h3, "class", "uk-card-title");
    			add_location(h3, file$R, 9, 8, 294);
    			add_location(p0, file$R, 10, 8, 375);
    			attr_dev(span, "uk-icon", "icon: link;ratio:0.8");
    			add_location(span, file$R, 11, 158, 588);
    			attr_dev(a, "href", "https://discord.com/channels/833074824447655976/909866360060932127");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$R, 11, 57, 487);
    			add_location(p1, file$R, 11, 8, 438);
    			attr_dev(div0, "class", "uk-card uk-card-primary uk-card-hover uk-card-body uk-light");
    			add_location(div0, file$R, 8, 6, 212);
    			attr_dev(div1, "class", "uk-margin-large");
    			add_location(div1, file$R, 7, 4, 176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h3);
    			append_dev(h3, t0);
    			append_dev(div0, t1);
    			append_dev(div0, p0);
    			append_dev(p0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(p1, t4);
    			append_dev(p1, t5);
    			append_dev(p1, a);
    			append_dev(a, t6);
    			append_dev(a, span);
    			append_dev(p1, t7);
    			append_dev(p1, t8);
    			append_dev(div0, t9);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.reminder_create.card_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("wallet.reminder_create.message_headline") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 4 && t4_value !== (t4_value = /*$_*/ ctx[2]("wallet.reminder_create.message_prefix") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 4 && t8_value !== (t8_value = /*$_*/ ctx[2]("wallet.reminder_create.message_suffix") + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*pendingAccounts, $_*/ 5) {
    				each_value = /*pendingAccounts*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(7:2) {#if pendingAccounts.length > 0 && isConnected }",
    		ctx
    	});

    	return block;
    }

    // (13:8) {#each pendingAccounts as a}
    function create_each_block$3(ctx) {
    	let p;
    	let t0_value = /*a*/ ctx[3].nickname + "";
    	let t0;
    	let t1;
    	let t2_value = /*$_*/ ctx[2]("wallet.reminder_create.onboard_key") + "";
    	let t2;
    	let t3;
    	let span;
    	let t4_value = /*a*/ ctx[3].authkey + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" - ");
    			t2 = text(t2_value);
    			t3 = text(" : ");
    			span = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(span, "class", "uk-text-uppercase");
    			add_location(span, file$R, 14, 72, 811);
    			add_location(p, file$R, 13, 10, 734);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(p, span);
    			append_dev(span, t4);
    			append_dev(p, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pendingAccounts*/ 1 && t0_value !== (t0_value = /*a*/ ctx[3].nickname + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("wallet.reminder_create.onboard_key") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*pendingAccounts*/ 1 && t4_value !== (t4_value = /*a*/ ctx[3].authkey + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(13:8) {#each pendingAccounts as a}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let main;
    	let if_block = /*pendingAccounts*/ ctx[0].length > 0 && /*isConnected*/ ctx[1] && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$R, 5, 0, 114);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*pendingAccounts*/ ctx[0].length > 0 && /*isConnected*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ReminderCreate', slots, []);
    	let { pendingAccounts } = $$props;
    	let { isConnected } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (pendingAccounts === undefined && !('pendingAccounts' in $$props || $$self.$$.bound[$$self.$$.props['pendingAccounts']])) {
    			console.warn("<ReminderCreate> was created without expected prop 'pendingAccounts'");
    		}

    		if (isConnected === undefined && !('isConnected' in $$props || $$self.$$.bound[$$self.$$.props['isConnected']])) {
    			console.warn("<ReminderCreate> was created without expected prop 'isConnected'");
    		}
    	});

    	const writable_props = ['pendingAccounts', 'isConnected'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ReminderCreate> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('pendingAccounts' in $$props) $$invalidate(0, pendingAccounts = $$props.pendingAccounts);
    		if ('isConnected' in $$props) $$invalidate(1, isConnected = $$props.isConnected);
    	};

    	$$self.$capture_state = () => ({ _: $format, pendingAccounts, isConnected, $_ });

    	$$self.$inject_state = $$props => {
    		if ('pendingAccounts' in $$props) $$invalidate(0, pendingAccounts = $$props.pendingAccounts);
    		if ('isConnected' in $$props) $$invalidate(1, isConnected = $$props.isConnected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pendingAccounts, isConnected, $_];
    }

    class ReminderCreate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$R, create_fragment$R, safe_not_equal, { pendingAccounts: 0, isConnected: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ReminderCreate",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get pendingAccounts() {
    		throw new Error("<ReminderCreate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pendingAccounts(value) {
    		throw new Error("<ReminderCreate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isConnected() {
    		throw new Error("<ReminderCreate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isConnected(value) {
    		throw new Error("<ReminderCreate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/settings/SetNetworkPlaylist.svelte generated by Svelte v3.59.2 */
    const file$Q = "src/components/settings/SetNetworkPlaylist.svelte";

    // (43:8) <Link to={routes.home}>
    function create_default_slot$2(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("settings.network_settings.btn_cancel") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "uk-button uk-button-default uk-align-right");
    			add_location(span, file$Q, 43, 10, 1445);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("settings.network_settings.btn_cancel") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(43:8) <Link to={routes.home}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let main;
    	let form;
    	let fieldset;
    	let div0;
    	let span0;
    	let t0_value = /*$_*/ ctx[1]("settings.network_settings.playlist") + "";
    	let t0;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let span1;
    	let t3_value = /*$_*/ ctx[1]("settings.network_settings.btn_submit") + "";
    	let t3;
    	let t4;
    	let link;
    	let current;
    	let mounted;
    	let dispose;

    	link = new Link$1({
    			props: {
    				to: routes.home,
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			form = element("form");
    			fieldset = element("fieldset");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(link.$$.fragment);
    			add_location(span0, file$Q, 27, 8, 967);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", /*playlist_json_url*/ ctx[0]);
    			add_location(input, file$Q, 28, 8, 1033);
    			attr_dev(div0, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div0, file$Q, 26, 6, 906);
    			attr_dev(span1, "class", "uk-button uk-button-primary uk-align-right");
    			attr_dev(span1, "id", "add-btn");
    			add_location(span1, file$Q, 37, 8, 1217);
    			add_location(div1, file$Q, 36, 6, 1203);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$Q, 25, 4, 869);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$Q, 24, 2, 840);
    			add_location(main, file$Q, 23, 0, 831);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*playlist_json_url*/ ctx[0]);
    			append_dev(fieldset, t2);
    			append_dev(fieldset, div1);
    			append_dev(div1, span1);
    			append_dev(span1, t3);
    			append_dev(div1, t4);
    			mount_component(link, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[3]),
    					listen_dev(span1, "click", /*updateNetwork*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("settings.network_settings.playlist") + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*playlist_json_url*/ 1) {
    				attr_dev(input, "placeholder", /*playlist_json_url*/ ctx[0]);
    			}

    			if (dirty & /*playlist_json_url*/ 1 && input.value !== /*playlist_json_url*/ ctx[0]) {
    				set_input_value(input, /*playlist_json_url*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 2) && t3_value !== (t3_value = /*$_*/ ctx[1]("settings.network_settings.btn_submit") + "")) set_data_dev(t3, t3_value);
    			const link_changes = {};

    			if (dirty & /*$$scope, $_*/ 18) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(link);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SetNetworkPlaylist', slots, []);
    	let playlist_json_url = "https://raw.githubusercontent.com/OLSF/seed-peers/main/fullnode_seed_playlist.json";

    	function updateNetwork() {
    		// check input data
    		// submit
    		i$1("override_playlist", { url: playlist_json_url }).then(res => {
    			network_profile.set(res);
    			notify_success("Network Settings Updated");
    		}).catch(error => {
    			raise_error(error, false, "updateNetwork");
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SetNetworkPlaylist> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		playlist_json_url = this.value;
    		$$invalidate(0, playlist_json_url);
    	}

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		raise_error,
    		network_profile,
    		invoke: i$1,
    		routes,
    		notify_success,
    		_: $format,
    		playlist_json_url,
    		updateNetwork,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('playlist_json_url' in $$props) $$invalidate(0, playlist_json_url = $$props.playlist_json_url);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [playlist_json_url, $_, updateNetwork, input_input_handler];
    }

    class SetNetworkPlaylist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SetNetworkPlaylist",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src/components/dev/DebugSwitcher.svelte generated by Svelte v3.59.2 */
    const file$P = "src/components/dev/DebugSwitcher.svelte";

    function create_fragment$P(ctx) {
    	let div1;
    	let h4;
    	let t1;
    	let label;
    	let input;
    	let t2;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Debug Mode";
    			t1 = space();
    			label = element("label");
    			input = element("input");
    			t2 = space();
    			div0 = element("div");
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$P, 12, 1, 234);
    			attr_dev(input, "type", "checkbox");
    			input.checked = /*debugEnabled*/ ctx[0];
    			add_location(input, file$P, 16, 2, 355);
    			attr_dev(div0, "class", "uk-switch-slider uk-switch-on-off round");
    			add_location(div0, file$P, 21, 2, 452);
    			attr_dev(label, "class", "uk-switch");
    			add_location(label, file$P, 15, 1, 327);
    			add_location(div1, file$P, 11, 0, 227);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			append_dev(div1, t1);
    			append_dev(div1, label);
    			append_dev(label, input);
    			append_dev(label, t2);
    			append_dev(label, div0);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", /*click_handler*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*debugEnabled*/ 1) {
    				prop_dev(input, "checked", /*debugEnabled*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DebugSwitcher', slots, []);
    	let debugEnabled = false;

    	onMount(async () => {
    		debugMode.subscribe(boo => $$invalidate(0, debugEnabled = boo));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DebugSwitcher> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => debugModeToggle();

    	$$self.$capture_state = () => ({
    		onMount,
    		debugMode,
    		debugModeToggle,
    		debugEnabled
    	});

    	$$self.$inject_state = $$props => {
    		if ('debugEnabled' in $$props) $$invalidate(0, debugEnabled = $$props.debugEnabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [debugEnabled, click_handler];
    }

    class DebugSwitcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugSwitcher",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src/components/layout/CardError.svelte generated by Svelte v3.59.2 */
    const file$O = "src/components/layout/CardError.svelte";
    const get_body_slot_changes$1 = dirty => ({});
    const get_body_slot_context$1 = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});

    function create_fragment$O(ctx) {
    	let main;
    	let div1;
    	let h3;
    	let t0;
    	let div0;
    	let t1;
    	let debugswitcher;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[1].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[0], get_title_slot_context$1);
    	const body_slot_template = /*#slots*/ ctx[1].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[0], get_body_slot_context$1);
    	debugswitcher = new DebugSwitcher({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			h3 = element("h3");
    			if (title_slot) title_slot.c();
    			t0 = space();
    			div0 = element("div");
    			if (body_slot) body_slot.c();
    			t1 = space();
    			create_component(debugswitcher.$$.fragment);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase");
    			add_location(h3, file$O, 5, 6, 180);
    			add_location(div0, file$O, 6, 6, 257);
    			attr_dev(div1, "class", "uk-card uk-card-secondary uk-card-hover uk-card-body uk-light ");
    			add_location(div1, file$O, 4, 4, 97);
    			add_location(main, file$O, 3, 0, 86);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, h3);

    			if (title_slot) {
    				title_slot.m(h3, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (body_slot) {
    				body_slot.m(div0, null);
    			}

    			append_dev(div1, t1);
    			mount_component(debugswitcher, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[0], dirty, get_title_slot_changes$1),
    						get_title_slot_context$1
    					);
    				}
    			}

    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						body_slot,
    						body_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(body_slot_template, /*$$scope*/ ctx[0], dirty, get_body_slot_changes$1),
    						get_body_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(body_slot, local);
    			transition_in(debugswitcher.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(body_slot, local);
    			transition_out(debugswitcher.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (title_slot) title_slot.d(detaching);
    			if (body_slot) body_slot.d(detaching);
    			destroy_component(debugswitcher);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardError', slots, ['title','body']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ DebugSwitcher });
    	return [$$scope, slots];
    }

    class CardError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardError",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/components/layout/ConnectionError.svelte generated by Svelte v3.59.2 */
    const file$N = "src/components/layout/ConnectionError.svelte";

    // (9:4) 
    function create_title_slot$9(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[0]("layout.connection_error.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$N, 8, 4, 204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("layout.connection_error.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$9.name,
    		type: "slot",
    		source: "(9:4) ",
    		ctx
    	});

    	return block;
    }

    // (10:4) 
    function create_body_slot$9(ctx) {
    	let div;
    	let html_tag;
    	let raw_value = /*$_*/ ctx[0]('layout.connection_error.body') + "";
    	let t;
    	let setnetworkplaylist;
    	let current;
    	setnetworkplaylist = new SetNetworkPlaylist({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			html_tag = new HtmlTag(false);
    			t = space();
    			create_component(setnetworkplaylist.$$.fragment);
    			html_tag.a = t;
    			attr_dev(div, "slot", "body");
    			add_location(div, file$N, 9, 4, 272);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			html_tag.m(raw_value, div);
    			append_dev(div, t);
    			mount_component(setnetworkplaylist, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 1) && raw_value !== (raw_value = /*$_*/ ctx[0]('layout.connection_error.body') + "")) html_tag.p(raw_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(setnetworkplaylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(setnetworkplaylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(setnetworkplaylist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$9.name,
    		type: "slot",
    		source: "(10:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$9],
    					title: [create_title_slot$9]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$N, 5, 0, 178);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConnectionError', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ConnectionError> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: $format, SetNetworkPlaylist, CardError, $_ });
    	return [$_];
    }

    class ConnectionError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConnectionError",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src/components/wallet/Wallet.svelte generated by Svelte v3.59.2 */
    const file$M = "src/components/wallet/Wallet.svelte";

    // (52:4) {#if isRefreshing}
    function create_if_block_4$2(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			set_style(span, "position", "absolute");
    			set_style(span, "top", "0px");
    			set_style(span, "left", "0px");
    			add_location(span, file$M, 53, 8, 2058);
    			set_style(div, "position", "relative");
    			add_location(div, file$M, 52, 6, 2018);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(52:4) {#if isRefreshing}",
    		ctx
    	});

    	return block;
    }

    // (58:4) {#if !isLoaded && !isRefreshing && !accountList }
    function create_if_block_3$4(ctx) {
    	let newbie;
    	let current;
    	newbie = new Newbie({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(newbie.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newbie, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newbie.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newbie.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newbie, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(58:4) {#if !isLoaded && !isRefreshing && !accountList }",
    		ctx
    	});

    	return block;
    }

    // (62:4) {#if !isLoaded && accountList && accountList.length == 0}
    function create_if_block_2$6(ctx) {
    	let newbie;
    	let current;
    	newbie = new Newbie({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(newbie.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newbie, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newbie.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newbie.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newbie, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(62:4) {#if !isLoaded && accountList && accountList.length == 0}",
    		ctx
    	});

    	return block;
    }

    // (66:4) {#if isLoaded && accountList && accountList.length > 0}
    function create_if_block$o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$b, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*isConnected*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(66:4) {#if isLoaded && accountList && accountList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (69:6) {:else}
    function create_else_block$d(ctx) {
    	let div0;
    	let h2;
    	let t0_value = /*$_*/ ctx[7]("wallet.wallet") + "";
    	let t0;
    	let t1;
    	let accountslist;
    	let t2;
    	let remindercreate;
    	let t3;
    	let div1;
    	let link0;
    	let t4;
    	let link1;
    	let current;

    	accountslist = new AccountsList({
    			props: {
    				my_account: /*my_account*/ ctx[0],
    				accountList: /*accountList*/ ctx[1],
    				isMining: /*isMining*/ ctx[3],
    				isConnected: /*isConnected*/ ctx[5]
    			},
    			$$inline: true
    		});

    	remindercreate = new ReminderCreate({
    			props: {
    				pendingAccounts: /*pendingAccounts*/ ctx[2],
    				isConnected: /*isConnected*/ ctx[5]
    			},
    			$$inline: true
    		});

    	link0 = new Link$1({
    			props: {
    				to: routes.keygen,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				to: routes.accountFromMnem,
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(accountslist.$$.fragment);
    			t2 = space();
    			create_component(remindercreate.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t4 = space();
    			create_component(link1.$$.fragment);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$M, 70, 10, 2501);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$M, 69, 8, 2454);
    			attr_dev(div1, "uk-grid", "");
    			attr_dev(div1, "class", "uk-flex uk-flex-center");
    			add_location(div1, file$M, 79, 8, 2772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(accountslist, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(remindercreate, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(link0, div1, null);
    			append_dev(div1, t4);
    			mount_component(link1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 128) && t0_value !== (t0_value = /*$_*/ ctx[7]("wallet.wallet") + "")) set_data_dev(t0, t0_value);
    			const accountslist_changes = {};
    			if (dirty & /*my_account*/ 1) accountslist_changes.my_account = /*my_account*/ ctx[0];
    			if (dirty & /*accountList*/ 2) accountslist_changes.accountList = /*accountList*/ ctx[1];
    			if (dirty & /*isMining*/ 8) accountslist_changes.isMining = /*isMining*/ ctx[3];
    			if (dirty & /*isConnected*/ 32) accountslist_changes.isConnected = /*isConnected*/ ctx[5];
    			accountslist.$set(accountslist_changes);
    			const remindercreate_changes = {};
    			if (dirty & /*pendingAccounts*/ 4) remindercreate_changes.pendingAccounts = /*pendingAccounts*/ ctx[2];
    			if (dirty & /*isConnected*/ 32) remindercreate_changes.isConnected = /*isConnected*/ ctx[5];
    			remindercreate.$set(remindercreate_changes);
    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 16512) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 16512) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountslist.$$.fragment, local);
    			transition_in(remindercreate.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountslist.$$.fragment, local);
    			transition_out(remindercreate.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			destroy_component(accountslist, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(remindercreate, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			destroy_component(link0);
    			destroy_component(link1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(69:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (67:6) {#if !isConnected}
    function create_if_block_1$b(ctx) {
    	let connectionerror;
    	let current;
    	connectionerror = new ConnectionError({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(connectionerror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(connectionerror, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(connectionerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(connectionerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(connectionerror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(67:6) {#if !isConnected}",
    		ctx
    	});

    	return block;
    }

    // (81:10) <Link to={routes.keygen}>
    function create_default_slot_1(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[7]("wallet.btn_new_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-secondary");
    			add_location(button, file$M, 81, 12, 2865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 128 && t_value !== (t_value = /*$_*/ ctx[7]("wallet.btn_new_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(81:10) <Link to={routes.keygen}>",
    		ctx
    	});

    	return block;
    }

    // (86:10) <Link to={routes.accountFromMnem}>
    function create_default_slot$1(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[7]("wallet.btn_restore_account") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$M, 86, 12, 3054);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 128 && t_value !== (t_value = /*$_*/ ctx[7]("wallet.btn_restore_account") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(86:10) <Link to={routes.accountFromMnem}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let main;
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = /*isRefreshing*/ ctx[4] && create_if_block_4$2(ctx);
    	let if_block1 = !/*isLoaded*/ ctx[6] && !/*isRefreshing*/ ctx[4] && !/*accountList*/ ctx[1] && create_if_block_3$4(ctx);
    	let if_block2 = !/*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length == 0 && create_if_block_2$6(ctx);
    	let if_block3 = /*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length > 0 && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			add_location(div, file$M, 50, 2, 1983);
    			add_location(main, file$M, 49, 0, 1974);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isRefreshing*/ ctx[4]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*isLoaded*/ ctx[6] && !/*isRefreshing*/ ctx[4] && !/*accountList*/ ctx[1]) {
    				if (if_block1) {
    					if (dirty & /*isLoaded, isRefreshing, accountList*/ 82) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length == 0) {
    				if (if_block2) {
    					if (dirty & /*isLoaded, accountList*/ 66) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*isLoaded*/ ctx[6] && /*accountList*/ ctx[1] && /*accountList*/ ctx[1].length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*isLoaded, accountList*/ 66) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$o(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(7, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Wallet', slots, []);
    	uikit.use(uikitIcons);
    	let my_account;
    	let accountList = null;
    	let pendingAccounts = [];
    	let isMining = false;
    	let isRefreshing = true;
    	let isConnected = true;
    	let isLoaded = false;
    	let unsubsConnected;
    	let unsubsAll_accounts;
    	let unsubsSigningAccount;
    	let unsubsIsAccountsLoaded;
    	let unsubsMinerLoopEnabled;
    	let unsubsIsRefreshingAccounts;

    	onMount(async () => {
    		unsubsConnected = connected.subscribe(b => $$invalidate(5, isConnected = b));

    		unsubsAll_accounts = all_accounts.subscribe(all => {
    			$$invalidate(1, accountList = all);
    			$$invalidate(2, pendingAccounts = all.filter(x => !x.on_chain));
    		});

    		unsubsSigningAccount = signingAccount.subscribe(a => $$invalidate(0, my_account = a));
    		unsubsIsAccountsLoaded = isAccountsLoaded.subscribe(boo => $$invalidate(6, isLoaded = boo));
    		unsubsMinerLoopEnabled = minerLoopEnabled.subscribe(boo => $$invalidate(3, isMining = boo));
    		unsubsIsRefreshingAccounts = isRefreshingAccounts.subscribe(boo => $$invalidate(4, isRefreshing = boo));
    	});

    	onDestroy(async () => {
    		unsubsConnected && unsubsConnected();
    		unsubsAll_accounts && unsubsAll_accounts();
    		unsubsSigningAccount && unsubsSigningAccount();
    		unsubsIsAccountsLoaded && unsubsIsAccountsLoaded();
    		unsubsMinerLoopEnabled && unsubsMinerLoopEnabled();
    		unsubsIsRefreshingAccounts && unsubsIsRefreshingAccounts();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Wallet> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: $format,
    		onDestroy,
    		onMount,
    		Link: Link$1,
    		isRefreshingAccounts,
    		all_accounts,
    		signingAccount,
    		isAccountsLoaded,
    		routes,
    		Newbie,
    		AccountsList,
    		ReminderCreate,
    		minerLoopEnabled,
    		UIkit: uikit,
    		Icons: uikitIcons,
    		connected,
    		ConnectionError,
    		my_account,
    		accountList,
    		pendingAccounts,
    		isMining,
    		isRefreshing,
    		isConnected,
    		isLoaded,
    		unsubsConnected,
    		unsubsAll_accounts,
    		unsubsSigningAccount,
    		unsubsIsAccountsLoaded,
    		unsubsMinerLoopEnabled,
    		unsubsIsRefreshingAccounts,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('my_account' in $$props) $$invalidate(0, my_account = $$props.my_account);
    		if ('accountList' in $$props) $$invalidate(1, accountList = $$props.accountList);
    		if ('pendingAccounts' in $$props) $$invalidate(2, pendingAccounts = $$props.pendingAccounts);
    		if ('isMining' in $$props) $$invalidate(3, isMining = $$props.isMining);
    		if ('isRefreshing' in $$props) $$invalidate(4, isRefreshing = $$props.isRefreshing);
    		if ('isConnected' in $$props) $$invalidate(5, isConnected = $$props.isConnected);
    		if ('isLoaded' in $$props) $$invalidate(6, isLoaded = $$props.isLoaded);
    		if ('unsubsConnected' in $$props) unsubsConnected = $$props.unsubsConnected;
    		if ('unsubsAll_accounts' in $$props) unsubsAll_accounts = $$props.unsubsAll_accounts;
    		if ('unsubsSigningAccount' in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ('unsubsIsAccountsLoaded' in $$props) unsubsIsAccountsLoaded = $$props.unsubsIsAccountsLoaded;
    		if ('unsubsMinerLoopEnabled' in $$props) unsubsMinerLoopEnabled = $$props.unsubsMinerLoopEnabled;
    		if ('unsubsIsRefreshingAccounts' in $$props) unsubsIsRefreshingAccounts = $$props.unsubsIsRefreshingAccounts;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		my_account,
    		accountList,
    		pendingAccounts,
    		isMining,
    		isRefreshing,
    		isConnected,
    		isLoaded,
    		$_
    	];
    }

    class Wallet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Wallet",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    var s,d=function(t,e){this.type="Logical",this.width=t,this.height=e;},l=function(){function t(t,e){this.type="Physical",this.width=t,this.height=e;}return t.prototype.toLogical=function(t){return new d(this.width/t,this.height/t)},t}(),c=function(t,e){this.type="Logical",this.x=t,this.y=e;},h=function(){function t(t,e){this.type="Physical",this.x=t,this.y=e;}return t.prototype.toLogical=function(t){return new c(this.x/t,this.y/t)},t}();function m(){return new v(window.__TAURI__.__currentWindow.label,{skip:!0})}function p(){return window.__TAURI__.__windows.map((function(t){return new v(t.label,{skip:!0})}))}!function(t){t[t.Critical=1]="Critical",t[t.Informational=2]="Informational";}(s||(s={}));var f=["tauri://created","tauri://error"],y=function(){function t(t){this.label=t,this.listeners=Object.create(null);}return t.prototype.listen=function(t,n){return r$1(this,void 0,void 0,(function(){var e=this;return o$1(this,(function(i){return this._handleTauriEvent(t,n)?[2,Promise.resolve((function(){var i=e.listeners[t];i.splice(i.indexOf(n),1);}))]:[2,o(t,n)]}))}))},t.prototype.once=function(t,n){return r$1(this,void 0,void 0,(function(){var e=this;return o$1(this,(function(i){return this._handleTauriEvent(t,n)?[2,Promise.resolve((function(){var i=e.listeners[t];i.splice(i.indexOf(n),1);}))]:[2,s$1(t,n)]}))}))},t.prototype.emit=function(t,n){return r$1(this,void 0,void 0,(function(){var e,o;return o$1(this,(function(i){if(f.includes(t)){for(e=0,o=this.listeners[t]||[];e<o.length;e++)(0, o[e])({event:t,id:-1,payload:n});return [2,Promise.resolve()]}return [2,r(t,this.label,n)]}))}))},t.prototype._handleTauriEvent=function(t,e){return !!f.includes(t)&&(t in this.listeners?this.listeners[t].push(e):this.listeners[t]=[e],!0)},t}(),g=function(n$2){function r(){return null!==n$2&&n$2.apply(this,arguments)||this}return n$1(r,n$2),r.prototype.scaleFactor=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"scaleFactor"}}}})]}))}))},r.prototype.innerPosition=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"innerPosition"}}}})]}))}))},r.prototype.outerPosition=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"outerPosition"}}}})]}))}))},r.prototype.innerSize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"innerSize"}}}})]}))}))},r.prototype.outerSize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"outerSize"}}}})]}))}))},r.prototype.isFullscreen=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isFullscreen"}}}})]}))}))},r.prototype.isMaximized=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isMaximized"}}}})]}))}))},r.prototype.isDecorated=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isDecorated"}}}})]}))}))},r.prototype.isResizable=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isResizable"}}}})]}))}))},r.prototype.isVisible=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"isVisible"}}}})]}))}))},r.prototype.center=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"center"}}}})]}))}))},r.prototype.requestUserAttention=function(t){return r$1(this,void 0,void 0,(function(){var e;return o$1(this,(function(i){return e=null,t&&(e=t===s.Critical?{type:"Critical"}:{type:"Informational"}),[2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"requestUserAttention",payload:e}}}})]}))}))},r.prototype.setResizable=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setResizable",payload:t}}}})]}))}))},r.prototype.setTitle=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setTitle",payload:t}}}})]}))}))},r.prototype.maximize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"maximize"}}}})]}))}))},r.prototype.unmaximize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"unmaximize"}}}})]}))}))},r.prototype.toggleMaximize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"toggleMaximize"}}}})]}))}))},r.prototype.minimize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"minimize"}}}})]}))}))},r.prototype.unminimize=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"unminimize"}}}})]}))}))},r.prototype.show=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"show"}}}})]}))}))},r.prototype.hide=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"hide"}}}})]}))}))},r.prototype.close=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"close"}}}})]}))}))},r.prototype.setDecorations=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setDecorations",payload:t}}}})]}))}))},r.prototype.setAlwaysOnTop=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setAlwaysOnTop",payload:t}}}})]}))}))},r.prototype.setSize=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){if(!t||"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `size` argument must be either a LogicalSize or a PhysicalSize instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setSize",payload:{type:t.type,data:{width:t.width,height:t.height}}}}}})]}))}))},r.prototype.setMinSize=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){if(t&&"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `size` argument must be either a LogicalSize or a PhysicalSize instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setMinSize",payload:t?{type:t.type,data:{width:t.width,height:t.height}}:null}}}})]}))}))},r.prototype.setMaxSize=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){if(t&&"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `size` argument must be either a LogicalSize or a PhysicalSize instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setMaxSize",payload:t?{type:t.type,data:{width:t.width,height:t.height}}:null}}}})]}))}))},r.prototype.setPosition=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){if(!t||"Logical"!==t.type&&"Physical"!==t.type)throw new Error("the `position` argument must be either a LogicalPosition or a PhysicalPosition instance");return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setPosition",payload:{type:t.type,data:{x:t.x,y:t.y}}}}}})]}))}))},r.prototype.setFullscreen=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setFullscreen",payload:t}}}})]}))}))},r.prototype.setFocus=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setFocus"}}}})]}))}))},r.prototype.setIcon=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setIcon",payload:{icon:t}}}}})]}))}))},r.prototype.setSkipTaskbar=function(t){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(e){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"setSkipTaskbar",payload:t}}}})]}))}))},r.prototype.startDragging=function(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{label:this.label,cmd:{type:"startDragging"}}}})]}))}))},r}(y),v=function(r){function a(t,a){void 0===a&&(a={});var u=r.call(this,t)||this;return (null==a?void 0:a.skip)||n({__tauriModule:"Window",message:{cmd:"createWebview",data:{options:e({label:t},a)}}}).then((function(){return r$1(u,void 0,void 0,(function(){return o$1(this,(function(t){return [2,this.emit("tauri://created")]}))}))})).catch((function(t){return r$1(u,void 0,void 0,(function(){return o$1(this,(function(e){return [2,this.emit("tauri://error",t)]}))}))})),u}return n$1(a,r),a.getByLabel=function(t){return p().some((function(e){return e.label===t}))?new a(t,{skip:!0}):null},a}(g),b=new v(null,{skip:!0});function _(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{cmd:{type:"currentMonitor"}}}})]}))}))}function w(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{cmd:{type:"primaryMonitor"}}}})]}))}))}function M(){return r$1(this,void 0,void 0,(function(){return o$1(this,(function(t){return [2,n({__tauriModule:"Window",message:{cmd:"manage",data:{cmd:{type:"availableMonitors"}}}})]}))}))}Object.freeze({__proto__:null,WebviewWindow:v,WebviewWindowHandle:y,WindowManager:g,getCurrent:m,getAll:p,appWindow:b,LogicalSize:d,PhysicalSize:l,LogicalPosition:c,PhysicalPosition:h,get UserAttentionType(){return s},currentMonitor:_,primaryMonitor:w,availableMonitors:M});

    const current_window = m();
    const towerOnce = async () => {
        console.log("mine tower once");
        minerEventReceived.set(false);
        minerProofComplete.set(false);
        // defaults for newbies
        let previous_duration = get_store_value(network_profile).chain_id == Networks.TESTING
            ? 5 * 1000 // Test difficulty 
            : 60 * 60 * 1000; // Default to Prod difficulty, assume 60 minutes for newbies 
        let t = get_store_value(tower);
        if (t.last_local_proof && t.last_local_proof.elapsed_secs != null) {
            previous_duration = 1 + (t.last_local_proof.elapsed_secs * 1000); // at least 1
        }
        let progress = {
            proof_in_progress: t.local_height ? t.local_height + 1 : 1,
            time_start: Date.now(),
            previous_duration,
            complete: false,
            error: false,
            time_elapsed: 0,
            pct_complete: 0,
        };
        t.progress = progress;
        tower.set(t);
        // This is a long running async call.
        // when miner_once returnsm, it's with the response of the proof, or error.
        return i$1("miner_once", {})
            .then(res => {
            console.log('miner_once proof completed' + res);
            responses.set(res);
            setProofComplete();
            // start the sending of txs
            // TODO: unsure why when it emits immediately thre is no action on rust side, perhaps listener startup.
            setTimeout(emitBacklog, 1000);
            // refresh local proofs view, also wait for file to be written
            setTimeout(getLocalHeight, 1000);
            return res;
        })
            .catch(e => {
            console.log('miner_once error: ' + e);
            // disable mining when there is a proof error.
            minerLoopEnabled.set(false);
            raise_error(e, false, "towerOnce");
            proofError();
            return false;
        });
    };
    const maybeStartMiner = async () => {
        // maybe try to start a new proof
        console.log("maybeStartMiner");
        let t = get_store_value(tower);
        let proofComplete = (t && t.progress && t.progress.complete);
        if (
        // user must have set mining switch on
        get_store_value(minerLoopEnabled) &&
            // there should be no backlog in progress
            !get_store_value(backlogInProgress) &&
            // only try to restart if a proof has completed.
            proofComplete) {
            return towerOnce();
        }
    };
    // Only the backlog service needs a listener
    const startBacklogListener = async () => {
        await i$1("start_backlog_sender_listener", {})
            .then((res) => {
            responses.set(res);
            backlogListenerReady.set(true);
            return res;
        })
            .catch((e) => raise_error(e, false, "startBacklogListener"));
    };
    // Stop listening on the rust side for new requests to mine a proof.
    const killBacklogListener = async () => {
        console.log("kill listener");
        return current_window.emit("kill-backlog-listener").then(_ => backlogListenerReady.set(false));
    };
    const emitBacklog = async () => {
        console.log("emit backlog");
        // NOTE: backlog is only in progress is rust emits ack-backlog-request
        clearDisplayErrors();
        current_window.emit('send-backlog', 'please...');
    };
    const hasProofsPending = () => {
        let t = get_store_value(tower);
        // is the user a newbie?
        // if so, any local height needs to be submitted.
        if (t.local_height && get_store_value(isTowerNewbie)) {
            return true;
        }
        // if the user has local height and has tower state
        if (t.local_height && t.on_chain && t.on_chain.verified_tower_height) {
            // only do this if there is a delta
            if ((t.local_height - t.on_chain.verified_tower_height) > 0) {
                return true;
            }
        }
        return false;
    };
    const maybeEmitBacklog = async () => {
        // only emit a backlog event, if there are any proofs pending 
        // and there is no backlog already in progress
        // and finally check that the listener has started.
        if (hasProofsPending() &&
            !get_store_value(backlogInProgress) &&
            get_store_value(backlogListenerReady)) {
            maybeEmitBacklog();
        }
    };
    const getTowerChainView = async () => {
        console.log("getTowerChainView");
        isRefreshingAccounts.set(true);
        return i$1("get_onchain_tower_state", {
            account: get_store_value(signingAccount).account
        })
            .then((res) => {
            let t = get_store_value(tower);
            t.on_chain = res;
            tower.set(t);
            responses.set(JSON.stringify(res));
            if (t.on_chain && t.on_chain.verified_tower_height) {
                isTowerNewbie.set(false);
            }
            isRefreshingAccounts.set(false);
        })
            .catch((e) => {
            //need to reset, otherwise may be looking at wrong account
            let t = get_store_value(tower);
            t.on_chain = {};
            tower.set(t);
            if (t.on_chain && !t.on_chain.verified_tower_height) {
                isTowerNewbie.set(true);
            }
            raise_error(e, true, "getTowerChainView");
            isRefreshingAccounts.set(false);
        });
    };
    // update the `tower.local_proof`
    const getLocalHeight = async () => {
        console.log("getLocalHeight");
        return i$1("get_last_local_proof", {})
            .then((res) => {
            // console.log(res);
            // if res.
            let t = get_store_value(tower);
            t.last_local_proof = res;
            t.local_height = res.height;
            tower.set(t);
            responses.set(JSON.stringify(res));
        })
            .catch((e) => {
            let t = get_store_value(tower);
            t.local_height = -1;
            tower.set(t);
            raise_error(e, true, "getLocalHeight");
        });
    };
    const getEpochRules = async () => {
        console.log("getEpochRules");
        i$1("get_epoch_rules", {})
            .then((res) => {
            // console.log(res);
            // if res.
            let t = get_store_value(tower);
            t.rules = res;
            tower.set(t);
            responses.set(JSON.stringify(res));
        })
            .catch((e) => {
            raise_error(e, true, "getEpochRules");
        });
    };
    function proofError() {
        let t = get_store_value(tower);
        t.progress.error = true;
        tower.set(t);
    }
    function setProofComplete() {
        let t = get_store_value(tower);
        t.progress.complete = true;
        tower.set(t);
        minerProofComplete.set(true);
    }
    function setProofProgres() {
        let t = get_store_value(tower);
        let done = get_store_value(minerProofComplete);
        if (t.progress && !done) {
            t.progress.time_elapsed = Date.now() - t.progress.time_start;
            t.progress.pct_complete = t.progress.time_elapsed / t.progress.previous_duration;
            tower.set(t);
        }
    }
    // submit any transactions that are in the backlog. Proofs that have been mined but for any reason were not committed.
    const submitBacklog = async () => {
        console.log('submitBacklog called');
        clearDisplayErrors();
        backlogInProgress.set(true);
        i$1("submit_backlog", {})
            .then(res => {
            backlogInProgress.set(false);
            backlogSubmitted.set(true);
            console.log('submit_backlog response: ' + res);
            responses.set(res);
            notify_success("Backlog submitted");
            return res;
        })
            .catch(e => {
            backlogInProgress.set(false);
            backlogSubmitted.set(false);
            console.log('>>> submit_backlog error: ' + e);
            raise_error(e, false, "submitBacklog");
        });
    };
    // For debugging or rescue purposes. Sometimes the user may have a proof that for some reason was not committed to the chain.
    const submitProofZero = async () => {
        backlogInProgress.set(true);
        i$1("submit_proof_zero", {})
            .then((res) => {
            console.log(res);
            responses.set(res);
            return res;
        })
            .catch((e) => {
            raise_error(e, false, "submitProofZero");
        });
    };

    let tick_in_progress = false;
    const carpeTick = async () => {
        if (!tick_in_progress) {
            console.log("carpeTick");
            tick_in_progress = true;
            // this should be instant
            await getEpochRules();
            // also should be instant
            await getLocalHeight();
            // fetch a waypoint to see if we can connect to any fullnode.
            // If successful this will set the `network.connected` bool to true. And wallet will display a view.
            if (!get_store_value(scanning_fullnodes)) { // don't try to connect while we are booting up the app and looking for fullnodes
                refreshWaypoint()
                    .then(loadAccounts)
                    .then(getTowerChainView)
                    .finally(() => {
                    maybeEmitBacklog(); // do this no matter what
                    maybeStartMiner();
                    tick_in_progress = false;
                });
            }
        }
        else {
            console.log("deduplicate tick");
        }
    };

    async function enableMining() {
        if (!get_store_value(minerLoopEnabled)) {
            minerLoopEnabled.set(true);
            // When the user turns on the toggle, they will be prompted for OS password.
            // the backlog listener prevents the user from having to re-enter the password everytime
            // a new proof needs to be submitted.
            // The backlog listener requires the OS login of the user.
            // we should only ask for this once. We ask for it when the user toggles the miner.
            // if the user has stuck proofs, we will show an error screen with a button for
            // manually triggering the backlog.
            startBacklogListener();
            // start the first iteration of the loop.
            carpeTick();
            towerOnce();
            return true;
        }
    }
    async function disableMining() {
        // stop the envent listener.
        // set mining to disabled
        minerLoopEnabled.set(false);
        killBacklogListener(); // TODO: how do we prevent zombie listeners from makeing duplicates.
        return true;
    }
    function toggleMining() {
        if (get_store_value(minerLoopEnabled)) {
            disableMining();
        }
        else {
            enableMining();
        }
    }

    /* src/components/miner/ToggleMiner.svelte generated by Svelte v3.59.2 */
    const file$L = "src/components/miner/ToggleMiner.svelte";

    function create_fragment$L(ctx) {
    	let main;
    	let div1;
    	let label;
    	let input;
    	let t;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			label = element("label");
    			input = element("input");
    			t = space();
    			div0 = element("div");
    			attr_dev(input, "type", "checkbox");
    			input.checked = /*enabled*/ ctx[0];
    			add_location(input, file$L, 21, 6, 486);
    			attr_dev(div0, "class", "uk-switch-slider uk-switch-on-off round");
    			add_location(div0, file$L, 26, 6, 598);
    			attr_dev(label, "class", "uk-switch");
    			add_location(label, file$L, 20, 4, 454);
    			attr_dev(div1, "class", "uk-text-center uk-margin");
    			set_style(div1, "position", "relative");
    			add_location(div1, file$L, 19, 2, 384);
    			add_location(main, file$L, 18, 0, 375);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, label);
    			append_dev(label, input);
    			append_dev(label, t);
    			append_dev(label, div0);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", /*click_handler*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*enabled*/ 1) {
    				prop_dev(input, "checked", /*enabled*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ToggleMiner', slots, []);
    	let enabled;
    	let unsubscribe;

    	onMount(async () => {
    		unsubscribe = minerLoopEnabled.subscribe(boo => $$invalidate(0, enabled = boo));
    	});

    	onDestroy(async () => {
    		unsubscribe && unsubscribe();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToggleMiner> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => toggleMining();

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		toggleMining,
    		minerLoopEnabled,
    		enabled,
    		unsubscribe
    	});

    	$$self.$inject_state = $$props => {
    		if ('enabled' in $$props) $$invalidate(0, enabled = $$props.enabled);
    		if ('unsubscribe' in $$props) unsubscribe = $$props.unsubscribe;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [enabled, click_handler];
    }

    class ToggleMiner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToggleMiner",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src/components/miner/MinerProgress.svelte generated by Svelte v3.59.2 */
    const file$K = "src/components/miner/MinerProgress.svelte";

    // (56:6) {:else}
    function create_else_block$c(ctx) {
    	let t0_value = /*$_*/ ctx[3]("miner.miner_process.status_in_process") + "";
    	let t0;
    	let t1;
    	let t2_value = formatPercent(/*percent*/ ctx[0]) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("miner.miner_process.status_in_process") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*percent*/ 1 && t2_value !== (t2_value = formatPercent(/*percent*/ ctx[0]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(56:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:6) {#if proofDone }
    function create_if_block_1$a(ctx) {
    	let t_value = /*$_*/ ctx[3]("miner.miner_process.status_complete") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("miner.miner_process.status_complete") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(54:6) {#if proofDone }",
    		ctx
    	});

    	return block;
    }

    // (71:6) {#if percent > 1.01 }
    function create_if_block$n(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[3]("miner.miner_process.notes2") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$K, 71, 8, 2324);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t_value !== (t_value = /*$_*/ ctx[3]("miner.miner_process.notes2") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(71:6) {#if percent > 1.01 }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let main;
    	let div2;
    	let div1;
    	let span0;
    	let t0;
    	let div0;
    	let raw_value = /*$_*/ ctx[3]("miner.miner_process.notes") + "";
    	let t1;
    	let progress;
    	let t2;
    	let span1;
    	let div2_class_value;

    	function select_block_type(ctx, dirty) {
    		if (/*proofDone*/ ctx[1]) return create_if_block_1$a;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*percent*/ ctx[0] > 1.01 && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div2 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			progress = element("progress");
    			t2 = space();
    			span1 = element("span");
    			if (if_block1) if_block1.c();
    			attr_dev(span0, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(span0, file$K, 52, 4, 1612);
    			attr_dev(div0, "uk-dropdown", "");
    			attr_dev(div0, "class", "uk-text-light uk-text-muted uk-text-thin");
    			add_location(div0, file$K, 62, 8, 1998);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$K, 51, 4, 1584);
    			attr_dev(progress, "id", "mining-progressbar");
    			attr_dev(progress, "class", "uk-progress");
    			progress.value = "0";
    			attr_dev(progress, "max", "1");
    			add_location(progress, file$K, 67, 4, 2148);
    			attr_dev(span1, "class", "uk-text-light uk-text-muted uk-text-thin");
    			add_location(span1, file$K, 69, 4, 2232);
    			attr_dev(div2, "class", div2_class_value = "" + ((/*enable*/ ctx[2] ? '' : 'uk-invisible') + " uk-margin-top"));
    			add_location(div2, file$K, 49, 2, 1520);
    			add_location(main, file$K, 48, 0, 1511);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div2);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			if_block0.m(span0, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div2, t1);
    			append_dev(div2, progress);
    			append_dev(div2, t2);
    			append_dev(div2, span1);
    			if (if_block1) if_block1.m(span1, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span0, null);
    				}
    			}

    			if (dirty & /*$_*/ 8 && raw_value !== (raw_value = /*$_*/ ctx[3]("miner.miner_process.notes") + "")) div0.innerHTML = raw_value;
    			if (/*percent*/ ctx[0] > 1.01) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$n(ctx);
    					if_block1.c();
    					if_block1.m(span1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*enable*/ 4 && div2_class_value !== (div2_class_value = "" + ((/*enable*/ ctx[2] ? '' : 'uk-invisible') + " uk-margin-top"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function formatPercent(decimal) {
    	return (decimal * 100).toFixed(0) + "%";
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(3, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MinerProgress', slots, []);
    	let { tower } = $$props;
    	let percent = 0;
    	let looper;
    	let proofDone = false;
    	let enable = false;
    	let unsubsProofComplete;
    	let unsubsLoopEnabled;

    	afterUpdate(() => {
    		// Progress bar only starts when Rust confirms it is starting the miner.
    		// Progress bar ends when:
    		// - Rust side sends event with a proof completed
    		// - Rust side send event with a failure
    		if (tower.progress && tower.progress.pct_complete) {
    			let bar = document.getElementById("mining-progressbar");
    			bar.value = $$invalidate(0, percent = tower.progress.pct_complete);
    		}
    	});

    	onMount(async () => {
    		unsubsProofComplete = minerProofComplete.subscribe(b => {
    			$$invalidate(1, proofDone = b);

    			if (b) {
    				$$invalidate(0, percent = 1);
    			}
    		});

    		unsubsLoopEnabled = minerLoopEnabled.subscribe(b => {
    			$$invalidate(2, enable = b);

    			if (enable) {
    				// create the bar if not yet started.
    				// for safety clear the interval
    				clearInterval(looper);

    				looper = setInterval(() => setProofProgres(), 1000);
    			}
    		});
    	});

    	onDestroy(() => {
    		clearInterval(looper);
    		unsubsProofComplete && unsubsProofComplete();
    		unsubsLoopEnabled && unsubsLoopEnabled();
    	});

    	$$self.$$.on_mount.push(function () {
    		if (tower === undefined && !('tower' in $$props || $$self.$$.bound[$$self.$$.props['tower']])) {
    			console.warn("<MinerProgress> was created without expected prop 'tower'");
    		}
    	});

    	const writable_props = ['tower'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MinerProgress> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('tower' in $$props) $$invalidate(4, tower = $$props.tower);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		afterUpdate,
    		_: $format,
    		minerProofComplete,
    		minerLoopEnabled,
    		setProofProgres,
    		tower,
    		percent,
    		looper,
    		proofDone,
    		enable,
    		unsubsProofComplete,
    		unsubsLoopEnabled,
    		formatPercent,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('tower' in $$props) $$invalidate(4, tower = $$props.tower);
    		if ('percent' in $$props) $$invalidate(0, percent = $$props.percent);
    		if ('looper' in $$props) looper = $$props.looper;
    		if ('proofDone' in $$props) $$invalidate(1, proofDone = $$props.proofDone);
    		if ('enable' in $$props) $$invalidate(2, enable = $$props.enable);
    		if ('unsubsProofComplete' in $$props) unsubsProofComplete = $$props.unsubsProofComplete;
    		if ('unsubsLoopEnabled' in $$props) unsubsLoopEnabled = $$props.unsubsLoopEnabled;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [percent, proofDone, enable, $_, tower];
    }

    class MinerProgress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$K, create_fragment$K, safe_not_equal, { tower: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerProgress",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get tower() {
    		throw new Error("<MinerProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tower(value) {
    		throw new Error("<MinerProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/TowerStateSkeleton.svelte generated by Svelte v3.59.2 */
    const file$J = "src/components/miner/TowerStateSkeleton.svelte";

    function create_fragment$J(ctx) {
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let span0;
    	let t0_value = /*$_*/ ctx[0]("miner.tower_state.local_height") + "";
    	let t0;
    	let t1;
    	let th1;
    	let span1;
    	let t2_value = /*$_*/ ctx[0]("miner.tower_state.on_chain_height") + "";
    	let t2;
    	let t3;
    	let th2;
    	let span2;
    	let t4_value = /*$_*/ ctx[0]("miner.tower_state.mined_in_last_epoch") + "";
    	let t4;
    	let t5;
    	let th3;
    	let span3;
    	let t6_value = /*$_*/ ctx[0]("miner.tower_state.sent_in_this_epoch") + "";
    	let t6;
    	let t7;
    	let tbody;
    	let tr1;
    	let td0;
    	let span4;
    	let t9;
    	let td1;
    	let span5;
    	let t11;
    	let td2;
    	let span6;
    	let t13;
    	let td3;
    	let span7;

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			span4 = element("span");
    			span4.textContent = "0000";
    			t9 = space();
    			td1 = element("td");
    			span5 = element("span");
    			span5.textContent = "0000";
    			t11 = space();
    			td2 = element("td");
    			span6 = element("span");
    			span6.textContent = "0000";
    			t13 = space();
    			td3 = element("td");
    			span7 = element("span");
    			span7.textContent = "0000";
    			attr_dev(span0, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span0, file$J, 6, 33, 156);
    			attr_dev(th0, "class", "uk-text-center");
    			add_location(th0, file$J, 6, 6, 129);
    			attr_dev(span1, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span1, file$J, 7, 33, 273);
    			attr_dev(th1, "class", "uk-text-center");
    			add_location(th1, file$J, 7, 6, 246);
    			attr_dev(span2, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span2, file$J, 8, 33, 393);
    			attr_dev(th2, "class", "uk-text-center");
    			add_location(th2, file$J, 8, 6, 366);
    			attr_dev(span3, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span3, file$J, 9, 33, 517);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$J, 9, 6, 490);
    			add_location(tr0, file$J, 5, 4, 118);
    			add_location(thead, file$J, 4, 2, 106);
    			attr_dev(span4, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span4, file$J, 14, 10, 680);
    			add_location(td0, file$J, 14, 6, 676);
    			attr_dev(span5, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span5, file$J, 15, 10, 740);
    			add_location(td1, file$J, 15, 6, 736);
    			attr_dev(span6, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span6, file$J, 16, 10, 800);
    			add_location(td2, file$J, 16, 6, 796);
    			attr_dev(span7, "class", "skeleton-container svelte-1r6v8nn");
    			add_location(span7, file$J, 17, 10, 860);
    			add_location(td3, file$J, 17, 6, 856);
    			attr_dev(tr1, "class", "uk-text-center");
    			add_location(tr1, file$J, 13, 4, 642);
    			add_location(tbody, file$J, 12, 2, 630);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$J, 3, 0, 62);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(th0, span0);
    			append_dev(span0, t0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(th1, span1);
    			append_dev(span1, t2);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(th2, span2);
    			append_dev(span2, t4);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(th3, span3);
    			append_dev(span3, t6);
    			append_dev(table, t7);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, span4);
    			append_dev(tr1, t9);
    			append_dev(tr1, td1);
    			append_dev(td1, span5);
    			append_dev(tr1, t11);
    			append_dev(tr1, td2);
    			append_dev(td2, span6);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(td3, span7);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("miner.tower_state.local_height") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("miner.tower_state.on_chain_height") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("miner.tower_state.mined_in_last_epoch") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("miner.tower_state.sent_in_this_epoch") + "")) set_data_dev(t6, t6_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TowerStateSkeleton', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TowerStateSkeleton> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: $format, $_ });
    	return [$_];
    }

    class TowerStateSkeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TowerStateSkeleton",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src/components/miner/TowerState.svelte generated by Svelte v3.59.2 */
    const file$I = "src/components/miner/TowerState.svelte";

    // (60:2) {:else}
    function create_else_block_3(ctx) {
    	let towerstateskeleton;
    	let current;
    	towerstateskeleton = new TowerStateSkeleton({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(towerstateskeleton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(towerstateskeleton, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(towerstateskeleton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(towerstateskeleton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(towerstateskeleton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(60:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (7:2) {#if minerTower && minerTower.on_chain && minerTower.on_chain.previous_proof_hash}
    function create_if_block$m(ctx) {
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t0_value = /*$_*/ ctx[1]("miner.tower_state.local_height") + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*$_*/ ctx[1]("miner.tower_state.on_chain_height") + "";
    	let t2;
    	let t3;
    	let th2;
    	let t4_value = /*$_*/ ctx[1]("miner.tower_state.mined_in_last_epoch") + "";
    	let t4;
    	let t5;
    	let th3;
    	let t6_value = /*$_*/ ctx[1]("miner.tower_state.sent_in_this_epoch") + "";
    	let t6;
    	let t7;
    	let tbody;
    	let tr1;
    	let td0;
    	let t8;
    	let td1;
    	let t9_value = /*minerTower*/ ctx[0].on_chain.verified_tower_height + "";
    	let t9;
    	let t10;
    	let td2;
    	let t11_value = /*minerTower*/ ctx[0].on_chain.latest_epoch_mining + "";
    	let t11;
    	let t12;
    	let td3;
    	let div1;
    	let t13;
    	let t14_value = /*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch + "";
    	let t14;
    	let t15;
    	let div0;

    	function select_block_type_1(ctx, dirty) {
    		if (/*minerTower*/ ctx[0].local_height >= 0) return create_if_block_4$1;
    		return create_else_block_2$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch >= 8) return create_if_block_3$3;
    		return create_else_block_1$3;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch >= 72) return create_if_block_1$9;
    		if (/*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch >= 8) return create_if_block_2$5;
    		return create_else_block$b;
    	}

    	let current_block_type_2 = select_block_type_3(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			t6 = text(t6_value);
    			t7 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			if_block0.c();
    			t8 = space();
    			td1 = element("td");
    			t9 = text(t9_value);
    			t10 = space();
    			td2 = element("td");
    			t11 = text(t11_value);
    			t12 = space();
    			td3 = element("td");
    			div1 = element("div");
    			if_block1.c();
    			t13 = space();
    			t14 = text(t14_value);
    			t15 = space();
    			div0 = element("div");
    			if_block2.c();
    			attr_dev(th0, "class", "uk-text-center");
    			add_location(th0, file$I, 10, 10, 322);
    			attr_dev(th1, "class", "uk-text-center");
    			add_location(th1, file$I, 11, 10, 403);
    			attr_dev(th2, "class", "uk-text-center");
    			add_location(th2, file$I, 12, 10, 487);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$I, 13, 10, 575);
    			add_location(tr0, file$I, 9, 8, 307);
    			add_location(thead, file$I, 8, 6, 291);
    			add_location(td0, file$I, 19, 10, 788);
    			add_location(td1, file$I, 33, 10, 1153);
    			add_location(td2, file$I, 34, 10, 1216);
    			attr_dev(div0, "uk-dropdown", "");
    			add_location(div0, file$I, 43, 14, 1680);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$I, 36, 12, 1294);
    			add_location(td3, file$I, 35, 10, 1277);
    			attr_dev(tr1, "class", "uk-text-center");
    			add_location(tr1, file$I, 17, 8, 703);
    			add_location(tbody, file$I, 16, 6, 687);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$I, 7, 4, 243);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(th0, t0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(th1, t2);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(th2, t4);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(th3, t6);
    			append_dev(table, t7);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			if_block0.m(td0, null);
    			append_dev(tr1, t8);
    			append_dev(tr1, td1);
    			append_dev(td1, t9);
    			append_dev(tr1, t10);
    			append_dev(tr1, td2);
    			append_dev(td2, t11);
    			append_dev(tr1, t12);
    			append_dev(tr1, td3);
    			append_dev(td3, div1);
    			if_block1.m(div1, null);
    			append_dev(div1, t13);
    			append_dev(div1, t14);
    			append_dev(div1, t15);
    			append_dev(div1, div0);
    			if_block2.m(div0, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.tower_state.local_height") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("miner.tower_state.on_chain_height") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 2 && t4_value !== (t4_value = /*$_*/ ctx[1]("miner.tower_state.mined_in_last_epoch") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 2 && t6_value !== (t6_value = /*$_*/ ctx[1]("miner.tower_state.sent_in_this_epoch") + "")) set_data_dev(t6, t6_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(td0, null);
    				}
    			}

    			if (dirty & /*minerTower*/ 1 && t9_value !== (t9_value = /*minerTower*/ ctx[0].on_chain.verified_tower_height + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*minerTower*/ 1 && t11_value !== (t11_value = /*minerTower*/ ctx[0].on_chain.latest_epoch_mining + "")) set_data_dev(t11, t11_value);

    			if (current_block_type_1 !== (current_block_type_1 = select_block_type_2(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, t13);
    				}
    			}

    			if (dirty & /*minerTower*/ 1 && t14_value !== (t14_value = /*minerTower*/ ctx[0].on_chain.actual_count_proofs_in_epoch + "")) set_data_dev(t14, t14_value);

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_3(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(7:2) {#if minerTower && minerTower.on_chain && minerTower.on_chain.previous_proof_hash}",
    		ctx
    	});

    	return block;
    }

    // (23:12) {:else}
    function create_else_block_2$1(ctx) {
    	let div1;
    	let span;
    	let t0;
    	let div0;
    	let t1_value = /*$_*/ ctx[1]("miner.tower_state.empty") + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			attr_dev(span, "uk-icon", "icon: minus-circle");
    			add_location(span, file$I, 25, 14, 951);
    			attr_dev(div0, "uk-dropdown", "");
    			add_location(div0, file$I, 26, 14, 1002);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$I, 24, 12, 913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t1_value !== (t1_value = /*$_*/ ctx[1]("miner.tower_state.empty") + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(23:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:12) {#if minerTower.local_height >= 0}
    function create_if_block_4$1(ctx) {
    	let t_value = /*minerTower*/ ctx[0].local_height + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*minerTower*/ 1 && t_value !== (t_value = /*minerTower*/ ctx[0].local_height + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(21:12) {#if minerTower.local_height >= 0}",
    		ctx
    	});

    	return block;
    }

    // (40:14) {:else}
    function create_else_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-warning uk-margin");
    			attr_dev(span, "uk-icon", "icon: minus-circle");
    			add_location(span, file$I, 40, 16, 1509);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(40:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:14) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 8}
    function create_if_block_3$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-muted uk-margin");
    			attr_dev(span, "uk-icon", "icon: check");
    			add_location(span, file$I, 38, 16, 1408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(38:14) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 8}",
    		ctx
    	});

    	return block;
    }

    // (49:16) {:else}
    function create_else_block$b(ctx) {
    	let t_value = /*$_*/ ctx[1]("miner.tower_state.proof_less") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.tower_state.proof_less") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(49:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:80) 
    function create_if_block_2$5(ctx) {
    	let t_value = /*$_*/ ctx[1]("miner.tower_state.proof_ok") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.tower_state.proof_ok") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(47:80) ",
    		ctx
    	});

    	return block;
    }

    // (45:16) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 72}
    function create_if_block_1$9(ctx) {
    	let t_value = /*$_*/ ctx[1]("miner.tower_state.proof_more") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.tower_state.proof_more") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(45:16) {#if minerTower.on_chain.actual_count_proofs_in_epoch >= 72}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$m, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*minerTower*/ ctx[0] && /*minerTower*/ ctx[0].on_chain && /*minerTower*/ ctx[0].on_chain.previous_proof_hash) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if_block.c();
    			add_location(main, file$I, 5, 0, 147);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TowerState', slots, []);
    	let { minerTower } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (minerTower === undefined && !('minerTower' in $$props || $$self.$$.bound[$$self.$$.props['minerTower']])) {
    			console.warn("<TowerState> was created without expected prop 'minerTower'");
    		}
    	});

    	const writable_props = ['minerTower'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TowerState> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('minerTower' in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    	};

    	$$self.$capture_state = () => ({ _: $format, TowerStateSkeleton, minerTower, $_ });

    	$$self.$inject_state = $$props => {
    		if ('minerTower' in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [minerTower, $_];
    }

    class TowerState extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$I, create_fragment$I, safe_not_equal, { minerTower: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TowerState",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get minerTower() {
    		throw new Error("<TowerState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<TowerState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/MinerPhases.svelte generated by Svelte v3.59.2 */

    const file$H = "src/components/miner/MinerPhases.svelte";

    function create_fragment$H(ctx) {
    	let main;
    	let div;
    	let ul;
    	let li0;
    	let span0;
    	let span0_uk_icon_value;
    	let t0;
    	let t1_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_started") + "";
    	let t1;
    	let t2;
    	let t3;
    	let li1;
    	let span1;
    	let span1_uk_icon_value;
    	let t4;
    	let t5_value = /*$_*/ ctx[6]("miner.miner_phrases.mining_enabled") + "";
    	let t5;
    	let t6;
    	let t7;
    	let li2;
    	let span2;
    	let span2_uk_icon_value;
    	let t8;
    	let t9_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_started") + "";
    	let t9;
    	let t10;
    	let t11;
    	let li3;
    	let span3;
    	let span3_uk_icon_value;
    	let t12;
    	let t13_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_complete") + "";
    	let t13;
    	let t14;
    	let t15;
    	let li4;
    	let span4;
    	let span4_uk_icon_value;
    	let t16;
    	let t17_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_in_process") + "";
    	let t17;
    	let t18;
    	let t19;
    	let li5;
    	let span5;
    	let span5_uk_icon_value;
    	let t20;
    	let t21_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_complete") + "";
    	let t21;
    	let t22;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			span0 = element("span");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(":");
    			t3 = space();
    			li1 = element("li");
    			span1 = element("span");
    			t4 = space();
    			t5 = text(t5_value);
    			t6 = text(":");
    			t7 = space();
    			li2 = element("li");
    			span2 = element("span");
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = text(":");
    			t11 = space();
    			li3 = element("li");
    			span3 = element("span");
    			t12 = space();
    			t13 = text(t13_value);
    			t14 = text(":");
    			t15 = space();
    			li4 = element("li");
    			span4 = element("span");
    			t16 = space();
    			t17 = text(t17_value);
    			t18 = text(":");
    			t19 = space();
    			li5 = element("li");
    			span5 = element("span");
    			t20 = space();
    			t21 = text(t21_value);
    			t22 = text(":");
    			attr_dev(span0, "uk-icon", span0_uk_icon_value = /*listenerReady*/ ctx[0] ? "check" : "close");
    			add_location(span0, file$H, 49, 8, 1652);
    			add_location(li0, file$H, 48, 6, 1639);
    			attr_dev(span1, "uk-icon", span1_uk_icon_value = /*loopEnabled*/ ctx[1] ? "check" : "close");
    			add_location(span1, file$H, 54, 8, 1790);
    			add_location(li1, file$H, 53, 6, 1777);
    			attr_dev(span2, "uk-icon", span2_uk_icon_value = /*proofStarted*/ ctx[2] ? "check" : "close");
    			add_location(span2, file$H, 59, 8, 1925);
    			add_location(li2, file$H, 58, 6, 1912);
    			attr_dev(span3, "uk-icon", span3_uk_icon_value = /*isProofComplete*/ ctx[3] ? "check" : "close");
    			add_location(span3, file$H, 64, 8, 2060);
    			add_location(li3, file$H, 63, 6, 2047);
    			attr_dev(span4, "uk-icon", span4_uk_icon_value = /*isBacklogInProgress*/ ctx[4] ? "check" : "close");
    			add_location(span4, file$H, 69, 8, 2199);
    			add_location(li4, file$H, 68, 6, 2186);
    			attr_dev(span5, "uk-icon", span5_uk_icon_value = /*isBacklogComplete*/ ctx[5] ? "check" : "close");
    			add_location(span5, file$H, 74, 8, 2346);
    			add_location(li5, file$H, 73, 6, 2333);
    			attr_dev(ul, "class", "uk-list uk-list-divider");
    			add_location(ul, file$H, 47, 4, 1596);
    			attr_dev(div, "class", "uk-margin");
    			add_location(div, file$H, 46, 2, 1568);
    			add_location(main, file$H, 45, 0, 1559);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			append_dev(li0, span0);
    			append_dev(li0, t0);
    			append_dev(li0, t1);
    			append_dev(li0, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, span1);
    			append_dev(li1, t4);
    			append_dev(li1, t5);
    			append_dev(li1, t6);
    			append_dev(ul, t7);
    			append_dev(ul, li2);
    			append_dev(li2, span2);
    			append_dev(li2, t8);
    			append_dev(li2, t9);
    			append_dev(li2, t10);
    			append_dev(ul, t11);
    			append_dev(ul, li3);
    			append_dev(li3, span3);
    			append_dev(li3, t12);
    			append_dev(li3, t13);
    			append_dev(li3, t14);
    			append_dev(ul, t15);
    			append_dev(ul, li4);
    			append_dev(li4, span4);
    			append_dev(li4, t16);
    			append_dev(li4, t17);
    			append_dev(li4, t18);
    			append_dev(ul, t19);
    			append_dev(ul, li5);
    			append_dev(li5, span5);
    			append_dev(li5, t20);
    			append_dev(li5, t21);
    			append_dev(li5, t22);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*listenerReady*/ 1 && span0_uk_icon_value !== (span0_uk_icon_value = /*listenerReady*/ ctx[0] ? "check" : "close")) {
    				attr_dev(span0, "uk-icon", span0_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t1_value !== (t1_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_started") + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*loopEnabled*/ 2 && span1_uk_icon_value !== (span1_uk_icon_value = /*loopEnabled*/ ctx[1] ? "check" : "close")) {
    				attr_dev(span1, "uk-icon", span1_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t5_value !== (t5_value = /*$_*/ ctx[6]("miner.miner_phrases.mining_enabled") + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*proofStarted*/ 4 && span2_uk_icon_value !== (span2_uk_icon_value = /*proofStarted*/ ctx[2] ? "check" : "close")) {
    				attr_dev(span2, "uk-icon", span2_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t9_value !== (t9_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_started") + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*isProofComplete*/ 8 && span3_uk_icon_value !== (span3_uk_icon_value = /*isProofComplete*/ ctx[3] ? "check" : "close")) {
    				attr_dev(span3, "uk-icon", span3_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t13_value !== (t13_value = /*$_*/ ctx[6]("miner.miner_phrases.proof_complete") + "")) set_data_dev(t13, t13_value);

    			if (dirty & /*isBacklogInProgress*/ 16 && span4_uk_icon_value !== (span4_uk_icon_value = /*isBacklogInProgress*/ ctx[4] ? "check" : "close")) {
    				attr_dev(span4, "uk-icon", span4_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t17_value !== (t17_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_in_process") + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*isBacklogComplete*/ 32 && span5_uk_icon_value !== (span5_uk_icon_value = /*isBacklogComplete*/ ctx[5] ? "check" : "close")) {
    				attr_dev(span5, "uk-icon", span5_uk_icon_value);
    			}

    			if (dirty & /*$_*/ 64 && t21_value !== (t21_value = /*$_*/ ctx[6]("miner.miner_phrases.backlog_complete") + "")) set_data_dev(t21, t21_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(6, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MinerPhases', slots, []);
    	let listenerReady;
    	let loopEnabled;
    	let proofStarted;
    	let isProofComplete;
    	let isBacklogInProgress;
    	let isBacklogComplete;
    	let unsubsBacklogListenerReady;
    	let unsubsMinerLoopEnabled;
    	let unsubsMinerEventReceived;
    	let unsubsMinerProofComplete;
    	let unsubsBacklogInProgress;
    	let unsubsBacklogSubmitted;

    	onMount(async () => {
    		unsubsBacklogListenerReady = backlogListenerReady.subscribe(b => $$invalidate(0, listenerReady = b));
    		unsubsMinerLoopEnabled = minerLoopEnabled.subscribe(b => $$invalidate(1, loopEnabled = b));
    		unsubsMinerEventReceived = minerEventReceived.subscribe(b => $$invalidate(2, proofStarted = b));
    		unsubsMinerProofComplete = minerProofComplete.subscribe(b => $$invalidate(3, isProofComplete = b));
    		unsubsBacklogInProgress = backlogInProgress.subscribe(b => $$invalidate(4, isBacklogInProgress = b));
    		unsubsBacklogSubmitted = backlogSubmitted.subscribe(b => $$invalidate(5, isBacklogComplete = b));
    	});

    	onDestroy(async () => {
    		unsubsBacklogListenerReady && unsubsBacklogListenerReady();
    		unsubsMinerLoopEnabled && unsubsMinerLoopEnabled();
    		unsubsMinerEventReceived && unsubsMinerEventReceived();
    		unsubsMinerProofComplete && unsubsMinerProofComplete();
    		unsubsBacklogInProgress && unsubsBacklogInProgress();
    		unsubsBacklogSubmitted && unsubsBacklogSubmitted();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MinerPhases> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		_: $format,
    		backlogListenerReady,
    		minerLoopEnabled,
    		minerEventReceived,
    		backlogInProgress,
    		backlogSubmitted,
    		minerProofComplete,
    		listenerReady,
    		loopEnabled,
    		proofStarted,
    		isProofComplete,
    		isBacklogInProgress,
    		isBacklogComplete,
    		unsubsBacklogListenerReady,
    		unsubsMinerLoopEnabled,
    		unsubsMinerEventReceived,
    		unsubsMinerProofComplete,
    		unsubsBacklogInProgress,
    		unsubsBacklogSubmitted,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('listenerReady' in $$props) $$invalidate(0, listenerReady = $$props.listenerReady);
    		if ('loopEnabled' in $$props) $$invalidate(1, loopEnabled = $$props.loopEnabled);
    		if ('proofStarted' in $$props) $$invalidate(2, proofStarted = $$props.proofStarted);
    		if ('isProofComplete' in $$props) $$invalidate(3, isProofComplete = $$props.isProofComplete);
    		if ('isBacklogInProgress' in $$props) $$invalidate(4, isBacklogInProgress = $$props.isBacklogInProgress);
    		if ('isBacklogComplete' in $$props) $$invalidate(5, isBacklogComplete = $$props.isBacklogComplete);
    		if ('unsubsBacklogListenerReady' in $$props) unsubsBacklogListenerReady = $$props.unsubsBacklogListenerReady;
    		if ('unsubsMinerLoopEnabled' in $$props) unsubsMinerLoopEnabled = $$props.unsubsMinerLoopEnabled;
    		if ('unsubsMinerEventReceived' in $$props) unsubsMinerEventReceived = $$props.unsubsMinerEventReceived;
    		if ('unsubsMinerProofComplete' in $$props) unsubsMinerProofComplete = $$props.unsubsMinerProofComplete;
    		if ('unsubsBacklogInProgress' in $$props) unsubsBacklogInProgress = $$props.unsubsBacklogInProgress;
    		if ('unsubsBacklogSubmitted' in $$props) unsubsBacklogSubmitted = $$props.unsubsBacklogSubmitted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		listenerReady,
    		loopEnabled,
    		proofStarted,
    		isProofComplete,
    		isBacklogInProgress,
    		isBacklogComplete,
    		$_
    	];
    }

    class MinerPhases extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerPhases",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/components/miner/MinerDebug.svelte generated by Svelte v3.59.2 */
    const file$G = "src/components/miner/MinerDebug.svelte";

    // (16:0) {#if debug}
    function create_if_block$l(ctx) {
    	let main;
    	let div7;
    	let div5;
    	let div0;
    	let button0;
    	let t1;
    	let div1;
    	let button1;
    	let t3;
    	let div2;
    	let button2;
    	let t5;
    	let div3;
    	let button3;
    	let t7;
    	let div4;
    	let button4;
    	let t9;
    	let div6;
    	let minerphases;
    	let t10;
    	let current;
    	let mounted;
    	let dispose;
    	minerphases = new MinerPhases({ $$inline: true });
    	let if_block = /*minerTower*/ ctx[0] && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div7 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Start Tower";
    			t1 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Start Backlog Listener";
    			t3 = space();
    			div2 = element("div");
    			button2 = element("button");
    			button2.textContent = "Kill Listener";
    			t5 = space();
    			div3 = element("div");
    			button3 = element("button");
    			button3.textContent = "Emit Backlog Event";
    			t7 = space();
    			div4 = element("div");
    			button4 = element("button");
    			button4.textContent = "Resend Proof Zero";
    			t9 = space();
    			div6 = element("div");
    			create_component(minerphases.$$.fragment);
    			t10 = space();
    			if (if_block) if_block.c();
    			attr_dev(button0, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button0, file$G, 20, 10, 623);
    			attr_dev(div0, "class", "uk-margin");
    			add_location(div0, file$G, 19, 8, 589);
    			attr_dev(button1, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button1, file$G, 26, 10, 804);
    			attr_dev(div1, "class", "uk-margin");
    			add_location(div1, file$G, 25, 8, 770);
    			attr_dev(button2, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button2, file$G, 33, 10, 1026);
    			attr_dev(div2, "class", "uk-margin");
    			add_location(div2, file$G, 32, 8, 992);
    			attr_dev(button3, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button3, file$G, 40, 10, 1230);
    			attr_dev(div3, "class", "uk-margin");
    			add_location(div3, file$G, 39, 8, 1196);
    			attr_dev(button4, "class", "uk-button uk-button-default uk-width-1-1");
    			add_location(button4, file$G, 47, 10, 1431);
    			attr_dev(div4, "class", "uk-margin");
    			add_location(div4, file$G, 46, 8, 1397);
    			attr_dev(div5, "class", "uk-width-1-2");
    			add_location(div5, file$G, 18, 6, 554);
    			attr_dev(div6, "class", "uk-width-1-2");
    			add_location(div6, file$G, 56, 6, 1636);
    			attr_dev(div7, "class", "uk-grid");
    			add_location(div7, file$G, 17, 4, 526);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$G, 16, 2, 497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div0);
    			append_dev(div0, button0);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div1, button1);
    			append_dev(div5, t3);
    			append_dev(div5, div2);
    			append_dev(div2, button2);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div3, button3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button4);
    			append_dev(div7, t9);
    			append_dev(div7, div6);
    			mount_component(minerphases, div6, null);
    			append_dev(main, t10);
    			if (if_block) if_block.m(main, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", towerOnce, false, false, false, false),
    					listen_dev(button1, "click", startBacklogListener, false, false, false, false),
    					listen_dev(button2, "click", killBacklogListener, false, false, false, false),
    					listen_dev(button3, "click", emitBacklog, false, false, false, false),
    					listen_dev(button4, "click", submitProofZero, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*minerTower*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(minerphases.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(minerphases.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(minerphases);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(16:0) {#if debug}",
    		ctx
    	});

    	return block;
    }

    // (62:4) {#if minerTower}
    function create_if_block_1$8(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*minerTower*/ ctx[0].on_chain.previous_proof_hash + "";
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Latest on-chain proof hash: ");
    			t1 = text(t1_value);
    			add_location(p, file$G, 62, 6, 1739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*minerTower*/ 1 && t1_value !== (t1_value = /*minerTower*/ ctx[0].on_chain.previous_proof_hash + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(62:4) {#if minerTower}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*debug*/ ctx[1] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*debug*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*debug*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MinerDebug', slots, []);
    	let { minerTower } = $$props;
    	let debug;
    	let unsubsDebug;

    	onMount(async () => {
    		unsubsDebug = debugMode.subscribe(boo => $$invalidate(1, debug = boo));
    	});

    	onDestroy(async () => {
    		unsubsDebug && unsubsDebug();
    	});

    	$$self.$$.on_mount.push(function () {
    		if (minerTower === undefined && !('minerTower' in $$props || $$self.$$.bound[$$self.$$.props['minerTower']])) {
    			console.warn("<MinerDebug> was created without expected prop 'minerTower'");
    		}
    	});

    	const writable_props = ['minerTower'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MinerDebug> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('minerTower' in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    	};

    	$$self.$capture_state = () => ({
    		emitBacklog,
    		killBacklogListener,
    		startBacklogListener,
    		submitProofZero,
    		towerOnce,
    		debugMode,
    		onMount,
    		onDestroy,
    		MinerPhases,
    		minerTower,
    		debug,
    		unsubsDebug
    	});

    	$$self.$inject_state = $$props => {
    		if ('minerTower' in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    		if ('debug' in $$props) $$invalidate(1, debug = $$props.debug);
    		if ('unsubsDebug' in $$props) unsubsDebug = $$props.unsubsDebug;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [minerTower, debug];
    }

    class MinerDebug extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$G, create_fragment$G, safe_not_equal, { minerTower: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerDebug",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get minerTower() {
    		throw new Error("<MinerDebug>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<MinerDebug>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/layout/CardAlert.svelte generated by Svelte v3.59.2 */

    const file$F = "src/components/layout/CardAlert.svelte";
    const get_body_slot_changes = dirty => ({});
    const get_body_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});

    function create_fragment$F(ctx) {
    	let main;
    	let div1;
    	let h4;
    	let t;
    	let div0;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[1].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[0], get_title_slot_context);
    	const body_slot_template = /*#slots*/ ctx[1].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[0], get_body_slot_context);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			h4 = element("h4");
    			if (title_slot) title_slot.c();
    			t = space();
    			div0 = element("div");
    			if (body_slot) body_slot.c();
    			attr_dev(h4, "class", "uk-card-title uk-text-uppercase");
    			add_location(h4, file$F, 4, 6, 120);
    			add_location(div0, file$F, 5, 6, 197);
    			attr_dev(div1, "class", "uk-card uk-card-primary uk-card-hover uk-card-body uk-light");
    			add_location(div1, file$F, 3, 4, 40);
    			add_location(main, file$F, 2, 0, 29);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, h4);

    			if (title_slot) {
    				title_slot.m(h4, null);
    			}

    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (body_slot) {
    				body_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[0], dirty, get_title_slot_changes),
    						get_title_slot_context
    					);
    				}
    			}

    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						body_slot,
    						body_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(body_slot_template, /*$$scope*/ ctx[0], dirty, get_body_slot_changes),
    						get_body_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			transition_in(body_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			transition_out(body_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (title_slot) title_slot.d(detaching);
    			if (body_slot) body_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardAlert', slots, ['title','body']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardAlert> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class CardAlert extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardAlert",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src/components/miner/cards/CantStart.svelte generated by Svelte v3.59.2 */
    const file$E = "src/components/miner/cards/CantStart.svelte";

    // (7:4) 
    function create_title_slot$8(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[0]("miner.cards.cant_start.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$E, 6, 4, 142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("miner.cards.cant_start.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$8.name,
    		type: "slot",
    		source: "(7:4) ",
    		ctx
    	});

    	return block;
    }

    // (8:4) 
    function create_body_slot$8(ctx) {
    	let div;
    	let p;
    	let t_value = /*$_*/ ctx[0]("miner.cards.cant_start.body") + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$E, 8, 6, 234);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$E, 7, 4, 210);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("miner.cards.cant_start.body") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$8.name,
    		type: "slot",
    		source: "(8:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let main;
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot$8],
    					title: [create_title_slot$8]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(cardalert.$$.fragment);
    			add_location(main, file$E, 4, 0, 117);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(cardalert, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(cardalert);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CantStart', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CantStart> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: $format, CardAlert, $_ });
    	return [$_];
    }

    class CantStart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CantStart",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/components/miner/cards/FirstProof.svelte generated by Svelte v3.59.2 */
    const file$D = "src/components/miner/cards/FirstProof.svelte";

    // (16:2) 
    function create_title_slot$7(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.first_proof.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$D, 15, 2, 445);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.first_proof.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$7.name,
    		type: "slot",
    		source: "(16:2) ",
    		ctx
    	});

    	return block;
    }

    // (20:4) {:else}
    function create_else_block$a(ctx) {
    	let p;
    	let t_value = /*$_*/ ctx[1]("miner.cards.first_proof.body_disabled") + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$D, 20, 6, 614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.first_proof.body_disabled") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(20:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if enabled}
    function create_if_block$k(ctx) {
    	let html_tag;
    	let raw_value = /*$_*/ ctx[1]("miner.cards.first_proof.body") + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && raw_value !== (raw_value = /*$_*/ ctx[1]("miner.cards.first_proof.body") + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(18:4) {#if enabled}",
    		ctx
    	});

    	return block;
    }

    // (17:2) 
    function create_body_slot$7(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*enabled*/ ctx[0]) return create_if_block$k;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "slot", "body");
    			add_location(div, file$D, 16, 2, 511);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$7.name,
    		type: "slot",
    		source: "(17:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot$7],
    					title: [create_title_slot$7]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardalert.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardalert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_, enabled*/ 11) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardalert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FirstProof', slots, []);
    	let enabled = false;
    	let unsubsLoopEnabled;

    	onMount(async () => {
    		unsubsLoopEnabled = minerLoopEnabled.subscribe(boo => $$invalidate(0, enabled = boo));
    	});

    	onDestroy(async () => {
    		unsubsLoopEnabled && unsubsLoopEnabled();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FirstProof> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		CardAlert,
    		minerLoopEnabled,
    		_: $format,
    		enabled,
    		unsubsLoopEnabled,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('enabled' in $$props) $$invalidate(0, enabled = $$props.enabled);
    		if ('unsubsLoopEnabled' in $$props) unsubsLoopEnabled = $$props.unsubsLoopEnabled;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [enabled, $_];
    }

    class FirstProof extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FirstProof",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src/components/miner/MinerBacklog.svelte generated by Svelte v3.59.2 */
    const file$C = "src/components/miner/MinerBacklog.svelte";

    // (26:6) {:else}
    function create_else_block$9(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[1]("miner.miner_backlog.btn_submit") + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$C, 26, 8, 776);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.miner_backlog.btn_submit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(26:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (24:6) {#if inProgress}
    function create_if_block$j(ctx) {
    	let button;
    	let t_value = /*$_*/ ctx[1]("miner.miner_backlog.in_process") + "";
    	let t;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "uk-button");
    			button.disabled = true;
    			add_location(button, file$C, 24, 8, 671);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.miner_backlog.in_process") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(24:6) {#if inProgress}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[1]("miner.miner_backlog.title") + "";
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let p;
    	let t2_value = /*$_*/ ctx[1]("miner.miner_backlog.subtitle") + "";
    	let t2;
    	let t3;

    	function select_block_type(ctx, dirty) {
    		if (/*inProgress*/ ctx[0]) return create_if_block$j;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			if_block.c();
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$C, 15, 2, 412);
    			add_location(p, file$C, 20, 6, 580);
    			add_location(div0, file$C, 19, 4, 568);
    			attr_dev(div1, "class", "uk-margin uk-grid");
    			add_location(div1, file$C, 18, 2, 532);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$C, 14, 0, 385);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t2);
    			append_dev(div0, t3);
    			if_block.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.miner_backlog.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("miner.miner_backlog.subtitle") + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MinerBacklog', slots, []);
    	let unsubs;
    	let inProgress = false;

    	onMount(async () => {
    		unsubs = backlogInProgress.subscribe(b => $$invalidate(0, inProgress = b));
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MinerBacklog> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => submitBacklog();

    	$$self.$capture_state = () => ({
    		_: $format,
    		onMount,
    		onDestroy,
    		submitBacklog,
    		backlogInProgress,
    		unsubs,
    		inProgress,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    		if ('inProgress' in $$props) $$invalidate(0, inProgress = $$props.inProgress);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [inProgress, $_, click_handler];
    }

    class MinerBacklog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MinerBacklog",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* src/components/miner/cards/SyncProofsError.svelte generated by Svelte v3.59.2 */
    const file$B = "src/components/miner/cards/SyncProofsError.svelte";

    // (13:4) 
    function create_title_slot$6(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*delta*/ ctx[0]);
    			t1 = text(" proofs missing");
    			attr_dev(span, "slot", "title");
    			add_location(span, file$B, 12, 4, 337);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*delta*/ 1) set_data_dev(t0, /*delta*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$6.name,
    		type: "slot",
    		source: "(13:4) ",
    		ctx
    	});

    	return block;
    }

    // (14:4) 
    function create_body_slot$6(ctx) {
    	let div;
    	let minerbacklog;
    	let current;
    	minerbacklog = new MinerBacklog({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(minerbacklog.$$.fragment);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$B, 13, 4, 392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(minerbacklog, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(minerbacklog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(minerbacklog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(minerbacklog);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$6.name,
    		type: "slot",
    		source: "(14:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$6],
    					title: [create_title_slot$6]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$B, 10, 0, 312);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, delta*/ 5) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SyncProofsError', slots, []);
    	let { minerTower } = $$props;
    	let delta;

    	afterUpdate(() => {
    		$$invalidate(0, delta = minerTower.local_height - minerTower.on_chain.verified_tower_height);
    	});

    	$$self.$$.on_mount.push(function () {
    		if (minerTower === undefined && !('minerTower' in $$props || $$self.$$.bound[$$self.$$.props['minerTower']])) {
    			console.warn("<SyncProofsError> was created without expected prop 'minerTower'");
    		}
    	});

    	const writable_props = ['minerTower'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SyncProofsError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('minerTower' in $$props) $$invalidate(1, minerTower = $$props.minerTower);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		MinerBacklog,
    		CardError,
    		minerTower,
    		delta
    	});

    	$$self.$inject_state = $$props => {
    		if ('minerTower' in $$props) $$invalidate(1, minerTower = $$props.minerTower);
    		if ('delta' in $$props) $$invalidate(0, delta = $$props.delta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [delta, minerTower];
    }

    class SyncProofsError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$B, create_fragment$B, safe_not_equal, { minerTower: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SyncProofsError",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get minerTower() {
    		throw new Error("<SyncProofsError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<SyncProofsError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/cards/SyncProofs.svelte generated by Svelte v3.59.2 */
    const file$A = "src/components/miner/cards/SyncProofs.svelte";

    // (42:43) 
    function create_if_block_3$2(ctx) {
    	let syncproofserror;
    	let current;

    	syncproofserror = new SyncProofsError({
    			props: { minerTower: /*minerTower*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(syncproofserror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(syncproofserror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const syncproofserror_changes = {};
    			if (dirty & /*minerTower*/ 1) syncproofserror_changes.minerTower = /*minerTower*/ ctx[0];
    			syncproofserror.$set(syncproofserror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(syncproofserror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(syncproofserror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(syncproofserror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(42:43) ",
    		ctx
    	});

    	return block;
    }

    // (23:2) {#if listenerReady}
    function create_if_block$i(ctx) {
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot$5],
    					title: [create_title_slot$5]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardalert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardalert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_, delta*/ 84) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardalert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(23:2) {#if listenerReady}",
    		ctx
    	});

    	return block;
    }

    // (25:6) 
    function create_title_slot$5(ctx) {
    	let span1;
    	let t0_value = /*$_*/ ctx[4]("miner.cards.sync_proof.title") + "";
    	let t0;
    	let t1;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span0 = element("span");
    			attr_dev(span0, "class", "uk-margin");
    			attr_dev(span0, "uk-spinner", "ratio: 0.5");
    			add_location(span0, file$A, 26, 8, 830);
    			attr_dev(span1, "slot", "title");
    			attr_dev(span1, "class", "uk-text-uppercase");
    			add_location(span1, file$A, 24, 6, 730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t0);
    			append_dev(span1, t1);
    			append_dev(span1, span0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("miner.cards.sync_proof.title") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$5.name,
    		type: "slot",
    		source: "(25:6) ",
    		ctx
    	});

    	return block;
    }

    // (35:28) 
    function create_if_block_2$4(ctx) {
    	let p;
    	let t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body_0") + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "uk-text-muted uk-text-uppercase");
    			add_location(p, file$A, 35, 10, 1180);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t_value !== (t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body_0") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(35:28) ",
    		ctx
    	});

    	return block;
    }

    // (31:8) {#if delta > 0 }
    function create_if_block_1$7(ctx) {
    	let p;
    	let t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body", { values: { delta: /*delta*/ ctx[2] } }) + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "uk-text-muted uk-text-uppercase");
    			add_location(p, file$A, 31, 10, 1013);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, delta*/ 20 && t_value !== (t_value = /*$_*/ ctx[4]("miner.cards.sync_proof.body", { values: { delta: /*delta*/ ctx[2] } }) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(31:8) {#if delta > 0 }",
    		ctx
    	});

    	return block;
    }

    // (29:6) 
    function create_body_slot$5(ctx) {
    	let div;

    	function select_block_type_1(ctx, dirty) {
    		if (/*delta*/ ctx[2] > 0) return create_if_block_1$7;
    		if (/*delta*/ ctx[2] < 0) return create_if_block_2$4;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "slot", "body");
    			add_location(div, file$A, 28, 6, 901);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$5.name,
    		type: "slot",
    		source: "(29:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let main;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$i, create_if_block_3$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*listenerReady*/ ctx[3]) return 0;
    		if (!/*loading*/ ctx[1] && /*delta*/ ctx[2] && /*delta*/ ctx[2] > 0) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$A, 21, 0, 679);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SyncProofs', slots, []);
    	let { minerTower } = $$props;
    	let { loading = true } = $$props;
    	let delta = null;
    	let listenerReady = false;
    	let unsubsListener;

    	afterUpdate(() => {
    		$$invalidate(2, delta = minerTower.local_height - minerTower.on_chain.verified_tower_height);
    	});

    	onMount(async () => {
    		unsubsListener = backlogListenerReady.subscribe(b => $$invalidate(3, listenerReady = b));
    	});

    	onDestroy(async () => {
    		unsubsListener && unsubsListener();
    	});

    	$$self.$$.on_mount.push(function () {
    		if (minerTower === undefined && !('minerTower' in $$props || $$self.$$.bound[$$self.$$.props['minerTower']])) {
    			console.warn("<SyncProofs> was created without expected prop 'minerTower'");
    		}
    	});

    	const writable_props = ['minerTower', 'loading'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SyncProofs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('minerTower' in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
    	};

    	$$self.$capture_state = () => ({
    		_: $format,
    		onDestroy,
    		onMount,
    		afterUpdate,
    		backlogListenerReady,
    		CardAlert,
    		SyncProofsError,
    		minerTower,
    		loading,
    		delta,
    		listenerReady,
    		unsubsListener,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('minerTower' in $$props) $$invalidate(0, minerTower = $$props.minerTower);
    		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
    		if ('delta' in $$props) $$invalidate(2, delta = $$props.delta);
    		if ('listenerReady' in $$props) $$invalidate(3, listenerReady = $$props.listenerReady);
    		if ('unsubsListener' in $$props) unsubsListener = $$props.unsubsListener;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [minerTower, loading, delta, listenerReady, $_];
    }

    class SyncProofs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$A, create_fragment$A, safe_not_equal, { minerTower: 0, loading: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SyncProofs",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get minerTower() {
    		throw new Error("<SyncProofs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minerTower(value) {
    		throw new Error("<SyncProofs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<SyncProofs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<SyncProofs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/layout/ErrorAccordion.svelte generated by Svelte v3.59.2 */
    const file$z = "src/components/layout/ErrorAccordion.svelte";

    function create_fragment$z(ctx) {
    	let main;
    	let ul;
    	let li;
    	let a;
    	let t0_value = /*$_*/ ctx[1]("layout.error_accordion.title") + "";
    	let t0;
    	let t1;
    	let div;
    	let p0;
    	let t2_value = /*$_*/ ctx[1]("layout.error_accordion.category") + "";
    	let t2;
    	let t3;
    	let t4_value = /*error*/ ctx[0].category + "";
    	let t4;
    	let t5;
    	let p1;
    	let t6_value = /*$_*/ ctx[1]("layout.error_accordion.id") + "";
    	let t6;
    	let t7;
    	let t8_value = /*error*/ ctx[0].uid + "";
    	let t8;
    	let t9;
    	let p2;
    	let t10_value = /*error*/ ctx[0].msg + "";
    	let t10;

    	const block = {
    		c: function create() {
    			main = element("main");
    			ul = element("ul");
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = text(" - ");
    			t4 = text(t4_value);
    			t5 = space();
    			p1 = element("p");
    			t6 = text(t6_value);
    			t7 = text(" - ");
    			t8 = text(t8_value);
    			t9 = space();
    			p2 = element("p");
    			t10 = text(t10_value);
    			attr_dev(a, "class", "uk-accordion-title");
    			attr_dev(a, "href", "#");
    			add_location(a, file$z, 7, 6, 122);
    			add_location(p0, file$z, 10, 8, 254);
    			add_location(p1, file$z, 11, 8, 328);
    			add_location(p2, file$z, 12, 8, 391);
    			attr_dev(div, "class", "uk-accordion-content");
    			add_location(div, file$z, 9, 6, 211);
    			add_location(li, file$z, 6, 4, 111);
    			attr_dev(ul, "uk-accordion", "");
    			add_location(ul, file$z, 5, 2, 89);
    			add_location(main, file$z, 4, 0, 80);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, ul);
    			append_dev(ul, li);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    			append_dev(li, div);
    			append_dev(div, p0);
    			append_dev(p0, t2);
    			append_dev(p0, t3);
    			append_dev(p0, t4);
    			append_dev(div, t5);
    			append_dev(div, p1);
    			append_dev(p1, t6);
    			append_dev(p1, t7);
    			append_dev(p1, t8);
    			append_dev(div, t9);
    			append_dev(div, p2);
    			append_dev(p2, t10);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("layout.error_accordion.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("layout.error_accordion.category") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*error*/ 1 && t4_value !== (t4_value = /*error*/ ctx[0].category + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 2 && t6_value !== (t6_value = /*$_*/ ctx[1]("layout.error_accordion.id") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*error*/ 1 && t8_value !== (t8_value = /*error*/ ctx[0].uid + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*error*/ 1 && t10_value !== (t10_value = /*error*/ ctx[0].msg + "")) set_data_dev(t10, t10_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ErrorAccordion', slots, []);
    	let { error } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (error === undefined && !('error' in $$props || $$self.$$.bound[$$self.$$.props['error']])) {
    			console.warn("<ErrorAccordion> was created without expected prop 'error'");
    		}
    	});

    	const writable_props = ['error'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ErrorAccordion> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('error' in $$props) $$invalidate(0, error = $$props.error);
    	};

    	$$self.$capture_state = () => ({ _: $format, error, $_ });

    	$$self.$inject_state = $$props => {
    		if ('error' in $$props) $$invalidate(0, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [error, $_];
    }

    class ErrorAccordion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$z, create_fragment$z, safe_not_equal, { error: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ErrorAccordion",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get error() {
    		throw new Error("<ErrorAccordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<ErrorAccordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/miner/cards/DiscoError.svelte generated by Svelte v3.59.2 */
    const file$y = "src/components/miner/cards/DiscoError.svelte";

    // (19:0) {#if display}
    function create_if_block$h(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$4],
    					title: [create_title_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$y, 19, 2, 523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 11) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(19:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (22:6) 
    function create_title_slot$4(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.disco_error.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$y, 21, 6, 552);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.disco_error.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$4.name,
    		type: "slot",
    		source: "(22:6) ",
    		ctx
    	});

    	return block;
    }

    // (23:6) 
    function create_body_slot$4(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.disco_error.body") + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$y, 23, 8, 649);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$y, 22, 6, 623);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.disco_error.body") + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$4.name,
    		type: "slot",
    		source: "(23:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DiscoError', slots, []);
    	let display = null;
    	let unsubs;

    	onMount(async () => {
    		unsubs = displayDiscontinuity.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DiscoError> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		ErrorAccordion,
    		CardError,
    		displayDiscontinuity,
    		_: $format,
    		display,
    		unsubs,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('display' in $$props) $$invalidate(0, display = $$props.display);
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_];
    }

    class DiscoError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DiscoError",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src/components/miner/cards/InvalidProof.svelte generated by Svelte v3.59.2 */
    const file$x = "src/components/miner/cards/InvalidProof.svelte";

    // (18:0) {#if display}
    function create_if_block$g(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$3],
    					title: [create_title_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$x, 18, 2, 520);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 11) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(18:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (21:6) 
    function create_title_slot$3(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$x, 20, 6, 549);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$3.name,
    		type: "slot",
    		source: "(21:6) ",
    		ctx
    	});

    	return block;
    }

    // (22:6) 
    function create_body_slot$3(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.body") + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$x, 22, 8, 647);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$x, 21, 6, 621);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.invalid_proof.body") + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$3.name,
    		type: "slot",
    		source: "(22:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InvalidProof', slots, []);
    	let display = null;
    	let unsubs;

    	onMount(async () => {
    		unsubs = displayInvalidProof.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InvalidProof> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		ErrorAccordion,
    		CardError,
    		displayInvalidProof,
    		_: $format,
    		display,
    		unsubs,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('display' in $$props) $$invalidate(0, display = $$props.display);
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_];
    }

    class InvalidProof extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InvalidProof",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src/components/miner/cards/TooManyProofs.svelte generated by Svelte v3.59.2 */
    const file$w = "src/components/miner/cards/TooManyProofs.svelte";

    // (19:0) {#if display}
    function create_if_block$f(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$2],
    					title: [create_title_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$w, 19, 2, 582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 19) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(19:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (22:6) 
    function create_title_slot$2(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$w, 21, 6, 611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$2.name,
    		type: "slot",
    		source: "(22:6) ",
    		ctx
    	});

    	return block;
    }

    // (23:6) 
    function create_body_slot$2(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.body", { values: { maxNum: /*maxNum*/ ctx[2] } }) + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$w, 23, 8, 711);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$w, 22, 6, 685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.too_many_proofs.body", { values: { maxNum: /*maxNum*/ ctx[2] } }) + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$2.name,
    		type: "slot",
    		source: "(23:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TooManyProofs', slots, []);
    	let unsubs;
    	let display = null;
    	let maxNum = 72; // TODO: this someday needs to be dynamic.

    	onMount(async () => {
    		unsubs = displayTooManyProofs.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TooManyProofs> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: $format,
    		onMount,
    		onDestroy,
    		ErrorAccordion,
    		CardError,
    		displayTooManyProofs,
    		unsubs,
    		display,
    		maxNum,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    		if ('display' in $$props) $$invalidate(0, display = $$props.display);
    		if ('maxNum' in $$props) $$invalidate(2, maxNum = $$props.maxNum);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_, maxNum];
    }

    class TooManyProofs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TooManyProofs",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/components/miner/cards/WrongDifficulty.svelte generated by Svelte v3.59.2 */
    const file$v = "src/components/miner/cards/WrongDifficulty.svelte";

    // (18:0) {#if display}
    function create_if_block$e(ctx) {
    	let main;
    	let carderror;
    	let current;

    	carderror = new CardError({
    			props: {
    				$$slots: {
    					body: [create_body_slot$1],
    					title: [create_title_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(carderror.$$.fragment);
    			add_location(main, file$v, 18, 2, 526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(carderror, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const carderror_changes = {};

    			if (dirty & /*$$scope, display, $_*/ 11) {
    				carderror_changes.$$scope = { dirty, ctx };
    			}

    			carderror.$set(carderror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carderror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carderror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(carderror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(18:0) {#if display}",
    		ctx
    	});

    	return block;
    }

    // (21:6) 
    function create_title_slot$1(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$v, 20, 6, 555);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$1.name,
    		type: "slot",
    		source: "(21:6) ",
    		ctx
    	});

    	return block;
    }

    // (22:6) 
    function create_body_slot$1(ctx) {
    	let div;
    	let p;
    	let t0_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.body") + "";
    	let t0;
    	let t1;
    	let erroraccordion;
    	let current;

    	erroraccordion = new ErrorAccordion({
    			props: { error: /*display*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(erroraccordion.$$.fragment);
    			add_location(p, file$v, 22, 8, 656);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$v, 21, 6, 630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(div, t1);
    			mount_component(erroraccordion, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("miner.cards.wrong_difficulty.body") + "")) set_data_dev(t0, t0_value);
    			const erroraccordion_changes = {};
    			if (dirty & /*display*/ 1) erroraccordion_changes.error = /*display*/ ctx[0];
    			erroraccordion.$set(erroraccordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(erroraccordion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(erroraccordion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(erroraccordion);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$1.name,
    		type: "slot",
    		source: "(22:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*display*/ ctx[0] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*display*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WrongDifficulty', slots, []);
    	let unsubs;
    	let display = null;

    	onMount(async () => {
    		unsubs = displayWrongDifficulty.subscribe(ce => {
    			$$invalidate(0, display = ce.category ? ce : null);
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WrongDifficulty> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: $format,
    		onMount,
    		onDestroy,
    		ErrorAccordion,
    		CardError,
    		displayWrongDifficulty,
    		unsubs,
    		display,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    		if ('display' in $$props) $$invalidate(0, display = $$props.display);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display, $_];
    }

    class WrongDifficulty extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WrongDifficulty",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src/components/miner/CommonErrors.svelte generated by Svelte v3.59.2 */
    const file$u = "src/components/miner/CommonErrors.svelte";

    function create_fragment$u(ctx) {
    	let main;
    	let div;
    	let wrongdifficulty;
    	let t0;
    	let toomanyproofs;
    	let t1;
    	let invalidproof;
    	let t2;
    	let discoerror;
    	let current;
    	wrongdifficulty = new WrongDifficulty({ $$inline: true });
    	toomanyproofs = new TooManyProofs({ $$inline: true });
    	invalidproof = new InvalidProof({ $$inline: true });
    	discoerror = new DiscoError({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			create_component(wrongdifficulty.$$.fragment);
    			t0 = space();
    			create_component(toomanyproofs.$$.fragment);
    			t1 = space();
    			create_component(invalidproof.$$.fragment);
    			t2 = space();
    			create_component(discoerror.$$.fragment);
    			attr_dev(div, "class", "uk-grid uk-child-width-expand");
    			add_location(div, file$u, 7, 2, 284);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$u, 6, 0, 257);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			mount_component(wrongdifficulty, div, null);
    			append_dev(div, t0);
    			mount_component(toomanyproofs, div, null);
    			append_dev(div, t1);
    			mount_component(invalidproof, div, null);
    			append_dev(div, t2);
    			mount_component(discoerror, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wrongdifficulty.$$.fragment, local);
    			transition_in(toomanyproofs.$$.fragment, local);
    			transition_in(invalidproof.$$.fragment, local);
    			transition_in(discoerror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wrongdifficulty.$$.fragment, local);
    			transition_out(toomanyproofs.$$.fragment, local);
    			transition_out(invalidproof.$$.fragment, local);
    			transition_out(discoerror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(wrongdifficulty);
    			destroy_component(toomanyproofs);
    			destroy_component(invalidproof);
    			destroy_component(discoerror);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CommonErrors', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CommonErrors> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		DiscoError,
    		InvalidProof,
    		TooManyProofs,
    		WrongDifficulty
    	});

    	return [];
    }

    class CommonErrors extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CommonErrors",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src/components/miner/cards/EpochStatus.svelte generated by Svelte v3.59.2 */
    const file$t = "src/components/miner/cards/EpochStatus.svelte";

    // (37:6) {:else}
    function create_else_block$8(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 37, 6, 1380);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 38, 6, 1513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.in_process_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(37:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (31:23) 
    function create_if_block_2$3(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 32, 6, 1129);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 33, 6, 1257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.empty_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(31:23) ",
    		ctx
    	});

    	return block;
    }

    // (25:33) 
    function create_if_block_1$6(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 25, 6, 803);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 26, 6, 934);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.complete_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(25:33) ",
    		ctx
    	});

    	return block;
    }

    // (20:4) {#if actual_proofs >= 72}
    function create_if_block$d(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_body") + "";
    	let t2;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-light uk-text-muted");
    			add_location(h3, file$t, 20, 6, 530);
    			attr_dev(p, "class", "uk-text-light uk-text-muted");
    			add_location(p, file$t, 21, 6, 659);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("miner.cards.epoch_status.exceed_body") + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(20:4) {#if actual_proofs >= 72}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let main;
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*actual_proofs*/ ctx[0] >= 72) return create_if_block$d;
    		if (/*actual_proofs*/ ctx[0] >= 8) return create_if_block_1$6;
    		if (/*newbie*/ ctx[1]) return create_if_block_2$3;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "uk-card uk-card-default uk-card-body");
    			add_location(div, file$t, 18, 2, 443);
    			add_location(main, file$t, 17, 0, 434);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EpochStatus', slots, []);
    	let actual_proofs;
    	let newbie = false;

    	onMount(() => {
    		tower.subscribe(t => {
    			if (t && t.on_chain) {
    				$$invalidate(0, actual_proofs = t.on_chain.actual_count_proofs_in_epoch);
    			}

    			isTowerNewbie.subscribe(n => {
    				$$invalidate(1, newbie = n);
    			});
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EpochStatus> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: $format,
    		onMount,
    		isTowerNewbie,
    		tower,
    		actual_proofs,
    		newbie,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('actual_proofs' in $$props) $$invalidate(0, actual_proofs = $$props.actual_proofs);
    		if ('newbie' in $$props) $$invalidate(1, newbie = $$props.newbie);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [actual_proofs, newbie, $_];
    }

    class EpochStatus extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EpochStatus",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src/components/miner/Miner.svelte generated by Svelte v3.59.2 */
    const file$s = "src/components/miner/Miner.svelte";

    // (55:2) {#if loading}
    function create_if_block_5(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			set_style(span, "position", "absolute");
    			set_style(span, "left", "0px");
    			set_style(span, "top", "0px");
    			attr_dev(span, "uk-spinner", "");
    			add_location(span, file$s, 56, 6, 2136);
    			set_style(div, "position", "relative");
    			add_location(div, file$s, 55, 4, 2098);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(55:2) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (66:2) {#if isDevTest}
    function create_if_block_4(ctx) {
    	let div;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "DEV MODE, RUNNING IN TEST DIFFICULTY";
    			attr_dev(p, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(p, file$s, 67, 6, 2434);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$s, 66, 4, 2391);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(66:2) {#if isDevTest}",
    		ctx
    	});

    	return block;
    }

    // (102:24) 
    function create_if_block_3$1(ctx) {
    	let cantstart;
    	let current;
    	cantstart = new CantStart({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(cantstart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cantstart, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cantstart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cantstart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cantstart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(102:24) ",
    		ctx
    	});

    	return block;
    }

    // (74:6) {#if (account && account.on_chain) ||             // so we don't get a flash of the error card on an intermittent local network connection if we are in fact mining            (minerTower && minerTower.progress.pct_complete)       }
    function create_if_block$c(ctx) {
    	let div0;
    	let toggleminer;
    	let t0;
    	let minerprogress;
    	let t1;
    	let div1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	toggleminer = new ToggleMiner({ $$inline: true });

    	minerprogress = new MinerProgress({
    			props: { tower: /*minerTower*/ ctx[6] },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_1$5, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*newbie*/ ctx[0] && !/*hasProofs*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(toggleminer.$$.fragment);
    			t0 = space();
    			create_component(minerprogress.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "uk-width-1-1 uk-align-center");
    			add_location(div0, file$s, 77, 8, 2856);
    			attr_dev(div1, "class", "uk-width-1-1");
    			add_location(div1, file$s, 83, 8, 3047);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(toggleminer, div0, null);
    			append_dev(div0, t0);
    			mount_component(minerprogress, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const minerprogress_changes = {};
    			if (dirty & /*minerTower*/ 64) minerprogress_changes.tower = /*minerTower*/ ctx[6];
    			minerprogress.$set(minerprogress_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggleminer.$$.fragment, local);
    			transition_in(minerprogress.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggleminer.$$.fragment, local);
    			transition_out(minerprogress.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(toggleminer);
    			destroy_component(minerprogress);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(74:6) {#if (account && account.on_chain) ||             // so we don't get a flash of the error card on an intermittent local network connection if we are in fact mining            (minerTower && minerTower.progress.pct_complete)       }",
    		ctx
    	});

    	return block;
    }

    // (87:10) {:else}
    function create_else_block$7(ctx) {
    	let div2;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let towerstate;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*isSendInProgress*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	towerstate = new TowerState({
    			props: { minerTower: /*minerTower*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			create_component(towerstate.$$.fragment);
    			attr_dev(div0, "class", "uk-width-1-3");
    			add_location(div0, file$s, 88, 14, 3219);
    			attr_dev(div1, "class", "uk-width-2-3");
    			add_location(div1, file$s, 95, 14, 3491);
    			attr_dev(div2, "class", "uk-grid uk-grid-match");
    			add_location(div2, file$s, 87, 12, 3169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			mount_component(towerstate, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const towerstate_changes = {};
    			if (dirty & /*minerTower*/ 64) towerstate_changes.minerTower = /*minerTower*/ ctx[6];
    			towerstate.$set(towerstate_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(towerstate.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(towerstate.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_component(towerstate);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(87:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:10) {#if newbie && !hasProofs }
    function create_if_block_1$5(ctx) {
    	let firstproof;
    	let current;
    	firstproof = new FirstProof({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(firstproof.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(firstproof, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(firstproof.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(firstproof.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(firstproof, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(85:10) {#if newbie && !hasProofs }",
    		ctx
    	});

    	return block;
    }

    // (92:16) {:else}
    function create_else_block_1$2(ctx) {
    	let epochstatus;
    	let current;

    	epochstatus = new EpochStatus({
    			props: {
    				minerTower: /*minerTower*/ ctx[6],
    				isTowerNewbie: /*newbie*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(epochstatus.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(epochstatus, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const epochstatus_changes = {};
    			if (dirty & /*minerTower*/ 64) epochstatus_changes.minerTower = /*minerTower*/ ctx[6];
    			if (dirty & /*newbie*/ 1) epochstatus_changes.isTowerNewbie = /*newbie*/ ctx[0];
    			epochstatus.$set(epochstatus_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(epochstatus.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(epochstatus.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(epochstatus, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(92:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (90:16) {#if isSendInProgress}
    function create_if_block_2$2(ctx) {
    	let syncproofs;
    	let current;

    	syncproofs = new SyncProofs({
    			props: {
    				minerTower: /*minerTower*/ ctx[6],
    				loading: /*loading*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(syncproofs.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(syncproofs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const syncproofs_changes = {};
    			if (dirty & /*minerTower*/ 64) syncproofs_changes.minerTower = /*minerTower*/ ctx[6];
    			if (dirty & /*loading*/ 2) syncproofs_changes.loading = /*loading*/ ctx[1];
    			syncproofs.$set(syncproofs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(syncproofs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(syncproofs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(syncproofs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(90:16) {#if isSendInProgress}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let main;
    	let t0;
    	let div0;
    	let h2;
    	let t1_value = /*$_*/ ctx[7]("miner.title") + "";
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let commonerrors;
    	let t5;
    	let minerdebug;
    	let current;
    	let if_block0 = /*loading*/ ctx[1] && create_if_block_5(ctx);
    	let if_block1 = /*isDevTest*/ ctx[3] && create_if_block_4(ctx);
    	const if_block_creators = [create_if_block$c, create_if_block_3$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*account*/ ctx[2] && /*account*/ ctx[2].on_chain || // so we don't get a flash of the error card on an intermittent local network connection if we are in fact mining
    		/*minerTower*/ ctx[6] && /*minerTower*/ ctx[6].progress.pct_complete) return 0;

    		if (/*account*/ ctx[2]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	commonerrors = new CommonErrors({ $$inline: true });

    	minerdebug = new MinerDebug({
    			props: { minerTower: /*minerTower*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			h2 = element("h2");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div1 = element("div");
    			if (if_block2) if_block2.c();
    			t4 = space();
    			create_component(commonerrors.$$.fragment);
    			t5 = space();
    			create_component(minerdebug.$$.fragment);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$s, 60, 4, 2264);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$s, 59, 2, 2223);
    			attr_dev(div1, "class", "uk-grid uk-margin-small");
    			add_location(div1, file$s, 72, 4, 2571);
    			attr_dev(main, "class", "uk-height-viewport");
    			add_location(main, file$s, 53, 0, 2044);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t0);
    			append_dev(main, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t1);
    			append_dev(main, t2);
    			if (if_block1) if_block1.m(main, null);
    			append_dev(main, t3);
    			append_dev(main, div1);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div1, null);
    			}

    			append_dev(main, t4);
    			mount_component(commonerrors, main, null);
    			append_dev(main, t5);
    			mount_component(minerdebug, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loading*/ ctx[1]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					if_block0.m(main, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || dirty & /*$_*/ 128) && t1_value !== (t1_value = /*$_*/ ctx[7]("miner.title") + "")) set_data_dev(t1, t1_value);

    			if (/*isDevTest*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(main, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block2) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block2 = if_blocks[current_block_type_index];

    					if (!if_block2) {
    						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block2.c();
    					} else {
    						if_block2.p(ctx, dirty);
    					}

    					transition_in(if_block2, 1);
    					if_block2.m(div1, null);
    				} else {
    					if_block2 = null;
    				}
    			}

    			const minerdebug_changes = {};
    			if (dirty & /*minerTower*/ 64) minerdebug_changes.minerTower = /*minerTower*/ ctx[6];
    			minerdebug.$set(minerdebug_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			transition_in(commonerrors.$$.fragment, local);
    			transition_in(minerdebug.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			transition_out(commonerrors.$$.fragment, local);
    			transition_out(minerdebug.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			destroy_component(commonerrors);
    			destroy_component(minerdebug);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(7, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Miner', slots, []);
    	let newbie = false;
    	let loading = true;
    	let account;
    	let isDevTest = false;
    	let isSendInProgress = false;
    	let hasProofs = false;
    	let minerTower;

    	// unsubscribe functions
    	let unsubsTower;

    	let unsubsIsTowerNewbie;
    	let unsubsBacklogInProgress;
    	let unsubsSigningAccount;
    	let unsubsIsRefreshingAccounts;
    	let unsubsIsDevTest;

    	onMount(async () => {
    		getTowerChainView();

    		unsubsTower = tower.subscribe(t => {
    			$$invalidate(6, minerTower = t);
    			$$invalidate(5, hasProofs = minerTower.last_local_proof ? true : false);
    		});

    		unsubsIsTowerNewbie = isTowerNewbie.subscribe(b => $$invalidate(0, newbie = b));
    		unsubsBacklogInProgress = backlogInProgress.subscribe(b => $$invalidate(4, isSendInProgress = b));
    		unsubsSigningAccount = signingAccount.subscribe(a => $$invalidate(2, account = a));
    		unsubsIsRefreshingAccounts = isRefreshingAccounts.subscribe(a => $$invalidate(1, loading = a));
    		unsubsIsDevTest = $$invalidate(3, isDevTest = get_store_value(nodeEnv) == "test");
    	});

    	onDestroy(async () => {
    		unsubsTower && unsubsTower();
    		unsubsIsTowerNewbie && unsubsIsTowerNewbie();
    		unsubsBacklogInProgress && unsubsBacklogInProgress();
    		unsubsSigningAccount && unsubsSigningAccount();
    		unsubsIsRefreshingAccounts && unsubsIsRefreshingAccounts();
    		unsubsIsDevTest && unsubsIsDevTest();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Miner> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		ToggleMiner,
    		MinerProgress,
    		TowerState,
    		MinerDebug,
    		CantStart,
    		isRefreshingAccounts,
    		signingAccount,
    		FirstProof,
    		backlogInProgress,
    		isTowerNewbie,
    		tower,
    		nodeEnv,
    		get: get_store_value,
    		SyncProofs,
    		CommonErrors,
    		getTowerChainView,
    		EpochStatus,
    		_: $format,
    		newbie,
    		loading,
    		account,
    		isDevTest,
    		isSendInProgress,
    		hasProofs,
    		minerTower,
    		unsubsTower,
    		unsubsIsTowerNewbie,
    		unsubsBacklogInProgress,
    		unsubsSigningAccount,
    		unsubsIsRefreshingAccounts,
    		unsubsIsDevTest,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('newbie' in $$props) $$invalidate(0, newbie = $$props.newbie);
    		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
    		if ('account' in $$props) $$invalidate(2, account = $$props.account);
    		if ('isDevTest' in $$props) $$invalidate(3, isDevTest = $$props.isDevTest);
    		if ('isSendInProgress' in $$props) $$invalidate(4, isSendInProgress = $$props.isSendInProgress);
    		if ('hasProofs' in $$props) $$invalidate(5, hasProofs = $$props.hasProofs);
    		if ('minerTower' in $$props) $$invalidate(6, minerTower = $$props.minerTower);
    		if ('unsubsTower' in $$props) unsubsTower = $$props.unsubsTower;
    		if ('unsubsIsTowerNewbie' in $$props) unsubsIsTowerNewbie = $$props.unsubsIsTowerNewbie;
    		if ('unsubsBacklogInProgress' in $$props) unsubsBacklogInProgress = $$props.unsubsBacklogInProgress;
    		if ('unsubsSigningAccount' in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ('unsubsIsRefreshingAccounts' in $$props) unsubsIsRefreshingAccounts = $$props.unsubsIsRefreshingAccounts;
    		if ('unsubsIsDevTest' in $$props) unsubsIsDevTest = $$props.unsubsIsDevTest;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		newbie,
    		loading,
    		account,
    		isDevTest,
    		isSendInProgress,
    		hasProofs,
    		minerTower,
    		$_
    	];
    }

    class Miner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Miner",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/components/settings/AccountSettings.svelte generated by Svelte v3.59.2 */
    const file$r = "src/components/settings/AccountSettings.svelte";

    function create_fragment$r(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[0]("settings.account_settings.title") + "";
    	let t0;
    	let t1;
    	let div4;
    	let div2;
    	let div1;
    	let button0;
    	let t2_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "";
    	let t2;
    	let t3;
    	let div0;
    	let p;
    	let t4_value = /*$_*/ ctx[0]("settings.account_settings.confirm") + "";
    	let t4;
    	let t5;
    	let button1;
    	let t6_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "";
    	let t6;
    	let t7;
    	let div3;
    	let span;
    	let t8_value = /*$_*/ ctx[0]("settings.account_settings.description") + "";
    	let t8;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");
    			p = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			button1 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			span = element("span");
    			t8 = text(t8_value);
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$r, 20, 2, 628);
    			attr_dev(button0, "class", "uk-button uk-button-danger");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$r, 28, 4, 830);
    			add_location(p, file$r, 30, 10, 989);
    			attr_dev(button1, "class", "uk-button uk-button-danger");
    			add_location(button1, file$r, 31, 10, 1048);
    			attr_dev(div0, "uk-dropdown", "mode: click");
    			add_location(div0, file$r, 29, 6, 947);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$r, 27, 4, 802);
    			add_location(div2, file$r, 25, 4, 791);
    			add_location(span, file$r, 39, 6, 1247);
    			add_location(div3, file$r, 38, 4, 1235);
    			attr_dev(div4, "class", "uk-margin");
    			attr_dev(div4, "uk-grid", "");
    			add_location(div4, file$r, 24, 2, 755);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$r, 19, 0, 600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(button0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t4);
    			append_dev(div0, t5);
    			append_dev(div0, button1);
    			append_dev(button1, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, span);
    			append_dev(span, t8);

    			if (!mounted) {
    				dispose = listen_dev(button1, "click", /*removeAccounts*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("settings.account_settings.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("settings.account_settings.confirm") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("settings.account_settings.btn_remove") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 1 && t8_value !== (t8_value = /*$_*/ ctx[0]("settings.account_settings.description") + "")) set_data_dev(t8, t8_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountSettings', slots, []);

    	const removeAccounts = async () => {
    		i$1("remove_accounts", {}).then(res => {
    			responses.set(res);
    			notify_success("accounts removed successfully");
    			loadAccounts();
    		}).catch(e => {
    			raise_error(e, false, "removeAccounts");
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountSettings> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		_: $format,
    		loadAccounts,
    		raise_error,
    		notify_success,
    		responses,
    		removeAccounts,
    		$_
    	});

    	return [$_, removeAccounts];
    }

    class AccountSettings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountSettings",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src/components/settings/UpdateNetwork.svelte generated by Svelte v3.59.2 */
    const file$q = "src/components/settings/UpdateNetwork.svelte";

    function create_fragment$q(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[2]("settings.network_settings.title") + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let h50;
    	let t4_value = /*$_*/ ctx[2]("settings.network_settings.list_of_peers") + "";
    	let t4;
    	let t5;
    	let p0;
    	let t6_value = /*$_*/ ctx[2]("settings.network_settings.description") + "";
    	let t6;
    	let t7;
    	let setnetworkplaylist;
    	let t8;
    	let h51;
    	let t9_value = /*$_*/ ctx[2]("settings.network_settings.override_peers") + "";
    	let t9;
    	let t10;
    	let p1;
    	let t11_value = /*$_*/ ctx[2]("settings.network_settings.override_peers_description") + "";
    	let t11;
    	let t12;
    	let form;
    	let fieldset;
    	let div;
    	let span0;
    	let t13_value = /*$_*/ ctx[2]("settings.network_settings.url_of_upstream_node") + "";
    	let t13;
    	let t14;
    	let input;
    	let t15;
    	let span1;
    	let t16_value = /*$_*/ ctx[2]("settings.network_settings.btn_update") + "";
    	let t16;
    	let t17;
    	let h52;
    	let t18_value = /*$_*/ ctx[2]("settings.network_settings.upstream_title") + "";
    	let t18;
    	let t19;
    	let p2;
    	let t20_value = /*$_*/ ctx[2]("settings.network_settings.upstream_subtitle") + "";
    	let t20;
    	let t21;
    	let button;
    	let t22_value = /*$_*/ ctx[2]("settings.network_settings.btn_fetch_new_waypoint") + "";
    	let t22;
    	let current;
    	let mounted;
    	let dispose;
    	setnetworkplaylist = new SetNetworkPlaylist({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(/*current_chain_id*/ ctx[1]);
    			t3 = space();
    			h50 = element("h5");
    			t4 = text(t4_value);
    			t5 = space();
    			p0 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(setnetworkplaylist.$$.fragment);
    			t8 = space();
    			h51 = element("h5");
    			t9 = text(t9_value);
    			t10 = space();
    			p1 = element("p");
    			t11 = text(t11_value);
    			t12 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div = element("div");
    			span0 = element("span");
    			t13 = text(t13_value);
    			t14 = space();
    			input = element("input");
    			t15 = space();
    			span1 = element("span");
    			t16 = text(t16_value);
    			t17 = space();
    			h52 = element("h5");
    			t18 = text(t18_value);
    			t19 = space();
    			p2 = element("p");
    			t20 = text(t20_value);
    			t21 = space();
    			button = element("button");
    			t22 = text(t22_value);
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$q, 31, 2, 1017);
    			attr_dev(h50, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h50, file$q, 33, 2, 1156);
    			add_location(p0, file$q, 34, 2, 1284);
    			attr_dev(h51, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h51, file$q, 37, 2, 1367);
    			add_location(p1, file$q, 38, 2, 1494);
    			add_location(span0, file$q, 43, 8, 1692);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "http://1.1.1.1:8080");
    			add_location(input, file$q, 44, 8, 1768);
    			attr_dev(div, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div, file$q, 42, 6, 1631);
    			attr_dev(span1, "class", "uk-button uk-button-primary uk-align-right");
    			attr_dev(span1, "id", "add-btn");
    			add_location(span1, file$q, 52, 6, 1935);
    			attr_dev(h52, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h52, file$q, 58, 6, 2128);
    			add_location(p2, file$q, 59, 6, 2259);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$q, 60, 6, 2324);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$q, 41, 4, 1594);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$q, 40, 2, 1565);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$q, 30, 0, 990);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, t2);
    			append_dev(main, t3);
    			append_dev(main, h50);
    			append_dev(h50, t4);
    			append_dev(main, t5);
    			append_dev(main, p0);
    			append_dev(p0, t6);
    			append_dev(main, t7);
    			mount_component(setnetworkplaylist, main, null);
    			append_dev(main, t8);
    			append_dev(main, h51);
    			append_dev(h51, t9);
    			append_dev(main, t10);
    			append_dev(main, p1);
    			append_dev(p1, t11);
    			append_dev(main, t12);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div);
    			append_dev(div, span0);
    			append_dev(span0, t13);
    			append_dev(div, t14);
    			append_dev(div, input);
    			set_input_value(input, /*upstream_url*/ ctx[0]);
    			append_dev(fieldset, t15);
    			append_dev(fieldset, span1);
    			append_dev(span1, t16);
    			append_dev(fieldset, t17);
    			append_dev(fieldset, h52);
    			append_dev(h52, t18);
    			append_dev(fieldset, t19);
    			append_dev(fieldset, p2);
    			append_dev(p2, t20);
    			append_dev(fieldset, t21);
    			append_dev(fieldset, button);
    			append_dev(button, t22);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
    					listen_dev(span1, "click", /*forceUpstream*/ ctx[3], false, false, false, false),
    					listen_dev(button, "click", refreshWaypoint, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 4) && t0_value !== (t0_value = /*$_*/ ctx[2]("settings.network_settings.title") + "")) set_data_dev(t0, t0_value);
    			if (!current || dirty & /*current_chain_id*/ 2) set_data_dev(t2, /*current_chain_id*/ ctx[1]);
    			if ((!current || dirty & /*$_*/ 4) && t4_value !== (t4_value = /*$_*/ ctx[2]("settings.network_settings.list_of_peers") + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty & /*$_*/ 4) && t6_value !== (t6_value = /*$_*/ ctx[2]("settings.network_settings.description") + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*$_*/ 4) && t9_value !== (t9_value = /*$_*/ ctx[2]("settings.network_settings.override_peers") + "")) set_data_dev(t9, t9_value);
    			if ((!current || dirty & /*$_*/ 4) && t11_value !== (t11_value = /*$_*/ ctx[2]("settings.network_settings.override_peers_description") + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*$_*/ 4) && t13_value !== (t13_value = /*$_*/ ctx[2]("settings.network_settings.url_of_upstream_node") + "")) set_data_dev(t13, t13_value);

    			if (dirty & /*upstream_url*/ 1 && input.value !== /*upstream_url*/ ctx[0]) {
    				set_input_value(input, /*upstream_url*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 4) && t16_value !== (t16_value = /*$_*/ ctx[2]("settings.network_settings.btn_update") + "")) set_data_dev(t16, t16_value);
    			if ((!current || dirty & /*$_*/ 4) && t18_value !== (t18_value = /*$_*/ ctx[2]("settings.network_settings.upstream_title") + "")) set_data_dev(t18, t18_value);
    			if ((!current || dirty & /*$_*/ 4) && t20_value !== (t20_value = /*$_*/ ctx[2]("settings.network_settings.upstream_subtitle") + "")) set_data_dev(t20, t20_value);
    			if ((!current || dirty & /*$_*/ 4) && t22_value !== (t22_value = /*$_*/ ctx[2]("settings.network_settings.btn_fetch_new_waypoint") + "")) set_data_dev(t22, t22_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(setnetworkplaylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(setnetworkplaylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(setnetworkplaylist);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpdateNetwork', slots, []);
    	let upstream_url = "";
    	let current_chain_id = "";

    	onMount(async () => {
    		getNetwork();

    		network_profile.subscribe(n => {
    			$$invalidate(0, upstream_url = n.urls.length == 1 ? n.urls[0] : ""); // just used to show OVERRIDE PEERS url
    			$$invalidate(1, current_chain_id = n.chain_id);
    		});
    	});

    	function forceUpstream() {
    		// check input data
    		// submit
    		i$1("force_upstream", { url: upstream_url }).then(res => {
    			network_profile.set(res);
    			notify_success("Network Settings Updated");
    		}).catch(error => {
    			raise_error(error, false, "forceUpstream");
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UpdateNetwork> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		upstream_url = this.value;
    		$$invalidate(0, upstream_url);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		raise_error,
    		network_profile,
    		getNetwork,
    		refreshWaypoint,
    		invoke: i$1,
    		notify_success,
    		SetNetworkPlaylist,
    		_: $format,
    		upstream_url,
    		current_chain_id,
    		forceUpstream,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('upstream_url' in $$props) $$invalidate(0, upstream_url = $$props.upstream_url);
    		if ('current_chain_id' in $$props) $$invalidate(1, current_chain_id = $$props.current_chain_id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [upstream_url, current_chain_id, $_, forceUpstream, input_input_handler];
    }

    class UpdateNetwork extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpdateNetwork",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src/components/settings/LangAppearanceSettings.svelte generated by Svelte v3.59.2 */
    const file$p = "src/components/settings/LangAppearanceSettings.svelte";

    function create_fragment$p(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[0]("settings.langapp_settings.title") + "";
    	let t0;
    	let t1;
    	let form;
    	let fieldset;
    	let h5;
    	let t2_value = /*$_*/ ctx[0]("settings.langapp_settings.lang") + "";
    	let t2;
    	let t3;
    	let p;
    	let t4_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_description") + "";
    	let t4;
    	let t5;
    	let button;
    	let t6_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_button") + "";
    	let t6;
    	let t7;
    	let div;
    	let ul;
    	let li0;
    	let a0;
    	let t9;
    	let li1;
    	let a1;
    	let t11;
    	let li2;
    	let a2;
    	let t13;
    	let li3;
    	let a3;
    	let t15;
    	let li4;
    	let a4;
    	let t17;
    	let li5;
    	let a5;
    	let t19;
    	let li6;
    	let a6;
    	let t21;
    	let li7;
    	let a7;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			h5 = element("h5");
    			t2 = text(t2_value);
    			t3 = space();
    			p = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			button = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "English";
    			t9 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "中文";
    			t11 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "French";
    			t13 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "German";
    			t15 = space();
    			li4 = element("li");
    			a4 = element("a");
    			a4.textContent = "Spanish";
    			t17 = space();
    			li5 = element("li");
    			a5 = element("a");
    			a5.textContent = "Italian";
    			t19 = space();
    			li6 = element("li");
    			a6 = element("a");
    			a6.textContent = "Portuguese";
    			t21 = space();
    			li7 = element("li");
    			a7 = element("a");
    			a7.textContent = "Arabic";
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$p, 5, 2, 140);
    			attr_dev(h5, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h5, file$p, 9, 6, 328);
    			add_location(p, file$p, 10, 6, 451);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$p, 11, 6, 515);
    			attr_dev(a0, "class", "uk-text-muted");
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$p, 14, 14, 724);
    			add_location(li0, file$p, 14, 10, 720);
    			attr_dev(a1, "class", "uk-text-muted");
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$p, 15, 14, 824);
    			add_location(li1, file$p, 15, 10, 820);
    			attr_dev(a2, "class", "uk-text-muted");
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$p, 16, 14, 922);
    			add_location(li2, file$p, 16, 10, 918);
    			attr_dev(a3, "class", "uk-text-muted");
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$p, 17, 14, 1021);
    			add_location(li3, file$p, 17, 10, 1017);
    			attr_dev(a4, "class", "uk-text-muted");
    			attr_dev(a4, "href", "#");
    			add_location(a4, file$p, 18, 14, 1120);
    			add_location(li4, file$p, 18, 10, 1116);
    			attr_dev(a5, "class", "uk-text-muted");
    			attr_dev(a5, "href", "#");
    			add_location(a5, file$p, 19, 14, 1220);
    			add_location(li5, file$p, 19, 10, 1216);
    			attr_dev(a6, "class", "uk-text-muted");
    			attr_dev(a6, "href", "#");
    			add_location(a6, file$p, 20, 14, 1320);
    			add_location(li6, file$p, 20, 10, 1316);
    			attr_dev(a7, "class", "uk-text-muted");
    			attr_dev(a7, "href", "#");
    			add_location(a7, file$p, 21, 14, 1423);
    			add_location(li7, file$p, 21, 10, 1419);
    			attr_dev(ul, "class", "uk-nav uk-dropdown-nav");
    			add_location(ul, file$p, 13, 8, 674);
    			attr_dev(div, "uk-dropdown", "mode: click");
    			add_location(div, file$p, 12, 6, 634);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$p, 8, 4, 291);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$p, 7, 2, 262);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$p, 4, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, h5);
    			append_dev(h5, t2);
    			append_dev(fieldset, t3);
    			append_dev(fieldset, p);
    			append_dev(p, t4);
    			append_dev(fieldset, t5);
    			append_dev(fieldset, button);
    			append_dev(button, t6);
    			append_dev(fieldset, t7);
    			append_dev(fieldset, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(ul, t9);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(ul, t11);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(ul, t13);
    			append_dev(ul, li3);
    			append_dev(li3, a3);
    			append_dev(ul, t15);
    			append_dev(ul, li4);
    			append_dev(li4, a4);
    			append_dev(ul, t17);
    			append_dev(ul, li5);
    			append_dev(li5, a5);
    			append_dev(ul, t19);
    			append_dev(ul, li6);
    			append_dev(li6, a6);
    			append_dev(ul, t21);
    			append_dev(ul, li7);
    			append_dev(li7, a7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(a2, "click", /*click_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(a3, "click", /*click_handler_3*/ ctx[4], false, false, false, false),
    					listen_dev(a4, "click", /*click_handler_4*/ ctx[5], false, false, false, false),
    					listen_dev(a5, "click", /*click_handler_5*/ ctx[6], false, false, false, false),
    					listen_dev(a6, "click", /*click_handler_6*/ ctx[7], false, false, false, false),
    					listen_dev(a7, "click", /*click_handler_7*/ ctx[8], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("settings.langapp_settings.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("settings.langapp_settings.lang") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_description") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("settings.langapp_settings.lang_button") + "")) set_data_dev(t6, t6_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LangAppearanceSettings', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LangAppearanceSettings> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setLocale("en");
    	const click_handler_1 = () => setLocale("zh_cn");
    	const click_handler_2 = () => setLocale("fr");
    	const click_handler_3 = () => setLocale("de");
    	const click_handler_4 = () => setLocale("es");
    	const click_handler_5 = () => setLocale("it");
    	const click_handler_6 = () => setLocale("pt");
    	const click_handler_7 = () => setLocale("ar");
    	$$self.$capture_state = () => ({ _: $format, setLocale, $_ });

    	return [
    		$_,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7
    	];
    }

    class LangAppearanceSettings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LangAppearanceSettings",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src/components/txs/SetWalletType.svelte generated by Svelte v3.59.2 */
    const file$o = "src/components/txs/SetWalletType.svelte";

    // (52:6) {#if loading}
    function create_if_block$b(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			add_location(span, file$o, 53, 10, 1975);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$o, 52, 8, 1928);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(52:6) {#if loading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let main;
    	let h4;
    	let t0_value = /*$_*/ ctx[1]("txs.set_wallet_type.title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[1]("txs.set_wallet_type.subtitle") + "";
    	let t2;
    	let t3;
    	let div4;
    	let div1;
    	let button0;
    	let t4_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_slow") + "";
    	let t4;
    	let button0_disabled_value;
    	let t5;
    	let div0;
    	let p1;
    	let t6_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_slow") + "";
    	let t6;
    	let t7;
    	let button1;
    	let t8_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_slow") + "";
    	let t8;
    	let t9;
    	let div3;
    	let button2;
    	let t10_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_community") + "";
    	let t10;
    	let button2_disabled_value;
    	let t11;
    	let div2;
    	let p2;
    	let t12_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_community") + "";
    	let t12;
    	let t13;
    	let button3;
    	let t14_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_community") + "";
    	let t14;
    	let t15;
    	let mounted;
    	let dispose;
    	let if_block = /*loading*/ ctx[0] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			div4 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			t4 = text(t4_value);
    			t5 = space();
    			div0 = element("div");
    			p1 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			button2 = element("button");
    			t10 = text(t10_value);
    			t11 = space();
    			div2 = element("div");
    			p2 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			button3 = element("button");
    			t14 = text(t14_value);
    			t15 = space();
    			if (if_block) if_block.c();
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$o, 25, 2, 736);
    			add_location(p0, file$o, 27, 2, 853);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			button0.disabled = button0_disabled_value = /*loading*/ ctx[0] ? true : false;
    			add_location(button0, file$o, 30, 4, 938);
    			add_location(p1, file$o, 32, 12, 1143);
    			attr_dev(button1, "class", "uk-button uk-button-danger");
    			add_location(button1, file$o, 33, 12, 1203);
    			attr_dev(div0, "class", "send-drop");
    			attr_dev(div0, "uk-dropdown", "mode: click");
    			add_location(div0, file$o, 31, 6, 1081);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$o, 29, 4, 910);
    			attr_dev(button2, "class", "uk-button uk-button-default");
    			attr_dev(button2, "type", "button");
    			button2.disabled = button2_disabled_value = /*loading*/ ctx[0] ? true : false;
    			add_location(button2, file$o, 41, 4, 1427);
    			add_location(p2, file$o, 43, 12, 1637);
    			attr_dev(button3, "class", "uk-button uk-button-danger");
    			add_location(button3, file$o, 44, 12, 1702);
    			attr_dev(div2, "class", "send-drop");
    			attr_dev(div2, "uk-dropdown", "mode: click");
    			add_location(div2, file$o, 42, 6, 1575);
    			attr_dev(div3, "class", "uk-inline");
    			add_location(div3, file$o, 40, 4, 1399);
    			add_location(div4, file$o, 28, 2, 900);
    			attr_dev(main, "class", "uk-margin");
    			add_location(main, file$o, 24, 0, 709);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(h4, t0);
    			append_dev(main, t1);
    			append_dev(main, p0);
    			append_dev(p0, t2);
    			append_dev(main, t3);
    			append_dev(main, div4);
    			append_dev(div4, div1);
    			append_dev(div1, button0);
    			append_dev(button0, t4);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			append_dev(div0, p1);
    			append_dev(p1, t6);
    			append_dev(div0, t7);
    			append_dev(div0, button1);
    			append_dev(button1, t8);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, button2);
    			append_dev(button2, t10);
    			append_dev(div3, t11);
    			append_dev(div3, div2);
    			append_dev(div2, p2);
    			append_dev(p2, t12);
    			append_dev(div2, t13);
    			append_dev(div2, button3);
    			append_dev(button3, t14);
    			append_dev(div4, t15);
    			if (if_block) if_block.m(div4, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button1, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_1*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("txs.set_wallet_type.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("txs.set_wallet_type.subtitle") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 2 && t4_value !== (t4_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_slow") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*loading*/ 1 && button0_disabled_value !== (button0_disabled_value = /*loading*/ ctx[0] ? true : false)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (dirty & /*$_*/ 2 && t6_value !== (t6_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_slow") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 2 && t8_value !== (t8_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_slow") + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*$_*/ 2 && t10_value !== (t10_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_community") + "")) set_data_dev(t10, t10_value);

    			if (dirty & /*loading*/ 1 && button2_disabled_value !== (button2_disabled_value = /*loading*/ ctx[0] ? true : false)) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (dirty & /*$_*/ 2 && t12_value !== (t12_value = /*$_*/ ctx[1]("txs.set_wallet_type.confirm_community") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$_*/ 2 && t14_value !== (t14_value = /*$_*/ ctx[1]("txs.set_wallet_type.btn_confirm_community") + "")) set_data_dev(t14, t14_value);

    			if (/*loading*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(div4, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SetWalletType', slots, []);
    	let loading = false;

    	function setWallet(num) {
    		$$invalidate(0, loading = true);

    		i$1("wallet_type", { typeInt: num }).then(res => {
    			$$invalidate(0, loading = false);
    			notify_success("Account set to Slow Wallet");
    			responses.set(res);
    		}).catch(e => {
    			$$invalidate(0, loading = false);
    			raise_error(e, false, "setWallet");
    		});

    		uikit.dropdown(document.getElementsByClassName("send-drop")).hide(500);
    	}
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SetWalletType> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setWallet(0);
    	const click_handler_1 = () => setWallet(1);

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		raise_error,
    		notify_success,
    		responses,
    		UIkit: uikit,
    		_: $format,
    		loading,
    		setWallet,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loading, $_, setWallet, click_handler, click_handler_1];
    }

    class SetWalletType extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SetWalletType",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src/components/settings/Settings.svelte generated by Svelte v3.59.2 */
    const file$n = "src/components/settings/Settings.svelte";

    function create_fragment$n(ctx) {
    	let main;
    	let div;
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("settings.title") + "";
    	let t0;
    	let t1;
    	let langappearancesettings;
    	let t2;
    	let updatenetwork;
    	let t3;
    	let accountsettings;
    	let t4;
    	let minerbacklog;
    	let t5;
    	let setwallettype;
    	let current;
    	langappearancesettings = new LangAppearanceSettings({ $$inline: true });
    	updatenetwork = new UpdateNetwork({ $$inline: true });
    	accountsettings = new AccountSettings({ $$inline: true });
    	minerbacklog = new MinerBacklog({ $$inline: true });
    	setwallettype = new SetWalletType({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(langappearancesettings.$$.fragment);
    			t2 = space();
    			create_component(updatenetwork.$$.fragment);
    			t3 = space();
    			create_component(accountsettings.$$.fragment);
    			t4 = space();
    			create_component(minerbacklog.$$.fragment);
    			t5 = space();
    			create_component(setwallettype.$$.fragment);
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$n, 10, 4, 404);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$n, 9, 2, 363);
    			add_location(main, file$n, 8, 0, 354);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			mount_component(langappearancesettings, main, null);
    			append_dev(main, t2);
    			mount_component(updatenetwork, main, null);
    			append_dev(main, t3);
    			mount_component(accountsettings, main, null);
    			append_dev(main, t4);
    			mount_component(minerbacklog, main, null);
    			append_dev(main, t5);
    			mount_component(setwallettype, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("settings.title") + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(langappearancesettings.$$.fragment, local);
    			transition_in(updatenetwork.$$.fragment, local);
    			transition_in(accountsettings.$$.fragment, local);
    			transition_in(minerbacklog.$$.fragment, local);
    			transition_in(setwallettype.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(langappearancesettings.$$.fragment, local);
    			transition_out(updatenetwork.$$.fragment, local);
    			transition_out(accountsettings.$$.fragment, local);
    			transition_out(minerbacklog.$$.fragment, local);
    			transition_out(setwallettype.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(langappearancesettings);
    			destroy_component(updatenetwork);
    			destroy_component(accountsettings);
    			destroy_component(minerbacklog);
    			destroy_component(setwallettype);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Settings', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		MinerBacklog,
    		AccountSettings,
    		UpdateNetwork,
    		LangAppearanceSettings,
    		SetWalletType,
    		_: $format,
    		$_
    	});

    	return [$_];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src/components/txs/DemoTx.svelte generated by Svelte v3.59.2 */
    const file$m = "src/components/txs/DemoTx.svelte";

    function create_fragment$m(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Demo Tx";
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$m, 23, 2, 535);
    			attr_dev(div, "class", "uk-margin-medium-bottom");
    			add_location(div, file$m, 22, 0, 495);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*demoTx*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DemoTx', slots, []);
    	let account_string = "";

    	signingAccount.subscribe(n => {
    		account_string = n.account;
    	});

    	const demoTx = async () => {
    		i$1("demo_tx", {}).then(res => {
    			responses.set(res);
    		}).catch(e => {
    			raise_error(e);
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DemoTx> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		signingAccount,
    		raise_error,
    		responses,
    		account_string,
    		demoTx
    	});

    	$$self.$inject_state = $$props => {
    		if ('account_string' in $$props) account_string = $$props.account_string;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [demoTx];
    }

    class DemoTx extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DemoTx",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src/components/dev/DebugActions.svelte generated by Svelte v3.59.2 */

    const { console: console_1$5 } = globals;
    const file$l = "src/components/dev/DebugActions.svelte";

    function create_fragment$l(ctx) {
    	let main;
    	let div4;
    	let div0;
    	let h40;
    	let t1;
    	let button0;
    	let t3;
    	let button1;
    	let t5;
    	let button2;
    	let t7;
    	let button3;
    	let t9;
    	let div1;
    	let h41;
    	let t11;
    	let button4;
    	let t13;
    	let button5;
    	let t15;
    	let button6;
    	let t17;
    	let div2;
    	let h42;
    	let t19;
    	let button7;
    	let t21;
    	let button8;
    	let t23;
    	let button9;
    	let t25;
    	let div3;
    	let button10;
    	let t27;
    	let demotx;
    	let current;
    	let mounted;
    	let dispose;
    	demotx = new DemoTx({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div4 = element("div");
    			div0 = element("div");
    			h40 = element("h4");
    			h40.textContent = "Helpers";
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Make Error";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Receive Event";
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = "Start Listener";
    			t7 = space();
    			button3 = element("button");
    			button3.textContent = "Send Event";
    			t9 = space();
    			div1 = element("div");
    			h41 = element("h4");
    			h41.textContent = "Tower";
    			t11 = space();
    			button4 = element("button");
    			button4.textContent = "Start Mock Tower Listener";
    			t13 = space();
    			button5 = element("button");
    			button5.textContent = "Mock Tower Once";
    			t15 = space();
    			button6 = element("button");
    			button6.textContent = "Mock Tower Once Fail";
    			t17 = space();
    			div2 = element("div");
    			h42 = element("h4");
    			h42.textContent = "Tests";
    			t19 = space();
    			button7 = element("button");
    			button7.textContent = "Async";
    			t21 = space();
    			button8 = element("button");
    			button8.textContent = "Start Forever";
    			t23 = space();
    			button9 = element("button");
    			button9.textContent = "Kill Forever";
    			t25 = space();
    			div3 = element("div");
    			button10 = element("button");
    			button10.textContent = "Init";
    			t27 = space();
    			create_component(demotx.$$.fragment);
    			attr_dev(h40, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h40, file$l, 85, 6, 2452);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			add_location(button0, file$l, 86, 6, 2544);
    			attr_dev(button1, "class", "uk-button uk-button-default");
    			add_location(button1, file$l, 87, 6, 2635);
    			attr_dev(button2, "class", "uk-button uk-button-default");
    			add_location(button2, file$l, 88, 6, 2744);
    			attr_dev(button3, "class", "uk-button uk-button-default");
    			add_location(button3, file$l, 89, 6, 2848);
    			attr_dev(div0, "class", "uk-margin-medium-bottom");
    			add_location(div0, file$l, 84, 4, 2408);
    			attr_dev(h41, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h41, file$l, 93, 6, 3007);
    			attr_dev(button4, "class", "uk-button uk-button-default");
    			add_location(button4, file$l, 94, 6, 3097);
    			attr_dev(button5, "class", "uk-button uk-button-default");
    			add_location(button5, file$l, 95, 6, 3217);
    			attr_dev(button6, "class", "uk-button uk-button-default");
    			add_location(button6, file$l, 96, 6, 3317);
    			attr_dev(div1, "class", "uk-margin-medium-bottom");
    			add_location(div1, file$l, 92, 4, 2963);
    			attr_dev(h42, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h42, file$l, 101, 6, 3481);
    			attr_dev(button7, "class", "uk-button uk-button-default");
    			add_location(button7, file$l, 102, 6, 3571);
    			attr_dev(button8, "class", "uk-button uk-button-default");
    			add_location(button8, file$l, 103, 6, 3657);
    			attr_dev(button9, "class", "uk-button uk-button-default");
    			add_location(button9, file$l, 104, 6, 3754);
    			attr_dev(div2, "class", "uk-margin-medium-bottom");
    			add_location(div2, file$l, 100, 4, 3437);
    			attr_dev(button10, "class", "uk-button uk-button-default");
    			add_location(button10, file$l, 108, 6, 3903);
    			attr_dev(div3, "class", "uk-margin-medium-bottom");
    			add_location(div3, file$l, 107, 4, 3859);
    			add_location(div4, file$l, 83, 2, 2398);
    			add_location(main, file$l, 82, 0, 2389);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div4);
    			append_dev(div4, div0);
    			append_dev(div0, h40);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			append_dev(div0, t5);
    			append_dev(div0, button2);
    			append_dev(div0, t7);
    			append_dev(div0, button3);
    			append_dev(div4, t9);
    			append_dev(div4, div1);
    			append_dev(div1, h41);
    			append_dev(div1, t11);
    			append_dev(div1, button4);
    			append_dev(div1, t13);
    			append_dev(div1, button5);
    			append_dev(div1, t15);
    			append_dev(div1, button6);
    			append_dev(div4, t17);
    			append_dev(div4, div2);
    			append_dev(div2, h42);
    			append_dev(div2, t19);
    			append_dev(div2, button7);
    			append_dev(div2, t21);
    			append_dev(div2, button8);
    			append_dev(div2, t23);
    			append_dev(div2, button9);
    			append_dev(div4, t25);
    			append_dev(div4, div3);
    			append_dev(div3, button10);
    			append_dev(div4, t27);
    			mount_component(demotx, div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*makeError*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*triggerEventFromRustToJs*/ ctx[1], false, false, false, false),
    					listen_dev(button2, "click", /*debugStartListener*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*emitEventFromHereToRust*/ ctx[2], false, false, false, false),
    					listen_dev(button4, "click", /*startMockTowerListener*/ ctx[8], false, false, false, false),
    					listen_dev(button5, "click", /*mockTowerOnce*/ ctx[9], false, false, false, false),
    					listen_dev(button6, "click", /*mockTowerOnceFail*/ ctx[10], false, false, false, false),
    					listen_dev(button7, "click", /*testAsync*/ ctx[5], false, false, false, false),
    					listen_dev(button8, "click", /*startForever*/ ctx[6], false, false, false, false),
    					listen_dev(button9, "click", /*killForever*/ ctx[7], false, false, false, false),
    					listen_dev(button10, "click", /*init*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(demotx.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(demotx.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(demotx);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DebugActions', slots, []);

    	const makeError = async () => {
    		i$1("debug_error", { debugErr: false }).then(res => responses.set(res)).catch(e => raise_error(e, false, "makeError"));
    	};

    	const triggerEventFromRustToJs = async () => {
    		i$1("debug_emit_event", {}).then(res => responses.set(res)).catch(e => raise_error(e, false, "triggerEventFromRustToJs"));
    	};

    	function emitEventFromHereToRust() {
    		// emit an event that are only visible to the current window
    		const current = m();

    		current.emit('emit-from-window', 'Tauri is awesome!');
    	}

    	const debugStartListener = async () => {
    		i$1("debug_start_listener", {}).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	};

    	const init = async () => {
    		i$1("init_user", {
    			authkey: authkey_string,
    			account: account_string
    		}).then(res => {
    			responses.set(res); // pathStr: home,
    		}).catch(e => console.error(e));
    	};

    	const testAsync = async () => {
    		i$1("delay_async", {}).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	};

    	const startForever = async () => {
    		i$1("start_forever_task", {}).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	};

    	const killForever = async () => {
    		const current = m();
    		current.emit('kill_forever', 'Tauri is awesome!');
    	};

    	const startMockTowerListener = async () => {
    		console.log("start tower listener");

    		i$1("mock_build_tower", { success: true }).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	};

    	const mockTowerOnce = async () => {
    		const current = m();
    		current.emit('mock-tower-make-proof', 'Tauri is awesome!');
    	};

    	const mockTowerOnceFail = async () => {
    		i$1("mock_build_tower", { success: false }).then(res => {
    			responses.set(res);
    		}).catch(e => console.error(e));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<DebugActions> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		responses,
    		DemoTx,
    		raise_error,
    		getCurrent: m,
    		makeError,
    		triggerEventFromRustToJs,
    		emitEventFromHereToRust,
    		debugStartListener,
    		init,
    		testAsync,
    		startForever,
    		killForever,
    		startMockTowerListener,
    		mockTowerOnce,
    		mockTowerOnceFail
    	});

    	return [
    		makeError,
    		triggerEventFromRustToJs,
    		emitEventFromHereToRust,
    		debugStartListener,
    		init,
    		testAsync,
    		startForever,
    		killForever,
    		startMockTowerListener,
    		mockTowerOnce,
    		mockTowerOnceFail
    	];
    }

    class DebugActions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugActions",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src/components/dev/DebugSwitchProdTest.svelte generated by Svelte v3.59.2 */
    const file$k = "src/components/dev/DebugSwitchProdTest.svelte";

    function create_fragment$k(ctx) {
    	let main;
    	let h4;
    	let t1;
    	let div1;
    	let div0;
    	let label0;
    	let input0;
    	let input0_checked_value;
    	let t2;
    	let t3;
    	let label1;
    	let input1;
    	let input1_checked_value;
    	let t4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			h4 = element("h4");
    			h4.textContent = "Miner Difficulty";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = text(" Prod");
    			t3 = space();
    			label1 = element("label");
    			input1 = element("input");
    			t4 = text(" Test");
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$k, 10, 2, 288);
    			attr_dev(input0, "class", "uk-radio");
    			attr_dev(input0, "type", "radio");
    			attr_dev(input0, "name", "radio2");
    			input0.checked = input0_checked_value = /*current_env*/ ctx[0] == "prod";
    			add_location(input0, file$k, 14, 9, 481);
    			add_location(label0, file$k, 13, 6, 465);
    			attr_dev(input1, "class", "uk-radio");
    			attr_dev(input1, "type", "radio");
    			attr_dev(input1, "name", "radio2");
    			input1.checked = input1_checked_value = /*current_env*/ ctx[0] == "test";
    			add_location(input1, file$k, 23, 9, 709);
    			add_location(label1, file$k, 22, 6, 693);
    			attr_dev(div0, "class", "uk-margin uk-grid-small uk-child-width-auto uk-grid");
    			add_location(div0, file$k, 12, 4, 393);
    			add_location(div1, file$k, 11, 2, 383);
    			add_location(main, file$k, 9, 0, 279);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h4);
    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			append_dev(div0, label0);
    			append_dev(label0, input0);
    			append_dev(label0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, label1);
    			append_dev(label1, input1);
    			append_dev(label1, t4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(input1, "click", /*click_handler_1*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*current_env*/ 1 && input0_checked_value !== (input0_checked_value = /*current_env*/ ctx[0] == "prod")) {
    				prop_dev(input0, "checked", input0_checked_value);
    			}

    			if (dirty & /*current_env*/ 1 && input1_checked_value !== (input1_checked_value = /*current_env*/ ctx[0] == "test")) {
    				prop_dev(input1, "checked", input1_checked_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DebugSwitchProdTest', slots, []);
    	let current_env = "prod";

    	onMount(() => {
    		getEnv(); // TODO: this should be async and awaited
    		nodeEnv.subscribe(env => $$invalidate(0, current_env = env));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DebugSwitchProdTest> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setDebugProdTest("prod");
    	const click_handler_1 = () => setDebugProdTest("test");

    	$$self.$capture_state = () => ({
    		onMount,
    		getEnv,
    		nodeEnv,
    		setDebugProdTest,
    		current_env
    	});

    	$$self.$inject_state = $$props => {
    		if ('current_env' in $$props) $$invalidate(0, current_env = $$props.current_env);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [current_env, click_handler, click_handler_1];
    }

    class DebugSwitchProdTest extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugSwitchProdTest",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src/components/dev/DebugSwitchRexMainnet.svelte generated by Svelte v3.59.2 */
    const file$j = "src/components/dev/DebugSwitchRexMainnet.svelte";

    function create_fragment$j(ctx) {
    	let div2;
    	let h4;
    	let t1;
    	let div0;
    	let label0;
    	let input0;
    	let input0_checked_value;
    	let t2;
    	let t3;
    	let label1;
    	let input1;
    	let input1_checked_value;
    	let t4;
    	let t5;
    	let label2;
    	let input2;
    	let input2_checked_value;
    	let t6;
    	let t7;
    	let h5;
    	let t9;
    	let p;
    	let t11;
    	let div1;
    	let span0;
    	let t13;
    	let input3;
    	let t14;
    	let span1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Network Connection";
    			t1 = space();
    			div0 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t2 = text(" Mainnet");
    			t3 = space();
    			label1 = element("label");
    			input1 = element("input");
    			t4 = text(" Rex (testnet)");
    			t5 = space();
    			label2 = element("label");
    			input2 = element("input");
    			t6 = text(" Swarm (devnet)");
    			t7 = space();
    			h5 = element("h5");
    			h5.textContent = "Override The Waypoint";
    			t9 = space();
    			p = element("p");
    			p.textContent = "You need to know what you are doing here.";
    			t11 = space();
    			div1 = element("div");
    			span0 = element("span");
    			span0.textContent = "Waypoint";
    			t13 = space();
    			input3 = element("input");
    			t14 = space();
    			span1 = element("span");
    			span1.textContent = "Override Waypoint";
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$j, 29, 2, 852);
    			attr_dev(input0, "class", "uk-radio");
    			attr_dev(input0, "type", "radio");
    			attr_dev(input0, "name", "networkCb");
    			input0.checked = input0_checked_value = /*current_chain_id*/ ctx[0] == Networks.MAINNET;
    			add_location(input0, file$j, 34, 7, 1041);
    			add_location(label0, file$j, 33, 4, 1027);
    			attr_dev(input1, "class", "uk-radio");
    			attr_dev(input1, "type", "radio");
    			attr_dev(input1, "name", "networkCb");
    			input1.checked = input1_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTNET;
    			add_location(input1, file$j, 43, 7, 1276);
    			add_location(label1, file$j, 42, 4, 1262);
    			attr_dev(input2, "class", "uk-radio");
    			attr_dev(input2, "type", "radio");
    			attr_dev(input2, "name", "networkCb");
    			input2.checked = input2_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTING;
    			add_location(input2, file$j, 52, 7, 1517);
    			add_location(label2, file$j, 51, 4, 1503);
    			attr_dev(div0, "class", "uk-margin uk-grid-small uk-child-width-auto uk-grid");
    			add_location(div0, file$j, 32, 2, 957);
    			attr_dev(h5, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h5, file$j, 62, 2, 1753);
    			add_location(p, file$j, 65, 2, 1861);
    			add_location(span0, file$j, 67, 4, 1969);
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", /*waypoint*/ ctx[1]);
    			add_location(input3, file$j, 68, 4, 1997);
    			attr_dev(div1, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div1, file$j, 66, 2, 1912);
    			attr_dev(span1, "class", "uk-button uk-button-primary uk-align-right");
    			attr_dev(span1, "id", "add-btn");
    			add_location(span1, file$j, 77, 6, 2126);
    			attr_dev(div2, "class", "uk-margin-medium-bottom");
    			add_location(div2, file$j, 28, 0, 812);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h4);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, label0);
    			append_dev(label0, input0);
    			append_dev(label0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, label1);
    			append_dev(label1, input1);
    			append_dev(label1, t4);
    			append_dev(div0, t5);
    			append_dev(div0, label2);
    			append_dev(label2, input2);
    			append_dev(label2, t6);
    			append_dev(div2, t7);
    			append_dev(div2, h5);
    			append_dev(div2, t9);
    			append_dev(div2, p);
    			append_dev(div2, t11);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(div1, t13);
    			append_dev(div1, input3);
    			set_input_value(input3, /*waypoint*/ ctx[1]);
    			append_dev(div2, t14);
    			append_dev(div2, span1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(input1, "click", /*click_handler_1*/ ctx[4], false, false, false, false),
    					listen_dev(input2, "click", /*click_handler_2*/ ctx[5], false, false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[6]),
    					listen_dev(span1, "click", /*updateWaypoint*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*current_chain_id*/ 1 && input0_checked_value !== (input0_checked_value = /*current_chain_id*/ ctx[0] == Networks.MAINNET)) {
    				prop_dev(input0, "checked", input0_checked_value);
    			}

    			if (dirty & /*current_chain_id*/ 1 && input1_checked_value !== (input1_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTNET)) {
    				prop_dev(input1, "checked", input1_checked_value);
    			}

    			if (dirty & /*current_chain_id*/ 1 && input2_checked_value !== (input2_checked_value = /*current_chain_id*/ ctx[0] == Networks.TESTING)) {
    				prop_dev(input2, "checked", input2_checked_value);
    			}

    			if (dirty & /*waypoint*/ 2) {
    				attr_dev(input3, "placeholder", /*waypoint*/ ctx[1]);
    			}

    			if (dirty & /*waypoint*/ 2 && input3.value !== /*waypoint*/ ctx[1]) {
    				set_input_value(input3, /*waypoint*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DebugSwitchRexMainnet', slots, []);
    	let current_chain_id;
    	let waypoint = "";

    	function updateWaypoint() {
    		// check input data
    		// submit
    		i$1("force_waypoint", { wp: waypoint }).then(res => {
    			network_profile.set(res);
    			notify_success("Waypoint Updated");
    		}).catch(error => {
    			raise_error(error, false, "updateWaypoint");
    		});
    	}

    	onMount(async () => {
    		getNetwork();

    		network_profile.subscribe(n => {
    			$$invalidate(1, waypoint = n.waypoint);
    			$$invalidate(0, current_chain_id = n.chain_id);
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DebugSwitchRexMainnet> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setNetwork(Networks.MAINNET);
    	const click_handler_1 = () => setNetwork(Networks.TESTNET);
    	const click_handler_2 = () => setNetwork(Networks.TESTING);

    	function input3_input_handler() {
    		waypoint = this.value;
    		$$invalidate(1, waypoint);
    	}

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		onMount,
    		raise_error,
    		notify_success,
    		setNetwork,
    		getNetwork,
    		network_profile,
    		Networks,
    		current_chain_id,
    		waypoint,
    		updateWaypoint
    	});

    	$$self.$inject_state = $$props => {
    		if ('current_chain_id' in $$props) $$invalidate(0, current_chain_id = $$props.current_chain_id);
    		if ('waypoint' in $$props) $$invalidate(1, waypoint = $$props.waypoint);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		current_chain_id,
    		waypoint,
    		updateWaypoint,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		input3_input_handler
    	];
    }

    class DebugSwitchRexMainnet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugSwitchRexMainnet",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/components/dev/DebugPaths.svelte generated by Svelte v3.59.2 */
    const file$i = "src/components/dev/DebugPaths.svelte";

    function create_fragment$i(ctx) {
    	let main;
    	let div4;
    	let h4;
    	let t1;
    	let div0;
    	let span0;
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let span1;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let div2;
    	let span2;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let div3;
    	let span3;
    	let t13;
    	let t14;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div4 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Local Files";
    			t1 = space();
    			div0 = element("div");
    			span0 = element("span");
    			t2 = text("Configs Path: ");
    			t3 = text(/*config_path*/ ctx[0]);
    			t4 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t5 = text("App Configs: ");
    			t6 = text(/*config_path*/ ctx[0]);
    			t7 = text("/0L.toml");
    			t8 = space();
    			div2 = element("div");
    			span2 = element("span");
    			t9 = text("App Logs: ");
    			t10 = text(/*config_path*/ ctx[0]);
    			t11 = text("/carpe.log");
    			t12 = space();
    			div3 = element("div");
    			span3 = element("span");
    			t13 = text("Latest Proof Path: ");
    			t14 = text(/*last_proof_path*/ ctx[1]);
    			attr_dev(h4, "class", "uk-text-light uk-text-uppercase uk-text-muted uk-text-thin");
    			add_location(h4, file$i, 17, 4, 408);
    			add_location(span0, file$i, 21, 6, 524);
    			add_location(div0, file$i, 20, 4, 512);
    			add_location(span1, file$i, 24, 6, 593);
    			add_location(div1, file$i, 23, 4, 581);
    			add_location(span2, file$i, 27, 6, 669);
    			add_location(div2, file$i, 26, 4, 657);
    			add_location(span3, file$i, 30, 6, 744);
    			add_location(div3, file$i, 29, 4, 732);
    			attr_dev(div4, "class", "uk-margin-bottom");
    			add_location(div4, file$i, 16, 2, 373);
    			add_location(main, file$i, 15, 0, 364);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div4);
    			append_dev(div4, h4);
    			append_dev(div4, t1);
    			append_dev(div4, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t2);
    			append_dev(span0, t3);
    			append_dev(div4, t4);
    			append_dev(div4, div1);
    			append_dev(div1, span1);
    			append_dev(span1, t5);
    			append_dev(span1, t6);
    			append_dev(span1, t7);
    			append_dev(div4, t8);
    			append_dev(div4, div2);
    			append_dev(div2, span2);
    			append_dev(span2, t9);
    			append_dev(span2, t10);
    			append_dev(span2, t11);
    			append_dev(div4, t12);
    			append_dev(div4, div3);
    			append_dev(div3, span3);
    			append_dev(span3, t13);
    			append_dev(span3, t14);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*config_path*/ 1) set_data_dev(t3, /*config_path*/ ctx[0]);
    			if (dirty & /*config_path*/ 1) set_data_dev(t6, /*config_path*/ ctx[0]);
    			if (dirty & /*config_path*/ 1) set_data_dev(t10, /*config_path*/ ctx[0]);
    			if (dirty & /*last_proof_path*/ 2) set_data_dev(t14, /*last_proof_path*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DebugPaths', slots, []);
    	let config_path;
    	let last_proof_path;

    	i$1("debug_highest_proof_path", {}).then(path => {
    		$$invalidate(1, last_proof_path = path);
    	});

    	i$1("debug_preferences_path", {}).then(path => {
    		$$invalidate(0, config_path = path);
    	}).catch(err => {
    		$$invalidate(0, config_path = "no local tower proofs found");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DebugPaths> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ invoke: i$1, config_path, last_proof_path });

    	$$self.$inject_state = $$props => {
    		if ('config_path' in $$props) $$invalidate(0, config_path = $$props.config_path);
    		if ('last_proof_path' in $$props) $$invalidate(1, last_proof_path = $$props.last_proof_path);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [config_path, last_proof_path];
    }

    class DebugPaths extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DebugPaths",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src/components/dev/DevMode.svelte generated by Svelte v3.59.2 */
    const file$h = "src/components/dev/DevMode.svelte";

    function create_fragment$h(ctx) {
    	let main;
    	let div;
    	let debugcard;
    	let t0;
    	let debugpaths;
    	let t1;
    	let debugswitcher;
    	let t2;
    	let p;
    	let t4;
    	let debugswitchrexmainnet;
    	let t5;
    	let debugswitchprodtest;
    	let t6;
    	let debugactions;
    	let current;
    	debugcard = new DebugCard({ $$inline: true });
    	debugpaths = new DebugPaths({ $$inline: true });
    	debugswitcher = new DebugSwitcher({ $$inline: true });
    	debugswitchrexmainnet = new DebugSwitchRexMainnet({ $$inline: true });
    	debugswitchprodtest = new DebugSwitchProdTest({ $$inline: true });
    	debugactions = new DebugActions({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			create_component(debugcard.$$.fragment);
    			t0 = space();
    			create_component(debugpaths.$$.fragment);
    			t1 = space();
    			create_component(debugswitcher.$$.fragment);
    			t2 = space();
    			p = element("p");
    			p.textContent = "Turn on debug actions on all screens";
    			t4 = space();
    			create_component(debugswitchrexmainnet.$$.fragment);
    			t5 = space();
    			create_component(debugswitchprodtest.$$.fragment);
    			t6 = space();
    			create_component(debugactions.$$.fragment);
    			attr_dev(p, "class", "uk-margin-bottom");
    			add_location(p, file$h, 13, 4, 526);
    			attr_dev(div, "class", "uk-margin uk-container uk-dark");
    			set_style(div, "margin-bottom", "280px");
    			add_location(div, file$h, 9, 2, 389);
    			attr_dev(main, "class", "uk-height-viewport");
    			add_location(main, file$h, 8, 0, 353);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			mount_component(debugcard, div, null);
    			append_dev(div, t0);
    			mount_component(debugpaths, div, null);
    			append_dev(div, t1);
    			mount_component(debugswitcher, div, null);
    			append_dev(div, t2);
    			append_dev(div, p);
    			append_dev(div, t4);
    			mount_component(debugswitchrexmainnet, div, null);
    			append_dev(div, t5);
    			mount_component(debugswitchprodtest, div, null);
    			append_dev(div, t6);
    			mount_component(debugactions, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(debugcard.$$.fragment, local);
    			transition_in(debugpaths.$$.fragment, local);
    			transition_in(debugswitcher.$$.fragment, local);
    			transition_in(debugswitchrexmainnet.$$.fragment, local);
    			transition_in(debugswitchprodtest.$$.fragment, local);
    			transition_in(debugactions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(debugcard.$$.fragment, local);
    			transition_out(debugpaths.$$.fragment, local);
    			transition_out(debugswitcher.$$.fragment, local);
    			transition_out(debugswitchrexmainnet.$$.fragment, local);
    			transition_out(debugswitchprodtest.$$.fragment, local);
    			transition_out(debugactions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(debugcard);
    			destroy_component(debugpaths);
    			destroy_component(debugswitcher);
    			destroy_component(debugswitchrexmainnet);
    			destroy_component(debugswitchprodtest);
    			destroy_component(debugactions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DevMode', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DevMode> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		DebugCard,
    		DebugActions,
    		DebugSwitchProdTest,
    		DebugSwitchRexMainnet,
    		DebugSwitcher,
    		DebugPaths
    	});

    	return [];
    }

    class DevMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DevMode",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/components/wallet/AccountFromMnemSubmit.svelte generated by Svelte v3.59.2 */
    const file$g = "src/components/wallet/AccountFromMnemSubmit.svelte";

    // (104:0) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function select_block_type_2(ctx, dirty) {
    		if (/*isSubmitting*/ ctx[1]) return create_if_block_2$1;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			attr_dev(button, "class", "uk-button uk-button-primary");
    			attr_dev(button, "type", "button");
    			button.disabled = /*isSubmitting*/ ctx[1];
    			add_location(button, file$g, 104, 2, 3504);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_block.m(button, null);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*handleAdd*/ ctx[4]), false, true, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button, null);
    				}
    			}

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button, "disabled", /*isSubmitting*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(104:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:0) {#if isNewAccount}
    function create_if_block$a(ctx) {
    	let button0;
    	let t0_value = /*$_*/ ctx[2]("wallet.keygen.btn_create_account") + "";
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let h2;
    	let t2_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.title") + "";
    	let t2;
    	let t3;
    	let p0;
    	let raw_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.body") + "";
    	let t4;
    	let p1;
    	let button1;
    	let t5_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_cancel") + "";
    	let t5;
    	let t6;
    	let button2;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isSubmitting*/ ctx[1]) return create_if_block_1$4;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			p0 = element("p");
    			t4 = space();
    			p1 = element("p");
    			button1 = element("button");
    			t5 = text(t5_value);
    			t6 = space();
    			button2 = element("button");
    			if_block.c();
    			attr_dev(button0, "class", "uk-button uk-button-secondary uk-margin-small-right");
    			button0.disabled = /*isSubmitting*/ ctx[1];
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$g, 65, 2, 2297);
    			attr_dev(h2, "class", "uk-modal-title uk-text-uppercase uk-text-alert");
    			add_location(h2, file$g, 76, 6, 2631);
    			add_location(p0, file$g, 79, 6, 2763);
    			attr_dev(button1, "class", "uk-button uk-button-default uk-modal-close");
    			attr_dev(button1, "type", "button");
    			button1.disabled = /*isSubmitting*/ ctx[1];
    			add_location(button1, file$g, 81, 8, 2861);
    			attr_dev(button2, "class", "uk-button uk-button-primary");
    			attr_dev(button2, "type", "button");
    			button2.disabled = /*isSubmitting*/ ctx[1];
    			add_location(button2, file$g, 88, 8, 3085);
    			attr_dev(p1, "class", "uk-text-right");
    			add_location(p1, file$g, 80, 6, 2827);
    			attr_dev(div0, "class", "uk-modal-dialog uk-modal-body");
    			add_location(div0, file$g, 75, 4, 2581);
    			attr_dev(div1, "id", "submit-confirmation-modal");
    			attr_dev(div1, "uk-modal", "");
    			add_location(div1, file$g, 74, 2, 2531);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			append_dev(button0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p0);
    			p0.innerHTML = raw_value;
    			append_dev(div0, t4);
    			append_dev(div0, p1);
    			append_dev(p1, button1);
    			append_dev(button1, t5);
    			append_dev(p1, t6);
    			append_dev(p1, button2);
    			if_block.m(button2, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*openConfirmationModal*/ ctx[3]), false, true, false, false),
    					listen_dev(button2, "click", prevent_default(/*handleAdd*/ ctx[4]), false, true, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.keygen.btn_create_account") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button0, "disabled", /*isSubmitting*/ ctx[1]);
    			}

    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.title") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 4 && raw_value !== (raw_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.body") + "")) p0.innerHTML = raw_value;			if (dirty & /*$_*/ 4 && t5_value !== (t5_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_cancel") + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button1, "disabled", /*isSubmitting*/ ctx[1]);
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button2, null);
    				}
    			}

    			if (dirty & /*isSubmitting*/ 2) {
    				prop_dev(button2, "disabled", /*isSubmitting*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(65:0) {#if isNewAccount}",
    		ctx
    	});

    	return block;
    }

    // (113:4) {:else}
    function create_else_block_2(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(113:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (111:4) {#if isSubmitting}
    function create_if_block_2$1(ctx) {
    	let t0_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(111:4) {#if isSubmitting}",
    		ctx
    	});

    	return block;
    }

    // (97:10) {:else}
    function create_else_block$6(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submit") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(97:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (95:10) {#if isSubmitting}
    function create_if_block_1$4(ctx) {
    	let t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("wallet.account_from_mnem_submit.btn_submiting") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(95:10) {#if isSubmitting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*isNewAccount*/ ctx[0]) return create_if_block$a;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountFromMnemSubmit', slots, []);
    	let { danger_temp_mnem } = $$props;
    	let { isNewAccount = true } = $$props;
    	let unsubs;

    	onMount(async () => {
    		unsubs = mnem.subscribe(m => $$invalidate(5, danger_temp_mnem = m));
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	// const re = /[0-9A-Fa-f]{32}/g;
    	function openConfirmationModal() {
    		uikit.modal("#submit-confirmation-modal").show();
    	}

    	let isSubmitting = false;

    	function handleAdd() {
    		$$invalidate(1, isSubmitting = true);

    		// submit
    		i$1("init_from_mnem", { mnem: danger_temp_mnem.trim() }).then(res => {
    			if (isNewAccount) {
    				uikit.modal("#submit-confirmation-modal").$destroy(true); // known bug https://github.com/uikit/uikit/issues/1370
    				addNewAccount(res);
    			}

    			responses.set(JSON.stringify(res));
    			signingAccount.set(res);
    			$$invalidate(1, isSubmitting = false);
    			notify_success(`Account Added: ${res.nickname}`);

    			// load the account restored localy right away. Balance may takes few seconds to be fetched from the chain.
    			loadAccounts();

    			// set as init so we don't get sent back to Newbie account creation.
    			isInit.set(true);

    			connected.set(true); // provisionally set to true so we don't get flashed an error page.
    			scanning_fullnodes.set(false);

    			carpeTick().then(() => {
    				navigate("/");
    			}).catch(e => {
    				raise_error(e, true, "carpeTick");
    			});
    		}).catch(error => {
    			if (isNewAccount) {
    				uikit.modal("#submit-confirmation-modal").hide(); // navigate("/");
    			}

    			$$invalidate(1, isSubmitting = false);
    			raise_error(error, false, "handleAdd");
    		});
    	}

    	$$self.$$.on_mount.push(function () {
    		if (danger_temp_mnem === undefined && !('danger_temp_mnem' in $$props || $$self.$$.bound[$$self.$$.props['danger_temp_mnem']])) {
    			console.warn("<AccountFromMnemSubmit> was created without expected prop 'danger_temp_mnem'");
    		}
    	});

    	const writable_props = ['danger_temp_mnem', 'isNewAccount'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountFromMnemSubmit> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('danger_temp_mnem' in $$props) $$invalidate(5, danger_temp_mnem = $$props.danger_temp_mnem);
    		if ('isNewAccount' in $$props) $$invalidate(0, isNewAccount = $$props.isNewAccount);
    	};

    	$$self.$capture_state = () => ({
    		_: $format,
    		navigate,
    		responses,
    		signingAccount,
    		mnem,
    		isInit,
    		raise_error,
    		invoke: i$1,
    		notify_success,
    		onDestroy,
    		onMount,
    		connected,
    		scanning_fullnodes,
    		addNewAccount,
    		loadAccounts,
    		UIkit: uikit,
    		carpeTick,
    		danger_temp_mnem,
    		isNewAccount,
    		unsubs,
    		openConfirmationModal,
    		isSubmitting,
    		handleAdd,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('danger_temp_mnem' in $$props) $$invalidate(5, danger_temp_mnem = $$props.danger_temp_mnem);
    		if ('isNewAccount' in $$props) $$invalidate(0, isNewAccount = $$props.isNewAccount);
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    		if ('isSubmitting' in $$props) $$invalidate(1, isSubmitting = $$props.isSubmitting);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isNewAccount,
    		isSubmitting,
    		$_,
    		openConfirmationModal,
    		handleAdd,
    		danger_temp_mnem
    	];
    }

    class AccountFromMnemSubmit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$g, create_fragment$g, safe_not_equal, { danger_temp_mnem: 5, isNewAccount: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountFromMnemSubmit",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get danger_temp_mnem() {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set danger_temp_mnem(value) {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNewAccount() {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNewAccount(value) {
    		throw new Error("<AccountFromMnemSubmit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/wallet/AccountFromMnemForm.svelte generated by Svelte v3.59.2 */
    const file$f = "src/components/wallet/AccountFromMnemForm.svelte";

    function create_fragment$f(ctx) {
    	let main;
    	let h3;
    	let t0_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.title") + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.description") + "";
    	let t2;
    	let t3;
    	let form;
    	let fieldset;
    	let div;
    	let input;
    	let input_placeholder_value;
    	let t4;
    	let accountfrommnemsubmit;
    	let current;
    	let mounted;
    	let dispose;

    	accountfrommnemsubmit = new AccountFromMnemSubmit({
    			props: {
    				danger_temp_mnem: /*danger_temp_mnem*/ ctx[0],
    				isNewAccount: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div = element("div");
    			input = element("input");
    			t4 = space();
    			create_component(accountfrommnemsubmit.$$.fragment);
    			attr_dev(h3, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h3, file$f, 6, 2, 163);
    			add_location(p, file$f, 8, 2, 277);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", input_placeholder_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.placeholder"));
    			add_location(input, file$f, 12, 8, 464);
    			attr_dev(div, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div, file$f, 11, 6, 403);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$f, 10, 4, 366);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$f, 9, 2, 337);
    			add_location(main, file$f, 5, 0, 152);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h3);
    			append_dev(h3, t0);
    			append_dev(main, t1);
    			append_dev(main, p);
    			append_dev(p, t2);
    			append_dev(main, t3);
    			append_dev(main, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div);
    			append_dev(div, input);
    			set_input_value(input, /*danger_temp_mnem*/ ctx[0]);
    			append_dev(fieldset, t4);
    			mount_component(accountfrommnemsubmit, fieldset, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.title") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$_*/ 2) && t2_value !== (t2_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.description") + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*$_*/ 2 && input_placeholder_value !== (input_placeholder_value = /*$_*/ ctx[1]("wallet.account_from_mnem_from.placeholder"))) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*danger_temp_mnem*/ 1 && input.value !== /*danger_temp_mnem*/ ctx[0]) {
    				set_input_value(input, /*danger_temp_mnem*/ ctx[0]);
    			}

    			const accountfrommnemsubmit_changes = {};
    			if (dirty & /*danger_temp_mnem*/ 1) accountfrommnemsubmit_changes.danger_temp_mnem = /*danger_temp_mnem*/ ctx[0];
    			accountfrommnemsubmit.$set(accountfrommnemsubmit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountfrommnemsubmit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountfrommnemsubmit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(accountfrommnemsubmit);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountFromMnemForm', slots, []);
    	let danger_temp_mnem;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountFromMnemForm> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		danger_temp_mnem = this.value;
    		$$invalidate(0, danger_temp_mnem);
    	}

    	$$self.$capture_state = () => ({
    		_: $format,
    		AccountFromMnemSubmit,
    		danger_temp_mnem,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('danger_temp_mnem' in $$props) $$invalidate(0, danger_temp_mnem = $$props.danger_temp_mnem);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [danger_temp_mnem, $_, input_input_handler];
    }

    class AccountFromMnemForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountFromMnemForm",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src/components/dev/Swarm.svelte generated by Svelte v3.59.2 */

    const { console: console_1$4 } = globals;
    const file$e = "src/components/dev/Swarm.svelte";

    function create_fragment$e(ctx) {
    	let main;
    	let div2;
    	let h2;
    	let t1;
    	let div0;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let p2;
    	let t7;
    	let h4;
    	let t9;
    	let p3;
    	let t10;
    	let t11;
    	let t12;
    	let p4;
    	let t13;
    	let t14_value = /*swarm_files*/ ctx[1].path_exists + "";
    	let t14;
    	let t15;
    	let t16_value = /*swarm_files*/ ctx[1].path + "";
    	let t16;
    	let t17;
    	let p5;
    	let t18;
    	let t19_value = /*swarm_files*/ ctx[1].config_path_exists + "";
    	let t19;
    	let t20;
    	let t21_value = /*swarm_files*/ ctx[1].config_path + "";
    	let t21;
    	let t22;
    	let p6;
    	let t23;
    	let t24_value = /*swarm_files*/ ctx[1].proof_exists + "";
    	let t24;
    	let t25;
    	let t26_value = /*swarm_files*/ ctx[1].proof_path + "";
    	let t26;
    	let t27;
    	let div1;
    	let button0;
    	let t29;
    	let button1;
    	let t31;
    	let button2;
    	let t33;
    	let button3;
    	let t35;
    	let button4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div2 = element("div");
    			h2 = element("h2");
    			h2.textContent = "swarm";
    			t1 = space();
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "start swarm with:";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "NODE_ENV=test cargo run -p diem-swarm -- --diem-node\n        target/debug/diem-node -c ~/.0L/swarm_temp";
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "Carpe expects the swarm files to be in ~/.0L/swarm_temp";
    			t7 = space();
    			h4 = element("h4");
    			h4.textContent = "Swarm Diagnostics";
    			t9 = space();
    			p3 = element("p");
    			t10 = text("swarm running: ");
    			t11 = text(/*swarm_running*/ ctx[0]);
    			t12 = space();
    			p4 = element("p");
    			t13 = text("swarm path: ");
    			t14 = text(t14_value);
    			t15 = text(" - ");
    			t16 = text(t16_value);
    			t17 = space();
    			p5 = element("p");
    			t18 = text("alice config path: ");
    			t19 = text(t19_value);
    			t20 = text(" - ");
    			t21 = text(t21_value);
    			t22 = space();
    			p6 = element("p");
    			t23 = text("alice proof zero path: ");
    			t24 = text(t24_value);
    			t25 = text(" - ");
    			t26 = text(t26_value);
    			t27 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Check Swarm";
    			t29 = space();
    			button1 = element("button");
    			button1.textContent = "Init Alice Files";
    			t31 = space();
    			button2 = element("button");
    			button2.textContent = "Init Alice Keys";
    			t33 = space();
    			button3 = element("button");
    			button3.textContent = "Swarm Demo Tx";
    			t35 = space();
    			button4 = element("button");
    			button4.textContent = "Mine Once";
    			add_location(h2, file$e, 59, 4, 1740);
    			add_location(p0, file$e, 61, 6, 1771);
    			add_location(p1, file$e, 62, 6, 1802);
    			add_location(p2, file$e, 67, 6, 1936);
    			add_location(div0, file$e, 60, 4, 1759);
    			add_location(h4, file$e, 69, 4, 2014);
    			add_location(p3, file$e, 70, 4, 2045);
    			add_location(p4, file$e, 71, 4, 2087);
    			add_location(p5, file$e, 72, 4, 2157);
    			add_location(p6, file$e, 75, 4, 2260);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			add_location(button0, file$e, 80, 6, 2381);
    			attr_dev(button1, "class", "uk-button uk-button-default");
    			add_location(button1, file$e, 84, 6, 2491);
    			attr_dev(button2, "class", "uk-button uk-button-default");
    			add_location(button2, file$e, 88, 6, 2610);
    			attr_dev(button3, "class", "uk-button uk-button-default");
    			add_location(button3, file$e, 92, 6, 2727);
    			attr_dev(button4, "class", "uk-button uk-button-default");
    			add_location(button4, file$e, 96, 6, 2833);
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$e, 79, 4, 2361);
    			attr_dev(div2, "class", "uk-margin");
    			add_location(div2, file$e, 58, 2, 1712);
    			add_location(main, file$e, 57, 0, 1703);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div2);
    			append_dev(div2, h2);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(div0, t5);
    			append_dev(div0, p2);
    			append_dev(div2, t7);
    			append_dev(div2, h4);
    			append_dev(div2, t9);
    			append_dev(div2, p3);
    			append_dev(p3, t10);
    			append_dev(p3, t11);
    			append_dev(div2, t12);
    			append_dev(div2, p4);
    			append_dev(p4, t13);
    			append_dev(p4, t14);
    			append_dev(p4, t15);
    			append_dev(p4, t16);
    			append_dev(div2, t17);
    			append_dev(div2, p5);
    			append_dev(p5, t18);
    			append_dev(p5, t19);
    			append_dev(p5, t20);
    			append_dev(p5, t21);
    			append_dev(div2, t22);
    			append_dev(div2, p6);
    			append_dev(p6, t23);
    			append_dev(p6, t24);
    			append_dev(p6, t25);
    			append_dev(p6, t26);
    			append_dev(div2, t27);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t29);
    			append_dev(div1, button1);
    			append_dev(div1, t31);
    			append_dev(div1, button2);
    			append_dev(div1, t33);
    			append_dev(div1, button3);
    			append_dev(div1, t35);
    			append_dev(div1, button4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*swarmCheck*/ ctx[5], false, false, false, false),
    					listen_dev(button1, "click", /*initAliceFiles*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*initAliceKeys*/ ctx[6], false, false, false, false),
    					listen_dev(button3, "click", /*demo*/ ctx[3], false, false, false, false),
    					listen_dev(button4, "click", /*miner*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*swarm_running*/ 1) set_data_dev(t11, /*swarm_running*/ ctx[0]);
    			if (dirty & /*swarm_files*/ 2 && t14_value !== (t14_value = /*swarm_files*/ ctx[1].path_exists + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*swarm_files*/ 2 && t16_value !== (t16_value = /*swarm_files*/ ctx[1].path + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*swarm_files*/ 2 && t19_value !== (t19_value = /*swarm_files*/ ctx[1].config_path_exists + "")) set_data_dev(t19, t19_value);
    			if (dirty & /*swarm_files*/ 2 && t21_value !== (t21_value = /*swarm_files*/ ctx[1].config_path + "")) set_data_dev(t21, t21_value);
    			if (dirty & /*swarm_files*/ 2 && t24_value !== (t24_value = /*swarm_files*/ ctx[1].proof_exists + "")) set_data_dev(t24, t24_value);
    			if (dirty & /*swarm_files*/ 2 && t26_value !== (t26_value = /*swarm_files*/ ctx[1].proof_path + "")) set_data_dev(t26, t26_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Swarm', slots, []);
    	let home_path = "";
    	let swarm_running = "";
    	let swarm_files = "";

    	const easySwarm = async () => {
    		i$1("easy_swarm", {}).then(res => result = res).catch(e => raise_error(e, false, "easySwarm"));
    	};

    	const initAliceFiles = async () => {
    		i$1("init_swarm", {}).then(res => {
    			result = res;
    			swarmCheck();
    		}).catch(e => raise_error(e));
    	};

    	const demo = async () => {
    		i$1("swarm_demo_tx", {}).then(res => result = res).catch(e => raise_error(e));
    	};

    	const miner = async () => {
    		i$1("swarm_miner", {
    			swarmDir: home_path.concat("swarm_temp"),
    			swarmPersona: "alice"
    		}).then(res => result = res).catch(e => raise_error(e));
    	};

    	const swarmCheck = async () => {
    		i$1("swarm_process", {}).then(res => $$invalidate(0, swarm_running = res)).catch(e => raise_error(e));

    		i$1("swarm_files", {}).then(res => {
    			console.log(res);
    			$$invalidate(1, swarm_files = res);
    		}).catch(e => raise_error(e));
    	};

    	const initAliceKeys = async () => {
    		i$1("init_from_mnem", { mnem: alice_mnem }).then(res => {
    			responses.set(res);
    			setAccount(res);
    		}).catch(e => {
    			raise_error(e);
    		});
    	};

    	let alice_mnem = "talent sunset lizard pill fame nuclear spy noodle basket okay critic grow sleep legend hurry pitch blanket clerk impose rough degree sock insane purse";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<Swarm> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		setAccount,
    		raise_error,
    		responses,
    		home_path,
    		swarm_running,
    		swarm_files,
    		easySwarm,
    		initAliceFiles,
    		demo,
    		miner,
    		swarmCheck,
    		initAliceKeys,
    		alice_mnem
    	});

    	$$self.$inject_state = $$props => {
    		if ('home_path' in $$props) home_path = $$props.home_path;
    		if ('swarm_running' in $$props) $$invalidate(0, swarm_running = $$props.swarm_running);
    		if ('swarm_files' in $$props) $$invalidate(1, swarm_files = $$props.swarm_files);
    		if ('alice_mnem' in $$props) alice_mnem = $$props.alice_mnem;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		swarm_running,
    		swarm_files,
    		initAliceFiles,
    		demo,
    		miner,
    		swarmCheck,
    		initAliceKeys
    	];
    }

    class Swarm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Swarm",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/components/wallet/Keygen.svelte generated by Svelte v3.59.2 */

    const { console: console_1$3 } = globals;
    const file$d = "src/components/wallet/Keygen.svelte";

    // (82:2) {:else}
    function create_else_block$5(ctx) {
    	let div0;
    	let h3;
    	let t0_value = /*$_*/ ctx[4]("wallet.keygen.description") + "";
    	let t0;
    	let t1;
    	let div1;
    	let button;
    	let t2_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys") + "";
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			button = element("button");
    			t2 = text(t2_value);
    			attr_dev(h3, "class", "uk-text-light uk-text-muted uk-text-center");
    			add_location(h3, file$d, 84, 6, 2490);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$d, 83, 4, 2447);
    			attr_dev(button, "class", "uk-button uk-button-secondary uk-align-right");
    			add_location(button, file$d, 90, 6, 2655);
    			attr_dev(div1, "class", "uk-position-center");
    			add_location(div1, file$d, 89, 4, 2616);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h3);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*keygen*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.keygen.description") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 16 && t2_value !== (t2_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys") + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(82:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:2) {#if address && !hide}
    function create_if_block$9(ctx) {
    	let div1;
    	let h50;
    	let t0_value = /*$_*/ ctx[4]("wallet.keygen.account_address") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2;
    	let t3;
    	let h51;
    	let t4_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key") + "";
    	let t4;
    	let t5;
    	let p1;
    	let t6;
    	let t7;
    	let p2;
    	let t8_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key_description") + "";
    	let t8;
    	let t9;
    	let h52;
    	let t10_value = /*$_*/ ctx[4]("wallet.keygen.securite_recovery_phrase") + "";
    	let t10;
    	let t11;
    	let p3;
    	let t12_value = /*$_*/ ctx[4]("wallet.keygen.securite_note") + "";
    	let t12;
    	let t13;
    	let div0;
    	let textarea;
    	let t14;
    	let div2;
    	let p4;
    	let t15_value = /*$_*/ ctx[4]("wallet.keygen.account_tips") + "";
    	let t15;
    	let t16;
    	let div3;
    	let accountfrommnemsubmit;
    	let t17;
    	let button;
    	let t18_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys_2") + "";
    	let t18;
    	let current;
    	let mounted;
    	let dispose;

    	accountfrommnemsubmit = new AccountFromMnemSubmit({
    			props: { danger_temp_mnem: "" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h50 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(/*address*/ ctx[1]);
    			t3 = space();
    			h51 = element("h5");
    			t4 = text(t4_value);
    			t5 = space();
    			p1 = element("p");
    			t6 = text(/*authkey*/ ctx[2]);
    			t7 = space();
    			p2 = element("p");
    			t8 = text(t8_value);
    			t9 = space();
    			h52 = element("h5");
    			t10 = text(t10_value);
    			t11 = space();
    			p3 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			div0 = element("div");
    			textarea = element("textarea");
    			t14 = space();
    			div2 = element("div");
    			p4 = element("p");
    			t15 = text(t15_value);
    			t16 = space();
    			div3 = element("div");
    			create_component(accountfrommnemsubmit.$$.fragment);
    			t17 = space();
    			button = element("button");
    			t18 = text(t18_value);
    			attr_dev(h50, "class", "uk-text-muted uk-text-uppercase");
    			add_location(h50, file$d, 47, 6, 1372);
    			attr_dev(p0, "class", "uk-text-emphasis uk-text-uppercase");
    			add_location(p0, file$d, 48, 6, 1465);
    			attr_dev(h51, "class", "uk-text-muted uk-text-uppercase");
    			add_location(h51, file$d, 49, 6, 1531);
    			attr_dev(p1, "class", "uk-text-emphasis uk-text-uppercase");
    			add_location(p1, file$d, 50, 6, 1620);
    			add_location(p2, file$d, 51, 6, 1686);
    			attr_dev(h52, "class", "uk-text-muted uk-text-uppercase uk-text-danger");
    			add_location(h52, file$d, 53, 6, 1746);
    			attr_dev(p3, "class", "uk-text-danger");
    			add_location(p3, file$d, 56, 6, 1879);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "rows", "3");
    			textarea.readOnly = true;
    			textarea.value = /*display_mnem*/ ctx[0];
    			add_location(textarea, file$d, 60, 8, 1999);
    			attr_dev(div0, "class", "uk-margin");
    			add_location(div0, file$d, 59, 6, 1967);
    			attr_dev(div1, "class", "uk-margin uk-card uk-card-default uk-card-body uk-text-muted");
    			add_location(div1, file$d, 46, 4, 1291);
    			add_location(p4, file$d, 65, 6, 2114);
    			add_location(div2, file$d, 64, 4, 2102);
    			attr_dev(button, "class", "uk-button uk-button-default uk-align-right");
    			add_location(button, file$d, 73, 6, 2255);
    			add_location(div3, file$d, 70, 4, 2188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h50);
    			append_dev(h50, t0);
    			append_dev(div1, t1);
    			append_dev(div1, p0);
    			append_dev(p0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, h51);
    			append_dev(h51, t4);
    			append_dev(div1, t5);
    			append_dev(div1, p1);
    			append_dev(p1, t6);
    			append_dev(div1, t7);
    			append_dev(div1, p2);
    			append_dev(p2, t8);
    			append_dev(div1, t9);
    			append_dev(div1, h52);
    			append_dev(h52, t10);
    			append_dev(div1, t11);
    			append_dev(div1, p3);
    			append_dev(p3, t12);
    			append_dev(div1, t13);
    			append_dev(div1, div0);
    			append_dev(div0, textarea);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, p4);
    			append_dev(p4, t15);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(accountfrommnemsubmit, div3, null);
    			append_dev(div3, t17);
    			append_dev(div3, button);
    			append_dev(button, t18);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*keygen*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 16) && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.keygen.account_address") + "")) set_data_dev(t0, t0_value);
    			if (!current || dirty & /*address*/ 2) set_data_dev(t2, /*address*/ ctx[1]);
    			if ((!current || dirty & /*$_*/ 16) && t4_value !== (t4_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key") + "")) set_data_dev(t4, t4_value);
    			if (!current || dirty & /*authkey*/ 4) set_data_dev(t6, /*authkey*/ ctx[2]);
    			if ((!current || dirty & /*$_*/ 16) && t8_value !== (t8_value = /*$_*/ ctx[4]("wallet.keygen.onboard_key_description") + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*$_*/ 16) && t10_value !== (t10_value = /*$_*/ ctx[4]("wallet.keygen.securite_recovery_phrase") + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*$_*/ 16) && t12_value !== (t12_value = /*$_*/ ctx[4]("wallet.keygen.securite_note") + "")) set_data_dev(t12, t12_value);

    			if (!current || dirty & /*display_mnem*/ 1) {
    				prop_dev(textarea, "value", /*display_mnem*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 16) && t15_value !== (t15_value = /*$_*/ ctx[4]("wallet.keygen.account_tips") + "")) set_data_dev(t15, t15_value);
    			if ((!current || dirty & /*$_*/ 16) && t18_value !== (t18_value = /*$_*/ ctx[4]("wallet.keygen.btn_generate_keys_2") + "")) set_data_dev(t18, t18_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountfrommnemsubmit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountfrommnemsubmit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div3);
    			destroy_component(accountfrommnemsubmit);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(45:2) {#if address && !hide}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let main;
    	let div;
    	let h3;
    	let t0_value = /*$_*/ ctx[4]("wallet.keygen.title") + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*address*/ ctx[1] && !/*hide*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			attr_dev(h3, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h3, file$d, 39, 4, 1148);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$d, 38, 2, 1107);
    			add_location(main, file$d, 37, 0, 1098);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h3);
    			append_dev(h3, t0);
    			append_dev(main, t1);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 16) && t0_value !== (t0_value = /*$_*/ ctx[4]("wallet.keygen.title") + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Keygen', slots, []);
    	let display_mnem;
    	let address;
    	let authkey;
    	let unsubsMnem;
    	let unsubsSigningAccount;

    	onMount(async () => {
    		unsubsMnem = mnem.subscribe(m => $$invalidate(0, display_mnem = m));

    		unsubsSigningAccount = signingAccount.subscribe(a => {
    			$$invalidate(1, address = a.account);
    			$$invalidate(2, authkey = a.authkey);
    		});
    	});

    	onDestroy(async () => {
    		unsubsMnem && unsubsMnem();
    		unsubsSigningAccount && unsubsSigningAccount();
    	});

    	let hide = true;

    	const keygen = async () => {
    		i$1("keygen", {}).then(res => {
    			console.log(res);
    			responses.set(JSON.stringify(res));
    			signingAccount.set(res.entry);
    			mnem.set(res.mnem);
    			$$invalidate(3, hide = false);
    		}).catch(e => raise_error(e, true, "keygen"));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Keygen> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: $format,
    		onDestroy,
    		onMount,
    		invoke: i$1,
    		signingAccount,
    		mnem,
    		raise_error,
    		responses,
    		AccountFromMnemSubmit,
    		display_mnem,
    		address,
    		authkey,
    		unsubsMnem,
    		unsubsSigningAccount,
    		hide,
    		keygen,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('display_mnem' in $$props) $$invalidate(0, display_mnem = $$props.display_mnem);
    		if ('address' in $$props) $$invalidate(1, address = $$props.address);
    		if ('authkey' in $$props) $$invalidate(2, authkey = $$props.authkey);
    		if ('unsubsMnem' in $$props) unsubsMnem = $$props.unsubsMnem;
    		if ('unsubsSigningAccount' in $$props) unsubsSigningAccount = $$props.unsubsSigningAccount;
    		if ('hide' in $$props) $$invalidate(3, hide = $$props.hide);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [display_mnem, address, authkey, hide, $_, keygen];
    }

    class Keygen extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Keygen",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/components/txs/OnboardDialog.svelte generated by Svelte v3.59.2 */
    const file$c = "src/components/txs/OnboardDialog.svelte";

    // (53:12) {#if waiting}
    function create_if_block$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "ratio: 0.8");
    			set_style(span, "margin", "0px 10px 0px 0px");
    			add_location(span, file$c, 53, 14, 1604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(53:12) {#if waiting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let main;
    	let div3;
    	let div2;
    	let h2;
    	let t0_value = /*$_*/ ctx[4]("txs.onboard.title") + "";
    	let t0;
    	let t1;
    	let form;
    	let fieldset;
    	let div0;
    	let input;
    	let t2;
    	let p;
    	let t3;
    	let t4;
    	let div1;
    	let t5;
    	let button0;
    	let t6_value = /*$_*/ ctx[4]("txs.onboard.btn_cancel") + "";
    	let t6;
    	let t7;
    	let button1;

    	let t8_value = (/*waiting*/ ctx[3]
    	? /*$_*/ ctx[4]("txs.onboard.await")
    	: /*$_*/ ctx[4]("txs.onboard.btn_onboard")) + "";

    	let t8;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block = /*waiting*/ ctx[3] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div3 = element("div");
    			div2 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div0 = element("div");
    			input = element("input");
    			t2 = space();
    			p = element("p");
    			t3 = text(/*errorMessage*/ ctx[1]);
    			t4 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t5 = space();
    			button0 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			t8 = text(t8_value);
    			attr_dev(h2, "class", "uk-modal-title");
    			add_location(h2, file$c, 38, 6, 1086);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Onboard Key");
    			add_location(input, file$c, 43, 12, 1294);
    			attr_dev(div0, "class", "uk-margin uk-inline-block uk-width-1-1");
    			add_location(div0, file$c, 42, 10, 1229);
    			attr_dev(p, "class", "uk-text-warning");
    			add_location(p, file$c, 50, 10, 1479);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-modal-close uk-margin-right");
    			add_location(button0, file$c, 55, 12, 1699);
    			button1.disabled = button1_disabled_value = /*waiting*/ ctx[3] || !/*onboard_key*/ ctx[2] || /*account*/ ctx[0].balance < 2000000;
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			attr_dev(button1, "id", "create-acc");
    			add_location(button1, file$c, 58, 12, 1854);
    			attr_dev(div1, "class", "uk-align-right");
    			add_location(div1, file$c, 51, 10, 1535);
    			attr_dev(fieldset, "class", "uk-fieldset");
    			add_location(fieldset, file$c, 41, 8, 1188);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$c, 40, 6, 1155);
    			attr_dev(div2, "class", "uk-modal-dialog uk-modal-body");
    			add_location(div2, file$c, 37, 4, 1036);
    			attr_dev(div3, "id", "onboardDialog");
    			attr_dev(div3, "uk-modal", "");
    			add_location(div3, file$c, 36, 2, 998);
    			add_location(main, file$c, 35, 0, 989);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div3);
    			append_dev(div3, div2);
    			append_dev(div2, h2);
    			append_dev(h2, t0);
    			append_dev(div2, t1);
    			append_dev(div2, form);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*onboard_key*/ ctx[2]);
    			append_dev(fieldset, t2);
    			append_dev(fieldset, p);
    			append_dev(p, t3);
    			append_dev(fieldset, t4);
    			append_dev(fieldset, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, button0);
    			append_dev(button0, t6);
    			append_dev(div1, t7);
    			append_dev(div1, button1);
    			append_dev(button1, t8);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button1, "click", /*createUser*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("txs.onboard.title") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*onboard_key*/ 4 && input.value !== /*onboard_key*/ ctx[2]) {
    				set_input_value(input, /*onboard_key*/ ctx[2]);
    			}

    			if (dirty & /*errorMessage*/ 2) set_data_dev(t3, /*errorMessage*/ ctx[1]);

    			if (/*waiting*/ ctx[3]) {
    				if (if_block) ; else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(div1, t5);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$_*/ 16 && t6_value !== (t6_value = /*$_*/ ctx[4]("txs.onboard.btn_cancel") + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*waiting, $_*/ 24 && t8_value !== (t8_value = (/*waiting*/ ctx[3]
    			? /*$_*/ ctx[4]("txs.onboard.await")
    			: /*$_*/ ctx[4]("txs.onboard.btn_onboard")) + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*waiting, onboard_key, account*/ 13 && button1_disabled_value !== (button1_disabled_value = /*waiting*/ ctx[3] || !/*onboard_key*/ ctx[2] || /*account*/ ctx[0].balance < 2000000)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OnboardDialog', slots, []);
    	let { account } = $$props;

    	let { onSuccess = _ => {
    		
    	} } = $$props;

    	let errorMessage = "";
    	let onboard_key;
    	let waiting = false;

    	onMount(() => {
    		$$invalidate(1, errorMessage = account && account.balance < 2000000
    		? "Insuficient balance to onboard another account."
    		: "");
    	});

    	function createUser() {
    		$$invalidate(3, waiting = true);

    		// submit
    		i$1("create_user_account", { authkey: onboard_key }).then(res => {
    			responses.set(JSON.stringify(res));
    			notify_success("Account Added");
    			$$invalidate(3, waiting = false);
    			$$invalidate(2, onboard_key = null);
    			onSuccess(account);
    			uikit.modal("#onboardDialog").hide();
    		}).catch(error => {
    			$$invalidate(1, errorMessage = error.msg);
    			$$invalidate(3, waiting = false);
    		});
    	}

    	$$self.$$.on_mount.push(function () {
    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console.warn("<OnboardDialog> was created without expected prop 'account'");
    		}
    	});

    	const writable_props = ['account', 'onSuccess'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OnboardDialog> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		onboard_key = this.value;
    		$$invalidate(2, onboard_key);
    	}

    	$$self.$$set = $$props => {
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    		if ('onSuccess' in $$props) $$invalidate(6, onSuccess = $$props.onSuccess);
    	};

    	$$self.$capture_state = () => ({
    		_: $format,
    		invoke: i$1,
    		responses,
    		notify_success,
    		onMount,
    		UIkit: uikit,
    		account,
    		onSuccess,
    		errorMessage,
    		onboard_key,
    		waiting,
    		createUser,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    		if ('onSuccess' in $$props) $$invalidate(6, onSuccess = $$props.onSuccess);
    		if ('errorMessage' in $$props) $$invalidate(1, errorMessage = $$props.errorMessage);
    		if ('onboard_key' in $$props) $$invalidate(2, onboard_key = $$props.onboard_key);
    		if ('waiting' in $$props) $$invalidate(3, waiting = $$props.waiting);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		account,
    		errorMessage,
    		onboard_key,
    		waiting,
    		$_,
    		createUser,
    		onSuccess,
    		input_input_handler
    	];
    }

    class OnboardDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$c, create_fragment$c, safe_not_equal, { account: 0, onSuccess: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OnboardDialog",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get account() {
    		throw new Error("<OnboardDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<OnboardDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSuccess() {
    		throw new Error("<OnboardDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSuccess(value) {
    		throw new Error("<OnboardDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/txs/TransferDialog.svelte generated by Svelte v3.59.2 */
    const file$b = "src/components/txs/TransferDialog.svelte";

    // (86:6) {:else}
    function create_else_block$4(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[3]("txs.transfer.title") + "";
    	let t0;
    	let t1;
    	let form;
    	let fieldset;
    	let div1;
    	let label0;
    	let t2_value = /*$_*/ ctx[3]("txs.transfer.sender") + "";
    	let t2;
    	let t3;
    	let div0;
    	let input0;
    	let input0_value_value;
    	let t4;
    	let div3;
    	let label1;
    	let t5_value = /*$_*/ ctx[3]("txs.transfer.balance") + "";
    	let t5;
    	let t6;
    	let div2;
    	let input1;
    	let input1_value_value;
    	let t7;
    	let div5;
    	let label2;
    	let t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "";
    	let t8;
    	let t9;
    	let div4;
    	let input2;
    	let input2_placeholder_value;
    	let t10;
    	let div7;
    	let label3;
    	let t11_value = /*$_*/ ctx[3]("txs.transfer.amount_label") + "";
    	let t11;
    	let t12;
    	let div6;
    	let input3;
    	let input3_placeholder_value;
    	let t13;
    	let p;
    	let t14_value = (/*checkMessage*/ ctx[9] || /*errorMessage*/ ctx[6]) + "";
    	let t14;
    	let t15;
    	let div9;
    	let div8;
    	let t16;
    	let button0;

    	let t17_value = (/*waitingTxs*/ ctx[7]
    	? /*$_*/ ctx[3]("txs.transfer.btn_close")
    	: /*$_*/ ctx[3]("txs.transfer.btn_cancel")) + "";

    	let t17;
    	let t18;
    	let button1;

    	let t19_value = (/*waitingTxs*/ ctx[7]
    	? /*$_*/ ctx[3]("txs.transfer.await")
    	: /*$_*/ ctx[3]("txs.transfer.btn_next")) + "";

    	let t19;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block = /*waitingTxs*/ ctx[7] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			fieldset = element("fieldset");
    			div1 = element("div");
    			label0 = element("label");
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div3 = element("div");
    			label1 = element("label");
    			t5 = text(t5_value);
    			t6 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t7 = space();
    			div5 = element("div");
    			label2 = element("label");
    			t8 = text(t8_value);
    			t9 = space();
    			div4 = element("div");
    			input2 = element("input");
    			t10 = space();
    			div7 = element("div");
    			label3 = element("label");
    			t11 = text(t11_value);
    			t12 = space();
    			div6 = element("div");
    			input3 = element("input");
    			t13 = space();
    			p = element("p");
    			t14 = text(t14_value);
    			t15 = space();
    			div9 = element("div");
    			div8 = element("div");
    			if (if_block) if_block.c();
    			t16 = space();
    			button0 = element("button");
    			t17 = text(t17_value);
    			t18 = space();
    			button1 = element("button");
    			t19 = text(t19_value);
    			attr_dev(h2, "class", "uk-modal-title uk-text-muted uk-text-uppercase");
    			add_location(h2, file$b, 86, 8, 3334);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "sender-text");
    			add_location(label0, file$b, 90, 14, 3577);
    			attr_dev(input0, "id", "sender-text");
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "type", "text");
    			input0.value = input0_value_value = /*account*/ ctx[0].account;
    			set_style(input0, "pointer-events", "none");
    			add_location(input0, file$b, 92, 16, 3721);
    			attr_dev(div0, "class", "uk-form-controls");
    			add_location(div0, file$b, 91, 14, 3674);
    			attr_dev(div1, "class", "uk-width-3-4@s");
    			add_location(div1, file$b, 89, 12, 3534);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "balance-text");
    			add_location(label1, file$b, 102, 14, 4030);
    			attr_dev(input1, "id", "balance-text");
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "type", "text");
    			input1.value = input1_value_value = printCoins(/*account*/ ctx[0].balance);
    			set_style(input1, "pointer-events", "none");
    			add_location(input1, file$b, 104, 16, 4176);
    			attr_dev(div2, "class", "uk-form-controls");
    			add_location(div2, file$b, 103, 14, 4129);
    			attr_dev(div3, "class", "uk-width-1-4@s");
    			add_location(div3, file$b, 101, 12, 3987);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "receiver-text");
    			add_location(label2, file$b, 114, 14, 4496);
    			attr_dev(input2, "id", "receiver-text");
    			input2.autofocus = true;
    			input2.disabled = /*waitingTxs*/ ctx[7];
    			attr_dev(input2, "class", "uk-input");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", input2_placeholder_value = /*$_*/ ctx[3]("txs.transfer.receiver_placeholder"));
    			add_location(input2, file$b, 116, 16, 4644);
    			attr_dev(div4, "class", "uk-form-controls");
    			add_location(div4, file$b, 115, 14, 4597);
    			attr_dev(div5, "class", "uk-width-1-1");
    			add_location(div5, file$b, 113, 12, 4455);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "amount-text");
    			add_location(label3, file$b, 128, 14, 5045);
    			attr_dev(input3, "id", "amount-text");
    			input3.disabled = /*waitingTxs*/ ctx[7];
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", input3_placeholder_value = /*$_*/ ctx[3]("txs.transfer.amount_placeholder"));
    			add_location(input3, file$b, 131, 16, 5242);
    			attr_dev(div6, "class", "uk-form-controls uk-width-1-1");
    			add_location(div6, file$b, 129, 14, 5148);
    			attr_dev(div7, "class", "uk-width-1-1");
    			add_location(div7, file$b, 127, 12, 5004);
    			attr_dev(p, "class", "uk-text-warning");
    			add_location(p, file$b, 143, 12, 5661);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-modal-close uk-margin-right");
    			add_location(button0, file$b, 149, 16, 5959);
    			button1.disabled = button1_disabled_value = /*waitingTxs*/ ctx[7] || !/*isValidAmount*/ ctx[10] || !/*isReceiverValid*/ ctx[11];
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			add_location(button1, file$b, 152, 16, 6171);
    			attr_dev(div8, "class", "uk-align-right");
    			add_location(div8, file$b, 145, 14, 5776);
    			attr_dev(div9, "class", "uk-width-1-1");
    			add_location(div9, file$b, 144, 12, 5735);
    			attr_dev(fieldset, "class", "uk-fieldset uk-grid-small");
    			attr_dev(fieldset, "uk-grid", "");
    			add_location(fieldset, file$b, 88, 10, 3469);
    			attr_dev(form, "id", "account-form");
    			add_location(form, file$b, 87, 8, 3434);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, fieldset);
    			append_dev(fieldset, div1);
    			append_dev(div1, label0);
    			append_dev(label0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, input0);
    			append_dev(fieldset, t4);
    			append_dev(fieldset, div3);
    			append_dev(div3, label1);
    			append_dev(label1, t5);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, input1);
    			append_dev(fieldset, t7);
    			append_dev(fieldset, div5);
    			append_dev(div5, label2);
    			append_dev(label2, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*receiver*/ ctx[1]);
    			append_dev(fieldset, t10);
    			append_dev(fieldset, div7);
    			append_dev(div7, label3);
    			append_dev(label3, t11);
    			append_dev(div7, t12);
    			append_dev(div7, div6);
    			append_dev(div6, input3);
    			set_input_value(input3, /*amountFormatted*/ ctx[5]);
    			/*input3_binding*/ ctx[18](input3);
    			append_dev(fieldset, t13);
    			append_dev(fieldset, p);
    			append_dev(p, t14);
    			append_dev(fieldset, t15);
    			append_dev(fieldset, div9);
    			append_dev(div9, div8);
    			if (if_block) if_block.m(div8, null);
    			append_dev(div8, t16);
    			append_dev(div8, button0);
    			append_dev(button0, t17);
    			append_dev(div8, t18);
    			append_dev(div8, button1);
    			append_dev(button1, t19);
    			input2.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[16]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[17]),
    					listen_dev(input3, "input", /*handleChange*/ ctx[14], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[19], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("txs.transfer.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 8 && t2_value !== (t2_value = /*$_*/ ctx[3]("txs.transfer.sender") + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*account*/ 1 && input0_value_value !== (input0_value_value = /*account*/ ctx[0].account) && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*$_*/ 8 && t5_value !== (t5_value = /*$_*/ ctx[3]("txs.transfer.balance") + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*account*/ 1 && input1_value_value !== (input1_value_value = printCoins(/*account*/ ctx[0].balance)) && input1.value !== input1_value_value) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (dirty & /*$_*/ 8 && t8_value !== (t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*waitingTxs*/ 128) {
    				prop_dev(input2, "disabled", /*waitingTxs*/ ctx[7]);
    			}

    			if (dirty & /*$_*/ 8 && input2_placeholder_value !== (input2_placeholder_value = /*$_*/ ctx[3]("txs.transfer.receiver_placeholder"))) {
    				attr_dev(input2, "placeholder", input2_placeholder_value);
    			}

    			if (dirty & /*receiver*/ 2 && input2.value !== /*receiver*/ ctx[1]) {
    				set_input_value(input2, /*receiver*/ ctx[1]);
    			}

    			if (dirty & /*$_*/ 8 && t11_value !== (t11_value = /*$_*/ ctx[3]("txs.transfer.amount_label") + "")) set_data_dev(t11, t11_value);

    			if (dirty & /*waitingTxs*/ 128) {
    				prop_dev(input3, "disabled", /*waitingTxs*/ ctx[7]);
    			}

    			if (dirty & /*$_*/ 8 && input3_placeholder_value !== (input3_placeholder_value = /*$_*/ ctx[3]("txs.transfer.amount_placeholder"))) {
    				attr_dev(input3, "placeholder", input3_placeholder_value);
    			}

    			if (dirty & /*amountFormatted*/ 32 && input3.value !== /*amountFormatted*/ ctx[5]) {
    				set_input_value(input3, /*amountFormatted*/ ctx[5]);
    			}

    			if (dirty & /*checkMessage, errorMessage*/ 576 && t14_value !== (t14_value = (/*checkMessage*/ ctx[9] || /*errorMessage*/ ctx[6]) + "")) set_data_dev(t14, t14_value);

    			if (/*waitingTxs*/ ctx[7]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					if_block.m(div8, t16);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*waitingTxs, $_*/ 136 && t17_value !== (t17_value = (/*waitingTxs*/ ctx[7]
    			? /*$_*/ ctx[3]("txs.transfer.btn_close")
    			: /*$_*/ ctx[3]("txs.transfer.btn_cancel")) + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*waitingTxs, $_*/ 136 && t19_value !== (t19_value = (/*waitingTxs*/ ctx[7]
    			? /*$_*/ ctx[3]("txs.transfer.await")
    			: /*$_*/ ctx[3]("txs.transfer.btn_next")) + "")) set_data_dev(t19, t19_value);

    			if (dirty & /*waitingTxs, isValidAmount, isReceiverValid*/ 3200 && button1_disabled_value !== (button1_disabled_value = /*waitingTxs*/ ctx[7] || !/*isValidAmount*/ ctx[10] || !/*isReceiverValid*/ ctx[11])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(form);
    			/*input3_binding*/ ctx[18](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(86:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:6) {#if waitingConfirmation}
    function create_if_block$7(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[3]("txs.transfer.confirm_title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[3]("txs.transfer.please_confirm") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[3]("txs.transfer.sender") + "";
    	let t4;
    	let t5;
    	let span0;
    	let t6_value = /*account*/ ctx[0].account + "";
    	let t6;
    	let t7;
    	let p2;
    	let t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "";
    	let t8;
    	let t9;
    	let span1;
    	let t10;
    	let t11;
    	let p3;
    	let t12_value = /*$_*/ ctx[3]("txs.transfer.amount") + "";
    	let t12;
    	let t13;
    	let span2;
    	let t14_value = printUnscaledCoins(/*amount*/ ctx[2]) + "";
    	let t14;
    	let t15;
    	let p4;
    	let button0;
    	let t16_value = /*$_*/ ctx[3]("txs.transfer.btn_cancel") + "";
    	let t16;
    	let t17;
    	let button1;
    	let t18_value = /*$_*/ ctx[3]("txs.transfer.btn_confirm") + "";
    	let t18;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = text(": ");
    			span0 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			p2 = element("p");
    			t8 = text(t8_value);
    			t9 = text(": ");
    			span1 = element("span");
    			t10 = text(/*receiver*/ ctx[1]);
    			t11 = space();
    			p3 = element("p");
    			t12 = text(t12_value);
    			t13 = text(": ");
    			span2 = element("span");
    			t14 = text(t14_value);
    			t15 = space();
    			p4 = element("p");
    			button0 = element("button");
    			t16 = text(t16_value);
    			t17 = space();
    			button1 = element("button");
    			t18 = text(t18_value);
    			attr_dev(h2, "class", "uk-modal-title uk-text-muted");
    			add_location(h2, file$b, 75, 8, 2470);
    			add_location(p0, file$b, 76, 8, 2559);
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$b, 77, 66, 2668);
    			attr_dev(p1, "class", "uk-text-uppercase");
    			add_location(p1, file$b, 77, 8, 2610);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$b, 78, 68, 2792);
    			attr_dev(p2, "class", "uk-text-uppercase");
    			add_location(p2, file$b, 78, 8, 2732);
    			attr_dev(span2, "class", "uk-text-bold");
    			add_location(span2, file$b, 79, 66, 2907);
    			attr_dev(p3, "class", "uk-text-uppercase");
    			add_location(p3, file$b, 79, 8, 2849);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-margin-right");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$b, 82, 12, 3025);
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$b, 83, 12, 3175);
    			attr_dev(p4, "class", "uk-text-right");
    			add_location(p4, file$b, 81, 8, 2987);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t4);
    			append_dev(p1, t5);
    			append_dev(p1, span0);
    			append_dev(span0, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t8);
    			append_dev(p2, t9);
    			append_dev(p2, span1);
    			append_dev(span1, t10);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p3, anchor);
    			append_dev(p3, t12);
    			append_dev(p3, t13);
    			append_dev(p3, span2);
    			append_dev(span2, t14);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, p4, anchor);
    			append_dev(p4, button0);
    			append_dev(button0, t16);
    			append_dev(p4, t17);
    			append_dev(p4, button1);
    			append_dev(button1, t18);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*cancelClick*/ ctx[12], false, false, false, false),
    					listen_dev(button1, "click", /*confirmClick*/ ctx[13], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("txs.transfer.confirm_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 8 && t2_value !== (t2_value = /*$_*/ ctx[3]("txs.transfer.please_confirm") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 8 && t4_value !== (t4_value = /*$_*/ ctx[3]("txs.transfer.sender") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*account*/ 1 && t6_value !== (t6_value = /*account*/ ctx[0].account + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 8 && t8_value !== (t8_value = /*$_*/ ctx[3]("txs.transfer.receiver") + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*receiver*/ 2) set_data_dev(t10, /*receiver*/ ctx[1]);
    			if (dirty & /*$_*/ 8 && t12_value !== (t12_value = /*$_*/ ctx[3]("txs.transfer.amount") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*amount*/ 4 && t14_value !== (t14_value = printUnscaledCoins(/*amount*/ ctx[2]) + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*$_*/ 8 && t16_value !== (t16_value = /*$_*/ ctx[3]("txs.transfer.btn_cancel") + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*$_*/ 8 && t18_value !== (t18_value = /*$_*/ ctx[3]("txs.transfer.btn_confirm") + "")) set_data_dev(t18, t18_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(p4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(75:6) {#if waitingConfirmation}",
    		ctx
    	});

    	return block;
    }

    // (147:16) {#if waitingTxs}
    function create_if_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "ratio: 0.8");
    			set_style(span, "margin", "0px 10px 0px 0px");
    			add_location(span, file$b, 147, 18, 5856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(147:16) {#if waitingTxs}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let main;
    	let div1;
    	let div0;

    	function select_block_type(ctx, dirty) {
    		if (/*waitingConfirmation*/ ctx[8]) return create_if_block$7;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "uk-modal-dialog uk-modal-body");
    			add_location(div0, file$b, 73, 4, 2386);
    			attr_dev(div1, "id", "coinTransferDialog");
    			attr_dev(div1, "uk-modal", "");
    			add_location(div1, file$b, 72, 2, 2343);
    			add_location(main, file$b, 71, 0, 2334);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			if_block.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const re = /[a-fA-F0-9]{32}/i;

    function instance$b($$self, $$props, $$invalidate) {
    	let isReceiverValid;
    	let isValidAmount;
    	let checkMessage;
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(3, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TransferDialog', slots, []);
    	let { account } = $$props;

    	let { onSuccess = () => {
    		
    	} } = $$props;

    	const errorDic = {
    		"120127": $_("txs.transfer.error_slow_wallet"),
    		"1004": $_("txs.transfer.error_account_does_not_exist")
    	};

    	let receiver;
    	let amountInput;
    	let amount = 0;
    	let amountFormatted = "";
    	let errorMessage = "";
    	let waitingTxs = false;
    	let waitingConfirmation = false;

    	const transferCoins = () => {
    		$$invalidate(7, waitingTxs = true);

    		i$1("coin_transfer", { receiver: receiver.trim(), amount }).then(res => {
    			responses.set(JSON.stringify(res));
    			notify_success($_("txs.transfer.success"));
    			$$invalidate(7, waitingTxs = false);
    			$$invalidate(2, amount = null);
    			$$invalidate(5, amountFormatted = "");
    			$$invalidate(1, receiver = null);

    			// callback
    			onSuccess();

    			// close modal
    			uikit.modal('#coinTransferDialog').hide();
    		}).catch(error => {
    			$$invalidate(6, errorMessage = errorDic[error.msg]
    			? errorDic[error.msg]
    			: $_("txs.transfer.failed", { values: { code: error.msg } }));

    			$$invalidate(7, waitingTxs = false);
    		});
    	};

    	const cancelClick = () => {
    		$$invalidate(8, waitingConfirmation = false);
    	};

    	const confirmClick = () => {
    		$$invalidate(8, waitingConfirmation = false);
    		transferCoins();
    	};

    	const handleChange = () => {
    		let cleanedInput = amountInput.value.replace(/\D*/gm, '').replace(/^0+/gm, ''); // remove non digits
    		// remove leading zeros 

    		if (cleanedInput.length === 0) {
    			$$invalidate(2, amount = 0);
    			$$invalidate(5, amountFormatted = '');
    		} else {
    			$$invalidate(2, amount = parseInt(cleanedInput));
    			$$invalidate(5, amountFormatted = printUnscaledCoins(amount, 0, 0));
    		}
    	};

    	$$self.$$.on_mount.push(function () {
    		if (account === undefined && !('account' in $$props || $$self.$$.bound[$$self.$$.props['account']])) {
    			console.warn("<TransferDialog> was created without expected prop 'account'");
    		}
    	});

    	const writable_props = ['account', 'onSuccess'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TransferDialog> was created with unknown prop '${key}'`);
    	});

    	function input2_input_handler() {
    		receiver = this.value;
    		$$invalidate(1, receiver);
    	}

    	function input3_input_handler() {
    		amountFormatted = this.value;
    		$$invalidate(5, amountFormatted);
    	}

    	function input3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			amountInput = $$value;
    			$$invalidate(4, amountInput);
    		});
    	}

    	const click_handler = () => $$invalidate(8, waitingConfirmation = true);

    	$$self.$$set = $$props => {
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    		if ('onSuccess' in $$props) $$invalidate(15, onSuccess = $$props.onSuccess);
    	};

    	$$self.$capture_state = () => ({
    		_: $format,
    		responses,
    		notify_success,
    		invoke: i$1,
    		UIkit: uikit,
    		unscaledCoins,
    		printUnscaledCoins,
    		printCoins,
    		account,
    		onSuccess,
    		errorDic,
    		receiver,
    		amountInput,
    		amount,
    		amountFormatted,
    		errorMessage,
    		waitingTxs,
    		waitingConfirmation,
    		re,
    		transferCoins,
    		cancelClick,
    		confirmClick,
    		handleChange,
    		checkMessage,
    		isValidAmount,
    		isReceiverValid,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    		if ('onSuccess' in $$props) $$invalidate(15, onSuccess = $$props.onSuccess);
    		if ('receiver' in $$props) $$invalidate(1, receiver = $$props.receiver);
    		if ('amountInput' in $$props) $$invalidate(4, amountInput = $$props.amountInput);
    		if ('amount' in $$props) $$invalidate(2, amount = $$props.amount);
    		if ('amountFormatted' in $$props) $$invalidate(5, amountFormatted = $$props.amountFormatted);
    		if ('errorMessage' in $$props) $$invalidate(6, errorMessage = $$props.errorMessage);
    		if ('waitingTxs' in $$props) $$invalidate(7, waitingTxs = $$props.waitingTxs);
    		if ('waitingConfirmation' in $$props) $$invalidate(8, waitingConfirmation = $$props.waitingConfirmation);
    		if ('checkMessage' in $$props) $$invalidate(9, checkMessage = $$props.checkMessage);
    		if ('isValidAmount' in $$props) $$invalidate(10, isValidAmount = $$props.isValidAmount);
    		if ('isReceiverValid' in $$props) $$invalidate(11, isReceiverValid = $$props.isReceiverValid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*receiver, account*/ 3) {
    			$$invalidate(11, isReceiverValid = receiver && re.test(receiver) && receiver != account.account);
    		}

    		if ($$self.$$.dirty & /*amount, account*/ 5) {
    			$$invalidate(10, isValidAmount = amount > 0 && amount < unscaledCoins(account.balance));
    		}

    		if ($$self.$$.dirty & /*amount, account, $_, receiver*/ 15) {
    			$$invalidate(9, checkMessage = amount > unscaledCoins(account.balance)
    			? $_("txs.transfer.error_amount_greater_than_balance")
    			: receiver && receiver.toUpperCase() == account.account.toUpperCase()
    				? $_("txs.transfer.error_receiver_equals_sender")
    				: "");
    		}
    	};

    	return [
    		account,
    		receiver,
    		amount,
    		$_,
    		amountInput,
    		amountFormatted,
    		errorMessage,
    		waitingTxs,
    		waitingConfirmation,
    		checkMessage,
    		isValidAmount,
    		isReceiverValid,
    		cancelClick,
    		confirmClick,
    		handleChange,
    		onSuccess,
    		input2_input_handler,
    		input3_input_handler,
    		input3_binding,
    		click_handler
    	];
    }

    class TransferDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$b, create_fragment$b, safe_not_equal, { account: 0, onSuccess: 15 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TransferDialog",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get account() {
    		throw new Error("<TransferDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set account(value) {
    		throw new Error("<TransferDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onSuccess() {
    		throw new Error("<TransferDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSuccess(value) {
    		throw new Error("<TransferDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/txs/Transactions.svelte generated by Svelte v3.59.2 */
    const file$a = "src/components/txs/Transactions.svelte";

    // (46:2) {:else}
    function create_else_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(46:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (27:2) {#if account}
    function create_if_block$6(ctx) {
    	let div1;
    	let div0;
    	let h40;
    	let span0;
    	let t0_value = /*$_*/ ctx[1]("txs.account") + "";
    	let t0;
    	let t1;
    	let t2;
    	let span1;
    	let t3_value = /*account*/ ctx[0].account + "";
    	let t3;
    	let t4;
    	let h41;
    	let span2;
    	let t5_value = /*$_*/ ctx[1]("txs.balance") + "";
    	let t5;
    	let t6;
    	let t7;
    	let span3;
    	let t8_value = printCoins(/*account*/ ctx[0].balance) + "";
    	let t8;
    	let t9;
    	let button0;
    	let t10_value = /*$_*/ ctx[1]("txs.btn_onboard") + "";
    	let t10;
    	let t11;
    	let button1;
    	let t12_value = /*$_*/ ctx[1]("txs.btn_transfer") + "";
    	let t12;
    	let t13;
    	let onboarddialog;
    	let t14;
    	let transferdialog;
    	let current;

    	onboarddialog = new OnboardDialog({
    			props: {
    				account: /*account*/ ctx[0],
    				onSuccess: /*onSuccess*/ ctx[2]
    			},
    			$$inline: true
    		});

    	transferdialog = new TransferDialog({
    			props: {
    				account: /*account*/ ctx[0],
    				onSuccess: /*onSuccess*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h40 = element("h4");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text(":");
    			t2 = space();
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			h41 = element("h4");
    			span2 = element("span");
    			t5 = text(t5_value);
    			t6 = text(":");
    			t7 = space();
    			span3 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			button0 = element("button");
    			t10 = text(t10_value);
    			t11 = space();
    			button1 = element("button");
    			t12 = text(t12_value);
    			t13 = space();
    			create_component(onboarddialog.$$.fragment);
    			t14 = space();
    			create_component(transferdialog.$$.fragment);
    			attr_dev(span0, "class", "uk-text-uppercase");
    			add_location(span0, file$a, 30, 10, 901);
    			attr_dev(span1, "class", "uk-text-bold uk-text-uppercase");
    			add_location(span1, file$a, 31, 10, 973);
    			attr_dev(h40, "class", "uk-text-muted");
    			add_location(h40, file$a, 29, 8, 864);
    			attr_dev(span2, "class", "uk-text-uppercase");
    			add_location(span2, file$a, 35, 10, 1103);
    			attr_dev(span3, "class", "uk-text-bold");
    			add_location(span3, file$a, 36, 10, 1174);
    			attr_dev(h41, "class", "uk-text-muted");
    			add_location(h41, file$a, 34, 8, 1066);
    			attr_dev(div0, "class", "uk-section");
    			add_location(div0, file$a, 28, 6, 831);
    			attr_dev(button0, "uk-toggle", "target: #onboardDialog");
    			attr_dev(button0, "class", "uk-button uk-button-default uk-margin-right");
    			add_location(button0, file$a, 40, 6, 1276);
    			attr_dev(button1, "uk-toggle", "target: #coinTransferDialog");
    			attr_dev(button1, "class", "uk-button uk-button-primary");
    			add_location(button1, file$a, 41, 6, 1410);
    			attr_dev(div1, "class", "uk-text-center");
    			add_location(div1, file$a, 27, 4, 796);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h40);
    			append_dev(h40, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(h40, t2);
    			append_dev(h40, span1);
    			append_dev(span1, t3);
    			append_dev(div0, t4);
    			append_dev(div0, h41);
    			append_dev(h41, span2);
    			append_dev(span2, t5);
    			append_dev(span2, t6);
    			append_dev(h41, t7);
    			append_dev(h41, span3);
    			append_dev(span3, t8);
    			append_dev(div1, t9);
    			append_dev(div1, button0);
    			append_dev(button0, t10);
    			append_dev(div1, t11);
    			append_dev(div1, button1);
    			append_dev(button1, t12);
    			insert_dev(target, t13, anchor);
    			mount_component(onboarddialog, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(transferdialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("txs.account") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*account*/ 1) && t3_value !== (t3_value = /*account*/ ctx[0].account + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*$_*/ 2) && t5_value !== (t5_value = /*$_*/ ctx[1]("txs.balance") + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*account*/ 1) && t8_value !== (t8_value = printCoins(/*account*/ ctx[0].balance) + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*$_*/ 2) && t10_value !== (t10_value = /*$_*/ ctx[1]("txs.btn_onboard") + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*$_*/ 2) && t12_value !== (t12_value = /*$_*/ ctx[1]("txs.btn_transfer") + "")) set_data_dev(t12, t12_value);
    			const onboarddialog_changes = {};
    			if (dirty & /*account*/ 1) onboarddialog_changes.account = /*account*/ ctx[0];
    			onboarddialog.$set(onboarddialog_changes);
    			const transferdialog_changes = {};
    			if (dirty & /*account*/ 1) transferdialog_changes.account = /*account*/ ctx[0];
    			transferdialog.$set(transferdialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(onboarddialog.$$.fragment, local);
    			transition_in(transferdialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(onboarddialog.$$.fragment, local);
    			transition_out(transferdialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t13);
    			destroy_component(onboarddialog, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(transferdialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(27:2) {#if account}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let main;
    	let div;
    	let h2;
    	let t0_value = /*$_*/ ctx[1]("nav.transactions") + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*account*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$a, 22, 4, 654);
    			attr_dev(div, "class", "uk-flex uk-flex-center");
    			add_location(div, file$a, 21, 2, 613);
    			add_location(main, file$a, 20, 0, 604);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			append_dev(div, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			if_blocks[current_block_type_index].m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 2) && t0_value !== (t0_value = /*$_*/ ctx[1]("nav.transactions") + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(main, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Transactions', slots, []);
    	let account;
    	let unsubs;

    	onMount(async () => {
    		unsubs = signingAccount.subscribe(obj => $$invalidate(0, account = obj));
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	const onSuccess = () => {
    		checkSigningAccountBalance();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Transactions> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		_: $format,
    		onDestroy,
    		onMount,
    		signingAccount,
    		OnboardDialog,
    		printCoins,
    		checkSigningAccountBalance,
    		TransferDialog,
    		account,
    		unsubs,
    		onSuccess,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('account' in $$props) $$invalidate(0, account = $$props.account);
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [account, $_, onSuccess];
    }

    class Transactions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Transactions",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/components/events/PageNumber.svelte generated by Svelte v3.59.2 */

    const file$9 = "src/components/events/PageNumber.svelte";

    function create_fragment$9(ctx) {
    	let a;
    	let div;
    	let span;
    	let t;
    	let div_class_value;
    	let a_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			div = element("div");
    			span = element("span");
    			t = text(/*number*/ ctx[1]);
    			attr_dev(span, "class", "page-index-number svelte-x6ry1i");
    			add_location(span, file$9, 6, 4, 286);

    			attr_dev(div, "class", div_class_value = "uk-text-center page-index " + (/*number*/ ctx[1] == /*index*/ ctx[0]
    			? 'page-index-selected'
    			: 'page-index-not-selected') + " svelte-x6ry1i");

    			add_location(div, file$9, 5, 2, 170);
    			attr_dev(a, "id", a_id_value = "pageIndex" + /*number*/ ctx[1]);
    			attr_dev(a, "class", "uk-align-left page-index-link svelte-x6ry1i");
    			add_location(a, file$9, 4, 0, 66);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div);
    			append_dev(div, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*number*/ 2) set_data_dev(t, /*number*/ ctx[1]);

    			if (dirty & /*number, index*/ 3 && div_class_value !== (div_class_value = "uk-text-center page-index " + (/*number*/ ctx[1] == /*index*/ ctx[0]
    			? 'page-index-selected'
    			: 'page-index-not-selected') + " svelte-x6ry1i")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*number*/ 2 && a_id_value !== (a_id_value = "pageIndex" + /*number*/ ctx[1])) {
    				attr_dev(a, "id", a_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PageNumber', slots, []);
    	let { number } = $$props;
    	let { index } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (number === undefined && !('number' in $$props || $$self.$$.bound[$$self.$$.props['number']])) {
    			console.warn("<PageNumber> was created without expected prop 'number'");
    		}

    		if (index === undefined && !('index' in $$props || $$self.$$.bound[$$self.$$.props['index']])) {
    			console.warn("<PageNumber> was created without expected prop 'index'");
    		}
    	});

    	const writable_props = ['number', 'index'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PageNumber> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, index = number);

    	$$self.$$set = $$props => {
    		if ('number' in $$props) $$invalidate(1, number = $$props.number);
    		if ('index' in $$props) $$invalidate(0, index = $$props.index);
    	};

    	$$self.$capture_state = () => ({ number, index });

    	$$self.$inject_state = $$props => {
    		if ('number' in $$props) $$invalidate(1, number = $$props.number);
    		if ('index' in $$props) $$invalidate(0, index = $$props.index);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [index, number, click_handler];
    }

    class PageNumber extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, { number: 1, index: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PageNumber",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get number() {
    		throw new Error("<PageNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set number(value) {
    		throw new Error("<PageNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<PageNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<PageNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/events/EventsTable.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1 } = globals;
    const file$8 = "src/components/events/EventsTable.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    // (52:6) {#each pages[pageIndex] as event}
    function create_each_block_1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*event*/ ctx[29].transaction_version + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*formatEventType*/ ctx[5](/*event*/ ctx[29].data.type) + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = printCoins(/*event*/ ctx[29].data.amount.amount) + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*event*/ ctx[29].data.sender + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*event*/ ctx[29].data.receiver + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text(t8_value);
    			t9 = space();
    			attr_dev(td0, "class", "uk-text-right");
    			add_location(td0, file$8, 53, 10, 1543);
    			attr_dev(td1, "class", "uk-text-center");
    			add_location(td1, file$8, 54, 10, 1612);
    			attr_dev(td2, "class", "uk-text-right");
    			add_location(td2, file$8, 55, 10, 1689);
    			attr_dev(td3, "class", "uk-text-center");
    			add_location(td3, file$8, 56, 10, 1769);
    			attr_dev(td4, "class", "uk-text-center");
    			add_location(td4, file$8, 57, 10, 1831);
    			add_location(tr, file$8, 52, 8, 1528);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pages, pageIndex*/ 3 && t0_value !== (t0_value = /*event*/ ctx[29].transaction_version + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*pages, pageIndex*/ 3 && t2_value !== (t2_value = /*formatEventType*/ ctx[5](/*event*/ ctx[29].data.type) + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*pages, pageIndex*/ 3 && t4_value !== (t4_value = printCoins(/*event*/ ctx[29].data.amount.amount) + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*pages, pageIndex*/ 3 && t6_value !== (t6_value = /*event*/ ctx[29].data.sender + "")) set_data_dev(t6, t6_value);
    			if (dirty[0] & /*pages, pageIndex*/ 3 && t8_value !== (t8_value = /*event*/ ctx[29].data.receiver + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(52:6) {#each pages[pageIndex] as event}",
    		ctx
    	});

    	return block;
    }

    // (79:2) {#if Object.keys(pages).length > 1}
    function create_if_block$5(ctx) {
    	let div1;
    	let a0;
    	let span0;
    	let t0;
    	let div0;
    	let show_if;
    	let show_if_1;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let a1;
    	let span1;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$2, create_if_block_2, create_if_block_3, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*pages*/ 2) show_if = null;
    		if (dirty[0] & /*pages, pageIndex*/ 3) show_if_1 = null;
    		if (show_if == null) show_if = !!(Object.keys(/*pages*/ ctx[1]).length <= 7);
    		if (show_if) return 0;
    		if (/*pageIndex*/ ctx[0] <= 4) return 1;
    		if (show_if_1 == null) show_if_1 = !!(Object.keys(/*pages*/ ctx[1]).length - /*pageIndex*/ ctx[0] < 4);
    		if (show_if_1) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx, [-1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			a0 = element("a");
    			span0 = element("span");
    			t0 = space();
    			div0 = element("div");
    			if_block.c();
    			t1 = space();
    			a1 = element("a");
    			span1 = element("span");
    			attr_dev(span0, "uk-icon", "chevron-left");
    			add_location(span0, file$8, 85, 8, 2360);
    			attr_dev(a0, "href", '#');
    			attr_dev(a0, "class", "previous-page-btn uk-align-left uk-text-center svelte-1022rtd");
    			add_location(a0, file$8, 80, 6, 2219);
    			attr_dev(div0, "class", "page-numbers-container uk-align-left  svelte-1022rtd");
    			add_location(div0, file$8, 87, 6, 2414);
    			attr_dev(span1, "uk-icon", "chevron-right");
    			add_location(span1, file$8, 127, 8, 4528);
    			attr_dev(a1, "href", '#');
    			attr_dev(a1, "class", "next-page-btn uk-align-left uk-text-center svelte-1022rtd");
    			add_location(a1, file$8, 122, 6, 4397);
    			attr_dev(div1, "class", "pagination-container uk-text-center svelte-1022rtd");
    			add_location(div1, file$8, 79, 4, 2163);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a0);
    			append_dev(a0, span0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div1, t1);
    			append_dev(div1, a1);
    			append_dev(a1, span1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*previousPageClick*/ ctx[3], false, false, false, false),
    					listen_dev(a1, "click", /*nextPageClick*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(79:2) {#if Object.keys(pages).length > 1}",
    		ctx
    	});

    	return block;
    }

    // (113:8) {:else}
    function create_else_block$2(ctx) {
    	let pagenumber0;
    	let updating_index;
    	let t0;
    	let div0;
    	let t2;
    	let pagenumber1;
    	let updating_index_1;
    	let t3;
    	let pagenumber2;
    	let updating_index_2;
    	let t4;
    	let pagenumber3;
    	let updating_index_3;
    	let t5;
    	let div1;
    	let t7;
    	let pagenumber4;
    	let updating_index_4;
    	let current;

    	function pagenumber0_index_binding_2(value) {
    		/*pagenumber0_index_binding_2*/ ctx[20](value);
    	}

    	let pagenumber0_props = { number: 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber0_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber0 = new PageNumber({ props: pagenumber0_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber0, 'index', pagenumber0_index_binding_2));

    	function pagenumber1_index_binding_2(value) {
    		/*pagenumber1_index_binding_2*/ ctx[21](value);
    	}

    	let pagenumber1_props = { number: /*pageIndex*/ ctx[0] - 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber1_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber1 = new PageNumber({ props: pagenumber1_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber1, 'index', pagenumber1_index_binding_2));

    	function pagenumber2_index_binding_2(value) {
    		/*pagenumber2_index_binding_2*/ ctx[22](value);
    	}

    	let pagenumber2_props = { number: /*pageIndex*/ ctx[0] };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber2_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber2 = new PageNumber({ props: pagenumber2_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber2, 'index', pagenumber2_index_binding_2));

    	function pagenumber3_index_binding_2(value) {
    		/*pagenumber3_index_binding_2*/ ctx[23](value);
    	}

    	let pagenumber3_props = { number: /*pageIndex*/ ctx[0] + 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber3_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber3 = new PageNumber({ props: pagenumber3_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber3, 'index', pagenumber3_index_binding_2));

    	function pagenumber4_index_binding_2(value) {
    		/*pagenumber4_index_binding_2*/ ctx[24](value);
    	}

    	let pagenumber4_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber4_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber4 = new PageNumber({ props: pagenumber4_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber4, 'index', pagenumber4_index_binding_2));

    	const block = {
    		c: function create() {
    			create_component(pagenumber0.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "...";
    			t2 = space();
    			create_component(pagenumber1.$$.fragment);
    			t3 = space();
    			create_component(pagenumber2.$$.fragment);
    			t4 = space();
    			create_component(pagenumber3.$$.fragment);
    			t5 = space();
    			div1 = element("div");
    			div1.textContent = "...";
    			t7 = space();
    			create_component(pagenumber4.$$.fragment);
    			attr_dev(div0, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div0, file$8, 114, 10, 3938);
    			attr_dev(div1, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div1, file$8, 118, 10, 4219);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pagenumber1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pagenumber2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(pagenumber3, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(pagenumber4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber0_changes = {};

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber0_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber0.$set(pagenumber0_changes);
    			const pagenumber1_changes = {};
    			if (dirty[0] & /*pageIndex*/ 1) pagenumber1_changes.number = /*pageIndex*/ ctx[0] - 1;

    			if (!updating_index_1 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_1 = true;
    				pagenumber1_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_1 = false);
    			}

    			pagenumber1.$set(pagenumber1_changes);
    			const pagenumber2_changes = {};
    			if (dirty[0] & /*pageIndex*/ 1) pagenumber2_changes.number = /*pageIndex*/ ctx[0];

    			if (!updating_index_2 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_2 = true;
    				pagenumber2_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_2 = false);
    			}

    			pagenumber2.$set(pagenumber2_changes);
    			const pagenumber3_changes = {};
    			if (dirty[0] & /*pageIndex*/ 1) pagenumber3_changes.number = /*pageIndex*/ ctx[0] + 1;

    			if (!updating_index_3 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_3 = true;
    				pagenumber3_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_3 = false);
    			}

    			pagenumber3.$set(pagenumber3_changes);
    			const pagenumber4_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber4_changes.number = Object.keys(/*pages*/ ctx[1]).length;

    			if (!updating_index_4 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_4 = true;
    				pagenumber4_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_4 = false);
    			}

    			pagenumber4.$set(pagenumber4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber0.$$.fragment, local);
    			transition_in(pagenumber1.$$.fragment, local);
    			transition_in(pagenumber2.$$.fragment, local);
    			transition_in(pagenumber3.$$.fragment, local);
    			transition_in(pagenumber4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber0.$$.fragment, local);
    			transition_out(pagenumber1.$$.fragment, local);
    			transition_out(pagenumber2.$$.fragment, local);
    			transition_out(pagenumber3.$$.fragment, local);
    			transition_out(pagenumber4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			destroy_component(pagenumber1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pagenumber2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(pagenumber3, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			destroy_component(pagenumber4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(113:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (104:60) 
    function create_if_block_3(ctx) {
    	let pagenumber0;
    	let updating_index;
    	let t0;
    	let div;
    	let t2;
    	let pagenumber1;
    	let updating_index_1;
    	let t3;
    	let pagenumber2;
    	let updating_index_2;
    	let t4;
    	let pagenumber3;
    	let updating_index_3;
    	let t5;
    	let pagenumber4;
    	let updating_index_4;
    	let t6;
    	let pagenumber5;
    	let updating_index_5;
    	let current;

    	function pagenumber0_index_binding_1(value) {
    		/*pagenumber0_index_binding_1*/ ctx[14](value);
    	}

    	let pagenumber0_props = { number: 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber0_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber0 = new PageNumber({ props: pagenumber0_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber0, 'index', pagenumber0_index_binding_1));

    	function pagenumber1_index_binding_1(value) {
    		/*pagenumber1_index_binding_1*/ ctx[15](value);
    	}

    	let pagenumber1_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length - 4
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber1_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber1 = new PageNumber({ props: pagenumber1_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber1, 'index', pagenumber1_index_binding_1));

    	function pagenumber2_index_binding_1(value) {
    		/*pagenumber2_index_binding_1*/ ctx[16](value);
    	}

    	let pagenumber2_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length - 3
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber2_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber2 = new PageNumber({ props: pagenumber2_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber2, 'index', pagenumber2_index_binding_1));

    	function pagenumber3_index_binding_1(value) {
    		/*pagenumber3_index_binding_1*/ ctx[17](value);
    	}

    	let pagenumber3_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length - 2
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber3_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber3 = new PageNumber({ props: pagenumber3_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber3, 'index', pagenumber3_index_binding_1));

    	function pagenumber4_index_binding_1(value) {
    		/*pagenumber4_index_binding_1*/ ctx[18](value);
    	}

    	let pagenumber4_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length - 1
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber4_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber4 = new PageNumber({ props: pagenumber4_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber4, 'index', pagenumber4_index_binding_1));

    	function pagenumber5_index_binding_1(value) {
    		/*pagenumber5_index_binding_1*/ ctx[19](value);
    	}

    	let pagenumber5_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber5_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber5 = new PageNumber({ props: pagenumber5_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber5, 'index', pagenumber5_index_binding_1));

    	const block = {
    		c: function create() {
    			create_component(pagenumber0.$$.fragment);
    			t0 = space();
    			div = element("div");
    			div.textContent = "...";
    			t2 = space();
    			create_component(pagenumber1.$$.fragment);
    			t3 = space();
    			create_component(pagenumber2.$$.fragment);
    			t4 = space();
    			create_component(pagenumber3.$$.fragment);
    			t5 = space();
    			create_component(pagenumber4.$$.fragment);
    			t6 = space();
    			create_component(pagenumber5.$$.fragment);
    			attr_dev(div, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div, file$8, 105, 10, 3336);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pagenumber1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pagenumber2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(pagenumber3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(pagenumber4, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(pagenumber5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber0_changes = {};

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber0_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber0.$set(pagenumber0_changes);
    			const pagenumber1_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber1_changes.number = Object.keys(/*pages*/ ctx[1]).length - 4;

    			if (!updating_index_1 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_1 = true;
    				pagenumber1_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_1 = false);
    			}

    			pagenumber1.$set(pagenumber1_changes);
    			const pagenumber2_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber2_changes.number = Object.keys(/*pages*/ ctx[1]).length - 3;

    			if (!updating_index_2 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_2 = true;
    				pagenumber2_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_2 = false);
    			}

    			pagenumber2.$set(pagenumber2_changes);
    			const pagenumber3_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber3_changes.number = Object.keys(/*pages*/ ctx[1]).length - 2;

    			if (!updating_index_3 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_3 = true;
    				pagenumber3_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_3 = false);
    			}

    			pagenumber3.$set(pagenumber3_changes);
    			const pagenumber4_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber4_changes.number = Object.keys(/*pages*/ ctx[1]).length - 1;

    			if (!updating_index_4 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_4 = true;
    				pagenumber4_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_4 = false);
    			}

    			pagenumber4.$set(pagenumber4_changes);
    			const pagenumber5_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber5_changes.number = Object.keys(/*pages*/ ctx[1]).length;

    			if (!updating_index_5 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_5 = true;
    				pagenumber5_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_5 = false);
    			}

    			pagenumber5.$set(pagenumber5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber0.$$.fragment, local);
    			transition_in(pagenumber1.$$.fragment, local);
    			transition_in(pagenumber2.$$.fragment, local);
    			transition_in(pagenumber3.$$.fragment, local);
    			transition_in(pagenumber4.$$.fragment, local);
    			transition_in(pagenumber5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber0.$$.fragment, local);
    			transition_out(pagenumber1.$$.fragment, local);
    			transition_out(pagenumber2.$$.fragment, local);
    			transition_out(pagenumber3.$$.fragment, local);
    			transition_out(pagenumber4.$$.fragment, local);
    			transition_out(pagenumber5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);
    			destroy_component(pagenumber1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pagenumber2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(pagenumber3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(pagenumber4, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(pagenumber5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(104:60) ",
    		ctx
    	});

    	return block;
    }

    // (95:33) 
    function create_if_block_2(ctx) {
    	let pagenumber0;
    	let updating_index;
    	let t0;
    	let pagenumber1;
    	let updating_index_1;
    	let t1;
    	let pagenumber2;
    	let updating_index_2;
    	let t2;
    	let pagenumber3;
    	let updating_index_3;
    	let t3;
    	let pagenumber4;
    	let updating_index_4;
    	let t4;
    	let div;
    	let t6;
    	let pagenumber5;
    	let updating_index_5;
    	let current;

    	function pagenumber0_index_binding(value) {
    		/*pagenumber0_index_binding*/ ctx[8](value);
    	}

    	let pagenumber0_props = { number: 1 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber0_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber0 = new PageNumber({ props: pagenumber0_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber0, 'index', pagenumber0_index_binding));

    	function pagenumber1_index_binding(value) {
    		/*pagenumber1_index_binding*/ ctx[9](value);
    	}

    	let pagenumber1_props = { number: 2 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber1_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber1 = new PageNumber({ props: pagenumber1_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber1, 'index', pagenumber1_index_binding));

    	function pagenumber2_index_binding(value) {
    		/*pagenumber2_index_binding*/ ctx[10](value);
    	}

    	let pagenumber2_props = { number: 3 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber2_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber2 = new PageNumber({ props: pagenumber2_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber2, 'index', pagenumber2_index_binding));

    	function pagenumber3_index_binding(value) {
    		/*pagenumber3_index_binding*/ ctx[11](value);
    	}

    	let pagenumber3_props = { number: 4 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber3_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber3 = new PageNumber({ props: pagenumber3_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber3, 'index', pagenumber3_index_binding));

    	function pagenumber4_index_binding(value) {
    		/*pagenumber4_index_binding*/ ctx[12](value);
    	}

    	let pagenumber4_props = { number: 5 };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber4_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber4 = new PageNumber({ props: pagenumber4_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber4, 'index', pagenumber4_index_binding));

    	function pagenumber5_index_binding(value) {
    		/*pagenumber5_index_binding*/ ctx[13](value);
    	}

    	let pagenumber5_props = {
    		number: Object.keys(/*pages*/ ctx[1]).length
    	};

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber5_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber5 = new PageNumber({ props: pagenumber5_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber5, 'index', pagenumber5_index_binding));

    	const block = {
    		c: function create() {
    			create_component(pagenumber0.$$.fragment);
    			t0 = space();
    			create_component(pagenumber1.$$.fragment);
    			t1 = space();
    			create_component(pagenumber2.$$.fragment);
    			t2 = space();
    			create_component(pagenumber3.$$.fragment);
    			t3 = space();
    			create_component(pagenumber4.$$.fragment);
    			t4 = space();
    			div = element("div");
    			div.textContent = "...";
    			t6 = space();
    			create_component(pagenumber5.$$.fragment);
    			attr_dev(div, "class", "uk-text-center uk-align-left reticence svelte-1022rtd");
    			add_location(div, file$8, 100, 10, 3037);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pagenumber1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pagenumber2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pagenumber3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pagenumber4, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(pagenumber5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber0_changes = {};

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber0_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber0.$set(pagenumber0_changes);
    			const pagenumber1_changes = {};

    			if (!updating_index_1 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_1 = true;
    				pagenumber1_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_1 = false);
    			}

    			pagenumber1.$set(pagenumber1_changes);
    			const pagenumber2_changes = {};

    			if (!updating_index_2 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_2 = true;
    				pagenumber2_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_2 = false);
    			}

    			pagenumber2.$set(pagenumber2_changes);
    			const pagenumber3_changes = {};

    			if (!updating_index_3 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_3 = true;
    				pagenumber3_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_3 = false);
    			}

    			pagenumber3.$set(pagenumber3_changes);
    			const pagenumber4_changes = {};

    			if (!updating_index_4 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_4 = true;
    				pagenumber4_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_4 = false);
    			}

    			pagenumber4.$set(pagenumber4_changes);
    			const pagenumber5_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber5_changes.number = Object.keys(/*pages*/ ctx[1]).length;

    			if (!updating_index_5 && dirty[0] & /*pageIndex*/ 1) {
    				updating_index_5 = true;
    				pagenumber5_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index_5 = false);
    			}

    			pagenumber5.$set(pagenumber5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber0.$$.fragment, local);
    			transition_in(pagenumber1.$$.fragment, local);
    			transition_in(pagenumber2.$$.fragment, local);
    			transition_in(pagenumber3.$$.fragment, local);
    			transition_in(pagenumber4.$$.fragment, local);
    			transition_in(pagenumber5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber0.$$.fragment, local);
    			transition_out(pagenumber1.$$.fragment, local);
    			transition_out(pagenumber2.$$.fragment, local);
    			transition_out(pagenumber3.$$.fragment, local);
    			transition_out(pagenumber4.$$.fragment, local);
    			transition_out(pagenumber5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(pagenumber1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pagenumber2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(pagenumber3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pagenumber4, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t6);
    			destroy_component(pagenumber5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(95:33) ",
    		ctx
    	});

    	return block;
    }

    // (90:8) {#if Object.keys(pages).length <= 7}
    function create_if_block_1$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = Object.keys(/*pages*/ ctx[1]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pages, pageIndex*/ 3) {
    				each_value = Object.keys(/*pages*/ ctx[1]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(90:8) {#if Object.keys(pages).length <= 7}",
    		ctx
    	});

    	return block;
    }

    // (91:10) {#each Object.keys(pages) as number}
    function create_each_block$2(ctx) {
    	let pagenumber;
    	let updating_index;
    	let current;

    	function pagenumber_index_binding(value) {
    		/*pagenumber_index_binding*/ ctx[7](value);
    	}

    	let pagenumber_props = { number: Number(/*number*/ ctx[26]) };

    	if (/*pageIndex*/ ctx[0] !== void 0) {
    		pagenumber_props.index = /*pageIndex*/ ctx[0];
    	}

    	pagenumber = new PageNumber({ props: pagenumber_props, $$inline: true });
    	binding_callbacks.push(() => bind(pagenumber, 'index', pagenumber_index_binding));

    	const block = {
    		c: function create() {
    			create_component(pagenumber.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagenumber, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagenumber_changes = {};
    			if (dirty[0] & /*pages*/ 2) pagenumber_changes.number = Number(/*number*/ ctx[26]);

    			if (!updating_index && dirty[0] & /*pageIndex*/ 1) {
    				updating_index = true;
    				pagenumber_changes.index = /*pageIndex*/ ctx[0];
    				add_flush_callback(() => updating_index = false);
    			}

    			pagenumber.$set(pagenumber_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagenumber.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagenumber.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagenumber, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(91:10) {#each Object.keys(pages) as number}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let main;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0_value = /*$_*/ ctx[2]("events.version") + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*$_*/ ctx[2]("events.type") + "";
    	let t2;
    	let t3;
    	let th2;
    	let t4_value = /*$_*/ ctx[2]("events.amount") + "";
    	let t4;
    	let t5;
    	let th3;
    	let t6_value = /*$_*/ ctx[2]("events.sender") + "";
    	let t6;
    	let t7;
    	let th4;
    	let t8_value = /*$_*/ ctx[2]("events.receiver") + "";
    	let t8;
    	let t9;
    	let tbody;
    	let t10;
    	let show_if = Object.keys(/*pages*/ ctx[1]).length > 1;
    	let current;
    	let each_value_1 = /*pages*/ ctx[1][/*pageIndex*/ ctx[0]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block = show_if && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			t6 = text(t6_value);
    			t7 = space();
    			th4 = element("th");
    			t8 = text(t8_value);
    			t9 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t10 = space();
    			if (if_block) if_block.c();
    			attr_dev(th0, "class", "uk-text-right");
    			add_location(th0, file$8, 43, 8, 1122);
    			attr_dev(th1, "class", "uk-text-center");
    			set_style(th1, "width", "98px");
    			add_location(th1, file$8, 44, 8, 1184);
    			attr_dev(th2, "class", "uk-text-right");
    			add_location(th2, file$8, 45, 8, 1264);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$8, 46, 8, 1325);
    			attr_dev(th4, "class", "uk-text-center");
    			add_location(th4, file$8, 47, 8, 1387);
    			add_location(tr, file$8, 42, 6, 1109);
    			add_location(thead, file$8, 41, 4, 1095);
    			add_location(tbody, file$8, 50, 4, 1472);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$8, 40, 2, 1049);
    			add_location(main, file$8, 38, 0, 1023);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			append_dev(table, t9);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(tbody, null);
    				}
    			}

    			append_dev(main, t10);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*$_*/ 4) && t0_value !== (t0_value = /*$_*/ ctx[2]("events.version") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty[0] & /*$_*/ 4) && t2_value !== (t2_value = /*$_*/ ctx[2]("events.type") + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty[0] & /*$_*/ 4) && t4_value !== (t4_value = /*$_*/ ctx[2]("events.amount") + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty[0] & /*$_*/ 4) && t6_value !== (t6_value = /*$_*/ ctx[2]("events.sender") + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*$_*/ 4) && t8_value !== (t8_value = /*$_*/ ctx[2]("events.receiver") + "")) set_data_dev(t8, t8_value);

    			if (dirty[0] & /*pages, pageIndex, formatEventType*/ 35) {
    				each_value_1 = /*pages*/ ctx[1][/*pageIndex*/ ctx[0]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*pages*/ 2) show_if = Object.keys(/*pages*/ ctx[1]).length > 1;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*pages*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const maxPageSize = 5;

    function splitPages(items, pageSize) {
    	let ret = {};
    	let num = 1;

    	for (let i = 0; i < items.length; i = i + pageSize) {
    		let nextPage = items.slice(i, i + pageSize);
    		ret[num] = nextPage;
    		num++;
    	}

    	return ret;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let pages;
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventsTable', slots, []);
    	let { events } = $$props;

    	const eventTypesDic = {
    		receivedpayment: $_("events.received_payment"),
    		sentpayment: $_("events.sent_payment")
    	};

    	let pageIndex = 1; // [ 1 ... pages length ]

    	function previousPageClick() {
    		if (pageIndex > 1) {
    			$$invalidate(0, pageIndex = pageIndex - 1);
    		}
    	}

    	function nextPageClick() {
    		if (pageIndex < Object.keys(pages).length) {
    			$$invalidate(0, pageIndex = pageIndex + 1);
    		}
    	}

    	function formatEventType(type) {
    		const value = eventTypesDic[type];
    		return value || type;
    	}

    	$$self.$$.on_mount.push(function () {
    		if (events === undefined && !('events' in $$props || $$self.$$.bound[$$self.$$.props['events']])) {
    			console.warn("<EventsTable> was created without expected prop 'events'");
    		}
    	});

    	const writable_props = ['events'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventsTable> was created with unknown prop '${key}'`);
    	});

    	function pagenumber_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber0_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber1_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber2_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber3_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber4_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber5_index_binding(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber0_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber1_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber2_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber3_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber4_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber5_index_binding_1(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber0_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber1_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber2_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber3_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	function pagenumber4_index_binding_2(value) {
    		pageIndex = value;
    		$$invalidate(0, pageIndex);
    	}

    	$$self.$$set = $$props => {
    		if ('events' in $$props) $$invalidate(6, events = $$props.events);
    	};

    	$$self.$capture_state = () => ({
    		_: $format,
    		PageNumber,
    		printCoins,
    		events,
    		maxPageSize,
    		eventTypesDic,
    		pageIndex,
    		splitPages,
    		previousPageClick,
    		nextPageClick,
    		formatEventType,
    		pages,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('events' in $$props) $$invalidate(6, events = $$props.events);
    		if ('pageIndex' in $$props) $$invalidate(0, pageIndex = $$props.pageIndex);
    		if ('pages' in $$props) $$invalidate(1, pages = $$props.pages);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*events*/ 64) {
    			$$invalidate(1, pages = splitPages(events, maxPageSize));
    		}
    	};

    	return [
    		pageIndex,
    		pages,
    		$_,
    		previousPageClick,
    		nextPageClick,
    		formatEventType,
    		events,
    		pagenumber_index_binding,
    		pagenumber0_index_binding,
    		pagenumber1_index_binding,
    		pagenumber2_index_binding,
    		pagenumber3_index_binding,
    		pagenumber4_index_binding,
    		pagenumber5_index_binding,
    		pagenumber0_index_binding_1,
    		pagenumber1_index_binding_1,
    		pagenumber2_index_binding_1,
    		pagenumber3_index_binding_1,
    		pagenumber4_index_binding_1,
    		pagenumber5_index_binding_1,
    		pagenumber0_index_binding_2,
    		pagenumber1_index_binding_2,
    		pagenumber2_index_binding_2,
    		pagenumber3_index_binding_2,
    		pagenumber4_index_binding_2
    	];
    }

    class EventsTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { events: 6 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsTable",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get events() {
    		throw new Error("<EventsTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set events(value) {
    		throw new Error("<EventsTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/events/EventsTableDummy.svelte generated by Svelte v3.59.2 */
    const file$7 = "src/components/events/EventsTableDummy.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (24:6) {#each dummyEvents as event}
    function create_each_block$1(ctx) {
    	let tr;
    	let td0;
    	let span0;
    	let t0_value = /*event*/ ctx[3].version + "";
    	let t0;
    	let t1;
    	let td1;
    	let span1;
    	let t2_value = /*event*/ ctx[3].type + "";
    	let t2;
    	let t3;
    	let td2;
    	let span2;
    	let t4_value = /*event*/ ctx[3].amount + "";
    	let t4;
    	let t5;
    	let td3;
    	let span3;
    	let t6_value = /*event*/ ctx[3].sender + "";
    	let t6;
    	let t7;
    	let td4;
    	let span4;
    	let t8_value = /*event*/ ctx[3].receiver + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			td4 = element("td");
    			span4 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			attr_dev(span0, "class", "dummy-container svelte-1adt5y8");
    			add_location(span0, file$7, 25, 36, 1574);
    			attr_dev(td0, "class", "uk-text-right");
    			add_location(td0, file$7, 25, 10, 1548);
    			attr_dev(span1, "class", "dummy-container svelte-1adt5y8");
    			add_location(span1, file$7, 26, 37, 1669);
    			attr_dev(td1, "class", "uk-text-center");
    			add_location(td1, file$7, 26, 10, 1642);
    			attr_dev(span2, "class", "dummy-container svelte-1adt5y8");
    			add_location(span2, file$7, 27, 36, 1760);
    			attr_dev(td2, "class", "uk-text-right");
    			add_location(td2, file$7, 27, 10, 1734);
    			attr_dev(span3, "class", "dummy-container svelte-1adt5y8");
    			add_location(span3, file$7, 28, 37, 1854);
    			attr_dev(td3, "class", "uk-text-center");
    			add_location(td3, file$7, 28, 10, 1827);
    			attr_dev(span4, "class", "dummy-container svelte-1adt5y8");
    			add_location(span4, file$7, 29, 37, 1948);
    			attr_dev(td4, "class", "uk-text-center");
    			add_location(td4, file$7, 29, 10, 1921);
    			add_location(tr, file$7, 24, 8, 1533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, span0);
    			append_dev(span0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, span1);
    			append_dev(span1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, span2);
    			append_dev(span2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, span3);
    			append_dev(span3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, span4);
    			append_dev(span4, t8);
    			append_dev(tr, t9);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(24:6) {#each dummyEvents as event}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let main;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let span0;
    	let t0_value = /*$_*/ ctx[0]("events.version") + "";
    	let t0;
    	let t1;
    	let th1;
    	let span1;
    	let t2_value = /*$_*/ ctx[0]("events.type") + "";
    	let t2;
    	let t3;
    	let th2;
    	let span2;
    	let t4_value = /*$_*/ ctx[0]("events.amount") + "";
    	let t4;
    	let t5;
    	let th3;
    	let span3;
    	let t6_value = /*$_*/ ctx[0]("events.sender") + "";
    	let t6;
    	let t7;
    	let th4;
    	let span4;
    	let t8_value = /*$_*/ ctx[0]("events.receiver") + "";
    	let t8;
    	let t9;
    	let tbody;
    	let each_value = /*dummyEvents*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			span3 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			th4 = element("th");
    			span4 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span0, "class", "dummy-container svelte-1adt5y8");
    			add_location(span0, file$7, 15, 34, 993);
    			attr_dev(th0, "class", "uk-text-right");
    			add_location(th0, file$7, 15, 8, 967);
    			attr_dev(span1, "class", "dummy-container svelte-1adt5y8");
    			add_location(span1, file$7, 16, 35, 1093);
    			attr_dev(th1, "class", "uk-text-center");
    			add_location(th1, file$7, 16, 8, 1066);
    			attr_dev(span2, "class", "dummy-container svelte-1adt5y8");
    			add_location(span2, file$7, 17, 34, 1189);
    			attr_dev(th2, "class", "uk-text-right");
    			add_location(th2, file$7, 17, 8, 1163);
    			attr_dev(span3, "class", "dummy-container svelte-1adt5y8");
    			add_location(span3, file$7, 18, 35, 1288);
    			attr_dev(th3, "class", "uk-text-center");
    			add_location(th3, file$7, 18, 8, 1261);
    			attr_dev(span4, "class", "dummy-container svelte-1adt5y8");
    			add_location(span4, file$7, 19, 35, 1387);
    			attr_dev(th4, "class", "uk-text-center");
    			add_location(th4, file$7, 19, 8, 1360);
    			add_location(tr, file$7, 14, 6, 954);
    			add_location(thead, file$7, 13, 4, 940);
    			add_location(tbody, file$7, 22, 4, 1482);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$7, 12, 2, 894);
    			add_location(main, file$7, 11, 0, 885);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, span0);
    			append_dev(span0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, span1);
    			append_dev(span1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, span2);
    			append_dev(span2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, span3);
    			append_dev(span3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, span4);
    			append_dev(span4, t8);
    			append_dev(table, t9);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(tbody, null);
    				}
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("events.version") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("events.type") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("events.amount") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("events.sender") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 1 && t8_value !== (t8_value = /*$_*/ ctx[0]("events.receiver") + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*dummyEvents*/ 2) {
    				each_value = /*dummyEvents*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventsTableDummy', slots, []);
    	let received = $_("events.received_payment");

    	let dummyEvents = [
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		},
    		{
    			version: 99999999,
    			type: received,
    			amount: "000.00",
    			sender: "00000000000000000000000000000000",
    			receiver: "00000000000000000000000000000000"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventsTableDummy> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: $format, received, dummyEvents, $_ });

    	$$self.$inject_state = $$props => {
    		if ('received' in $$props) received = $$props.received;
    		if ('dummyEvents' in $$props) $$invalidate(1, dummyEvents = $$props.dummyEvents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$_, dummyEvents];
    }

    class EventsTableDummy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsTableDummy",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/components/events/EventsError.svelte generated by Svelte v3.59.2 */
    const file$6 = "src/components/events/EventsError.svelte";

    function create_fragment$6(ctx) {
    	let main;
    	let div1;
    	let h3;
    	let t0_value = /*$_*/ ctx[1]("events.loading.error") + "";
    	let t0;
    	let t1;
    	let div0;
    	let p;
    	let t2;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			p = element("p");
    			t2 = text(/*loadingError*/ ctx[0]);
    			attr_dev(h3, "class", "uk-card-title uk-text-uppercase uk-text-muted");
    			add_location(h3, file$6, 8, 6, 188);
    			add_location(p, file$6, 10, 8, 302);
    			add_location(div0, file$6, 9, 6, 288);
    			attr_dev(div1, "class", "uk-card uk-card-default uk-card-hover uk-card-body uk-text-muted");
    			add_location(div1, file$6, 7, 4, 103);
    			add_location(main, file$6, 6, 0, 92);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, h3);
    			append_dev(h3, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("events.loading.error") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*loadingError*/ 1) set_data_dev(t2, /*loadingError*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventsError', slots, []);
    	let { loadingError } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (loadingError === undefined && !('loadingError' in $$props || $$self.$$.bound[$$self.$$.props['loadingError']])) {
    			console.warn("<EventsError> was created without expected prop 'loadingError'");
    		}
    	});

    	const writable_props = ['loadingError'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventsError> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('loadingError' in $$props) $$invalidate(0, loadingError = $$props.loadingError);
    	};

    	$$self.$capture_state = () => ({ _: $format, loadingError, $_ });

    	$$self.$inject_state = $$props => {
    		if ('loadingError' in $$props) $$invalidate(0, loadingError = $$props.loadingError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadingError, $_];
    }

    class EventsError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { loadingError: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsError",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get loadingError() {
    		throw new Error("<EventsError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadingError(value) {
    		throw new Error("<EventsError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/events/Events.svelte generated by Svelte v3.59.2 */
    const file$5 = "src/components/events/Events.svelte";

    // (44:4) {:else}
    function create_else_block$1(ctx) {
    	let eventstable;
    	let current;

    	eventstable = new EventsTable({
    			props: { events: /*events*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(eventstable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventstable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventstable_changes = {};
    			if (dirty & /*events*/ 1) eventstable_changes.events = /*events*/ ctx[0];
    			eventstable.$set(eventstable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventstable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventstable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventstable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(44:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:29) 
    function create_if_block_1$1(ctx) {
    	let span;
    	let t;
    	let eventstabledummy;
    	let current;
    	eventstabledummy = new EventsTableDummy({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = space();
    			create_component(eventstabledummy.$$.fragment);
    			attr_dev(span, "uk-spinner", "");
    			set_style(span, "position", "absolute");
    			set_style(span, "top", "0px");
    			set_style(span, "left", "0px");
    			add_location(span, file$5, 41, 6, 1488);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(eventstabledummy, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventstabledummy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventstabledummy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t);
    			destroy_component(eventstabledummy, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(41:29) ",
    		ctx
    	});

    	return block;
    }

    // (39:4) {#if loadingError}
    function create_if_block$4(ctx) {
    	let eventserror;
    	let current;

    	eventserror = new EventsError({
    			props: { loadingError: /*loadingError*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(eventserror.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventserror, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventserror_changes = {};
    			if (dirty & /*loadingError*/ 2) eventserror_changes.loadingError = /*loadingError*/ ctx[1];
    			eventserror.$set(eventserror_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventserror.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventserror.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventserror, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(39:4) {#if loadingError}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let main;
    	let div1;
    	let div0;
    	let h2;
    	let t0_value = /*$_*/ ctx[2]("events.account_events") + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$4, create_if_block_1$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loadingError*/ ctx[1]) return 0;
    		if (/*events*/ ctx[0] == null) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div1 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$5, 36, 6, 1287);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$5, 35, 4, 1244);
    			set_style(div1, "position", "relative");
    			add_location(div1, file$5, 34, 2, 1208);
    			add_location(main, file$5, 33, 0, 1199);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div1, t1);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 4) && t0_value !== (t0_value = /*$_*/ ctx[2]("events.account_events") + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Events', slots, []);
    	let events = null;
    	let myAccount = null;
    	let unsubscribeAccount;
    	let unsubscribeEvents;
    	let loadingError = null;

    	const errors = {
    		"corrupted_db": $_("events.loading.corrupted_db"),
    		"account_not_on_chain": $_("events.loading.account_off_chain")
    	};

    	onMount(async () => {
    		unsubscribeAccount = signingAccount.subscribe(account => {
    			if (myAccount && myAccount.account == account.account) {
    				return;
    			}

    			$$invalidate(1, loadingError = null);
    			myAccount = account;
    			getAccountEvents(myAccount, error => $$invalidate(1, loadingError = errors[error] || error));

    			unsubscribeEvents = accountEvents.subscribe(all => {
    				$$invalidate(0, events = all[myAccount.account]);
    			});
    		});
    	});

    	onDestroy(async () => {
    		unsubscribeAccount && unsubscribeAccount();
    		unsubscribeEvents && unsubscribeEvents();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Events> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		accountEvents,
    		signingAccount,
    		getAccountEvents,
    		EventsTable,
    		EventsTableDummy,
    		_: $format,
    		EventsError,
    		events,
    		myAccount,
    		unsubscribeAccount,
    		unsubscribeEvents,
    		loadingError,
    		errors,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('events' in $$props) $$invalidate(0, events = $$props.events);
    		if ('myAccount' in $$props) myAccount = $$props.myAccount;
    		if ('unsubscribeAccount' in $$props) unsubscribeAccount = $$props.unsubscribeAccount;
    		if ('unsubscribeEvents' in $$props) unsubscribeEvents = $$props.unsubscribeEvents;
    		if ('loadingError' in $$props) $$invalidate(1, loadingError = $$props.loadingError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [events, loadingError, $_];
    }

    class Events extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Events",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    function i(){return r$1(this,void 0,void 0,(function(){function t(){r&&r(),r=void 0;}var r;return o$1(this,(function(n){return [2,new Promise((function(n,i){o("tauri://update-status",(function(o){var a;(a=null==o?void 0:o.payload).error?(t(),i(a.error)):"DONE"===a.status&&(t(),n());})).then((function(t){r=t;})).catch((function(n){throw t(),n})),c$1("tauri://update-install").catch((function(n){throw t(),n}));}))]}))}))}function u(){return r$1(this,void 0,void 0,(function(){function t(){i&&i(),i=void 0;}var i;return o$1(this,(function(n){return [2,new Promise((function(n,u){s$1("tauri://update-available",(function(o){var a;a=null==o?void 0:o.payload,t(),n({manifest:a,shouldUpdate:!0});})).catch((function(n){throw t(),n})),o("tauri://update-status",(function(o){var a;(a=null==o?void 0:o.payload).error?(t(),u(a.error)):"UPTODATE"===a.status&&(t(),n({shouldUpdate:!1}));})).then((function(t){i=t;})).catch((function(n){throw t(),n})),c$1("tauri://update").catch((function(n){throw t(),n}));}))]}))}))}Object.freeze({__proto__:null,installUpdate:i,checkUpdate:u});

    /* src/components/about/About.svelte generated by Svelte v3.59.2 */

    const { console: console_1$2 } = globals;
    const file$4 = "src/components/about/About.svelte";

    function create_fragment$4(ctx) {
    	let main;
    	let div0;
    	let h2;
    	let t0_value = /*$_*/ ctx[1]("about.about") + "";
    	let t0;
    	let t1;
    	let div1;
    	let h3;
    	let t2_value = /*$_*/ ctx[1]("about.release") + "";
    	let t2;
    	let t3;
    	let p0;
    	let span0;
    	let t4_value = /*$_*/ ctx[1]("about.version") + "";
    	let t4;
    	let t5;
    	let t6;
    	let t7_value = /*release*/ ctx[0].version + "";
    	let t7;
    	let t8;
    	let p1;
    	let span1;
    	let t9_value = /*$_*/ ctx[1]("about.commit") + "";
    	let t9;
    	let t10;
    	let t11_value = /*release*/ ctx[0].hash + "";
    	let t11;
    	let t12;
    	let p2;
    	let span2;
    	let t13_value = /*$_*/ ctx[1]("about.branch") + "";
    	let t13;
    	let t14;
    	let t15_value = /*release*/ ctx[0].head + "";
    	let t15;
    	let t16;
    	let div2;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			h3 = element("h3");
    			t2 = text(t2_value);
    			t3 = space();
    			p0 = element("p");
    			span0 = element("span");
    			t4 = text(t4_value);
    			t5 = text(": ");
    			t6 = text("v");
    			t7 = text(t7_value);
    			t8 = space();
    			p1 = element("p");
    			span1 = element("span");
    			t9 = text(t9_value);
    			t10 = text(": ");
    			t11 = text(t11_value);
    			t12 = space();
    			p2 = element("p");
    			span2 = element("span");
    			t13 = text(t13_value);
    			t14 = text(": ");
    			t15 = text(t15_value);
    			t16 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Update";
    			attr_dev(h2, "class", "uk-text-light uk-text-muted uk-text-uppercase");
    			add_location(h2, file$4, 24, 4, 493);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$4, 23, 2, 452);
    			attr_dev(h3, "class", "uk-card-title uk-text-muted");
    			add_location(h3, file$4, 27, 4, 657);
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$4, 29, 6, 760);
    			attr_dev(p0, "class", "uk-text-muted");
    			add_location(p0, file$4, 28, 4, 728);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$4, 32, 6, 881);
    			attr_dev(p1, "class", "uk-text-muted");
    			add_location(p1, file$4, 31, 4, 849);
    			attr_dev(span2, "class", "uk-text-bold");
    			add_location(span2, file$4, 35, 6, 997);
    			attr_dev(p2, "class", "uk-text-muted");
    			add_location(p2, file$4, 34, 4, 965);
    			attr_dev(div1, "class", "uk-card uk-card-default uk-card-body uk-width-1-2@m");
    			add_location(div1, file$4, 26, 2, 587);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			add_location(button, file$4, 40, 4, 1099);
    			add_location(div2, file$4, 39, 2, 1089);
    			attr_dev(main, "class", "uk-height-viewport");
    			add_location(main, file$4, 22, 0, 416);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, h3);
    			append_dev(h3, t2);
    			append_dev(div1, t3);
    			append_dev(div1, p0);
    			append_dev(p0, span0);
    			append_dev(span0, t4);
    			append_dev(span0, t5);
    			append_dev(p0, t6);
    			append_dev(p0, t7);
    			append_dev(div1, t8);
    			append_dev(div1, p1);
    			append_dev(p1, span1);
    			append_dev(span1, t9);
    			append_dev(span1, t10);
    			append_dev(p1, t11);
    			append_dev(div1, t12);
    			append_dev(div1, p2);
    			append_dev(p2, span2);
    			append_dev(span2, t13);
    			append_dev(span2, t14);
    			append_dev(p2, t15);
    			append_dev(main, t16);
    			append_dev(main, div2);
    			append_dev(div2, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*tryUpdate*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("about.about") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 2 && t2_value !== (t2_value = /*$_*/ ctx[1]("about.release") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 2 && t4_value !== (t4_value = /*$_*/ ctx[1]("about.version") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*release*/ 1 && t7_value !== (t7_value = /*release*/ ctx[0].version + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*$_*/ 2 && t9_value !== (t9_value = /*$_*/ ctx[1]("about.commit") + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*release*/ 1 && t11_value !== (t11_value = /*release*/ ctx[0].hash + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*$_*/ 2 && t13_value !== (t13_value = /*$_*/ ctx[1]("about.branch") + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*release*/ 1 && t15_value !== (t15_value = /*release*/ ctx[0].head + "")) set_data_dev(t15, t15_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('About', slots, []);
    	let release = {};

    	onMount(async () => {
    		getVersion();
    		app_version.subscribe(v => $$invalidate(0, release = v));
    	});

    	const tryUpdate = async () => {
    		u().then(r => console.log(r));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		getVersion,
    		app_version,
    		_: $format,
    		checkUpdate: u,
    		release,
    		tryUpdate,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('release' in $$props) $$invalidate(0, release = $$props.release);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [release, $_, tryUpdate];
    }

    class About extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/components/layout/SearchingFullnodes.svelte generated by Svelte v3.59.2 */
    const file$3 = "src/components/layout/SearchingFullnodes.svelte";

    // (11:2) {#if isLoaded && scanning}
    function create_if_block$3(ctx) {
    	let div1;
    	let span;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			span.textContent = "Attempting to connect to blockchain  ";
    			div0 = element("div");
    			attr_dev(span, "class", "uk-text-uppercase");
    			add_location(span, file$3, 12, 6, 415);
    			attr_dev(div0, "uk-spinner", "ratio: 0.5");
    			attr_dev(div0, "class", "uk-padding");
    			add_location(div0, file$3, 12, 83, 492);
    			attr_dev(div1, "class", "uk-background-primary uk-light uk-text-center uk-padding");
    			add_location(div1, file$3, 11, 4, 338);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			append_dev(div1, div0);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(11:2) {#if isLoaded && scanning}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let main;
    	let if_block = /*isLoaded*/ ctx[1] && /*scanning*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$3, 9, 0, 298);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isLoaded*/ ctx[1] && /*scanning*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchingFullnodes', slots, []);
    	let scanning = true;
    	let isLoaded = false;
    	isAccountsLoaded.subscribe(boo => $$invalidate(1, isLoaded = boo));
    	scanning_fullnodes.subscribe(b => $$invalidate(0, scanning = b));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchingFullnodes> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		scanning_fullnodes,
    		isAccountsLoaded,
    		scanning,
    		isLoaded
    	});

    	$$self.$inject_state = $$props => {
    		if ('scanning' in $$props) $$invalidate(0, scanning = $$props.scanning);
    		if ('isLoaded' in $$props) $$invalidate(1, isLoaded = $$props.isLoaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [scanning, isLoaded];
    }

    class SearchingFullnodes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchingFullnodes",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/components/layout/RecoveryMode.svelte generated by Svelte v3.59.2 */

    const { console: console_1$1 } = globals;
    const file$2 = "src/components/layout/RecoveryMode.svelte";

    // (19:2) {#if is_recovery}
    function create_if_block$2(ctx) {
    	let cardalert;
    	let current;

    	cardalert = new CardAlert({
    			props: {
    				$$slots: {
    					body: [create_body_slot],
    					title: [create_title_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardalert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardalert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardalert_changes = {};

    			if (dirty & /*$$scope, $_, epoch_recovery_ends*/ 14) {
    				cardalert_changes.$$scope = { dirty, ctx };
    			}

    			cardalert.$set(cardalert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardalert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardalert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardalert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(19:2) {#if is_recovery}",
    		ctx
    	});

    	return block;
    }

    // (21:4) 
    function create_title_slot(ctx) {
    	let span;
    	let t_value = /*$_*/ ctx[2]("layout.recovery_mode.title") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "title");
    			add_location(span, file$2, 20, 4, 518);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t_value !== (t_value = /*$_*/ ctx[2]("layout.recovery_mode.title") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(21:4) ",
    		ctx
    	});

    	return block;
    }

    // (23:4) 
    function create_body_slot(ctx) {
    	let div;

    	let t_value = /*$_*/ ctx[2]("layout.recovery_mode.body", {
    		values: {
    			epoch_recovery_ends: /*epoch_recovery_ends*/ ctx[1],
    			epoch_recovery_ends_after: /*epoch_recovery_ends*/ ctx[1] + 1
    		}
    	}) + "";

    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$2, 22, 4, 589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, epoch_recovery_ends*/ 6 && t_value !== (t_value = /*$_*/ ctx[2]("layout.recovery_mode.body", {
    				values: {
    					epoch_recovery_ends: /*epoch_recovery_ends*/ ctx[1],
    					epoch_recovery_ends_after: /*epoch_recovery_ends*/ ctx[1] + 1
    				}
    			}) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot.name,
    		type: "slot",
    		source: "(23:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let main;
    	let current;
    	let if_block = /*is_recovery*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			add_location(main, file$2, 17, 0, 473);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*is_recovery*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*is_recovery*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RecoveryMode', slots, []);
    	let is_recovery = false;
    	let epoch_recovery_ends = null;

    	i$1("get_recovery_mode", {}).then(ends => {
    		console.log(">>> get_recovery_mode");
    		console.log(ends);

    		if (ends > 0) {
    			($$invalidate(0, is_recovery = true), $$invalidate(1, epoch_recovery_ends = ends));
    		}
    	}).catch(e => {
    		console.log(e);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<RecoveryMode> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		invoke: i$1,
    		_: $format,
    		CardAlert,
    		is_recovery,
    		epoch_recovery_ends,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('is_recovery' in $$props) $$invalidate(0, is_recovery = $$props.is_recovery);
    		if ('epoch_recovery_ends' in $$props) $$invalidate(1, epoch_recovery_ends = $$props.epoch_recovery_ends);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [is_recovery, epoch_recovery_ends, $_];
    }

    class RecoveryMode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RecoveryMode",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/make-whole/MakeWhole.svelte generated by Svelte v3.59.2 */
    const file$1 = "src/components/make-whole/MakeWhole.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (120:4) {:else}
    function create_else_block_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-spinner", "");
    			set_style(span, "position", "absolute");
    			set_style(span, "top", "0px");
    			set_style(span, "left", "0px");
    			add_location(span, file$1, 120, 6, 4180);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(120:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (90:4) {#if credits}
    function create_if_block$1(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0_value = /*$_*/ ctx[4]("make_whole.table.account") + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*$_*/ ctx[4]("make_whole.table.amount") + "";
    	let t2;
    	let t3;
    	let th2;
    	let t4_value = /*$_*/ ctx[4]("make_whole.table.claim") + "";
    	let t4;
    	let t5;
    	let tbody;
    	let each_value = /*credits*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "class", "uk-text-left");
    			add_location(th0, file$1, 93, 12, 3033);
    			attr_dev(th1, "class", "uk-text-right");
    			add_location(th1, file$1, 94, 12, 3108);
    			attr_dev(th2, "class", "uk-text-center");
    			add_location(th2, file$1, 95, 12, 3183);
    			add_location(tr, file$1, 92, 10, 3016);
    			add_location(thead, file$1, 91, 8, 2998);
    			add_location(tbody, file$1, 98, 8, 3287);
    			attr_dev(table, "class", "uk-table uk-table-divider");
    			add_location(table, file$1, 90, 6, 2948);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			append_dev(table, t5);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(tbody, null);
    				}
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("make_whole.table.account") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 16 && t2_value !== (t2_value = /*$_*/ ctx[4]("make_whole.table.amount") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 16 && t4_value !== (t4_value = /*$_*/ ctx[4]("make_whole.table.claim") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*credits, isProcessing, claimCoins, $_, printCoins*/ 51) {
    				each_value = /*credits*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(90:4) {#if credits}",
    		ctx
    	});

    	return block;
    }

    // (107:16) {:else}
    function create_else_block(ctx) {
    	let button;

    	let t_value = (/*isProcessing*/ ctx[1]
    	? /*$_*/ ctx[4]("make_whole.claim_btn.await")
    	: /*$_*/ ctx[4]("make_whole.claim_btn.claim")) + "";

    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*credit*/ ctx[8]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			button.disabled = /*isProcessing*/ ctx[1];
    			set_style(button, "width", "180px");
    			attr_dev(button, "class", "uk-button uk-button-primary");
    			add_location(button, file$1, 107, 18, 3732);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*isProcessing, $_*/ 18 && t_value !== (t_value = (/*isProcessing*/ ctx[1]
    			? /*$_*/ ctx[4]("make_whole.claim_btn.await")
    			: /*$_*/ ctx[4]("make_whole.claim_btn.claim")) + "")) set_data_dev(t, t_value);

    			if (dirty & /*isProcessing*/ 2) {
    				prop_dev(button, "disabled", /*isProcessing*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(107:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (105:16) {#if credit.claimed}
    function create_if_block_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-success");
    			attr_dev(span, "uk-icon", "icon: check; ratio: 1; color: green");
    			add_location(span, file$1, 105, 18, 3606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(105:16) {#if credit.claimed}",
    		ctx
    	});

    	return block;
    }

    // (100:10) {#each credits as credit}
    function create_each_block(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*credit*/ ctx[8].account + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = printCoins(/*credit*/ ctx[8].coins.value) + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4;

    	function select_block_type_1(ctx, dirty) {
    		if (/*credit*/ ctx[8].claimed) return create_if_block_1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			if_block.c();
    			t4 = space();
    			attr_dev(td0, "class", "uk-text-left");
    			add_location(td0, file$1, 101, 14, 3362);
    			attr_dev(td1, "class", "uk-text-right");
    			add_location(td1, file$1, 102, 14, 3423);
    			attr_dev(td2, "class", "uk-text-center");
    			set_style(td2, "width", "200px");
    			add_location(td2, file$1, 103, 14, 3501);
    			add_location(tr, file$1, 100, 12, 3343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			if_block.m(td2, null);
    			append_dev(tr, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*credits*/ 1 && t0_value !== (t0_value = /*credit*/ ctx[8].account + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*credits*/ 1 && t2_value !== (t2_value = printCoins(/*credit*/ ctx[8].coins.value) + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(td2, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(100:10) {#each credits as credit}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let main;
    	let div2;
    	let div1;
    	let div0;
    	let h20;
    	let span;
    	let t0;
    	let p0;
    	let t1_value = /*$_*/ ctx[4]("make_whole.modal_success.title") + "";
    	let t1;
    	let t2;
    	let html_tag;

    	let raw0_value = /*$_*/ ctx[4]("make_whole.modal_success.amount_for_account", {
    		values: {
    			coins: /*selected*/ ctx[2] && printCoins(/*selected*/ ctx[2].coins.value),
    			account: /*selected*/ ctx[2] ? /*selected*/ ctx[2].account : ''
    		}
    	}) + "";

    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[4]("make_whole.modal_success.check_balance") + "";
    	let t4;
    	let t5;
    	let p2;
    	let button0;
    	let t6_value = /*$_*/ ctx[4]("make_whole.modal_success.ok_btn") + "";
    	let t6;
    	let t7;
    	let div5;
    	let div4;
    	let div3;
    	let h21;
    	let t8_value = /*$_*/ ctx[4]("make_whole.modal_error.title") + "";
    	let t8;
    	let t9;
    	let p3;
    	let t10;
    	let t11;
    	let p4;
    	let button1;
    	let t12_value = /*$_*/ ctx[4]("make_whole.modal_error.ok_btn") + "";
    	let t12;
    	let t13;
    	let div8;
    	let div6;
    	let h3;
    	let t14_value = /*$_*/ ctx[4]("make_whole.card.title") + "";
    	let t14;
    	let t15;
    	let html_tag_1;
    	let raw1_value = /*$_*/ ctx[4]("make_whole.card.body") + "";
    	let t16;
    	let div7;
    	let t17;

    	function select_block_type(ctx, dirty) {
    		if (/*credits*/ ctx[0]) return create_if_block$1;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			span = element("span");
    			t0 = space();
    			p0 = element("p");
    			t1 = text(t1_value);
    			t2 = space();
    			html_tag = new HtmlTag(false);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			button0 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			h21 = element("h2");
    			t8 = text(t8_value);
    			t9 = space();
    			p3 = element("p");
    			t10 = text(/*errorMsg*/ ctx[3]);
    			t11 = space();
    			p4 = element("p");
    			button1 = element("button");
    			t12 = text(t12_value);
    			t13 = space();
    			div8 = element("div");
    			div6 = element("div");
    			h3 = element("h3");
    			t14 = text(t14_value);
    			t15 = space();
    			html_tag_1 = new HtmlTag(false);
    			t16 = space();
    			div7 = element("div");
    			t17 = space();
    			if_block.c();
    			attr_dev(span, "class", "success-icon svelte-zqs745");
    			attr_dev(span, "uk-icon", "icon: check; ratio: 2");
    			add_location(span, file$1, 50, 35, 1498);
    			attr_dev(h20, "class", "uk-modal-title");
    			add_location(h20, file$1, 50, 8, 1471);
    			attr_dev(p0, "class", "uk-text-small");
    			add_location(p0, file$1, 51, 8, 1579);
    			html_tag.a = t3;
    			add_location(p1, file$1, 53, 8, 1833);
    			attr_dev(div0, "class", "uk-section");
    			add_location(div0, file$1, 49, 6, 1438);
    			attr_dev(button0, "class", "uk-button uk-button-large uk-button-primary uk-margin-right uk-modal-close");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$1, 57, 8, 1942);
    			attr_dev(p2, "class", "uk-text-center");
    			add_location(p2, file$1, 56, 6, 1907);
    			attr_dev(div1, "class", "uk-modal-dialog uk-modal-body uk-text-center");
    			set_style(div1, "background-image", "url('/images/confetti.gif')");
    			add_location(div1, file$1, 48, 4, 1319);
    			attr_dev(div2, "id", "claimedWithSuccess");
    			attr_dev(div2, "uk-modal", "");
    			add_location(div2, file$1, 47, 2, 1276);
    			attr_dev(h21, "class", "uk-modal-title");
    			add_location(h21, file$1, 68, 8, 2294);
    			add_location(p3, file$1, 69, 8, 2373);
    			attr_dev(div3, "class", "uk-section");
    			add_location(div3, file$1, 67, 6, 2261);
    			attr_dev(button1, "class", "uk-button uk-button-large uk-button-primary uk-margin-right uk-modal-close");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$1, 73, 8, 2446);
    			attr_dev(p4, "class", "uk-text-center");
    			add_location(p4, file$1, 72, 6, 2411);
    			attr_dev(div4, "class", "uk-modal-dialog uk-modal-body uk-text-center");
    			add_location(div4, file$1, 66, 4, 2196);
    			attr_dev(div5, "id", "claimError");
    			attr_dev(div5, "uk-modal", "");
    			add_location(div5, file$1, 65, 2, 2161);
    			attr_dev(h3, "class", "uk-card-title uk-text-muted uk-text-uppercase");
    			add_location(h3, file$1, 83, 6, 2751);
    			html_tag_1.a = null;
    			attr_dev(div6, "class", "uk-card uk-card-default uk-card-body");
    			add_location(div6, file$1, 82, 4, 2694);
    			add_location(div7, file$1, 86, 4, 2900);
    			attr_dev(div8, "class", "uk-container");
    			add_location(div8, file$1, 81, 2, 2663);
    			add_location(main, file$1, 46, 0, 1267);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h20);
    			append_dev(h20, span);
    			append_dev(div0, t0);
    			append_dev(div0, p0);
    			append_dev(p0, t1);
    			append_dev(div0, t2);
    			html_tag.m(raw0_value, div0);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(p1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, p2);
    			append_dev(p2, button0);
    			append_dev(button0, t6);
    			append_dev(main, t7);
    			append_dev(main, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, h21);
    			append_dev(h21, t8);
    			append_dev(div3, t9);
    			append_dev(div3, p3);
    			append_dev(p3, t10);
    			append_dev(div4, t11);
    			append_dev(div4, p4);
    			append_dev(p4, button1);
    			append_dev(button1, t12);
    			append_dev(main, t13);
    			append_dev(main, div8);
    			append_dev(div8, div6);
    			append_dev(div6, h3);
    			append_dev(h3, t14);
    			append_dev(div6, t15);
    			html_tag_1.m(raw1_value, div6);
    			append_dev(div8, t16);
    			append_dev(div8, div7);
    			append_dev(div8, t17);
    			if_block.m(div8, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 16 && t1_value !== (t1_value = /*$_*/ ctx[4]("make_whole.modal_success.title") + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$_, selected*/ 20 && raw0_value !== (raw0_value = /*$_*/ ctx[4]("make_whole.modal_success.amount_for_account", {
    				values: {
    					coins: /*selected*/ ctx[2] && printCoins(/*selected*/ ctx[2].coins.value),
    					account: /*selected*/ ctx[2] ? /*selected*/ ctx[2].account : ''
    				}
    			}) + "")) html_tag.p(raw0_value);

    			if (dirty & /*$_*/ 16 && t4_value !== (t4_value = /*$_*/ ctx[4]("make_whole.modal_success.check_balance") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 16 && t6_value !== (t6_value = /*$_*/ ctx[4]("make_whole.modal_success.ok_btn") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 16 && t8_value !== (t8_value = /*$_*/ ctx[4]("make_whole.modal_error.title") + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*errorMsg*/ 8) set_data_dev(t10, /*errorMsg*/ ctx[3]);
    			if (dirty & /*$_*/ 16 && t12_value !== (t12_value = /*$_*/ ctx[4]("make_whole.modal_error.ok_btn") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$_*/ 16 && t14_value !== (t14_value = /*$_*/ ctx[4]("make_whole.card.title") + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*$_*/ 16 && raw1_value !== (raw1_value = /*$_*/ ctx[4]("make_whole.card.body") + "")) html_tag_1.p(raw1_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div8, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store($format, '_');
    	component_subscribe($$self, $format, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MakeWhole', slots, []);
    	let credits;
    	let unsubs;

    	onMount(async () => {
    		unsubs = makeWhole.subscribe(mk => {
    			$$invalidate(0, credits = []);

    			for (const address in mk) {
    				let accountCredits = mk[address];

    				accountCredits.forEach(credit => {
    					credits.push({
    						account: address,
    						coins: credit.coins,
    						claimed: credit.claimed
    					});
    				});
    			}
    		});
    	});

    	onDestroy(async () => {
    		unsubs && unsubs();
    	});

    	let isProcessing = false;
    	let selected = null;
    	let errorMsg = "";

    	const claimCoins = credit => {
    		$$invalidate(2, selected = credit);
    		$$invalidate(1, isProcessing = true);

    		let callback = error => {
    			$$invalidate(1, isProcessing = false);

    			if (error) {
    				$$invalidate(3, errorMsg = error);
    				uikit.modal('#claimError').show();
    				return;
    			}

    			uikit.modal('#claimedWithSuccess').show();
    		};

    		callback.bind({ isProcessing });
    		claimMakeWhole(selected.account, callback);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MakeWhole> was created with unknown prop '${key}'`);
    	});

    	const click_handler = credit => claimCoins(credit);

    	$$self.$capture_state = () => ({
    		UIkit: uikit,
    		printCoins,
    		makeWhole,
    		onDestroy,
    		onMount,
    		claimMakeWhole,
    		_: $format,
    		credits,
    		unsubs,
    		isProcessing,
    		selected,
    		errorMsg,
    		claimCoins,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('credits' in $$props) $$invalidate(0, credits = $$props.credits);
    		if ('unsubs' in $$props) unsubs = $$props.unsubs;
    		if ('isProcessing' in $$props) $$invalidate(1, isProcessing = $$props.isProcessing);
    		if ('selected' in $$props) $$invalidate(2, selected = $$props.selected);
    		if ('errorMsg' in $$props) $$invalidate(3, errorMsg = $$props.errorMsg);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [credits, isProcessing, selected, errorMsg, $_, claimCoins, click_handler];
    }

    class MakeWhole extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MakeWhole",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.59.2 */

    const { console: console_1 } = globals;
    const file = "src/App.svelte";

    // (126:8) {#if debug}
    function create_if_block(ctx) {
    	let debugcard;
    	let current;
    	debugcard = new DebugCard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(debugcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(debugcard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(debugcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(debugcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(debugcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(126:8) {#if debug}",
    		ctx
    	});

    	return block;
    }

    // (99:4) <Router>
    function create_default_slot(ctx) {
    	let nav;
    	let t0;
    	let div;
    	let route0;
    	let t1;
    	let route1;
    	let t2;
    	let route2;
    	let t3;
    	let route3;
    	let t4;
    	let route4;
    	let t5;
    	let route5;
    	let t6;
    	let route6;
    	let t7;
    	let route7;
    	let t8;
    	let route8;
    	let t9;
    	let route9;
    	let t10;
    	let route10;
    	let t11;
    	let current;
    	nav = new Nav({ $$inline: true });

    	route0 = new Route$1({
    			props: {
    				path: routes.home,
    				component: Wallet,
    				primary: false
    			},
    			$$inline: true
    		});

    	route1 = new Route$1({
    			props: {
    				path: routes.accountFromMnem,
    				component: AccountFromMnemForm,
    				primary: false
    			},
    			$$inline: true
    		});

    	route2 = new Route$1({
    			props: {
    				path: routes.keygen,
    				component: Keygen,
    				primary: false
    			},
    			$$inline: true
    		});

    	route3 = new Route$1({
    			props: {
    				path: routes.miner,
    				component: Miner,
    				primary: false
    			},
    			$$inline: true
    		});

    	route4 = new Route$1({
    			props: {
    				path: routes.transactions,
    				component: Transactions,
    				primary: false
    			},
    			$$inline: true
    		});

    	route5 = new Route$1({
    			props: {
    				path: routes.events,
    				component: Events,
    				primary: false
    			},
    			$$inline: true
    		});

    	route6 = new Route$1({
    			props: {
    				path: routes.settings,
    				component: Settings,
    				primary: false
    			},
    			$$inline: true
    		});

    	route7 = new Route$1({
    			props: {
    				path: routes.about,
    				component: About,
    				primary: false
    			},
    			$$inline: true
    		});

    	route8 = new Route$1({
    			props: {
    				path: routes.makeWhole,
    				component: MakeWhole,
    				primary: false
    			},
    			$$inline: true
    		});

    	route9 = new Route$1({
    			props: {
    				path: routes.developer,
    				component: DevMode,
    				primary: false
    			},
    			$$inline: true
    		});

    	route10 = new Route$1({
    			props: {
    				path: routes.swarm,
    				component: Swarm,
    				primary: false
    			},
    			$$inline: true
    		});

    	let if_block = /*debug*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			create_component(nav.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(route0.$$.fragment);
    			t1 = space();
    			create_component(route1.$$.fragment);
    			t2 = space();
    			create_component(route2.$$.fragment);
    			t3 = space();
    			create_component(route3.$$.fragment);
    			t4 = space();
    			create_component(route4.$$.fragment);
    			t5 = space();
    			create_component(route5.$$.fragment);
    			t6 = space();
    			create_component(route6.$$.fragment);
    			t7 = space();
    			create_component(route7.$$.fragment);
    			t8 = space();
    			create_component(route8.$$.fragment);
    			t9 = space();
    			create_component(route9.$$.fragment);
    			t10 = space();
    			create_component(route10.$$.fragment);
    			t11 = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "uk-background-muted uk-margin-large");
    			add_location(div, file, 100, 6, 4220);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nav, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(route0, div, null);
    			append_dev(div, t1);
    			mount_component(route1, div, null);
    			append_dev(div, t2);
    			mount_component(route2, div, null);
    			append_dev(div, t3);
    			mount_component(route3, div, null);
    			append_dev(div, t4);
    			mount_component(route4, div, null);
    			append_dev(div, t5);
    			mount_component(route5, div, null);
    			append_dev(div, t6);
    			mount_component(route6, div, null);
    			append_dev(div, t7);
    			mount_component(route7, div, null);
    			append_dev(div, t8);
    			mount_component(route8, div, null);
    			append_dev(div, t9);
    			mount_component(route9, div, null);
    			append_dev(div, t10);
    			mount_component(route10, div, null);
    			append_dev(div, t11);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*debug*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*debug*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(route6.$$.fragment, local);
    			transition_in(route7.$$.fragment, local);
    			transition_in(route8.$$.fragment, local);
    			transition_in(route9.$$.fragment, local);
    			transition_in(route10.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(route6.$$.fragment, local);
    			transition_out(route7.$$.fragment, local);
    			transition_out(route8.$$.fragment, local);
    			transition_out(route9.$$.fragment, local);
    			transition_out(route10.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nav, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(route0);
    			destroy_component(route1);
    			destroy_component(route2);
    			destroy_component(route3);
    			destroy_component(route4);
    			destroy_component(route5);
    			destroy_component(route6);
    			destroy_component(route7);
    			destroy_component(route8);
    			destroy_component(route9);
    			destroy_component(route10);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(99:4) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let searchingfullnodes;
    	let t0;
    	let recoverymode;
    	let t1;
    	let div;
    	let router;
    	let current;
    	searchingfullnodes = new SearchingFullnodes({ $$inline: true });
    	recoverymode = new RecoveryMode({ $$inline: true });

    	router = new Router$1({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(searchingfullnodes.$$.fragment);
    			t0 = space();
    			create_component(recoverymode.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(router.$$.fragment);
    			attr_dev(div, "class", "uk-container");
    			add_location(div, file, 97, 2, 4160);
    			attr_dev(main, "class", "uk-background-muted uk-height-viewport");
    			add_location(main, file, 93, 0, 4059);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(searchingfullnodes, main, null);
    			append_dev(main, t0);
    			mount_component(recoverymode, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			mount_component(router, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, debug*/ 129) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchingfullnodes.$$.fragment, local);
    			transition_in(recoverymode.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchingfullnodes.$$.fragment, local);
    			transition_out(recoverymode.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(searchingfullnodes);
    			destroy_component(recoverymode);
    			destroy_component(router);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	init_preferences();
    	let unlistenProofStart;
    	let unlistenAck;
    	let unlistenBacklogSuccess;
    	let unlistenBacklogError;
    	let unlistenUpdater;
    	let healthTick;
    	let debug = false;

    	onMount(async () => {
    		logger(Level.Warn, "Webview is starting");
    		isCarpeInit();
    		getEnv();
    		getVersion();

    		// iterates through the list of peers in 0L.toml, and updates the statistics in preferences.json. So we don't need to test fullnodes on every transaction.
    		refreshUpstreamPeerStats().then(() => {
    			carpeTick();
    		});

    		healthTick = setInterval(carpeTick, 30000); // do a healthcheck, this is async
    		debugMode.subscribe(b => $$invalidate(0, debug = b));

    		///// Backlog /////
    		// Todo: Should this listener only be started in the miner view?
    		// submitted tower txs, which happens with backlog, requires a private key.
    		// so that the user does not need to keep authorizing the key,
    		// there is a listener service which loads the key once, and then waits for a specific
    		// event to trigger the backlog submission.
    		unlistenProofStart = await o("proof-start", event => {
    			responses.set(event.payload);

    			//update the tower stats after we show the backlog being up to date.
    			minerEventReceived.set(true);

    			backlogInProgress.set(false);
    			backlogSubmitted.set(false);
    		});

    		unlistenAck = await o("ack-backlog-request", event => {
    			backlogInProgress.set(true);
    		});

    		unlistenBacklogSuccess = await o("backlog-success", event => {
    			responses.set(event.payload);

    			//update the tower stats after we show the backlog being up to date.
    			backlogInProgress.set(false);

    			backlogSubmitted.set(true);
    			carpeTick();
    		});

    		unlistenBacklogError = await o("backlog-error", event => {
    			// TODO: show an UX in the miner view for this type of error
    			raise_error(event.payload, true, "listen(backlog-error)");

    			backlogInProgress.set(false);
    			backlogSubmitted.set(false);
    		});

    		unlistenUpdater = await o('tauri://update-status', data => {
    			let msg = JSON.stringify(data === null || data === void 0 ? void 0 : data.payload);
    			console.log("updater...", msg);
    			logger(Level.Warn, msg);
    		});
    	});

    	onDestroy(() => {
    		unlistenProofStart();
    		unlistenAck();
    		unlistenBacklogSuccess();
    		unlistenBacklogError();
    		unlistenUpdater();
    		clearInterval(healthTick);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		listen: o,
    		onDestroy,
    		onMount,
    		Router: Router$1,
    		Route: Route$1,
    		Nav,
    		DebugCard,
    		Wallet,
    		Miner,
    		Settings,
    		DevMode,
    		AccountFromMnemForm,
    		Swarm,
    		Keygen,
    		Transactions,
    		Events,
    		About,
    		backlogInProgress,
    		backlogSubmitted,
    		minerEventReceived,
    		raise_error,
    		getEnv,
    		responses,
    		debugMode,
    		routes,
    		isCarpeInit,
    		getVersion,
    		carpeTick,
    		init_preferences,
    		SearchingFullnodes,
    		RecoveryMode,
    		MakeWhole,
    		refreshUpstreamPeerStats,
    		Level,
    		logger,
    		unlistenProofStart,
    		unlistenAck,
    		unlistenBacklogSuccess,
    		unlistenBacklogError,
    		unlistenUpdater,
    		healthTick,
    		debug
    	});

    	$$self.$inject_state = $$props => {
    		if ('unlistenProofStart' in $$props) unlistenProofStart = $$props.unlistenProofStart;
    		if ('unlistenAck' in $$props) unlistenAck = $$props.unlistenAck;
    		if ('unlistenBacklogSuccess' in $$props) unlistenBacklogSuccess = $$props.unlistenBacklogSuccess;
    		if ('unlistenBacklogError' in $$props) unlistenBacklogError = $$props.unlistenBacklogError;
    		if ('unlistenUpdater' in $$props) unlistenUpdater = $$props.unlistenUpdater;
    		if ('healthTick' in $$props) healthTick = $$props.healthTick;
    		if ('debug' in $$props) $$invalidate(0, debug = $$props.debug);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [debug];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
        props: {
            name: 'tauri',
        },
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
